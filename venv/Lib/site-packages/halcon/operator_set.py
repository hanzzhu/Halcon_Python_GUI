# **********************************************************
# File generated by the HALCON-Compiler hcomp version 20.11
# Usage: Interface to Python
#
# Software by: MVTec Software GmbH, www.mvtec.com
# **********************************************************

# mypy: no-warn-unused-ignores

from typing import Sequence, Tuple, Optional, Union

from .ffi import (
    HalconOperator,
    HTupleElementType,
    HTupleType,
)

from .util import MaybeSequence
from .hhandle import HHandle
from .hobject import HObject


def abs_diff_image(
    image_1: HObject,
    image_2: HObject,
    mult: Union[int, float]
) -> HObject:
    """
    Calculate the absolute difference of two images.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    mult : Union[int, float]
           Scale factor.
           Value Suggestion: 1.0
           Assertion: Mult > 0

    Returns
    -------

    image_abs_diff : HObject
                     Absolute value of the difference of the input images.

    See Also
    --------
    add_image, scale_image, dyn_threshold

    Alternatives
    ------------
    sub_image

    Successors
    ----------
    threshold

    Notes
    -----
    Note that the acceleration gained by SIMD technology is highest on
    large, compact input regions. However, in rare cases, the execution of
    abs_diff_image might take significantly longer with SIMD technology
    than without, depending on the input region and the capabilities of
    the hardware. In these cases, the use of SIMD technology can be
    avoided by set_system(::'mmx_enable','false':).
    """
    with HalconOperator(1604) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, mult)
        proc.execute()
        image_abs_diff = HObject(proc.get_output_object_key(1))
        return image_abs_diff  # type: ignore


def abs_funct_1d(
    function: Sequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Absolute value of the y values.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    function_absolute : Sequence[Union[float, int]]
                        Function with the absolute values of the y values.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1384) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.execute()
        function_absolute = proc.get_output_tuple_m(0)
        return function_absolute  # type: ignore


def abs_image(image: HObject) -> HObject:
    """
    Calculate the absolute value (modulus) of an image.

    Parameters
    ----------

    image : HObject
            Image(s) for which the absolute gray values are to be
            calculated.

    Returns
    -------

    image_abs : HObject
                Result image(s).

    See Also
    --------
    convert_image_type, power_byte
    """
    with HalconOperator(1611) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_abs = HObject(proc.get_output_object_key(1))
        return image_abs  # type: ignore


def abs_matrix(matrix_id: HHandle) -> HHandle:
    """
    Compute the absolute values of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    matrix_abs_id : HHandle
                    Matrix handle with the absolute values of the input
                    matrix.

    Alternatives
    ------------
    abs_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(868) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        matrix_abs_id = proc.get_output_tuple_s(0)
        return matrix_abs_id  # type: ignore


def abs_matrix_mod(matrix_id: HHandle) -> None:
    """
    Compute the absolute values of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Alternatives
    ------------
    abs_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(867) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.execute()


def access_channel(
    multi_channel_image: HObject,
    channel: int
) -> HObject:
    """
    Access a channel of a multi-channel image.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    channel : int
              Index of channel to be accessed.
              Value Suggestion: 1

    Returns
    -------

    image : HObject
            One channel of MultiChannelImage.

    See Also
    --------
    count_channels

    Alternatives
    ------------
    decompose2, decompose3, decompose4, decompose5

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1135) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.set_input_tuple(0, channel)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def acos_image(image: HObject) -> HObject:
    """
    Calculate the arccosine of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    arccos_image : HObject
                   Output image.

    See Also
    --------
    asin_image, atan_image, atan2_image, tan_image, sin_image, cos_image

    Notes
    -----
    acos_image can be executed on OpenCL devices.
    """
    with HalconOperator(1599) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        arccos_image = HObject(proc.get_output_object_key(1))
        return arccos_image  # type: ignore


def activate_compute_device(device_handle: HHandle) -> None:
    """
    Activate a compute device.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    See Also
    --------
    deactivate_compute_device, deactivate_all_compute_devices

    Predecessors
    ------------
    open_compute_device
    """
    with HalconOperator(302) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.execute()


def adapt_shape_model_high_noise(
    image_reduced: HObject,
    model_id: HHandle,
    gen_param: Sequence[str]
) -> HHandle:
    """
    Adapt a shape model's parameters for high noise images.

    Parameters
    ----------

    image_reduced : HObject
                    Sample search image with reduced domain.

    model_id : HHandle
               Handle of the shape model.

    gen_param : Sequence[str]
                Parameters to be estimated.
                Value Suggestion: all

    Returns
    -------

    result_dict : HHandle
                  Dictionary with the estimated parameter values.

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model, create_aniso_shape_model

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models
    """
    with HalconOperator(2204) as proc:
        proc.set_input_object(1, image_reduced)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param)
        proc.init_oct(0)
        proc.execute()
        result_dict = proc.get_output_tuple_s(0)
        return result_dict  # type: ignore


def adapt_template(image: HObject, template_id: HHandle) -> None:
    """
    Adapting a template to the size of an image.

    Parameters
    ----------

    image : HObject
            Image which determines the size of the later matching.

    template_id : HHandle
                  Template number.

    Predecessors
    ------------
    create_template, create_template_rot, read_template

    Successors
    ----------
    set_reference_template, best_match, fast_match, fast_match_mg,
    set_offset_template, best_match_mg, best_match_pre_mg, best_match_rot,
    best_match_rot_mg

    Warnings
    --------
    adapt_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1498) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.execute()


def add_channels(regions: HObject, image: HObject) -> HObject:
    """
    Add gray values to regions.

    Parameters
    ----------

    regions : HObject
              Input regions (without pixel values).

    image : HObject
            Input image with pixel values for regions.

    Returns
    -------

    gray_regions : HObject
                   Output image(s) with regions and pixel values (one
                   image per input region).

    See Also
    --------
    full_domain, get_domain, intersection

    Alternatives
    ------------
    change_domain, reduce_domain

    Predecessors
    ------------
    threshold, regiongrowing, gen_circle, draw_region

    Successors
    ----------
    threshold, regiongrowing, get_domain
    """
    with HalconOperator(1144) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.execute()
        gray_regions = HObject(proc.get_output_object_key(1))
        return gray_regions  # type: ignore


def add_class_train_data_gmm(
    gmmhandle: HHandle,
    class_train_data_handle: HHandle
) -> None:
    """
    Add training data to a Gaussian Mixture Model (GMM).

    Parameters
    ----------

    gmmhandle : HHandle
                Handle of a GMM which receives the training data.

    class_train_data_handle : HHandle
                              Handle of training data for a classifier.

    See Also
    --------
    create_class_gmm

    Alternatives
    ------------
    add_sample_class_gmm

    Predecessors
    ------------
    create_class_gmm, create_class_train_data

    Successors
    ----------
    get_sample_class_gmm
    """
    with HalconOperator(1786) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, class_train_data_handle)
        proc.execute()


def add_class_train_data_knn(
    knnhandle: HHandle,
    class_train_data_handle: HHandle
) -> None:
    """
    Add training data to a k-nearest neighbors (k-NN) classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of a k-NN which receives the  training data.

    class_train_data_handle : HHandle
                              Training data for a classifier.

    See Also
    --------
    create_class_knn

    Alternatives
    ------------
    add_sample_class_knn

    Predecessors
    ------------
    create_class_knn, create_class_train_data

    Successors
    ----------
    get_sample_class_knn
    """
    with HalconOperator(1790) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, class_train_data_handle)
        proc.execute()


def add_class_train_data_mlp(
    mlphandle: HHandle,
    class_train_data_handle: HHandle
) -> None:
    """
    Add training data to a multilayer perceptron (MLP).

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle which receives the training data.

    class_train_data_handle : HHandle
                              Training data for a classifier.

    See Also
    --------
    create_class_mlp

    Alternatives
    ------------
    add_sample_class_mlp

    Predecessors
    ------------
    create_class_mlp, create_class_train_data

    Successors
    ----------
    get_sample_class_mlp
    """
    with HalconOperator(1788) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, class_train_data_handle)
        proc.execute()


def add_class_train_data_svm(
    svmhandle: HHandle,
    class_train_data_handle: HHandle
) -> None:
    """
    Add training data to a support vector machine (SVM).

    Parameters
    ----------

    svmhandle : HHandle
                Handle of a SVM which receives the training data.

    class_train_data_handle : HHandle
                              Training data for a classifier.

    See Also
    --------
    create_class_svm

    Alternatives
    ------------
    add_sample_class_svm

    Predecessors
    ------------
    create_class_svm, create_class_train_data

    Successors
    ----------
    get_sample_class_svm
    """
    with HalconOperator(1792) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, class_train_data_handle)
        proc.execute()


def add_deformable_surface_model_reference_point(
    deformable_surface_model: HHandle,
    reference_point_x: MaybeSequence[Union[float, int]],
    reference_point_y: MaybeSequence[Union[float, int]],
    reference_point_z: MaybeSequence[Union[float, int]]
) -> Sequence[int]:
    """
    Add a reference point to a deformable surface model.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    reference_point_x : MaybeSequence[Union[float, int]]
                        x-coordinates of a reference point.

    reference_point_y : MaybeSequence[Union[float, int]]
                        x-coordinates of a reference point.

    reference_point_z : MaybeSequence[Union[float, int]]
                        x-coordinates of a reference point.

    Returns
    -------

    reference_point_index : Sequence[int]
                            Index of the new reference point.

    See Also
    --------
    create_deformable_surface_model, find_deformable_surface_model,
    refine_deformable_surface_model

    Predecessors
    ------------
    create_deformable_surface_model, read_deformable_surface_model

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    write_deformable_surface_model
    """
    with HalconOperator(1029) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, reference_point_x)
        proc.set_input_tuple(2, reference_point_y)
        proc.set_input_tuple(3, reference_point_z)
        proc.init_oct(0)
        proc.execute()
        reference_point_index = proc.get_output_tuple_m(0)
        return reference_point_index  # type: ignore


def add_deformable_surface_model_reference_point_s(
    deformable_surface_model: HHandle,
    reference_point_x: MaybeSequence[Union[float, int]],
    reference_point_y: MaybeSequence[Union[float, int]],
    reference_point_z: MaybeSequence[Union[float, int]]
) -> int:
    """
    Add a reference point to a deformable surface model.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    reference_point_x : MaybeSequence[Union[float, int]]
                        x-coordinates of a reference point.

    reference_point_y : MaybeSequence[Union[float, int]]
                        x-coordinates of a reference point.

    reference_point_z : MaybeSequence[Union[float, int]]
                        x-coordinates of a reference point.

    Returns
    -------

    reference_point_index : int
                            Index of the new reference point.

    See Also
    --------
    create_deformable_surface_model, find_deformable_surface_model,
    refine_deformable_surface_model

    Predecessors
    ------------
    create_deformable_surface_model, read_deformable_surface_model

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    write_deformable_surface_model
    """
    with HalconOperator(1029) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, reference_point_x)
        proc.set_input_tuple(2, reference_point_y)
        proc.set_input_tuple(3, reference_point_z)
        proc.init_oct(0)
        proc.execute()
        reference_point_index = proc.get_output_tuple_s(0)
        return reference_point_index  # type: ignore


def add_deformable_surface_model_sample(
    deformable_surface_model: HHandle,
    object_model_3d: MaybeSequence[HHandle]
) -> None:
    """
    Add a sample deformation to a deformable surface model

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the deformed 3D object model.

    See Also
    --------
    find_deformable_surface_model, refine_deformable_surface_model,
    read_deformable_surface_model, create_deformable_surface_model,
    write_deformable_surface_model, clear_deformable_surface_model

    Alternatives
    ------------
    read_deformable_surface_model

    Predecessors
    ------------
    create_deformable_surface_model, find_deformable_surface_model,
    refine_deformable_surface_model

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    get_deformable_surface_model_param, write_deformable_surface_model,
    clear_deformable_surface_model
    """
    with HalconOperator(1030) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, object_model_3d)
        proc.execute()


def add_dl_pruning_batch(
    dlmodel_handle_to_prune: HHandle,
    dlpruning_handle: HHandle,
    dlsample_batch: Sequence[HHandle]
) -> None:
    """
    Calculate scores to prune a deep learning model.

    Parameters
    ----------

    dlmodel_handle_to_prune : HHandle
                              Handle of a deep learning model to prune.

    dlpruning_handle : HHandle
                       Pruning data handle.

    dlsample_batch : Sequence[HHandle]
                     Tuple of dictionaries with input images.

    Predecessors
    ------------
    read_dl_model, create_dl_pruning, set_dl_pruning_param

    Successors
    ----------
    get_dl_pruning_param, gen_dl_pruned_model
    """
    with HalconOperator(2205) as proc:
        proc.set_input_tuple(0, dlmodel_handle_to_prune)
        proc.set_input_tuple(1, dlpruning_handle)
        proc.set_input_tuple(2, dlsample_batch)
        proc.execute()


def add_image(
    image_1: HObject,
    image_2: HObject,
    mult: Union[int, float],
    add: Union[int, float]
) -> HObject:
    """
    Add two images.

    Parameters
    ----------

    image_1 : HObject
              Image(s) 1.

    image_2 : HObject
              Image(s) 2.

    mult : Union[int, float]
           Factor for gray value adaption.
           Value Suggestion: 0.5

    add : Union[int, float]
          Value for gray value range adaption.
          Value Suggestion: 0

    Returns
    -------

    image_result : HObject
                   Result image(s) by the addition.

    See Also
    --------
    sub_image, mult_image

    Alternatives
    ------------
    sub_image, mult_image

    Notes
    -----
    Note that the acceleration gained by SIMD technology is highest on
    large, compact input regions. However, in rare cases, the execution of
    add_image might take significantly longer with SIMD technology than
    without, depending on the input region and the capabilities of the
    hardware. In these cases, the use of SIMD technology can be avoided by
    set_system(::'mmx_enable','false':).
    """
    with HalconOperator(1610) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, mult)
        proc.set_input_tuple(1, add)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def add_matrix(matrix_aid: HHandle, matrix_bid: HHandle) -> HHandle:
    """
    Add two matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    Returns
    -------

    matrix_sum_id : HHandle
                    Matrix handle with the sum of the input matrices.

    See Also
    --------
    sub_matrix, sub_matrix_mod

    Alternatives
    ------------
    add_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(881) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.init_oct(0)
        proc.execute()
        matrix_sum_id = proc.get_output_tuple_s(0)
        return matrix_sum_id  # type: ignore


def add_matrix_mod(matrix_aid: HHandle, matrix_bid: HHandle) -> None:
    """
    Add two matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    See Also
    --------
    sub_matrix, sub_matrix_mod

    Alternatives
    ------------
    add_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(880) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.execute()


def add_metrology_object_circle_measure(
    metrology_handle: HHandle,
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    radius: MaybeSequence[Union[int, float]],
    measure_length_1: Union[int, float],
    measure_length_2: Union[int, float],
    measure_sigma: Union[int, float],
    measure_threshold: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> int:
    """
    Add a circle or a circular arc to a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    row : MaybeSequence[Union[int, float]]
          Row coordinate (or Y) of the center of the circle or circular
          arc.

    column : MaybeSequence[Union[int, float]]
             Column (or X) coordinate of the center of the circle or
             circular arc.

    radius : MaybeSequence[Union[int, float]]
             Radius of the circle or circular arc.

    measure_length_1 : Union[int, float]
                       Half length of the measure regions perpendicular to
                       the boundary.
                       Value Suggestion: 20.0
                       Assertion: MeasureLength1 < Radius

    measure_length_2 : Union[int, float]
                       Half length of the measure regions tangential to
                       the boundary.
                       Value Suggestion: 5.0

    measure_sigma : Union[int, float]
                    Sigma of the Gaussian function for the smoothing.
                    Value Suggestion: 1.0
                    Assertion: 0.4 <= MeasureSigma && MeasureSigma <= 100

    measure_threshold : Union[int, float]
                        Minimum edge amplitude.
                        Value Suggestion: 30.0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    index : int
            Index of the created metrology object.

    See Also
    --------
    get_metrology_object_model_contour, set_metrology_model_param,
    add_metrology_object_ellipse_measure,
    add_metrology_object_line_measure,
    add_metrology_object_rectangle2_measure

    Alternatives
    ------------
    add_metrology_object_generic

    Predecessors
    ------------
    set_metrology_model_image_size

    Successors
    ----------
    align_metrology_model, apply_metrology_model
    """
    with HalconOperator(815) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, radius)
        proc.set_input_tuple(4, measure_length_1)
        proc.set_input_tuple(5, measure_length_2)
        proc.set_input_tuple(6, measure_sigma)
        proc.set_input_tuple(7, measure_threshold)
        proc.set_input_tuple(8, gen_param_name)
        proc.set_input_tuple(9, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def add_metrology_object_ellipse_measure(
    metrology_handle: HHandle,
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    radius_1: MaybeSequence[Union[int, float]],
    radius_2: MaybeSequence[Union[int, float]],
    measure_length_1: Union[int, float],
    measure_length_2: Union[int, float],
    measure_sigma: Union[int, float],
    measure_threshold: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> int:
    """
    Add an ellipse or an elliptic arc to a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    row : MaybeSequence[Union[int, float]]
          Row (or Y) coordinate of the center of the ellipse.

    column : MaybeSequence[Union[int, float]]
             Column (or X) coordinate of the center of the ellipse.

    phi : MaybeSequence[Union[int, float]]
          Orientation of the main axis [rad].

    radius_1 : MaybeSequence[Union[int, float]]
               Length of the larger half axis.

    radius_2 : MaybeSequence[Union[int, float]]
               Length of the smaller half axis.

    measure_length_1 : Union[int, float]
                       Half length of the measure regions perpendicular to
                       the boundary.
                       Value Suggestion: 20.0
                       Assertion: MeasureLength1 < Radius1 && MeasureLength1 < Radius2

    measure_length_2 : Union[int, float]
                       Half length of the measure regions tangential to
                       the boundary.
                       Value Suggestion: 5.0

    measure_sigma : Union[int, float]
                    Sigma of the Gaussian function for the smoothing.
                    Value Suggestion: 1.0
                    Assertion: 0.4 <= MeasureSigma && MeasureSigma <= 100

    measure_threshold : Union[int, float]
                        Minimum edge amplitude.
                        Value Suggestion: 30.0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    index : int
            Index of the created metrology object.

    See Also
    --------
    get_metrology_object_model_contour, set_metrology_model_param,
    add_metrology_object_circle_measure,
    add_metrology_object_line_measure,
    add_metrology_object_rectangle2_measure

    Alternatives
    ------------
    add_metrology_object_generic

    Predecessors
    ------------
    set_metrology_model_image_size

    Successors
    ----------
    align_metrology_model, apply_metrology_model
    """
    with HalconOperator(814) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, radius_1)
        proc.set_input_tuple(5, radius_2)
        proc.set_input_tuple(6, measure_length_1)
        proc.set_input_tuple(7, measure_length_2)
        proc.set_input_tuple(8, measure_sigma)
        proc.set_input_tuple(9, measure_threshold)
        proc.set_input_tuple(10, gen_param_name)
        proc.set_input_tuple(11, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def add_metrology_object_generic(
    metrology_handle: HHandle,
    shape: MaybeSequence[str],
    shape_param: Sequence[Union[int, float]],
    measure_length_1: Union[int, float],
    measure_length_2: Union[int, float],
    measure_sigma: Union[int, float],
    measure_threshold: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> int:
    """
    Add a metrology object to a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    shape : MaybeSequence[str]
            Type of the metrology object to be added.
            Value Suggestion: circle

    shape_param : Sequence[Union[int, float]]
                  Parameters of the metrology object to be added.

    measure_length_1 : Union[int, float]
                       Half length of the measure regions perpendicular to
                       the boundary.
                       Value Suggestion: 20.0

    measure_length_2 : Union[int, float]
                       Half length of the measure regions tangential to
                       the boundary.
                       Value Suggestion: 5.0

    measure_sigma : Union[int, float]
                    Sigma of the Gaussian function for the smoothing.
                    Value Suggestion: 1.0
                    Assertion: 0.4 <= MeasureSigma && MeasureSigma <= 100

    measure_threshold : Union[int, float]
                        Minimum edge amplitude.
                        Value Suggestion: 30.0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    index : int
            Index of the created metrology object.

    See Also
    --------
    get_metrology_object_model_contour

    Predecessors
    ------------
    set_metrology_model_image_size, set_metrology_model_param

    Successors
    ----------
    align_metrology_model, apply_metrology_model, set_metrology_model_param
    """
    with HalconOperator(791) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, shape)
        proc.set_input_tuple(2, shape_param)
        proc.set_input_tuple(3, measure_length_1)
        proc.set_input_tuple(4, measure_length_2)
        proc.set_input_tuple(5, measure_sigma)
        proc.set_input_tuple(6, measure_threshold)
        proc.set_input_tuple(7, gen_param_name)
        proc.set_input_tuple(8, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def add_metrology_object_line_measure(
    metrology_handle: HHandle,
    row_begin: MaybeSequence[Union[int, float]],
    column_begin: MaybeSequence[Union[int, float]],
    row_end: MaybeSequence[Union[int, float]],
    column_end: MaybeSequence[Union[int, float]],
    measure_length_1: Union[int, float],
    measure_length_2: Union[int, float],
    measure_sigma: Union[int, float],
    measure_threshold: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> int:
    """
    Add a line to a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    row_begin : MaybeSequence[Union[int, float]]
                Row (or Y) coordinate of the start of the line.

    column_begin : MaybeSequence[Union[int, float]]
                   Column (or X) coordinate of the start of the line.

    row_end : MaybeSequence[Union[int, float]]
              Row (or Y) coordinate of the end of the line.

    column_end : MaybeSequence[Union[int, float]]
                 Column (or X) coordinate of the end of the line.

    measure_length_1 : Union[int, float]
                       Half length of the measure regions perpendicular to
                       the boundary.
                       Value Suggestion: 20.0

    measure_length_2 : Union[int, float]
                       Half length of the measure regions tangential to
                       the boundary.
                       Value Suggestion: 5.0

    measure_sigma : Union[int, float]
                    Sigma of the Gaussian function for the smoothing.
                    Value Suggestion: 1.0
                    Assertion: 0.4 <= MeasureSigma && MeasureSigma <= 100

    measure_threshold : Union[int, float]
                        Minimum edge amplitude.
                        Value Suggestion: 30.0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    index : int
            Index of the created metrology object.

    See Also
    --------
    get_metrology_object_model_contour, set_metrology_model_param,
    add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure,
    add_metrology_object_rectangle2_measure

    Alternatives
    ------------
    add_metrology_object_generic

    Predecessors
    ------------
    set_metrology_model_image_size

    Successors
    ----------
    align_metrology_model, apply_metrology_model
    """
    with HalconOperator(813) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, row_begin)
        proc.set_input_tuple(2, column_begin)
        proc.set_input_tuple(3, row_end)
        proc.set_input_tuple(4, column_end)
        proc.set_input_tuple(5, measure_length_1)
        proc.set_input_tuple(6, measure_length_2)
        proc.set_input_tuple(7, measure_sigma)
        proc.set_input_tuple(8, measure_threshold)
        proc.set_input_tuple(9, gen_param_name)
        proc.set_input_tuple(10, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def add_metrology_object_rectangle2_measure(
    metrology_handle: HHandle,
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    length_1: MaybeSequence[Union[int, float]],
    length_2: MaybeSequence[Union[int, float]],
    measure_length_1: Union[int, float],
    measure_length_2: Union[int, float],
    measure_sigma: Union[int, float],
    measure_threshold: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> int:
    """
    Add a rectangle to a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    row : MaybeSequence[Union[int, float]]
          Row (or Y) coordinate of the center of the rectangle.

    column : MaybeSequence[Union[int, float]]
             Column (or X) coordinate of the center of the rectangle.

    phi : MaybeSequence[Union[int, float]]
          Orientation of the main axis [rad].

    length_1 : MaybeSequence[Union[int, float]]
               Length of the larger half edge of the rectangle.

    length_2 : MaybeSequence[Union[int, float]]
               Length of the smaller half edge of the rectangle.

    measure_length_1 : Union[int, float]
                       Half length of the measure regions perpendicular to
                       the boundary.
                       Value Suggestion: 20.0
                       Assertion: MeasureLength1 < Length1 && MeasureLength1 < Length2

    measure_length_2 : Union[int, float]
                       Half length of the measure regions tangential to
                       the boundary.
                       Value Suggestion: 5.0

    measure_sigma : Union[int, float]
                    Sigma of the Gaussian function for the smoothing.
                    Value Suggestion: 1.0
                    Assertion: 0.4 <= MeasureSigma && MeasureSigma <= 100

    measure_threshold : Union[int, float]
                        Minimum edge amplitude.
                        Value Suggestion: 30.0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    index : int
            Index of the created metrology object.

    See Also
    --------
    get_metrology_object_model_contour, set_metrology_model_param,
    add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure, add_metrology_object_line_measure

    Alternatives
    ------------
    add_metrology_object_generic

    Predecessors
    ------------
    set_metrology_model_image_size

    Successors
    ----------
    align_metrology_model, apply_metrology_model
    """
    with HalconOperator(812) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, length_1)
        proc.set_input_tuple(5, length_2)
        proc.set_input_tuple(6, measure_length_1)
        proc.set_input_tuple(7, measure_length_2)
        proc.set_input_tuple(8, measure_sigma)
        proc.set_input_tuple(9, measure_threshold)
        proc.set_input_tuple(10, gen_param_name)
        proc.set_input_tuple(11, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def add_noise_distribution(
    image: HObject,
    distribution: Sequence[float]
) -> HObject:
    """
    Add noise to an image.

    Parameters
    ----------

    image : HObject
            Input image.

    distribution : Sequence[float]
                   Noise distribution.

    Returns
    -------

    image_noise : HObject
                  Noisy image.

    See Also
    --------
    sp_distribution, gauss_distribution, noise_distribution_mean,
    add_noise_white

    Alternatives
    ------------
    add_noise_white

    Predecessors
    ------------
    gauss_distribution, sp_distribution, noise_distribution_mean
    """
    with HalconOperator(1442) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, distribution)
        proc.execute()
        image_noise = HObject(proc.get_output_object_key(1))
        return image_noise  # type: ignore


def add_noise_white(image: HObject, amp: float) -> HObject:
    """
    Add noise to an image.

    Parameters
    ----------

    image : HObject
            Input image.

    amp : float
          Maximum noise amplitude.
          Value Suggestion: 60.0
          Assertion: Amp > 0

    Returns
    -------

    image_noise : HObject
                  Noisy image.

    See Also
    --------
    add_noise_distribution, noise_distribution_mean, gauss_distribution,
    sp_distribution

    Alternatives
    ------------
    add_noise_distribution
    """
    with HalconOperator(1441) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, amp)
        proc.execute()
        image_noise = HObject(proc.get_output_object_key(1))
        return image_noise  # type: ignore


def add_noise_white_contour_xld(
    contours: HObject,
    num_regr_points: int,
    amp: float
) -> HObject:
    """
    Add noise to XLD contours.

    Parameters
    ----------

    contours : HObject
               Original contours.

    num_regr_points : int
                      Number of points used to calculate the regression
                      line.
                      Value Suggestion: 5
                      Assertion: NumRegrPoints >= 3 && odd(NumRegrPoints)

    amp : float
          Maximum amplitude of the added noise (equally distributed in
          [-Amp,Amp]).
          Value Suggestion: 1.0
          Assertion: Amp > 0

    Returns
    -------

    noisy_contours : HObject
                     Noisy contours.

    See Also
    --------
    smooth_contours_xld, add_noise_white

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    gen_ellipse_contour_xld

    Successors
    ----------
    smooth_contours_xld
    """
    with HalconOperator(36) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_regr_points)
        proc.set_input_tuple(1, amp)
        proc.execute()
        noisy_contours = HObject(proc.get_output_object_key(1))
        return noisy_contours  # type: ignore


def add_sample_class_gmm(
    gmmhandle: HHandle,
    features: Sequence[float],
    class_id: int,
    randomize: float
) -> None:
    """
    Add a training sample to the training data of a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    features : Sequence[float]
               Feature vector of the training sample to be stored.

    class_id : int
               Class of the training sample to be stored.

    randomize : float
                Standard deviation of the Gaussian noise added to the
                training data.
                Value Suggestion: 0.0
                Assertion: Randomize >= 0.0

    See Also
    --------
    clear_samples_class_gmm, get_sample_num_class_gmm, get_sample_class_gmm

    Alternatives
    ------------
    read_samples_class_gmm, add_samples_image_class_gmm

    Predecessors
    ------------
    create_class_gmm

    Successors
    ----------
    train_class_gmm, write_samples_class_gmm
    """
    with HalconOperator(1838) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, class_id)
        proc.set_input_tuple(3, randomize)
        proc.execute()


def add_sample_class_knn(
    knnhandle: HHandle,
    features: MaybeSequence[float],
    class_id: MaybeSequence[int]
) -> None:
    """
    Add a sample to a  k-nearest neighbors (k-NN) classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    features : MaybeSequence[float]
               List of features to add.

    class_id : MaybeSequence[int]
               Class IDs of the features.

    See Also
    --------
    create_class_knn, read_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn
    """
    with HalconOperator(1815) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, class_id)
        proc.execute()


def add_sample_class_mlp(
    mlphandle: HHandle,
    features: Sequence[float],
    target: MaybeSequence[Union[int, float]]
) -> None:
    """
    Add a training sample to the training data of a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    features : Sequence[float]
               Feature vector of the training sample to be stored.

    target : MaybeSequence[Union[int, float]]
             Class or target vector of the training sample to be stored.

    See Also
    --------
    clear_samples_class_mlp, get_sample_num_class_mlp, get_sample_class_mlp

    Alternatives
    ------------
    read_samples_class_mlp

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    train_class_mlp, write_samples_class_mlp
    """
    with HalconOperator(1879) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, target)
        proc.execute()


def add_sample_class_svm(
    svmhandle: HHandle,
    features: Sequence[float],
    class_val: Union[int, float]
) -> None:
    """
    Add a training sample to the training data of a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    features : Sequence[float]
               Feature vector of the training sample to be stored.

    class_val : Union[int, float]
                Class of the training sample to be stored.

    See Also
    --------
    clear_samples_class_svm, get_support_vector_class_svm

    Alternatives
    ------------
    read_samples_class_svm

    Predecessors
    ------------
    create_class_svm

    Successors
    ----------
    train_class_svm, write_samples_class_svm, get_sample_num_class_svm,
    get_sample_class_svm
    """
    with HalconOperator(1859) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, class_val)
        proc.execute()


def add_sample_class_train_data(
    class_train_data_handle: HHandle,
    order: str,
    features: Sequence[float],
    class_id: Sequence[int]
) -> None:
    """
    Add a training sample to training data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    order : str
            The order of the feature vector.
            Value Suggestion: row

    features : Sequence[float]
               Feature vector of the training sample.

    class_id : Sequence[int]
               Class of the training sample.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    create_class_train_data

    Successors
    ----------
    add_class_train_data_svm, add_class_train_data_knn,
    add_class_train_data_gmm, add_class_train_data_mlp
    """
    with HalconOperator(1797) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, order)
        proc.set_input_tuple(2, features)
        proc.set_input_tuple(3, class_id)
        proc.execute()


def add_sample_identifier_preparation_data(
    sample_image: HObject,
    sample_identifier: HHandle,
    object_idx: Union[int, str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> int:
    """
    Add preparation data to an existing sample identifier.

    Parameters
    ----------

    sample_image : HObject
                   Image that shows an object.

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : Union[int, str]
                 Index of the object visible in the SampleImage.
                 Value Suggestion: unknown

    gen_param_name : Sequence[str]
                     Generic parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Generic parameter value.
                      Value Suggestion: []

    Returns
    -------

    object_sample_idx : int
                        Index of the object sample.

    See Also
    --------
    add_sample_identifier_training_data, train_sample_identifier,
    apply_sample_identifier, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Predecessors
    ------------
    create_sample_identifier, read_sample_identifier

    Successors
    ----------
    prepare_sample_identifier
    """
    with HalconOperator(914) as proc:
        proc.set_input_object(1, sample_image)
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_sample_idx = proc.get_output_tuple_s(0)
        return object_sample_idx  # type: ignore


def add_sample_identifier_training_data(
    sample_image: HObject,
    sample_identifier: HHandle,
    object_idx: Union[int, str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> int:
    """
    Add training data to an existing sample identifier.

    Parameters
    ----------

    sample_image : HObject
                   Image that shows an object.

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : Union[int, str]
                 Index of the object visible in the SampleImage.

    gen_param_name : Sequence[str]
                     Generic parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Generic parameter value.
                      Value Suggestion: []

    Returns
    -------

    object_sample_idx : int
                        Index of the object sample.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    apply_sample_identifier, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Predecessors
    ------------
    prepare_sample_identifier, read_sample_identifier

    Successors
    ----------
    train_sample_identifier
    """
    with HalconOperator(912) as proc:
        proc.set_input_object(1, sample_image)
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_sample_idx = proc.get_output_tuple_s(0)
        return object_sample_idx  # type: ignore


def add_samples_image_class_gmm(
    image: HObject,
    class_regions: HObject,
    gmmhandle: HHandle,
    randomize: float
) -> None:
    """
    Add training samples from an image to the training data of a Gaussian
    Mixture Model.

    Parameters
    ----------

    image : HObject
            Training image.

    class_regions : HObject
                    Regions of the classes to be trained.

    gmmhandle : HHandle
                GMM handle.

    randomize : float
                Standard deviation of the Gaussian noise added to the
                training data.
                Value Suggestion: 0.0
                Assertion: Randomize >= 0.0

    See Also
    --------
    classify_image_class_gmm, add_sample_class_gmm,
    clear_samples_class_gmm, get_sample_num_class_gmm, get_sample_class_gmm

    Alternatives
    ------------
    read_samples_class_gmm

    Predecessors
    ------------
    create_class_gmm

    Successors
    ----------
    train_class_gmm, write_samples_class_gmm
    """
    with HalconOperator(432) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, class_regions)
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, randomize)
        proc.execute()


def add_samples_image_class_knn(
    image: HObject,
    class_regions: HObject,
    knnhandle: HHandle
) -> None:
    """
    Add training samples from an image to the training data of a
    k-Nearest-Neighbor classifier.

    Parameters
    ----------

    image : HObject
            Training image.

    class_regions : HObject
                    Regions of the classes to be trained.

    knnhandle : HHandle
                Handle of the k-NN classifier.

    See Also
    --------
    classify_image_class_knn, add_sample_class_knn,
    add_samples_image_class_svm

    Alternatives
    ------------
    add_sample_class_knn

    Predecessors
    ------------
    create_class_knn

    Successors
    ----------
    train_class_knn
    """
    with HalconOperator(430) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, class_regions)
        proc.set_input_tuple(0, knnhandle)
        proc.execute()


def add_samples_image_class_mlp(
    image: HObject,
    class_regions: HObject,
    mlphandle: HHandle
) -> None:
    """
    Add training samples from an image to the training data of a
    multilayer perceptron.

    Parameters
    ----------

    image : HObject
            Training image.

    class_regions : HObject
                    Regions of the classes to be trained.

    mlphandle : HHandle
                MLP handle.

    See Also
    --------
    classify_image_class_mlp, add_sample_class_mlp,
    clear_samples_class_mlp, get_sample_num_class_mlp,
    get_sample_class_mlp, add_samples_image_class_svm

    Alternatives
    ------------
    read_samples_class_mlp

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    train_class_mlp, write_samples_class_mlp
    """
    with HalconOperator(436) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, class_regions)
        proc.set_input_tuple(0, mlphandle)
        proc.execute()


def add_samples_image_class_svm(
    image: HObject,
    class_regions: HObject,
    svmhandle: HHandle
) -> None:
    """
    Add training samples from an image to the training data of a support
    vector machine.

    Parameters
    ----------

    image : HObject
            Training image.

    class_regions : HObject
                    Regions of the classes to be trained.

    svmhandle : HHandle
                SVM handle.

    See Also
    --------
    classify_image_class_svm, add_sample_class_svm,
    clear_samples_class_svm, get_sample_num_class_svm,
    get_sample_class_svm, add_samples_image_class_mlp

    Alternatives
    ------------
    read_samples_class_svm

    Predecessors
    ------------
    create_class_svm

    Successors
    ----------
    train_class_svm, write_samples_class_svm
    """
    with HalconOperator(434) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, class_regions)
        proc.set_input_tuple(0, svmhandle)
        proc.execute()


def add_scene_3d_camera(
    scene_3d: HHandle,
    camera_param: Sequence[Union[float, int, str]]
) -> int:
    """
    Add a camera to a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    camera_param : Sequence[Union[float, int, str]]
                   Parameters of the new camera.

    Returns
    -------

    camera_index : int
                   Index of the new camera in the 3D scene.

    Predecessors
    ------------
    create_scene_3d

    Successors
    ----------
    set_scene_3d_camera_pose, display_scene_3d

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1218) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, camera_param)
        proc.init_oct(0)
        proc.execute()
        camera_index = proc.get_output_tuple_s(0)
        return camera_index  # type: ignore


def add_scene_3d_instance(
    scene_3d: HHandle,
    object_model_3d: MaybeSequence[HHandle],
    pose: Sequence[Union[float, int]]
) -> int:
    """
    Add an instance of a 3D object model to a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    pose : Sequence[Union[float, int]]
           Pose of the 3D object model.

    Returns
    -------

    instance_index : int
                     Index of the new instance in the 3D scene.

    See Also
    --------
    remove_scene_3d_instance

    Predecessors
    ------------
    create_scene_3d

    Successors
    ----------
    set_scene_3d_instance_param, set_scene_3d_instance_pose
    """
    with HalconOperator(1217) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, pose)
        proc.init_oct(0)
        proc.execute()
        instance_index = proc.get_output_tuple_s(0)
        return instance_index  # type: ignore


def add_scene_3d_label(
    scene_3d: HHandle,
    text: MaybeSequence[str],
    reference_point: Sequence[Union[float, int]],
    position: Sequence[Union[float, int, str]],
    relates_to: Sequence[str]
) -> int:
    """
    Add a text label to a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    text : MaybeSequence[str]
           Text of the label.
           Value Suggestion: label

    reference_point : Sequence[Union[float, int]]
                      Point of reference of the label.

    position : Sequence[Union[float, int, str]]
               Position of the label.
               Value Suggestion: 'top'

    relates_to : Sequence[str]
                 Indicates fixed or relative positioning.
                 Value Suggestion: 'point'

    Returns
    -------

    label_index : int
                  Index of the new label in the 3D scene.

    See Also
    --------
    remove_scene_3d_instance

    Predecessors
    ------------
    create_scene_3d

    Successors
    ----------
    set_scene_3d_label_param
    """
    with HalconOperator(2040) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, text)
        proc.set_input_tuple(2, reference_point)
        proc.set_input_tuple(3, position)
        proc.set_input_tuple(4, relates_to)
        proc.init_oct(0)
        proc.execute()
        label_index = proc.get_output_tuple_s(0)
        return label_index  # type: ignore


def add_scene_3d_light(
    scene_3d: HHandle,
    light_position: Sequence[Union[int, float]],
    light_kind: str
) -> int:
    """
    Add a light source to a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    light_position : Sequence[Union[int, float]]
                     Position of the new light source.
                     Value Suggestion: [-100.0,-100.0,0.0]

    light_kind : str
                 Type of the new light source.
                 Value Suggestion: 'point_light'

    Returns
    -------

    light_index : int
                  Index of the new light source in the 3D scene.

    See Also
    --------
    remove_scene_3d_light

    Predecessors
    ------------
    create_scene_3d

    Successors
    ----------
    set_scene_3d_light_param
    """
    with HalconOperator(1216) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, light_position)
        proc.set_input_tuple(2, light_kind)
        proc.init_oct(0)
        proc.execute()
        light_index = proc.get_output_tuple_s(0)
        return light_index  # type: ignore


def add_texture_inspection_model_image(
    image: HObject,
    texture_inspection_model: HHandle
) -> Sequence[int]:
    """
    Add training images to the texture inspection model.

    Parameters
    ----------

    image : HObject
            Image of flawless texture.

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    Returns
    -------

    indices : Sequence[int]
              Indices of the images that have been added to the texture
              inspection model.

    Predecessors
    ------------
    create_texture_inspection_model, set_texture_inspection_model_param,
    get_texture_inspection_model_param

    Successors
    ----------
    train_texture_inspection_model, clear_texture_inspection_model,
    remove_texture_inspection_model_image,
    get_texture_inspection_model_image
    """
    with HalconOperator(2043) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, texture_inspection_model)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_m(0)
        return indices  # type: ignore


def add_texture_inspection_model_image_s(
    image: HObject,
    texture_inspection_model: HHandle
) -> int:
    """
    Add training images to the texture inspection model.

    Parameters
    ----------

    image : HObject
            Image of flawless texture.

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    Returns
    -------

    indices : int
              Indices of the images that have been added to the texture
              inspection model.

    Predecessors
    ------------
    create_texture_inspection_model, set_texture_inspection_model_param,
    get_texture_inspection_model_param

    Successors
    ----------
    train_texture_inspection_model, clear_texture_inspection_model,
    remove_texture_inspection_model_image,
    get_texture_inspection_model_image
    """
    with HalconOperator(2043) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, texture_inspection_model)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_s(0)
        return indices  # type: ignore


def adjust_mosaic_images(
    images: HObject,
    from_val: Sequence[int],
    to: Sequence[int],
    reference_image: int,
    hom_matrices_2d: Sequence[float],
    estimation_method: str,
    estimate_parameters: MaybeSequence[str],
    oecfmodel: str
) -> HObject:
    """
    Apply an automatic color correction to panorama images.

    Parameters
    ----------

    images : HObject
             Input images.

    from_val : Sequence[int]
               List of source images.

    to : Sequence[int]
         List of destination images.

    reference_image : int
                      Reference image.

    hom_matrices_2d : Sequence[float]
                      Projective matrices.

    estimation_method : str
                        Estimation algorithm for the correction.
                        Value Suggestion: standard

    estimate_parameters : MaybeSequence[str]
                          Parameters to be estimated.
                          Value Suggestion: ['mult_gray']

    oecfmodel : str
                Model of OECF to be used.
                Value Suggestion: ['laguerre']

    Returns
    -------

    corrected_images : HObject
                       Output images.

    Predecessors
    ------------
    stationary_camera_self_calibration

    Successors
    ----------
    gen_spherical_mosaic
    """
    with HalconOperator(1615) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, from_val)
        proc.set_input_tuple(1, to)
        proc.set_input_tuple(2, reference_image)
        proc.set_input_tuple(3, hom_matrices_2d)
        proc.set_input_tuple(4, estimation_method)
        proc.set_input_tuple(5, estimate_parameters)
        proc.set_input_tuple(6, oecfmodel)
        proc.execute()
        corrected_images = HObject(proc.get_output_object_key(1))
        return corrected_images  # type: ignore


def affine_trans_contour_xld(
    contours: HObject,
    hom_mat_2d: Sequence[float]
) -> HObject:
    """
    Apply an arbitrary affine 2D transformation to XLD contours.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    contours_affine_trans : HObject
                            Transformed XLD contours.

    See Also
    --------
    affine_trans_image, affine_trans_region

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_rotate,
    hom_mat2d_scale, hom_mat2d_reflect

    Notes
    -----
    affine_trans_contour_xld does not use the HALCON standard coordinate
    system (with the origin in the center of the upper left pixel), but
    instead uses the same coordinate system as in affine_trans_pixel,
    i.e., the origin lies in the upper left corner of the upper left
    pixel.  Therefore, applying affine_trans_contour_xld corresponds to a
    chain of transformations (see affine_trans_pixel), which is applied
    to each point of the contour (input and output pixels as homogeneous
    vectors). As an effect, you might get unexpected results when creating
    affine transformations based on coordinates that are derived from the
    contour, e.g., by operators like area_center_xld. For example, if you
    use this operator to calculate the center of gravity of a rotationally
    symmetric XLD contour and then rotate the contour around this point
    using hom_mat2d_rotate, the resulting contour will not lie on the
    original one. In such a case, you can compensate this effect by
    applying the following translations to HomMat2D before using it in
    affine_trans_contour_xld:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_contour_xld(Contours, ContoursAffineTrans,
    HomMat2DAdapted)
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_contour_xld(Contours, ContoursAffineTrans,
    HomMat2DAdapted)
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(49) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.execute()
        contours_affine_trans = HObject(proc.get_output_object_key(1))
        return contours_affine_trans  # type: ignore


def affine_trans_image(
    image: HObject,
    hom_mat_2d: Sequence[float],
    interpolation: str,
    adapt_image_size: str
) -> HObject:
    """
    Apply an arbitrary affine 2D transformation to images.

    Parameters
    ----------

    image : HObject
            Input image.

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    interpolation : str
                    Type of interpolation.
                    Value Suggestion: constant

    adapt_image_size : str
                       Adaption of size of result image.
                       Value Suggestion: false

    Returns
    -------

    image_affine_trans : HObject
                         Transformed image.

    See Also
    --------
    set_part_style

    Alternatives
    ------------
    affine_trans_image_size, zoom_image_size, zoom_image_factor,
    mirror_image, rotate_image, affine_trans_region

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_rotate,
    hom_mat2d_scale, hom_mat2d_reflect

    Notes
    -----
    The region of the input image is ignored.
    affine_trans_image does not use the HALCON standard coordinate system
    (with the origin in the center of the first pixel), but instead uses
    the same coordinate system as in affine_trans_pixel, i.e., the origin
    lies in the upper left corner of the first pixel. Therefore, applying
    affine_trans_image corresponds to a chain of transformations (see
    affine_trans_pixel), which is applied to each point of the image
    (input and output pixels as homogeneous vectors). As an effect, you
    might get unexpected results when creating affine transformations
    based on coordinates that are derived from the image, e.g., by
    operators like area_center_gray. For example, if you use this operator
    to calculate the center of gravity of a rotationally symmetric image
    and then rotate the image around this point using hom_mat2d_rotate,
    the resulting image will not lie on the original one. In such a case,
    you can compensate this effect by applying the following translations
    to HomMat2D before using it in affine_trans_image:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_image(Image, ImageAffineTrans, HomMat2DAdapted,
    'constant', 'false')
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_image(Image, ImageAffineTrans, HomMat2DAdapted,
    'constant', 'false')
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(1623) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, interpolation)
        proc.set_input_tuple(2, adapt_image_size)
        proc.execute()
        image_affine_trans = HObject(proc.get_output_object_key(1))
        return image_affine_trans  # type: ignore


def affine_trans_image_size(
    image: HObject,
    hom_mat_2d: Sequence[float],
    interpolation: str,
    width: int,
    height: int
) -> HObject:
    """
    Apply an arbitrary affine 2D transformation to an image and specify
    the output image size.

    Parameters
    ----------

    image : HObject
            Input image.

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    interpolation : str
                    Type of interpolation.
                    Value Suggestion: constant

    width : int
            Width of the output image.
            Value Suggestion: 640

    height : int
             Height of the output image.
             Value Suggestion: 480

    Returns
    -------

    image_affine_trans : HObject
                         Transformed image.

    See Also
    --------
    set_part_style

    Alternatives
    ------------
    affine_trans_image, zoom_image_size, zoom_image_factor, mirror_image,
    rotate_image, affine_trans_region

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_rotate,
    hom_mat2d_scale, hom_mat2d_reflect

    Notes
    -----
    The region of the input image is ignored.
    affine_trans_image_size does not use the HALCON standard coordinate
    system (with the origin in the center of the upper left pixel), but
    instead uses the same coordinate system as in affine_trans_pixel,
    i.e., the origin lies in the upper left corner of the upper left
    pixel.  Therefore, applying affine_trans_image_size corresponds to a
    chain of transformations (see affine_trans_pixel), which is applied to
    each point of the image (input and output pixels as homogeneous
    vectors).  As an effect, you might get unexpected results when
    creating affine transformations based on coordinates that are derived
    from the image, e.g., by operators like area_center_gray. For example,
    if you use this operator to calculate the center of gravity of a
    rotationally symmetric image and then rotate the image around this
    point using hom_mat2d_rotate, the resulting image will not lie on the
    original one. In such a case, you can compensate this effect by
    applying the following translations to HomMat2D before using it in
    affine_trans_image_size:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_image_size(Image, ImageAffineTrans, HomMat2DAdapted,
    'constant', Width, Height)
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_image_size(Image, ImageAffineTrans, HomMat2DAdapted,
    'constant', Width, Height)
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(1622) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, interpolation)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.execute()
        image_affine_trans = HObject(proc.get_output_object_key(1))
        return image_affine_trans  # type: ignore


def affine_trans_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    hom_mat_3d: Sequence[float]
) -> Sequence[HHandle]:
    """
    Apply an arbitrary affine 3D transformation to 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    hom_mat_3d : Sequence[float]
                 Transformation matrices.

    Returns
    -------

    object_model_3daffine_trans : Sequence[HHandle]
                                  Handles of the transformed 3D object
                                  models.

    See Also
    --------
    affine_trans_point_3d, rigid_trans_object_model_3d,
    projective_trans_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    affine_trans_object_model_3d transforms the attributes of type 3D
    points, 3D point normals, and the prepared shape model for shape-based
    3D matching. All other attributes are copied without modification. To
    transform 3D primitives, the operator rigid_trans_object_model_3d must
    be used.
    """
    with HalconOperator(1098) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        object_model_3daffine_trans = proc.get_output_tuple_m(0)
        return object_model_3daffine_trans  # type: ignore


def affine_trans_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    hom_mat_3d: Sequence[float]
) -> HHandle:
    """
    Apply an arbitrary affine 3D transformation to 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    hom_mat_3d : Sequence[float]
                 Transformation matrices.

    Returns
    -------

    object_model_3daffine_trans : HHandle
                                  Handles of the transformed 3D object
                                  models.

    See Also
    --------
    affine_trans_point_3d, rigid_trans_object_model_3d,
    projective_trans_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    affine_trans_object_model_3d transforms the attributes of type 3D
    points, 3D point normals, and the prepared shape model for shape-based
    3D matching. All other attributes are copied without modification. To
    transform 3D primitives, the operator rigid_trans_object_model_3d must
    be used.
    """
    with HalconOperator(1098) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        object_model_3daffine_trans = proc.get_output_tuple_s(0)
        return object_model_3daffine_trans  # type: ignore


def affine_trans_pixel(
    hom_mat_2d: Sequence[float],
    row: MaybeSequence[Union[float, int]],
    col: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Apply an arbitrary affine 2D transformation to pixel coordinates.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    row : MaybeSequence[Union[float, int]]
          Input pixel(s) (row coordinate).
          Value Suggestion: 64

    col : MaybeSequence[Union[float, int]]
          Input pixel(s) (column coordinate).
          Value Suggestion: 64

    Returns
    -------

    row_trans : Sequence[float]
                Output pixel(s) (row coordinate).

    col_trans : Sequence[float]
                Output pixel(s) (column coordinate).

    Alternatives
    ------------
    affine_trans_point_2d

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local
    """
    with HalconOperator(272) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, col)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_trans
            proc.get_output_tuple_m(1)   # col_trans
        )  # type: ignore


def affine_trans_pixel_s(
    hom_mat_2d: Sequence[float],
    row: MaybeSequence[Union[float, int]],
    col: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Apply an arbitrary affine 2D transformation to pixel coordinates.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    row : MaybeSequence[Union[float, int]]
          Input pixel(s) (row coordinate).
          Value Suggestion: 64

    col : MaybeSequence[Union[float, int]]
          Input pixel(s) (column coordinate).
          Value Suggestion: 64

    Returns
    -------

    row_trans : float
                Output pixel(s) (row coordinate).

    col_trans : float
                Output pixel(s) (column coordinate).

    Alternatives
    ------------
    affine_trans_point_2d

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local
    """
    with HalconOperator(272) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, col)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_trans
            proc.get_output_tuple_s(1)   # col_trans
        )  # type: ignore


def affine_trans_point_2d(
    hom_mat_2d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Apply an arbitrary affine 2D transformation to points.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point(s) (x or row coordinate).
         Value Suggestion: 64

    py : MaybeSequence[Union[float, int]]
         Input point(s) (y or column coordinate).
         Value Suggestion: 64

    Returns
    -------

    qx : Sequence[float]
         Output point(s) (x or row coordinate).

    qy : Sequence[float]
         Output point(s) (y or column coordinate).

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local
    """
    with HalconOperator(273) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1)   # qy
        )  # type: ignore


def affine_trans_point_2d_s(
    hom_mat_2d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Apply an arbitrary affine 2D transformation to points.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point(s) (x or row coordinate).
         Value Suggestion: 64

    py : MaybeSequence[Union[float, int]]
         Input point(s) (y or column coordinate).
         Value Suggestion: 64

    Returns
    -------

    qx : float
         Output point(s) (x or row coordinate).

    qy : float
         Output point(s) (y or column coordinate).

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local
    """
    with HalconOperator(273) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1)   # qy
        )  # type: ignore


def affine_trans_point_3d(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Apply an arbitrary affine 3D transformation to points.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point(s) (x coordinate).
         Value Suggestion: 64

    py : MaybeSequence[Union[float, int]]
         Input point(s) (y coordinate).
         Value Suggestion: 64

    pz : MaybeSequence[Union[float, int]]
         Input point(s) (z coordinate).
         Value Suggestion: 64

    Returns
    -------

    qx : Sequence[float]
         Output point(s) (x coordinate).

    qy : Sequence[float]
         Output point(s) (y coordinate).

    qz : Sequence[float]
         Output point(s) (z coordinate).

    Predecessors
    ------------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local
    """
    with HalconOperator(241) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1),  # qy
            proc.get_output_tuple_m(2)   # qz
        )  # type: ignore


def affine_trans_point_3d_s(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]]
) -> Tuple[float, float, float]:
    """
    Apply an arbitrary affine 3D transformation to points.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point(s) (x coordinate).
         Value Suggestion: 64

    py : MaybeSequence[Union[float, int]]
         Input point(s) (y coordinate).
         Value Suggestion: 64

    pz : MaybeSequence[Union[float, int]]
         Input point(s) (z coordinate).
         Value Suggestion: 64

    Returns
    -------

    qx : float
         Output point(s) (x coordinate).

    qy : float
         Output point(s) (y coordinate).

    qz : float
         Output point(s) (z coordinate).

    Predecessors
    ------------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local
    """
    with HalconOperator(241) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1),  # qy
            proc.get_output_tuple_s(2)   # qz
        )  # type: ignore


def affine_trans_polygon_xld(
    polygons: HObject,
    hom_mat_2d: Sequence[float]
) -> HObject:
    """
    Apply an arbitrary affine transformation to XLD polygons.

    Parameters
    ----------

    polygons : HObject
               Input XLD polygons.

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    polygons_affine_trans : HObject
                            Transformed XLD polygons.

    See Also
    --------
    affine_trans_image, affine_trans_region, affine_trans_contour_xld

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_rotate,
    hom_mat2d_scale, hom_mat2d_reflect

    Notes
    -----
    The XLD contours that are possibly referenced by Polygons are neither
    transformed nor stored with the output polygons, since this is
    generally impossible without creating inconsistencies for the
    attributes of the XLD contours.  Hence, operators that access the
    contours associated with a polygon, e.g., split_contours_xld will not
    work correctly.
    affine_trans_polygon_xld does not use the HALCON standard coordinate
    system (with the origin in the center of the upper left pixel), but
    instead uses the same coordinate system as in affine_trans_pixel,
    i.e., the origin lies in the upper left corner of the upper left
    pixel. Therefore, applying affine_trans_polygon_xld corresponds to a
    chain of transformations (see affine_trans_pixel), which is applied to
    each point of the polygon (input and output pixels as homogeneous
    vectors). As an effect, you might get unexpected results when creating
    affine transformations based on coordinates that are derived from the
    polygon, e.g., by operators like area_center_xld. For example, if you
    use this operator to calculate the center of gravity of a rotationally
    symmetric XLD polygon and then rotate the polygon around this point
    using hom_mat2d_rotate, the resulting polygon will not lie on the
    original one. In such a case, you can compensate this effect by
    applying the following translations to HomMat2D before using it in
    affine_trans_polygon_xld:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_polygon_xld(Polygons, PolygonsAffineTrans,
    HomMat2DAdapted)
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_polygon_xld(Polygons, PolygonsAffineTrans,
    HomMat2DAdapted)
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(48) as proc:
        proc.set_input_object(1, polygons)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.execute()
        polygons_affine_trans = HObject(proc.get_output_object_key(1))
        return polygons_affine_trans  # type: ignore


def affine_trans_region(
    region: HObject,
    hom_mat_2d: Sequence[float],
    interpolate: str
) -> HObject:
    """
    Apply an arbitrary affine 2D transformation to regions.

    Parameters
    ----------

    region : HObject
             Region(s) to be rotated and scaled.

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    interpolate : str
                  Should the transformation be done using interpolation?
                  Value Suggestion: nearest_neighbor

    Returns
    -------

    region_affine_trans : HObject
                          Transformed output region(s).

    See Also
    --------
    affine_trans_image

    Alternatives
    ------------
    move_region, mirror_region, zoom_region

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_scale, hom_mat2d_translate,
    hom_mat2d_invert, hom_mat2d_rotate, hom_mat2d_reflect

    Successors
    ----------
    select_shape

    Notes
    -----
    affine_trans_region in general is not reversible (clipping and
    discretization during rotation and scaling).
    affine_trans_region does not use the HALCON standard coordinate system
    (with the origin in the center of the upper left pixel), but instead
    uses the same coordinate system as in affine_trans_pixel, i.e., the
    origin lies in the upper left corner of the upper left pixel.
    Therefore, applying affine_trans_region corresponds to a chain of
    transformations (see affine_trans_pixel), which is  applied to each
    point of the region (input and output pixels as  homogeneous vectors).
    As an effect, you might get unexpected results when creating affine
    transformations based on coordinates that are derived from the region,
    e.g., by operators like area_center. For example, if you use this
    operator to calculate the center of gravity of a rotationally
    symmetric region and then rotate the region around this point using
    hom_mat2d_rotate, the resulting region will not lie on the original
    one. In such a case, you can compensate this effect by applying the
    following translations to HomMat2D before using it in
    affine_trans_region:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_region(Region, RegionAffineTrans, HomMat2DAdapted,
    'nearest_neighbor')
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    affine_trans_region(Region, RegionAffineTrans, HomMat2DAdapted,
    'nearest_neighbor')
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(488) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, interpolate)
        proc.execute()
        region_affine_trans = HObject(proc.get_output_object_key(1))
        return region_affine_trans  # type: ignore


def align_metrology_model(
    metrology_handle: HHandle,
    row: Union[int, float],
    column: Union[int, float],
    angle: Union[int, float]
) -> None:
    """
    Alignment of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    row : Union[int, float]
          Row coordinate of the alignment.
          Value Suggestion: 0

    column : Union[int, float]
             Column coordinate of the alignment.
             Value Suggestion: 0

    angle : Union[int, float]
            Rotation angle of the alignment.
            Value Suggestion: 0

    See Also
    --------
    get_metrology_object_model_contour

    Predecessors
    ------------
    set_metrology_model_param, add_metrology_object_generic

    Successors
    ----------
    apply_metrology_model
    """
    with HalconOperator(790) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, angle)
        proc.execute()


def angle_ll(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the angle between two lines.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the first line.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the first line.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the first line.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the first line.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the second line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the second line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the second line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the second line.

    Returns
    -------

    angle : Sequence[float]
            Angle between the lines [rad].

    Alternatives
    ------------
    angle_lx
    """
    with HalconOperator(1371) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.execute()
        angle = proc.get_output_tuple_m(0)
        return angle  # type: ignore


def angle_ll_s(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the angle between two lines.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the first line.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the first line.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the first line.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the first line.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the second line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the second line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the second line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the second line.

    Returns
    -------

    angle : float
            Angle between the lines [rad].

    Alternatives
    ------------
    angle_lx
    """
    with HalconOperator(1371) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.execute()
        angle = proc.get_output_tuple_s(0)
        return angle  # type: ignore


def angle_lx(
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the angle between one line and the horizontal axis.

    Parameters
    ----------

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    angle : Sequence[float]
            Angle between the line and the horizontal axis [rad].

    Alternatives
    ------------
    angle_ll
    """
    with HalconOperator(1370) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.execute()
        angle = proc.get_output_tuple_m(0)
        return angle  # type: ignore


def angle_lx_s(
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the angle between one line and the horizontal axis.

    Parameters
    ----------

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    angle : float
            Angle between the line and the horizontal axis [rad].

    Alternatives
    ------------
    angle_ll
    """
    with HalconOperator(1370) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.execute()
        angle = proc.get_output_tuple_s(0)
        return angle  # type: ignore


def anisotropic_diffusion(
    image: HObject,
    mode: str,
    contrast: float,
    theta: float,
    iterations: int
) -> HObject:
    """
    Perform an anisotropic diffusion of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    mode : str
           Diffusion coefficient as a function of the edge amplitude.
           Value Suggestion: weickert

    contrast : float
               Contrast parameter.
               Value Suggestion: 5.0
               Assertion: Contrast > 0

    theta : float
            Time step.
            Value Suggestion: 1.0
            Assertion: Theta > 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    Returns
    -------

    image_aniso : HObject
                  Output image.

    Alternatives
    ------------
    bilateral_filter, guided_filter

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1406) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, contrast)
        proc.set_input_tuple(2, theta)
        proc.set_input_tuple(3, iterations)
        proc.execute()
        image_aniso = HObject(proc.get_output_object_key(1))
        return image_aniso  # type: ignore


def append_channel(
    multi_channel_image: HObject,
    image: HObject
) -> HObject:
    """
    Append additional matrices (channels) to the image.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    image : HObject
            Image to be appended.

    Returns
    -------

    image_extended : HObject
                     Image appended by Image.

    Alternatives
    ------------
    compose2, compose3, compose4, compose5

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1134) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.set_input_object(2, image)
        proc.execute()
        image_extended = HObject(proc.get_output_object_key(1))
        return image_extended  # type: ignore


def append_ocr_trainf(
    character: HObject,
    image: HObject,
    class_val: MaybeSequence[str],
    training_file: str
) -> None:
    """
    Add characters to a training file.

    Parameters
    ----------

    character : HObject
                Characters to be trained.

    image : HObject
            Gray values of the characters.

    class_val : MaybeSequence[str]
                Class (name) of the characters.

    training_file : str
                    Name of the training file.
                    Value Suggestion: 'train_ocr'

    Alternatives
    ------------
    write_ocr_trainf, write_ocr_trainf_image

    Predecessors
    ------------
    threshold, connection, read_ocr_trainf

    Successors
    ----------
    trainf_ocr_class_mlp, trainf_ocr_class_svm, write_ocr_trainf
    """
    with HalconOperator(730) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, class_val)
        proc.set_input_tuple(1, training_file)
        proc.execute()


def apply_bead_inspection_model(
    image: HObject,
    bead_inspection_model: HHandle
) -> Tuple[HObject, HObject, HObject, Sequence[str]]:
    """
    Inspect beads in an image, as defined by the bead inspection model.

    Parameters
    ----------

    image : HObject
            Image to apply bead inspection on.

    bead_inspection_model : HHandle
                            Handle of the bead inspection model to be used.

    Returns
    -------

    left_contour : HObject
                   The detected left contour of the beads.

    right_contour : HObject
                    The detected right contour of the beads.

    error_segment : HObject
                    Detected error segments

    error_type : Sequence[str]
                 Types of detected errors.

    See Also
    --------
    get_bead_inspection_param, create_bead_inspection_model,
    set_bead_inspection_param

    Predecessors
    ------------
    create_bead_inspection_model, set_bead_inspection_param

    Successors
    ----------
    set_bead_inspection_param, clear_bead_inspection_model
    """
    with HalconOperator(1983) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bead_inspection_model)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # left_contour
            HObject(proc.get_output_object_key(2)),  # right_contour
            HObject(proc.get_output_object_key(3)),  # error_segment
            proc.get_output_tuple_m(0)   # error_type
        )  # type: ignore


def apply_color_trans_lut(
    image_1: HObject,
    image_2: HObject,
    image_3: HObject,
    color_trans_luthandle: HHandle
) -> Tuple[HObject, HObject, HObject]:
    """
    Color space transformation using pre-generated look-up-table.

    Parameters
    ----------

    image_1 : HObject
              Input image (channel 1).

    image_2 : HObject
              Input image (channel 2).

    image_3 : HObject
              Input image (channel 3).

    color_trans_luthandle : HHandle
                            Handle of the look-up-table for the color
                            space transformation.

    Returns
    -------

    image_result_1 : HObject
                     Color-transformed output image (channel 1).

    image_result_2 : HObject
                     Color-transformed output image (channel 2).

    image_result_3 : HObject
                     Color-transformed output image (channel 3).

    See Also
    --------
    create_color_trans_lut, clear_color_trans_lut

    Alternatives
    ------------
    trans_from_rgb, trans_to_rgb

    Predecessors
    ------------
    create_color_trans_lut

    Successors
    ----------
    clear_color_trans_lut
    """
    with HalconOperator(1578) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_object(3, image_3)
        proc.set_input_tuple(0, color_trans_luthandle)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_result_1
            HObject(proc.get_output_object_key(2)),  # image_result_2
            HObject(proc.get_output_object_key(3))   # image_result_3
        )  # type: ignore


def apply_deep_ocr(
    image: HObject,
    deep_ocr_handle: HHandle,
    mode: str
) -> Sequence[HHandle]:
    """
    Apply a Deep OCR model on a set of images for inference.

    Parameters
    ----------

    image : HObject
            Input image.

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    mode : str
           Inference mode.
           Value Suggestion: []

    Returns
    -------

    deep_ocr_result : Sequence[HHandle]
                      Tuple of result dictionaries.

    Predecessors
    ------------
    get_deep_ocr_param, set_deep_ocr_param, create_deep_ocr

    Notes
    -----
    System requirements: To run this operator on GPU (see
    get_deep_ocr_param), cuDNN and cuBLAS are required. For further
    details, please refer to the ``Installation Guide'', paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    Alternatively, this operator can also be run on CPU.
    """
    with HalconOperator(2206) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, deep_ocr_handle)
        proc.set_input_tuple(1, mode)
        proc.init_oct(0)
        proc.execute()
        deep_ocr_result = proc.get_output_tuple_m(0)
        return deep_ocr_result  # type: ignore


def apply_deep_ocr_s(
    image: HObject,
    deep_ocr_handle: HHandle,
    mode: str
) -> HHandle:
    """
    Apply a Deep OCR model on a set of images for inference.

    Parameters
    ----------

    image : HObject
            Input image.

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    mode : str
           Inference mode.
           Value Suggestion: []

    Returns
    -------

    deep_ocr_result : HHandle
                      Tuple of result dictionaries.

    Predecessors
    ------------
    get_deep_ocr_param, set_deep_ocr_param, create_deep_ocr

    Notes
    -----
    System requirements: To run this operator on GPU (see
    get_deep_ocr_param), cuDNN and cuBLAS are required. For further
    details, please refer to the ``Installation Guide'', paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    Alternatively, this operator can also be run on CPU.
    """
    with HalconOperator(2206) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, deep_ocr_handle)
        proc.set_input_tuple(1, mode)
        proc.init_oct(0)
        proc.execute()
        deep_ocr_result = proc.get_output_tuple_s(0)
        return deep_ocr_result  # type: ignore


def apply_distance_transform_xld(
    contour: HObject,
    distance_transform_id: HHandle
) -> HObject:
    """
    Determine the pointwise distance of two contours using an XLD distance
    transform.

    Parameters
    ----------

    contour : HObject
              Contour(s) for whose points the distances are calculated.

    distance_transform_id : HHandle
                            Handle of the XLD distance transform of the
                            reference contour.

    Returns
    -------

    contour_out : HObject
                  Copy of Contour containing the distances as an attribute.

    See Also
    --------
    get_contour_attrib_xld, set_distance_transform_xld_param,
    write_distance_transform_xld, serialize_distance_transform_xld,
    clear_distance_transform_xld

    Alternatives
    ------------
    distance_contours_xld

    Predecessors
    ------------
    create_distance_transform_xld, read_distance_transform_xld,
    deserialize_distance_transform_xld, set_distance_transform_xld_param

    Successors
    ----------
    get_contour_attrib_xld, segment_contour_attrib_xld
    """
    with HalconOperator(1352) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, distance_transform_id)
        proc.execute()
        contour_out = HObject(proc.get_output_object_key(1))
        return contour_out  # type: ignore


def apply_dl_classifier(
    images: HObject,
    dlclassifier_handle: HHandle
) -> HHandle:
    """
    Infer the class affiliations for a set of images using a
    deep-learning-based classifier.

    Parameters
    ----------

    images : HObject
             Tuple of input images.

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    Returns
    -------

    dlclassifier_result_handle : HHandle
                                 Handle of the deep learning
                                 classification  results.

    Alternatives
    ------------
    apply_dl_model, classify_class_mlp, classify_class_svm

    Predecessors
    ------------
    read_dl_classifier, train_dl_classifier_batch, set_dl_classifier_param

    Successors
    ----------
    get_dl_classifier_result, clear_dl_classifier

    Warnings
    --------
    apply_dl_classifier is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the general
    CNN-based operator apply_dl_model instead.

    Notes
    -----
    To run this operator, cuDNN and cuBLAS are required when 'runtime' is
    set to 'gpu', see set_dl_classifier_param. For further details, please
    refer to the ``Installation Guide'',  paragraph ``Requirements for
    Deep Learning and Deep-Learning-Based Methods''.
    """
    with HalconOperator(2102) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.init_oct(0)
        proc.execute()
        dlclassifier_result_handle = proc.get_output_tuple_s(0)
        return dlclassifier_result_handle  # type: ignore


def apply_dl_model(
    dlmodel_handle: HHandle,
    dlsample_batch: Sequence[HHandle],
    outputs: Sequence[str]
) -> Sequence[HHandle]:
    """
    Apply a deep-learning-based network on a set of images for inference.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    dlsample_batch : Sequence[HHandle]
                     Input data.

    outputs : Sequence[str]
              Requested outputs.
              Value Suggestion: []

    Returns
    -------

    dlresult_batch : Sequence[HHandle]
                     Result data.

    Predecessors
    ------------
    read_dl_model, train_dl_model_batch, train_dl_model_anomaly_dataset,
    set_dl_model_param

    Notes
    -----
    System requirements:  To run this operator on GPU by setting 'runtime'
    to 'gpu' (see get_dl_model_param), cuDNN and cuBLAS are required. For
    further details, please refer to the ``Installation Guide'', paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    Alternatively, this operator can also be run on CPU by setting
    'runtime' to 'cpu'
    """
    with HalconOperator(2146) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, dlsample_batch)
        proc.set_input_tuple(2, outputs)
        proc.init_oct(0)
        proc.execute()
        dlresult_batch = proc.get_output_tuple_m(0)
        return dlresult_batch  # type: ignore


def apply_metrology_model(
    image: HObject,
    metrology_handle: HHandle
) -> None:
    """
    Measure and fit the geometric shapes of all metrology objects of a
    metrology model.

    Parameters
    ----------

    image : HObject
            Input image.

    metrology_handle : HHandle
                       Handle of the metrology model.

    See Also
    --------
    set_metrology_object_fuzzy_param, read_metrology_model,
    write_metrology_model

    Predecessors
    ------------
    add_metrology_object_generic, add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure,
    add_metrology_object_line_measure,
    add_metrology_object_rectangle2_measure, align_metrology_model,
    set_metrology_model_param, set_metrology_object_param

    Successors
    ----------
    get_metrology_object_result, get_metrology_object_result_contour,
    get_metrology_object_measures

    Notes
    -----
    Note that all measure regions of all metrology objects must be
    recomputed if the width or the height of the input Image is not equal
    to the width and height stored in the metrology object (e.g. set with
    set_metrology_model_image_size). This leads to longer execution times
    of the operator.
    Note further that apply_metrology_model ignores the domain of Image
    for efficiency reasons (see also measure_pos).
    """
    with HalconOperator(804) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, metrology_handle)
        proc.execute()


def apply_sample_identifier(
    image: HObject,
    sample_identifier: HHandle,
    num_results: int,
    rating_threshold: float,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> Tuple[Sequence[int], Sequence[float]]:
    """
    Identify objects with a sample identifier.

    Parameters
    ----------

    image : HObject
            Image showing the object to be identified.

    sample_identifier : HHandle
                        Handle of the sample identifier.

    num_results : int
                  Number of suggested object indices.
                  Value Suggestion: 1

    rating_threshold : float
                       Rating threshold.
                       Value Suggestion: 0.0

    gen_param_name : Sequence[str]
                     Generic parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Generic parameter value.
                      Value Suggestion: []

    Returns
    -------

    object_idx : Sequence[int]
                 Index of the identified object.

    rating : Sequence[float]
             Rating value of the identified object.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Predecessors
    ------------
    train_sample_identifier, read_sample_identifier

    Successors
    ----------
    add_sample_identifier_training_data
    """
    with HalconOperator(904) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, num_results)
        proc.set_input_tuple(2, rating_threshold)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # object_idx
            proc.get_output_tuple_m(1)   # rating
        )  # type: ignore


def apply_sample_identifier_s(
    image: HObject,
    sample_identifier: HHandle,
    num_results: int,
    rating_threshold: float,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> Tuple[int, float]:
    """
    Identify objects with a sample identifier.

    Parameters
    ----------

    image : HObject
            Image showing the object to be identified.

    sample_identifier : HHandle
                        Handle of the sample identifier.

    num_results : int
                  Number of suggested object indices.
                  Value Suggestion: 1

    rating_threshold : float
                       Rating threshold.
                       Value Suggestion: 0.0

    gen_param_name : Sequence[str]
                     Generic parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Generic parameter value.
                      Value Suggestion: []

    Returns
    -------

    object_idx : int
                 Index of the identified object.

    rating : float
             Rating value of the identified object.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Predecessors
    ------------
    train_sample_identifier, read_sample_identifier

    Successors
    ----------
    add_sample_identifier_training_data
    """
    with HalconOperator(904) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, num_results)
        proc.set_input_tuple(2, rating_threshold)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # object_idx
            proc.get_output_tuple_s(1)   # rating
        )  # type: ignore


def apply_sheet_of_light_calibration(
    disparity: HObject,
    sheet_of_light_model_id: HHandle
) -> None:
    """
    Apply the calibration transformations to the input disparity image.

    Parameters
    ----------

    disparity : HObject
                Height or range image to be calibrated.

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    Successors
    ----------
    get_sheet_of_light_result, get_sheet_of_light_result_object_model_3d
    """
    with HalconOperator(382) as proc:
        proc.set_input_object(1, disparity)
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.execute()


def apply_texture_inspection_model(
    image: HObject,
    texture_inspection_model: HHandle
) -> Tuple[HObject, HHandle]:
    """
    Inspection of the texture within an image.

    Parameters
    ----------

    image : HObject
            Image of the texture to be inspected.

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    Returns
    -------

    novelty_region : HObject
                     Novelty regions.

    texture_inspection_result_id : HHandle
                                   Handle of the inspection results.

    Predecessors
    ------------
    train_texture_inspection_model

    Successors
    ----------
    get_texture_inspection_result_object,
    get_texture_inspection_model_param, clear_texture_inspection_result,
    clear_texture_inspection_model
    """
    with HalconOperator(2044) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, texture_inspection_model)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # novelty_region
            proc.get_output_tuple_s(0)   # texture_inspection_result_id
        )  # type: ignore


def approx_chain(
    row: Sequence[int],
    column: Sequence[int],
    min_width_coord: float,
    max_width_coord: float,
    thresh_start: float,
    thresh_end: float,
    thresh_step: float,
    min_width_smooth: float,
    max_width_smooth: float,
    min_width_curve: int,
    max_width_curve: int,
    weight_1: float,
    weight_2: float,
    weight_3: float
) -> Tuple[Sequence[int], Sequence[int], Sequence[float], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Approximate a contour by arcs and lines.

    Parameters
    ----------

    row : Sequence[int]
          Row of the contour.
          Value Suggestion: 32

    column : Sequence[int]
             Column of the contour.
             Value Suggestion: 32

    min_width_coord : float
                      Minimum width of Gauss operator for coordinate
                      smoothing ($>$ 0.4).
                      Value Suggestion: 0.5

    max_width_coord : float
                      Maximum width of Gauss operator for coordinate
                      smoothing ($>$ 0.4).
                      Value Suggestion: 2.4

    thresh_start : float
                   Minimum threshold value of the curvature for accepting
                   a corner (relative to the largest curvature present).
                   Value Suggestion: 0.3

    thresh_end : float
                 Maximum threshold value of the curvature for accepting a
                 corner (relative to the largest curvature present).
                 Value Suggestion: 0.9

    thresh_step : float
                  Step width for threshold increase.
                  Value Suggestion: 0.2

    min_width_smooth : float
                       Minimum width of Gauss operator for smoothing the
                       curvature function ($>$ 0.4).
                       Value Suggestion: 0.5

    max_width_smooth : float
                       Maximum width of Gauss operator for smoothing the
                       curvature function.
                       Value Suggestion: 2.4

    min_width_curve : int
                      Minimum width of curve area for curvature
                      determination ($>$ 0.4).
                      Value Suggestion: 2

    max_width_curve : int
                      Maximum width of curve area for curvature
                      determination.
                      Value Suggestion: 12

    weight_1 : float
               Weighting factor for approximation precision.
               Value Suggestion: 1.0

    weight_2 : float
               Weighting factor for large segments.
               Value Suggestion: 1.0

    weight_3 : float
               Weighting factor for small segments.
               Value Suggestion: 1.0

    Returns
    -------

    arc_center_row : Sequence[int]
                     Row of the center of an arc.

    arc_center_col : Sequence[int]
                     Column of the center of an arc.

    arc_angle : Sequence[float]
                Angle of an arc.

    arc_begin_row : Sequence[int]
                    Row of the starting point of an arc.

    arc_begin_col : Sequence[int]
                    Column of the starting point of an arc.

    line_begin_row : Sequence[int]
                     Row of the starting point of a line segment.

    line_begin_col : Sequence[int]
                     Column of the starting point of a line segment.

    line_end_row : Sequence[int]
                   Row of the ending point of a line segment.

    line_end_col : Sequence[int]
                   Column of the ending point of a line segment.

    order : Sequence[int]
            Sequence of line (value 0) and arc segments (value 1).

    See Also
    --------
    get_region_chain, smallest_circle, disp_circle, disp_line

    Alternatives
    ------------
    get_region_polygon, approx_chain_simple

    Predecessors
    ------------
    sobel_amp, edges_image, get_region_contour, threshold,
    hysteresis_threshold

    Successors
    ----------
    set_line_width, disp_arc, disp_line

    Warnings
    --------
    approx_chain is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    Contours which can possibly consist of only one segment should also be
    examined with a threshold maximum (ThreshEnd) $>$ 1.0, because
    otherwise at least one ``corner point'' is determined in any case.
    """
    with HalconOperator(1742) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, min_width_coord)
        proc.set_input_tuple(3, max_width_coord)
        proc.set_input_tuple(4, thresh_start)
        proc.set_input_tuple(5, thresh_end)
        proc.set_input_tuple(6, thresh_step)
        proc.set_input_tuple(7, min_width_smooth)
        proc.set_input_tuple(8, max_width_smooth)
        proc.set_input_tuple(9, min_width_curve)
        proc.set_input_tuple(10, max_width_curve)
        proc.set_input_tuple(11, weight_1)
        proc.set_input_tuple(12, weight_2)
        proc.set_input_tuple(13, weight_3)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # arc_center_row
            proc.get_output_tuple_m(1),  # arc_center_col
            proc.get_output_tuple_m(2),  # arc_angle
            proc.get_output_tuple_m(3),  # arc_begin_row
            proc.get_output_tuple_m(4),  # arc_begin_col
            proc.get_output_tuple_m(5),  # line_begin_row
            proc.get_output_tuple_m(6),  # line_begin_col
            proc.get_output_tuple_m(7),  # line_end_row
            proc.get_output_tuple_m(8),  # line_end_col
            proc.get_output_tuple_m(9)   # order
        )  # type: ignore


def approx_chain_simple(
    row: Sequence[int],
    column: Sequence[int]
) -> Tuple[Sequence[int], Sequence[int], Sequence[float], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Approximate a contour by arcs and lines.

    Parameters
    ----------

    row : Sequence[int]
          Row of the contour.
          Value Suggestion: 32

    column : Sequence[int]
             Column of the contour.
             Value Suggestion: 32

    Returns
    -------

    arc_center_row : Sequence[int]
                     Row of the center of an arc.

    arc_center_col : Sequence[int]
                     Column of the center of an arc.

    arc_angle : Sequence[float]
                Angle of an arc.

    arc_begin_row : Sequence[int]
                    Row of the starting point of an arc.

    arc_begin_col : Sequence[int]
                    Column of the starting point of an arc.

    line_begin_row : Sequence[int]
                     Row of the starting point of a line segment.

    line_begin_col : Sequence[int]
                     Column of the starting point of a line segment.

    line_end_row : Sequence[int]
                   Row of the ending point of a line segment.

    line_end_col : Sequence[int]
                   Column of the ending point of a line segment.

    order : Sequence[int]
            Sequence of line (value 0) and arc segments (value 1).

    See Also
    --------
    get_region_chain, smallest_circle, disp_circle, disp_line

    Alternatives
    ------------
    get_region_polygon, approx_chain

    Predecessors
    ------------
    sobel_amp, edges_image, get_region_contour, threshold,
    hysteresis_threshold

    Successors
    ----------
    set_line_width, disp_arc, disp_line

    Warnings
    --------
    approx_chain_simple is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1741) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # arc_center_row
            proc.get_output_tuple_m(1),  # arc_center_col
            proc.get_output_tuple_m(2),  # arc_angle
            proc.get_output_tuple_m(3),  # arc_begin_row
            proc.get_output_tuple_m(4),  # arc_begin_col
            proc.get_output_tuple_m(5),  # line_begin_row
            proc.get_output_tuple_m(6),  # line_begin_col
            proc.get_output_tuple_m(7),  # line_end_row
            proc.get_output_tuple_m(8),  # line_end_col
            proc.get_output_tuple_m(9)   # order
        )  # type: ignore


def area_center(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[float], Sequence[float]]:
    """
    Area and center of regions.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    area : Sequence[int]
           Area of the region.

    row : Sequence[float]
          Line index of the center.

    column : Sequence[float]
             Column index of the center.

    See Also
    --------
    select_shape

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1731) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # area
            proc.get_output_tuple_m(1),  # row
            proc.get_output_tuple_m(2)   # column
        )  # type: ignore


def area_center_gray(
    regions: HObject,
    image: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the area and center of gravity of a region in a gray value
    image.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    image : HObject
            Gray value image.

    Returns
    -------

    area : Sequence[float]
           Gray value volume of the region.

    row : Sequence[float]
          Row coordinate of the gray value center of gravity.

    column : Sequence[float]
             Column coordinate of the gray value center of gravity.

    See Also
    --------
    area_center_xld, elliptic_axis_gray

    Alternatives
    ------------
    area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Note that the operator area_center_gray only considers  the given
    Regions and ignores any previously set domain of the input image
    Image.  area_center_gray can be executed on OpenCL devices if the
    device supports the  cl_khr_fp64 and cl_khr_int64_base_atomics OpenCL
    extensions.
    """
    with HalconOperator(1764) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # area
            proc.get_output_tuple_m(1),  # row
            proc.get_output_tuple_m(2)   # column
        )  # type: ignore


def area_center_gray_s(
    regions: HObject,
    image: HObject
) -> Tuple[float, float, float]:
    """
    Compute the area and center of gravity of a region in a gray value
    image.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    image : HObject
            Gray value image.

    Returns
    -------

    area : float
           Gray value volume of the region.

    row : float
          Row coordinate of the gray value center of gravity.

    column : float
             Column coordinate of the gray value center of gravity.

    See Also
    --------
    area_center_xld, elliptic_axis_gray

    Alternatives
    ------------
    area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Note that the operator area_center_gray only considers  the given
    Regions and ignores any previously set domain of the input image
    Image.  area_center_gray can be executed on OpenCL devices if the
    device supports the  cl_khr_fp64 and cl_khr_int64_base_atomics OpenCL
    extensions.
    """
    with HalconOperator(1764) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # area
            proc.get_output_tuple_s(1),  # row
            proc.get_output_tuple_s(2)   # column
        )  # type: ignore


def area_center_points_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Area and center of gravity (centroid) of contours and polygons treated
    as point clouds.

    Parameters
    ----------

    xld : HObject
          Point clouds to be examined in form of contours or polygons.

    Returns
    -------

    area : Sequence[float]
           Area of the point cloud.

    row : Sequence[float]
          Row coordinate of the centroid.

    column : Sequence[float]
             Column coordinate of the centroid.

    See Also
    --------
    moments_points_xld, moments_any_points_xld, area_center,
    moments_region_2nd

    Alternatives
    ------------
    area_center_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld

    Notes
    -----
    Even if the contour or polygon XLD is not intersecting itself, the
    result of area_center_points_xld significantly differs from the result
    of area_center_xld as it is calculated from the point cloud and not
    from the enclosed region.
    """
    with HalconOperator(1674) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # area
            proc.get_output_tuple_m(1),  # row
            proc.get_output_tuple_m(2)   # column
        )  # type: ignore


def area_center_points_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Area and center of gravity (centroid) of contours and polygons treated
    as point clouds.

    Parameters
    ----------

    xld : HObject
          Point clouds to be examined in form of contours or polygons.

    Returns
    -------

    area : float
           Area of the point cloud.

    row : float
          Row coordinate of the centroid.

    column : float
             Column coordinate of the centroid.

    See Also
    --------
    moments_points_xld, moments_any_points_xld, area_center,
    moments_region_2nd

    Alternatives
    ------------
    area_center_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld

    Notes
    -----
    Even if the contour or polygon XLD is not intersecting itself, the
    result of area_center_points_xld significantly differs from the result
    of area_center_xld as it is calculated from the point cloud and not
    from the enclosed region.
    """
    with HalconOperator(1674) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # area
            proc.get_output_tuple_s(1),  # row
            proc.get_output_tuple_s(2)   # column
        )  # type: ignore


def area_center_s(regions: HObject) -> Tuple[int, float, float]:
    """
    Area and center of regions.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    area : int
           Area of the region.

    row : float
          Line index of the center.

    column : float
             Column index of the center.

    See Also
    --------
    select_shape

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1731) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # area
            proc.get_output_tuple_s(1),  # row
            proc.get_output_tuple_s(2)   # column
        )  # type: ignore


def area_center_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[str]]:
    """
    Area and center of gravity (centroid) of contours and polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    area : Sequence[float]
           Area enclosed by the contour or polygon.

    row : Sequence[float]
          Row coordinate of the centroid.

    column : Sequence[float]
             Column coordinate of the centroid.

    point_order : Sequence[str]
                  point order along the boundary ('positive'/'negative').

    See Also
    --------
    moments_xld, moments_any_xld, area_center, moments_region_2nd

    Alternatives
    ------------
    area_center_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1693) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # area
            proc.get_output_tuple_m(1),  # row
            proc.get_output_tuple_m(2),  # column
            proc.get_output_tuple_m(3)   # point_order
        )  # type: ignore


def area_center_xld_s(xld: HObject) -> Tuple[float, float, float, str]:
    """
    Area and center of gravity (centroid) of contours and polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    area : float
           Area enclosed by the contour or polygon.

    row : float
          Row coordinate of the centroid.

    column : float
             Column coordinate of the centroid.

    point_order : str
                  point order along the boundary ('positive'/'negative').

    See Also
    --------
    moments_xld, moments_any_xld, area_center, moments_region_2nd

    Alternatives
    ------------
    area_center_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1693) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # area
            proc.get_output_tuple_s(1),  # row
            proc.get_output_tuple_s(2),  # column
            proc.get_output_tuple_s(3)   # point_order
        )  # type: ignore


def area_holes(regions: HObject) -> Sequence[int]:
    """
    Compute the area of holes of regions.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    area : Sequence[int]
           Area(s) of holes of the region(s).

    See Also
    --------
    area_center, fill_up

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1730) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        area = proc.get_output_tuple_m(0)
        return area  # type: ignore


def area_holes_s(regions: HObject) -> int:
    """
    Compute the area of holes of regions.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    area : int
           Area(s) of holes of the region(s).

    See Also
    --------
    area_center, fill_up

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1730) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        area = proc.get_output_tuple_s(0)
        return area  # type: ignore


def area_intersection_rectangle2(
    rect_1row: Union[float, int],
    rect_1column: Union[float, int],
    rect_1phi: Union[float, int],
    rect_1length_1: Union[float, int],
    rect_1length_2: Union[float, int],
    rect_2row: MaybeSequence[Union[float, int]],
    rect_2column: MaybeSequence[Union[float, int]],
    rect_2phi: MaybeSequence[Union[float, int]],
    rect_2length_1: MaybeSequence[Union[float, int]],
    rect_2length_2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the intersection area of oriented rectangles.

    Parameters
    ----------

    rect_1row : Union[float, int]
                Center row coordinate of the first rectangle.

    rect_1column : Union[float, int]
                   Center column coordinate of the first rectangle.

    rect_1phi : Union[float, int]
                Angle between the positive horizontal axis and the first
                edge of the first rectangle (in radians).

    rect_1length_1 : Union[float, int]
                     Half length of the first edge of the first rectangle.

    rect_1length_2 : Union[float, int]
                     Half length of the second edge of the first rectangle.

    rect_2row : MaybeSequence[Union[float, int]]
                Center row coordinate of the second rectangle.

    rect_2column : MaybeSequence[Union[float, int]]
                   Center column coordinate of the second rectangle.

    rect_2phi : MaybeSequence[Union[float, int]]
                Angle between the positive horizontal axis and the first
                edge of the second rectangle (in radians).

    rect_2length_1 : MaybeSequence[Union[float, int]]
                     Half length of the first edge of the second rectangle.

    rect_2length_2 : MaybeSequence[Union[float, int]]
                     Half length of the second edge of the second
                     rectangle.

    Returns
    -------

    area_intersection : Sequence[float]
                        Intersection area of the first rectangle with the
                        second rectangle.

    See Also
    --------
    gen_rectangle2, intersection_segments, intersection_segment_line,
    intersection_segment_contour_xld, intersection_line_contour_xld,
    intersection_contours_xld
    """
    with HalconOperator(2176) as proc:
        proc.set_input_tuple(0, rect_1row)
        proc.set_input_tuple(1, rect_1column)
        proc.set_input_tuple(2, rect_1phi)
        proc.set_input_tuple(3, rect_1length_1)
        proc.set_input_tuple(4, rect_1length_2)
        proc.set_input_tuple(5, rect_2row)
        proc.set_input_tuple(6, rect_2column)
        proc.set_input_tuple(7, rect_2phi)
        proc.set_input_tuple(8, rect_2length_1)
        proc.set_input_tuple(9, rect_2length_2)
        proc.init_oct(0)
        proc.execute()
        area_intersection = proc.get_output_tuple_m(0)
        return area_intersection  # type: ignore


def area_intersection_rectangle2_s(
    rect_1row: Union[float, int],
    rect_1column: Union[float, int],
    rect_1phi: Union[float, int],
    rect_1length_1: Union[float, int],
    rect_1length_2: Union[float, int],
    rect_2row: MaybeSequence[Union[float, int]],
    rect_2column: MaybeSequence[Union[float, int]],
    rect_2phi: MaybeSequence[Union[float, int]],
    rect_2length_1: MaybeSequence[Union[float, int]],
    rect_2length_2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the intersection area of oriented rectangles.

    Parameters
    ----------

    rect_1row : Union[float, int]
                Center row coordinate of the first rectangle.

    rect_1column : Union[float, int]
                   Center column coordinate of the first rectangle.

    rect_1phi : Union[float, int]
                Angle between the positive horizontal axis and the first
                edge of the first rectangle (in radians).

    rect_1length_1 : Union[float, int]
                     Half length of the first edge of the first rectangle.

    rect_1length_2 : Union[float, int]
                     Half length of the second edge of the first rectangle.

    rect_2row : MaybeSequence[Union[float, int]]
                Center row coordinate of the second rectangle.

    rect_2column : MaybeSequence[Union[float, int]]
                   Center column coordinate of the second rectangle.

    rect_2phi : MaybeSequence[Union[float, int]]
                Angle between the positive horizontal axis and the first
                edge of the second rectangle (in radians).

    rect_2length_1 : MaybeSequence[Union[float, int]]
                     Half length of the first edge of the second rectangle.

    rect_2length_2 : MaybeSequence[Union[float, int]]
                     Half length of the second edge of the second
                     rectangle.

    Returns
    -------

    area_intersection : float
                        Intersection area of the first rectangle with the
                        second rectangle.

    See Also
    --------
    gen_rectangle2, intersection_segments, intersection_segment_line,
    intersection_segment_contour_xld, intersection_line_contour_xld,
    intersection_contours_xld
    """
    with HalconOperator(2176) as proc:
        proc.set_input_tuple(0, rect_1row)
        proc.set_input_tuple(1, rect_1column)
        proc.set_input_tuple(2, rect_1phi)
        proc.set_input_tuple(3, rect_1length_1)
        proc.set_input_tuple(4, rect_1length_2)
        proc.set_input_tuple(5, rect_2row)
        proc.set_input_tuple(6, rect_2column)
        proc.set_input_tuple(7, rect_2phi)
        proc.set_input_tuple(8, rect_2length_1)
        proc.set_input_tuple(9, rect_2length_2)
        proc.init_oct(0)
        proc.execute()
        area_intersection = proc.get_output_tuple_s(0)
        return area_intersection  # type: ignore


def area_object_model_3d(
    object_model_3d: MaybeSequence[HHandle]
) -> Sequence[float]:
    """
    Calculate the area of all faces of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    area : Sequence[float]
           Calculated area.

    See Also
    --------
    volume_object_model_3d_relative_to_plane,
    max_diameter_object_model_3d, moments_object_model_3d

    Predecessors
    ------------
    connection_object_model_3d, select_points_object_model_3d,
    prepare_object_model_3d, convex_hull_object_model_3d

    Successors
    ----------
    select_object_model_3d
    """
    with HalconOperator(1080) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        area = proc.get_output_tuple_m(0)
        return area  # type: ignore


def area_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle]
) -> float:
    """
    Calculate the area of all faces of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    area : float
           Calculated area.

    See Also
    --------
    volume_object_model_3d_relative_to_plane,
    max_diameter_object_model_3d, moments_object_model_3d

    Predecessors
    ------------
    connection_object_model_3d, select_points_object_model_3d,
    prepare_object_model_3d, convex_hull_object_model_3d

    Successors
    ----------
    select_object_model_3d
    """
    with HalconOperator(1080) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        area = proc.get_output_tuple_s(0)
        return area  # type: ignore


def asin_image(image: HObject) -> HObject:
    """
    Calculate the arcsine of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    arcsin_image : HObject
                   Output image.

    See Also
    --------
    acos_image, atan_image, atan2_image, tan_image, sin_image, cos_image

    Notes
    -----
    asin_image can be executed on OpenCL devices.
    """
    with HalconOperator(1600) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        arcsin_image = HObject(proc.get_output_object_key(1))
        return arcsin_image  # type: ignore


def atan2_image(image_y: HObject, image_x: HObject) -> HObject:
    """
    Calculate the arctangent of two images.

    Parameters
    ----------

    image_y : HObject
              Input image 1.

    image_x : HObject
              Input image 2.

    Returns
    -------

    arctan_image : HObject
                   Output image.

    See Also
    --------
    acos_image, asin_image, tan_image, sin_image, cos_image

    Alternatives
    ------------
    atan_image

    Notes
    -----
    atan2_image can be executed on an OpenCL device for int1, int2, int4,
    and real images. Note that the results of the OpenCL code may vary
    from the results produced by the CPU.
    """
    with HalconOperator(1597) as proc:
        proc.set_input_object(1, image_y)
        proc.set_input_object(2, image_x)
        proc.execute()
        arctan_image = HObject(proc.get_output_object_key(1))
        return arctan_image  # type: ignore


def atan_image(image: HObject) -> HObject:
    """
    Calculate the arctangent of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    arctan_image : HObject
                   Output image.

    See Also
    --------
    acos_image, asin_image, tan_image, sin_image, cos_image

    Alternatives
    ------------
    atan2_image

    Notes
    -----
    atan_image can be executed on OpenCL devices.
    """
    with HalconOperator(1598) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        arctan_image = HObject(proc.get_output_object_key(1))
        return arctan_image  # type: ignore


def attach_background_to_window(
    image: HObject,
    window_handle: HHandle
) -> None:
    """
    Attach a background image to a HALCON window.

    Parameters
    ----------

    image : HObject
            Background image.

    window_handle : HHandle
                    Window handle.

    Predecessors
    ------------
    open_window

    Successors
    ----------
    detach_background_from_window

    Notes
    -----
    Note that using any synchronous operator which actively probe the
    event queue, e.g., get_mbutton or read_char, will conflict with the
    interaction with the drawing objects. In case the state of the cursor
    has to  be read, please refer to the documentation of your framework
    of choice for an appropriate, non-invasive alternative.
    Furthermore, the event based functionality should not be used together
    with the former blocking operators draw_rectangle1, draw_rectangle2,
    draw_region, draw_xld or draw_circle. They conflict with the event
    based functionality, since they actively fetch all events sent to the
    HALCON window.
    """
    with HalconOperator(1164) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def attach_drawing_object_to_window(
    window_handle: HHandle,
    draw_handle: HHandle
) -> None:
    """
    Attach an existing drawing object to a HALCON window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    draw_handle : HHandle
                  Handle of the drawing object.

    See Also
    --------
    set_drawing_object_callback, get_drawing_object_iconic,
    get_drawing_object_params

    Predecessors
    ------------
    create_drawing_object_rectangle1, create_drawing_object_xld,
    create_drawing_object_circle_sector,
    create_drawing_object_ellipse_sector, create_drawing_object_ellipse,
    create_drawing_object_line, create_drawing_object_rectangle2,
    create_drawing_object_circle, create_drawing_object_text

    Successors
    ----------
    detach_drawing_object_from_window, get_drawing_object_params,
    get_drawing_object_iconic

    Notes
    -----
    Note that using any synchronous operator which actively probe the
    event queue, e.g., get_mbutton or read_char, will conflict with the
    interaction with the drawing objects. In case you need to read the
    state of the cursor, please refer to the documentation of your
    framework of choice for an appropriate, non-invasive alternative.
    Furthermore, the event based functionality should not be used together
    with the former blocking operators draw_rectangle1, draw_rectangle2,
    draw_region, draw_xld or draw_circle. They conflict with the event
    based functionality, since they actively fetch all events sent to the
    HALCON window.
    When working under UNIX/Linux it is necessary to turn on the support
    for multithreading in the Xlib. This is achieved by calling the
    function  XInitThreads() before any other function of the Xlib
    library. This means that you need to call it before any other function
    or method of your graphical development environment of choice.  See
    the documentation of the function XInitThreads() in the corresponding
    manual page for further details.
    """
    with HalconOperator(1166) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, draw_handle)
        proc.execute()


def auto_threshold(image: HObject, sigma: Union[int, float]) -> HObject:
    """
    Segment an image using thresholds determined from its histogram.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : Union[int, float]
            Sigma for the Gaussian smoothing of the histogram.
            Value Suggestion: 2.0
            Assertion: Sigma >= 0.0

    Returns
    -------

    regions : HObject
              Regions with gray values within the automatically determined
              intervals.

    See Also
    --------
    gray_histo, gray_histo_abs, histo_to_thresh, smooth_funct_1d_gauss,
    threshold

    Alternatives
    ------------
    binary_threshold, char_threshold

    Predecessors
    ------------
    anisotropic_diffusion, median_image, illuminate

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(472) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def axis_angle_to_quat(
    axis_x: Union[float, int],
    axis_y: Union[float, int],
    axis_z: Union[float, int],
    angle: Union[float, int]
) -> Sequence[Union[float, int]]:
    """
    Create a rotation quaternion.

    Parameters
    ----------

    axis_x : Union[float, int]
             X component of the rotation axis.

    axis_y : Union[float, int]
             Y component of the rotation axis.

    axis_z : Union[float, int]
             Z component of the rotation axis.

    angle : Union[float, int]
            Rotation angle in radians.

    Returns
    -------

    quaternion : Sequence[Union[float, int]]
                 Rotation quaternion.

    See Also
    --------
    quat_normalize, quat_conjugate, quat_interpolate, screw_to_dual_quat

    Successors
    ----------
    quat_to_hom_mat3d, quat_to_pose, quat_rotate_point_3d, quat_compose

    Notes
    -----
    The operator axis_angle_to_quat does not check whether the vector
    (AxisX, AxisY, AxisZ) is of unit length (i.e. of length 1). If this is
    not the case, Quaternion will be no valid rotation quaternion.
    """
    with HalconOperator(225) as proc:
        proc.set_input_tuple(0, axis_x)
        proc.set_input_tuple(1, axis_y)
        proc.set_input_tuple(2, axis_z)
        proc.set_input_tuple(3, angle)
        proc.init_oct(0)
        proc.execute()
        quaternion = proc.get_output_tuple_m(0)
        return quaternion  # type: ignore


def background_seg(foreground: HObject) -> HObject:
    """
    Determine the connected components of the background of given regions.

    Parameters
    ----------

    foreground : HObject
                 Input regions.

    Returns
    -------

    background_regions : HObject
                         Connected components of the background.

    See Also
    --------
    threshold, hysteresis_threshold, skeleton, expand_region, set_system,
    sobel_amp, edges_image, roberts, bandpass_image

    Alternatives
    ------------
    complement, connection

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape
    """
    with HalconOperator(505) as proc:
        proc.set_input_object(1, foreground)
        proc.execute()
        background_regions = HObject(proc.get_output_object_key(1))
        return background_regions  # type: ignore


def bandpass_image(image: HObject, filter_type: str) -> HObject:
    """
    Edge extraction using bandpass filters.

    Parameters
    ----------

    image : HObject
            Input images.

    filter_type : str
                  Filter type: currently only 'lines' is supported.
                  Value Suggestion: lines

    Returns
    -------

    image_bandpass : HObject
                     Bandpass-filtered images.

    See Also
    --------
    highpass_image, gray_skeleton

    Alternatives
    ------------
    convol_image, topographic_sketch, texture_laws

    Successors
    ----------
    threshold, skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1510) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter_type)
        proc.execute()
        image_bandpass = HObject(proc.get_output_object_key(1))
        return image_bandpass  # type: ignore


def best_match(
    image: HObject,
    template_id: HHandle,
    max_error: float,
    sub_pixel: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Searching the best matching of a template and an image.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    max_error : float
                Maximum average difference of the gray values.
                Value Suggestion: 20.0

    sub_pixel : str
                Subpixel accuracy in case of 'true'.
                Value Suggestion: false

    Returns
    -------

    row : Sequence[float]
          Row position of the best match.

    column : Sequence[float]
             Column position of the best match.

    error : Sequence[float]
            Average divergence of the gray values of the best match.

    Alternatives
    ------------
    fast_match, fast_match_mg, best_match_mg, best_match_pre_mg,
    best_match_rot, best_match_rot_mg, exhaustive_match,
    exhaustive_match_mg

    Predecessors
    ------------
    create_template, read_template, set_offset_template,
    set_reference_template, adapt_template, draw_region, draw_rectangle1,
    reduce_domain

    Warnings
    --------
    best_match is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  shape-based or
    NCC-based operators instead.
    """
    with HalconOperator(1505) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, max_error)
        proc.set_input_tuple(2, sub_pixel)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2)   # error
        )  # type: ignore


def best_match_mg(
    image: HObject,
    template_id: HHandle,
    max_error: float,
    sub_pixel: str,
    num_levels: int,
    which_levels: Union[str, int]
) -> Tuple[float, float, float]:
    """
    Searching the best gray value matches in a pyramid.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    max_error : float
                Maximal average difference of the gray values.
                Value Suggestion: 30.0

    sub_pixel : str
                Exactness in subpixels in case of 'true'.
                Value Suggestion: false

    num_levels : int
                 Number of the used resolution levels.
                 Value Suggestion: 4

    which_levels : Union[str, int]
                   Resolution level up to which the method ``best match''
                   is used.
                   Value Suggestion: 2

    Returns
    -------

    row : float
          Row position of the best match.

    column : float
             Column position of the best match.

    error : float
            Average divergence of the gray values in the best match.

    Alternatives
    ------------
    fast_match, fast_match_mg, best_match, best_match_pre_mg,
    best_match_rot, best_match_rot_mg, exhaustive_match,
    exhaustive_match_mg

    Predecessors
    ------------
    create_template, read_template, adapt_template, draw_region,
    draw_rectangle1, reduce_domain, set_reference_template,
    set_offset_template

    Warnings
    --------
    best_match_mg is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  shape-based or
    NCC-based operators instead.
    """
    with HalconOperator(1501) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, max_error)
        proc.set_input_tuple(2, sub_pixel)
        proc.set_input_tuple(3, num_levels)
        proc.set_input_tuple(4, which_levels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # error
        )  # type: ignore


def best_match_pre_mg(
    image_pyramid: HObject,
    template_id: HHandle,
    max_error: float,
    sub_pixel: str,
    num_levels: int,
    which_levels: Union[str, int]
) -> Tuple[float, float, float]:
    """
    Searching the best gray value matches in a pre generated pyramid.

    Parameters
    ----------

    image_pyramid : HObject
                    Image pyramid inside of which the pattern has to be
                    found.

    template_id : HHandle
                  Template number.

    max_error : float
                Maximal average difference of the gray values.
                Value Suggestion: 30.0

    sub_pixel : str
                Exactness in subpixels in case of 'true'.
                Value Suggestion: false

    num_levels : int
                 Number of the used resolution levels.
                 Value Suggestion: 3

    which_levels : Union[str, int]
                   Resolution level up to which the method ``best match''
                   is used.
                   Value Suggestion: original

    Returns
    -------

    row : float
          Row position of the best match.

    column : float
             Column position of the best match.

    error : float
            Average divergence of the gray values in the best match.

    Alternatives
    ------------
    fast_match, fast_match_mg, exhaustive_match, exhaustive_match_mg

    Predecessors
    ------------
    gen_gauss_pyramid, create_template, read_template, adapt_template,
    draw_region, draw_rectangle1, reduce_domain, set_reference_template

    Warnings
    --------
    best_match_pre_mg is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1500) as proc:
        proc.set_input_object(1, image_pyramid)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, max_error)
        proc.set_input_tuple(2, sub_pixel)
        proc.set_input_tuple(3, num_levels)
        proc.set_input_tuple(4, which_levels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # error
        )  # type: ignore


def best_match_rot(
    image: HObject,
    template_id: HHandle,
    angle_start: float,
    angle_extend: float,
    max_error: float,
    sub_pixel: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Searching the best matching of a template and an image with rotation.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    angle_start : float
                  Smallest Rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extend : float
                   Maximum positive Extension of AngleStart.
                   Value Suggestion: 0.79
                   Assertion: AngleExtend > 0

    max_error : float
                Maximum average difference of the gray values.
                Value Suggestion: 30.0

    sub_pixel : str
                Subpixel accuracy in case of 'true'.
                Value Suggestion: false

    Returns
    -------

    row : Sequence[float]
          Row position of the best match.

    column : Sequence[float]
             Column position of the best match.

    angle : Sequence[float]
            Rotation angle of pattern.

    error : Sequence[float]
            Average divergence of the gray values of the best match.

    See Also
    --------
    best_match, best_match_mg

    Alternatives
    ------------
    best_match_rot_mg

    Predecessors
    ------------
    create_template_rot, read_template, set_offset_template,
    set_reference_template, adapt_template, draw_region, draw_rectangle1,
    reduce_domain

    Warnings
    --------
    best_match_rot is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1504) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extend)
        proc.set_input_tuple(3, max_error)
        proc.set_input_tuple(4, sub_pixel)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3)   # error
        )  # type: ignore


def best_match_rot_mg(
    image: HObject,
    template_id: HHandle,
    angle_start: float,
    angle_extend: float,
    max_error: float,
    sub_pixel: str,
    num_levels: int
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Searching the best matching of a template and a pyramid with rotation.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    angle_start : float
                  Smallest Rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extend : float
                   Maximum positive Extension of AngleStart.
                   Value Suggestion: 0.79
                   Assertion: AngleExtend > 0

    max_error : float
                Maximum average difference of the gray values.
                Value Suggestion: 40.0

    sub_pixel : str
                Subpixel accuracy in case of 'true'.
                Value Suggestion: false

    num_levels : int
                 Number of the used resolution levels.
                 Value Suggestion: 3

    Returns
    -------

    row : Sequence[float]
          Row position of the best match.

    column : Sequence[float]
             Column position of the best match.

    angle : Sequence[float]
            Rotation angle of pattern.

    error : Sequence[float]
            Average divergence of the gray values of the best match.

    See Also
    --------
    fast_match

    Alternatives
    ------------
    best_match_rot, best_match_mg, find_ncc_model, find_ncc_models

    Predecessors
    ------------
    create_template_rot, set_reference_template, set_offset_template,
    adapt_template, draw_region, draw_rectangle1, reduce_domain

    Warnings
    --------
    best_match_rot_mg is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1503) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extend)
        proc.set_input_tuple(3, max_error)
        proc.set_input_tuple(4, sub_pixel)
        proc.set_input_tuple(5, num_levels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3)   # error
        )  # type: ignore


def best_match_rot_mg_s(
    image: HObject,
    template_id: HHandle,
    angle_start: float,
    angle_extend: float,
    max_error: float,
    sub_pixel: str,
    num_levels: int
) -> Tuple[float, float, float, float]:
    """
    Searching the best matching of a template and a pyramid with rotation.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    angle_start : float
                  Smallest Rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extend : float
                   Maximum positive Extension of AngleStart.
                   Value Suggestion: 0.79
                   Assertion: AngleExtend > 0

    max_error : float
                Maximum average difference of the gray values.
                Value Suggestion: 40.0

    sub_pixel : str
                Subpixel accuracy in case of 'true'.
                Value Suggestion: false

    num_levels : int
                 Number of the used resolution levels.
                 Value Suggestion: 3

    Returns
    -------

    row : float
          Row position of the best match.

    column : float
             Column position of the best match.

    angle : float
            Rotation angle of pattern.

    error : float
            Average divergence of the gray values of the best match.

    See Also
    --------
    fast_match

    Alternatives
    ------------
    best_match_rot, best_match_mg, find_ncc_model, find_ncc_models

    Predecessors
    ------------
    create_template_rot, set_reference_template, set_offset_template,
    adapt_template, draw_region, draw_rectangle1, reduce_domain

    Warnings
    --------
    best_match_rot_mg is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1503) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extend)
        proc.set_input_tuple(3, max_error)
        proc.set_input_tuple(4, sub_pixel)
        proc.set_input_tuple(5, num_levels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # angle
            proc.get_output_tuple_s(3)   # error
        )  # type: ignore


def best_match_rot_s(
    image: HObject,
    template_id: HHandle,
    angle_start: float,
    angle_extend: float,
    max_error: float,
    sub_pixel: str
) -> Tuple[float, float, float, float]:
    """
    Searching the best matching of a template and an image with rotation.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    angle_start : float
                  Smallest Rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extend : float
                   Maximum positive Extension of AngleStart.
                   Value Suggestion: 0.79
                   Assertion: AngleExtend > 0

    max_error : float
                Maximum average difference of the gray values.
                Value Suggestion: 30.0

    sub_pixel : str
                Subpixel accuracy in case of 'true'.
                Value Suggestion: false

    Returns
    -------

    row : float
          Row position of the best match.

    column : float
             Column position of the best match.

    angle : float
            Rotation angle of pattern.

    error : float
            Average divergence of the gray values of the best match.

    See Also
    --------
    best_match, best_match_mg

    Alternatives
    ------------
    best_match_rot_mg

    Predecessors
    ------------
    create_template_rot, read_template, set_offset_template,
    set_reference_template, adapt_template, draw_region, draw_rectangle1,
    reduce_domain

    Warnings
    --------
    best_match_rot is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1504) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extend)
        proc.set_input_tuple(3, max_error)
        proc.set_input_tuple(4, sub_pixel)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # angle
            proc.get_output_tuple_s(3)   # error
        )  # type: ignore


def best_match_s(
    image: HObject,
    template_id: HHandle,
    max_error: float,
    sub_pixel: str
) -> Tuple[float, float, float]:
    """
    Searching the best matching of a template and an image.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    max_error : float
                Maximum average difference of the gray values.
                Value Suggestion: 20.0

    sub_pixel : str
                Subpixel accuracy in case of 'true'.
                Value Suggestion: false

    Returns
    -------

    row : float
          Row position of the best match.

    column : float
             Column position of the best match.

    error : float
            Average divergence of the gray values of the best match.

    Alternatives
    ------------
    fast_match, fast_match_mg, best_match_mg, best_match_pre_mg,
    best_match_rot, best_match_rot_mg, exhaustive_match,
    exhaustive_match_mg

    Predecessors
    ------------
    create_template, read_template, set_offset_template,
    set_reference_template, adapt_template, draw_region, draw_rectangle1,
    reduce_domain

    Warnings
    --------
    best_match is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  shape-based or
    NCC-based operators instead.
    """
    with HalconOperator(1505) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, max_error)
        proc.set_input_tuple(2, sub_pixel)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # error
        )  # type: ignore


def bilateral_filter(
    image: HObject,
    image_joint: HObject,
    sigma_spatial: float,
    sigma_range: float,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HObject:
    """
    bilateral filtering of an image.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    image_joint : HObject
                  Joint image.

    sigma_spatial : float
                    Size of the Gaussian of the closeness function.
                    Value Suggestion: 3.0
                    Assertion: SigmaSpatial > 0.6

    sigma_range : float
                  Size of the Gaussian of the similarity function.
                  Value Suggestion: 20.0
                  Assertion: SigmaRange > 0.0001

    gen_param_name : MaybeSequence[str]
                     Generic parameter name.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Generic parameter value.
                      Value Suggestion: []

    Returns
    -------

    image_bilateral : HObject
                      Filtered output image.

    Alternatives
    ------------
    guided_filter, anisotropic_diffusion, median_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, var_threshold, regiongrowing
    """
    with HalconOperator(2045) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, image_joint)
        proc.set_input_tuple(0, sigma_spatial)
        proc.set_input_tuple(1, sigma_range)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()
        image_bilateral = HObject(proc.get_output_object_key(1))
        return image_bilateral  # type: ignore


def bin_threshold(image: HObject) -> HObject:
    """
    Segment an image using an automatically determined threshold.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    region : HObject
             Dark regions of the image.

    Warnings
    --------
    bin_threshold is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the operator
    binary_threshold instead.
    """
    with HalconOperator(473) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def binary_threshold(
    image: HObject,
    method: str,
    light_dark: str
) -> Tuple[HObject, Sequence[Union[str, int]]]:
    """
    Segment an image using binary thresholding.

    Parameters
    ----------

    image : HObject
            Input Image.

    method : str
             Segmentation method.
             Value Suggestion: max_separability

    light_dark : str
                 Extract foreground or background?
                 Value Suggestion: dark

    Returns
    -------

    region : HObject
             Segmented output region.

    used_threshold : Sequence[Union[str, int]]
                     Used threshold.

    See Also
    --------
    gray_histo, threshold

    Alternatives
    ------------
    auto_threshold, char_threshold, local_threshold

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(449) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, light_dark)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # region
            proc.get_output_tuple_m(0)   # used_threshold
        )  # type: ignore


def binary_threshold_s(
    image: HObject,
    method: str,
    light_dark: str
) -> Tuple[HObject, Union[str, int]]:
    """
    Segment an image using binary thresholding.

    Parameters
    ----------

    image : HObject
            Input Image.

    method : str
             Segmentation method.
             Value Suggestion: max_separability

    light_dark : str
                 Extract foreground or background?
                 Value Suggestion: dark

    Returns
    -------

    region : HObject
             Segmented output region.

    used_threshold : Union[str, int]
                     Used threshold.

    See Also
    --------
    gray_histo, threshold

    Alternatives
    ------------
    auto_threshold, char_threshold, local_threshold

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(449) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, light_dark)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # region
            proc.get_output_tuple_s(0)   # used_threshold
        )  # type: ignore


def binocular_calibration(
    nx: Sequence[Union[float, int]],
    ny: Sequence[Union[float, int]],
    nz: Sequence[Union[float, int]],
    nrow_1: Sequence[Union[float, int]],
    ncol_1: Sequence[Union[float, int]],
    nrow_2: Sequence[Union[float, int]],
    ncol_2: Sequence[Union[float, int]],
    start_cam_param_1: Sequence[Union[float, int, str]],
    start_cam_param_2: Sequence[Union[float, int, str]],
    nstart_pose_1: Sequence[Union[float, int]],
    nstart_pose_2: Sequence[Union[float, int]],
    estimate_params: Sequence[str]
) -> Tuple[Sequence[Union[float, int, str]], Sequence[Union[float, int, str]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[float]]:
    """
    Determine all camera parameters of a binocular stereo system.

    Parameters
    ----------

    nx : Sequence[Union[float, int]]
         Ordered Tuple with all X-coordinates of the calibration marks (in
         meters).

    ny : Sequence[Union[float, int]]
         Ordered Tuple with all Y-coordinates of the calibration marks (in
         meters).

    nz : Sequence[Union[float, int]]
         Ordered Tuple with all Z-coordinates of the calibration marks (in
         meters).

    nrow_1 : Sequence[Union[float, int]]
             Ordered Tuple with all row-coordinates of the extracted
             calibration marks of camera 1 (in pixels).

    ncol_1 : Sequence[Union[float, int]]
             Ordered Tuple with all column-coordinates of the extracted
             calibration marks of camera 1 (in pixels).

    nrow_2 : Sequence[Union[float, int]]
             Ordered Tuple with all row-coordinates of the extracted
             calibration marks of camera 2 (in pixels).

    ncol_2 : Sequence[Union[float, int]]
             Ordered Tuple with all column-coordinates of the extracted
             calibration marks of camera 2 (in pixels).

    start_cam_param_1 : Sequence[Union[float, int, str]]
                        Initial values for the internal parameters of
                        camera 1.

    start_cam_param_2 : Sequence[Union[float, int, str]]
                        Initial values for the internal parameters of
                        camera 2.

    nstart_pose_1 : Sequence[Union[float, int]]
                    Ordered tuple with all initial values for the poses of
                    the calibration model in relation to camera 1.

    nstart_pose_2 : Sequence[Union[float, int]]
                    Ordered tuple with all initial values for the poses of
                    the calibration model in relation to camera 2.

    estimate_params : Sequence[str]
                      Camera parameters to be estimated.
                      Value Suggestion: all

    Returns
    -------

    cam_param_1 : Sequence[Union[float, int, str]]
                  Internal parameters of camera 1.

    cam_param_2 : Sequence[Union[float, int, str]]
                  Internal parameters of camera 2.

    nfinal_pose_1 : Sequence[Union[float, int]]
                    Ordered tuple with all poses of the calibration model
                    in relation to camera 1.

    nfinal_pose_2 : Sequence[Union[float, int]]
                    Ordered tuple with all poses of the calibration model
                    in relation to camera 2.

    rel_pose : Sequence[Union[float, int]]
               Pose of camera 2 in relation to camera 1.

    errors : Sequence[float]
             Average error distances in pixels.

    See Also
    --------
    find_caltab, sim_caltab, read_cam_par, create_pose, convert_pose_type,
    read_pose, hom_mat3d_to_pose, create_caltab, binocular_disparity,
    binocular_distance

    Predecessors
    ------------
    find_marks_and_pose, caltab_points, read_cam_par

    Successors
    ----------
    write_pose, write_cam_par, pose_to_hom_mat3d, disp_caltab,
    gen_binocular_rectification_map

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.  Furthermore, stereo setups
    that contain area scan and line scan cameras at the same time are not
    supported.
    """
    with HalconOperator(370) as proc:
        proc.set_input_tuple(0, nx)
        proc.set_input_tuple(1, ny)
        proc.set_input_tuple(2, nz)
        proc.set_input_tuple(3, nrow_1)
        proc.set_input_tuple(4, ncol_1)
        proc.set_input_tuple(5, nrow_2)
        proc.set_input_tuple(6, ncol_2)
        proc.set_input_tuple(7, start_cam_param_1)
        proc.set_input_tuple(8, start_cam_param_2)
        proc.set_input_tuple(9, nstart_pose_1)
        proc.set_input_tuple(10, nstart_pose_2)
        proc.set_input_tuple(11, estimate_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # cam_param_1
            proc.get_output_tuple_m(1),  # cam_param_2
            proc.get_output_tuple_m(2),  # nfinal_pose_1
            proc.get_output_tuple_m(3),  # nfinal_pose_2
            proc.get_output_tuple_m(4),  # rel_pose
            proc.get_output_tuple_m(5)   # errors
        )  # type: ignore


def binocular_calibration_s(
    nx: Sequence[Union[float, int]],
    ny: Sequence[Union[float, int]],
    nz: Sequence[Union[float, int]],
    nrow_1: Sequence[Union[float, int]],
    ncol_1: Sequence[Union[float, int]],
    nrow_2: Sequence[Union[float, int]],
    ncol_2: Sequence[Union[float, int]],
    start_cam_param_1: Sequence[Union[float, int, str]],
    start_cam_param_2: Sequence[Union[float, int, str]],
    nstart_pose_1: Sequence[Union[float, int]],
    nstart_pose_2: Sequence[Union[float, int]],
    estimate_params: Sequence[str]
) -> Tuple[Sequence[Union[float, int, str]], Sequence[Union[float, int, str]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]], float]:
    """
    Determine all camera parameters of a binocular stereo system.

    Parameters
    ----------

    nx : Sequence[Union[float, int]]
         Ordered Tuple with all X-coordinates of the calibration marks (in
         meters).

    ny : Sequence[Union[float, int]]
         Ordered Tuple with all Y-coordinates of the calibration marks (in
         meters).

    nz : Sequence[Union[float, int]]
         Ordered Tuple with all Z-coordinates of the calibration marks (in
         meters).

    nrow_1 : Sequence[Union[float, int]]
             Ordered Tuple with all row-coordinates of the extracted
             calibration marks of camera 1 (in pixels).

    ncol_1 : Sequence[Union[float, int]]
             Ordered Tuple with all column-coordinates of the extracted
             calibration marks of camera 1 (in pixels).

    nrow_2 : Sequence[Union[float, int]]
             Ordered Tuple with all row-coordinates of the extracted
             calibration marks of camera 2 (in pixels).

    ncol_2 : Sequence[Union[float, int]]
             Ordered Tuple with all column-coordinates of the extracted
             calibration marks of camera 2 (in pixels).

    start_cam_param_1 : Sequence[Union[float, int, str]]
                        Initial values for the internal parameters of
                        camera 1.

    start_cam_param_2 : Sequence[Union[float, int, str]]
                        Initial values for the internal parameters of
                        camera 2.

    nstart_pose_1 : Sequence[Union[float, int]]
                    Ordered tuple with all initial values for the poses of
                    the calibration model in relation to camera 1.

    nstart_pose_2 : Sequence[Union[float, int]]
                    Ordered tuple with all initial values for the poses of
                    the calibration model in relation to camera 2.

    estimate_params : Sequence[str]
                      Camera parameters to be estimated.
                      Value Suggestion: all

    Returns
    -------

    cam_param_1 : Sequence[Union[float, int, str]]
                  Internal parameters of camera 1.

    cam_param_2 : Sequence[Union[float, int, str]]
                  Internal parameters of camera 2.

    nfinal_pose_1 : Sequence[Union[float, int]]
                    Ordered tuple with all poses of the calibration model
                    in relation to camera 1.

    nfinal_pose_2 : Sequence[Union[float, int]]
                    Ordered tuple with all poses of the calibration model
                    in relation to camera 2.

    rel_pose : Sequence[Union[float, int]]
               Pose of camera 2 in relation to camera 1.

    errors : float
             Average error distances in pixels.

    See Also
    --------
    find_caltab, sim_caltab, read_cam_par, create_pose, convert_pose_type,
    read_pose, hom_mat3d_to_pose, create_caltab, binocular_disparity,
    binocular_distance

    Predecessors
    ------------
    find_marks_and_pose, caltab_points, read_cam_par

    Successors
    ----------
    write_pose, write_cam_par, pose_to_hom_mat3d, disp_caltab,
    gen_binocular_rectification_map

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.  Furthermore, stereo setups
    that contain area scan and line scan cameras at the same time are not
    supported.
    """
    with HalconOperator(370) as proc:
        proc.set_input_tuple(0, nx)
        proc.set_input_tuple(1, ny)
        proc.set_input_tuple(2, nz)
        proc.set_input_tuple(3, nrow_1)
        proc.set_input_tuple(4, ncol_1)
        proc.set_input_tuple(5, nrow_2)
        proc.set_input_tuple(6, ncol_2)
        proc.set_input_tuple(7, start_cam_param_1)
        proc.set_input_tuple(8, start_cam_param_2)
        proc.set_input_tuple(9, nstart_pose_1)
        proc.set_input_tuple(10, nstart_pose_2)
        proc.set_input_tuple(11, estimate_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # cam_param_1
            proc.get_output_tuple_m(1),  # cam_param_2
            proc.get_output_tuple_m(2),  # nfinal_pose_1
            proc.get_output_tuple_m(3),  # nfinal_pose_2
            proc.get_output_tuple_m(4),  # rel_pose
            proc.get_output_tuple_s(5)   # errors
        )  # type: ignore


def binocular_disparity(
    image_rect_1: HObject,
    image_rect_2: HObject,
    method: str,
    mask_width: int,
    mask_height: int,
    texture_thresh: Union[float, int],
    min_disparity: int,
    max_disparity: int,
    num_levels: int,
    score_thresh: Union[float, int],
    filter: MaybeSequence[str],
    sub_disparity: str
) -> Tuple[HObject, HObject]:
    """
    Compute the disparities of a rectified image pair using correlation
    techniques.

    Parameters
    ----------

    image_rect_1 : HObject
                   Rectified image of camera 1.

    image_rect_2 : HObject
                   Rectified image of camera 2.

    method : str
             Matching function.
             Value Suggestion: ncc

    mask_width : int
                 Width of the correlation window.
                 Value Suggestion: 11
                 Assertion: 3 <= MaskWidth && odd(MaskWidth)

    mask_height : int
                  Height of the correlation window.
                  Value Suggestion: 11
                  Assertion: 3 <= MaskHeight && odd(MaskHeight)

    texture_thresh : Union[float, int]
                     Variance threshold of textured image regions.
                     Value Suggestion: 0.0
                     Assertion: 0.0 <= TextureThresh

    min_disparity : int
                    Minimum of the expected disparities.
                    Value Suggestion: -30

    max_disparity : int
                    Maximum of the expected disparities.
                    Value Suggestion: 30

    num_levels : int
                 Number of pyramid levels.
                 Value Suggestion: 1
                 Assertion: 1 <= NumLevels

    score_thresh : Union[float, int]
                   Threshold of the correlation function.
                   Value Suggestion: 0.5

    filter : MaybeSequence[str]
             Downstream filters.
             Value Suggestion: none

    sub_disparity : str
                    Subpixel interpolation of disparities.
                    Value Suggestion: none

    Returns
    -------

    disparity : HObject
                Disparity map.

    score : HObject
            Evaluation of the disparity values.

    See Also
    --------
    map_image, gen_binocular_rectification_map, binocular_calibration

    Alternatives
    ------------
    binocular_disparity_mg, binocular_disparity_ms, binocular_distance,
    binocular_distance_mg, binocular_distance_ms

    Predecessors
    ------------
    map_image

    Successors
    ----------
    threshold, disparity_to_distance, disparity_image_to_xyz
    """
    with HalconOperator(363) as proc:
        proc.set_input_object(1, image_rect_1)
        proc.set_input_object(2, image_rect_2)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, mask_width)
        proc.set_input_tuple(2, mask_height)
        proc.set_input_tuple(3, texture_thresh)
        proc.set_input_tuple(4, min_disparity)
        proc.set_input_tuple(5, max_disparity)
        proc.set_input_tuple(6, num_levels)
        proc.set_input_tuple(7, score_thresh)
        proc.set_input_tuple(8, filter)
        proc.set_input_tuple(9, sub_disparity)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # disparity
            HObject(proc.get_output_object_key(2))   # score
        )  # type: ignore


def binocular_disparity_mg(
    image_rect_1: HObject,
    image_rect_2: HObject,
    gray_constancy: float,
    gradient_constancy: float,
    smoothness: float,
    initial_guess: float,
    calculate_score: str,
    mgparam_name: MaybeSequence[str],
    mgparam_value: MaybeSequence[Union[str, float, int]]
) -> Tuple[HObject, HObject]:
    """
    Compute the disparities of a rectified stereo image pair using
    multigrid methods.

    Parameters
    ----------

    image_rect_1 : HObject
                   Rectified image of camera 1.

    image_rect_2 : HObject
                   Rectified image of camera 2.

    gray_constancy : float
                     Weight of the gray value constancy in the data term.
                     Value Suggestion: 1.0
                     Assertion: GrayConstancy >= 0.0

    gradient_constancy : float
                         Weight of the gradient constancy in the data term.
                         Value Suggestion: 30.0
                         Assertion: GradientConstancy >= 0.0

    smoothness : float
                 Weight of the smoothness term in relation to the data
                 term.
                 Value Suggestion: 5.0
                 Assertion: Smoothness > 0.0

    initial_guess : float
                    Initial guess of the disparity.
                    Value Suggestion: 0.0

    calculate_score : str
                      Should the quality measure should be returned in
                      Score?
                      Value Suggestion: false

    mgparam_name : MaybeSequence[str]
                   Parameter name(s) for the multigrid algorithm.
                   Value Suggestion: default_parameters

    mgparam_value : MaybeSequence[Union[str, float, int]]
                    Parameter value(s) for the multigrid algorithm.
                    Value Suggestion: fast_accurate

    Returns
    -------

    disparity : HObject
                Disparity map.

    score : HObject
            Score of the calculated disparity if CalculateScore is set to
            'true'.

    See Also
    --------
    map_image, gen_binocular_rectification_map, binocular_calibration

    Alternatives
    ------------
    binocular_disparity, binocular_disparity_ms, binocular_distance,
    binocular_distance_mg, binocular_distance_ms

    Predecessors
    ------------
    map_image

    Successors
    ----------
    threshold, disparity_to_distance, disparity_image_to_xyz
    """
    with HalconOperator(349) as proc:
        proc.set_input_object(1, image_rect_1)
        proc.set_input_object(2, image_rect_2)
        proc.set_input_tuple(0, gray_constancy)
        proc.set_input_tuple(1, gradient_constancy)
        proc.set_input_tuple(2, smoothness)
        proc.set_input_tuple(3, initial_guess)
        proc.set_input_tuple(4, calculate_score)
        proc.set_input_tuple(5, mgparam_name)
        proc.set_input_tuple(6, mgparam_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # disparity
            HObject(proc.get_output_object_key(2))   # score
        )  # type: ignore


def binocular_disparity_ms(
    image_rect_1: HObject,
    image_rect_2: HObject,
    min_disparity: int,
    max_disparity: int,
    surface_smoothing: int,
    edge_smoothing: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[str]
) -> Tuple[HObject, HObject]:
    """
    Compute the disparities of a rectified stereo image pair using
    multi-scanline optimization.

    Parameters
    ----------

    image_rect_1 : HObject
                   Rectified image of camera 1.

    image_rect_2 : HObject
                   Rectified image of camera 2.

    min_disparity : int
                    Minimum of the expected disparities.
                    Value Suggestion: -30

    max_disparity : int
                    Maximum of the expected disparities.
                    Value Suggestion: 30
                    Assertion: MinDisparity <= MaxDisparity

    surface_smoothing : int
                        Smoothing of surfaces.
                        Value Suggestion: 50
                        Assertion: SurfaceSmoothing >= 0

    edge_smoothing : int
                     Smoothing of edges.
                     Value Suggestion: 50
                     Assertion: EdgeSmoothing >= 0

    gen_param_name : MaybeSequence[str]
                     Parameter name(s) for the multi-scanline algorithm.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[str]
                      Parameter value(s) for the multi-scanline algorithm.
                      Value Suggestion: []

    Returns
    -------

    disparity : HObject
                Disparity map.

    score : HObject
            Score of the calculated disparity.

    See Also
    --------
    map_image, gen_binocular_rectification_map, binocular_calibration

    Alternatives
    ------------
    binocular_disparity, binocular_disparity_mg, binocular_distance,
    binocular_distance_mg, binocular_distance_ms

    Predecessors
    ------------
    map_image

    Successors
    ----------
    threshold, disparity_to_distance, disparity_image_to_xyz
    """
    with HalconOperator(347) as proc:
        proc.set_input_object(1, image_rect_1)
        proc.set_input_object(2, image_rect_2)
        proc.set_input_tuple(0, min_disparity)
        proc.set_input_tuple(1, max_disparity)
        proc.set_input_tuple(2, surface_smoothing)
        proc.set_input_tuple(3, edge_smoothing)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # disparity
            HObject(proc.get_output_object_key(2))   # score
        )  # type: ignore


def binocular_distance(
    image_rect_1: HObject,
    image_rect_2: HObject,
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    method: str,
    mask_width: int,
    mask_height: int,
    texture_thresh: Union[float, int],
    min_disparity: int,
    max_disparity: int,
    num_levels: int,
    score_thresh: Union[float, int],
    filter: MaybeSequence[str],
    sub_distance: MaybeSequence[str]
) -> Tuple[HObject, HObject]:
    """
    Compute the distance values for a rectified stereo image pair using
    correlation techniques.

    Parameters
    ----------

    image_rect_1 : HObject
                   Rectified image of camera 1.

    image_rect_2 : HObject
                   Rectified image of camera 2.

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    method : str
             Matching function.
             Value Suggestion: ncc

    mask_width : int
                 Width of the correlation window.
                 Value Suggestion: 11
                 Assertion: 3 <= MaskWidth && odd(MaskWidth)

    mask_height : int
                  Height of the correlation window.
                  Value Suggestion: 11
                  Assertion: 3 <= MaskHeight && odd(MaskHeight)

    texture_thresh : Union[float, int]
                     Variance threshold of textured image regions.
                     Value Suggestion: 0.0
                     Assertion: 0.0 <= TextureThresh

    min_disparity : int
                    Minimum of the expected disparities.
                    Value Suggestion: 0

    max_disparity : int
                    Maximum of the expected disparities.
                    Value Suggestion: 30

    num_levels : int
                 Number of pyramid levels.
                 Value Suggestion: 1
                 Assertion: 1 <= NumLevels

    score_thresh : Union[float, int]
                   Threshold of the correlation function.
                   Value Suggestion: 0.0

    filter : MaybeSequence[str]
             Downstream filters.
             Value Suggestion: none

    sub_distance : MaybeSequence[str]
                   Distance interpolation.
                   Value Suggestion: none

    Returns
    -------

    distance : HObject
               Distance image.

    score : HObject
            Evaluation of a distance value.

    See Also
    --------
    map_image, gen_binocular_rectification_map, binocular_calibration,
    distance_to_disparity, disparity_to_distance, disparity_image_to_xyz

    Alternatives
    ------------
    binocular_distance_mg, binocular_distance_ms, binocular_disparity,
    binocular_disparity_mg, binocular_disparity_ms

    Predecessors
    ------------
    map_image

    Successors
    ----------
    threshold

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For a stereo setup of mixed type (i.e., for a stereo setup in which
    one of the original cameras is a perspective camera and the other
    camera is a telecentric camera; see gen_binocular_rectification_map),
    the rectifying plane of the two cameras is in a position with respect
    to the object that would lead to very unintuitive distances.
    Therefore, binocular_distance does not support a stereo setup of mixed
    type.  For stereo setups of mixed type, please use
    reconstruct_surface_stereo, in which the reference coordinate system
    can be chosen arbitrarily.  Alternatively, binocular_disparity and
    disparity_image_to_xyz might be used.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(362) as proc:
        proc.set_input_object(1, image_rect_1)
        proc.set_input_object(2, image_rect_2)
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, method)
        proc.set_input_tuple(4, mask_width)
        proc.set_input_tuple(5, mask_height)
        proc.set_input_tuple(6, texture_thresh)
        proc.set_input_tuple(7, min_disparity)
        proc.set_input_tuple(8, max_disparity)
        proc.set_input_tuple(9, num_levels)
        proc.set_input_tuple(10, score_thresh)
        proc.set_input_tuple(11, filter)
        proc.set_input_tuple(12, sub_distance)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # distance
            HObject(proc.get_output_object_key(2))   # score
        )  # type: ignore


def binocular_distance_mg(
    image_rect_1: HObject,
    image_rect_2: HObject,
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    gray_constancy: float,
    gradient_constancy: float,
    smoothness: float,
    initial_guess: float,
    calculate_score: str,
    mgparam_name: MaybeSequence[str],
    mgparam_value: MaybeSequence[Union[str, float, int]]
) -> Tuple[HObject, HObject]:
    """
    Compute the distance values for a rectified stereo image pair using
    multigrid methods.

    Parameters
    ----------

    image_rect_1 : HObject
                   Rectified image of camera 1.

    image_rect_2 : HObject
                   Rectified image of camera 2.

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    gray_constancy : float
                     Weight of the gray value constancy in the data term.
                     Value Suggestion: 1.0
                     Assertion: GrayConstancy >= 0.0

    gradient_constancy : float
                         Weight of the gradient constancy in the data term.
                         Value Suggestion: 30.0
                         Assertion: GradientConstancy >= 0.0

    smoothness : float
                 Weight of the smoothness term in relation to the data
                 term.
                 Value Suggestion: 5.0
                 Assertion: Smoothness > 0.0

    initial_guess : float
                    Initial guess of the disparity.
                    Value Suggestion: 0.0

    calculate_score : str
                      Should the quality measure be returned in Score?
                      Value Suggestion: false

    mgparam_name : MaybeSequence[str]
                   Parameter name(s) for the multigrid algorithm.
                   Value Suggestion: default_parameters

    mgparam_value : MaybeSequence[Union[str, float, int]]
                    Parameter value(s) for the multigrid algorithm.
                    Value Suggestion: fast_accurate

    Returns
    -------

    distance : HObject
               Distance image.

    score : HObject
            Score of the calculated disparity if CalculateScore is set to
            'true'.

    See Also
    --------
    map_image, gen_binocular_rectification_map, binocular_calibration,
    disparity_to_distance, distance_to_disparity, disparity_image_to_xyz

    Alternatives
    ------------
    binocular_distance, binocular_distance_ms, binocular_disparity,
    binocular_disparity_mg, binocular_disparity_ms

    Predecessors
    ------------
    map_image

    Successors
    ----------
    threshold

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For a stereo setup of mixed type (i.e., for a stereo setup in which
    one of the original cameras is a perspective camera and the other
    camera is a telecentric camera; see gen_binocular_rectification_map),
    the rectifying plane of the two cameras is in a position with respect
    to the object that would lead to very unintuitive distances.
    Therefore, binocular_distance_mg does not support a stereo setup of
    mixed type.  For stereo setups of mixed type, please use
    reconstruct_surface_stereo, in which the reference coordinate system
    can be chosen arbitrarily.  Alternatively, binocular_disparity_mg and
    disparity_image_to_xyz might be used.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(348) as proc:
        proc.set_input_object(1, image_rect_1)
        proc.set_input_object(2, image_rect_2)
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, gray_constancy)
        proc.set_input_tuple(4, gradient_constancy)
        proc.set_input_tuple(5, smoothness)
        proc.set_input_tuple(6, initial_guess)
        proc.set_input_tuple(7, calculate_score)
        proc.set_input_tuple(8, mgparam_name)
        proc.set_input_tuple(9, mgparam_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # distance
            HObject(proc.get_output_object_key(2))   # score
        )  # type: ignore


def binocular_distance_ms(
    image_rect_1: HObject,
    image_rect_2: HObject,
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    min_disparity: int,
    max_disparity: int,
    surface_smoothing: int,
    edge_smoothing: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, int]]
) -> Tuple[HObject, HObject]:
    """
    Compute the distance values for a rectified stereo image pair using
    multi-scanline optimization.

    Parameters
    ----------

    image_rect_1 : HObject
                   Rectified image of camera 1.

    image_rect_2 : HObject
                   Rectified image of camera 2.

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    min_disparity : int
                    Minimum of the expected disparities.
                    Value Suggestion: -30

    max_disparity : int
                    Maximum of the expected disparities.
                    Value Suggestion: 30
                    Assertion: MinDisparity <= MaxDisparity

    surface_smoothing : int
                        Smoothing of surfaces.
                        Value Suggestion: 50
                        Assertion: SurfaceSmoothing >= 0

    edge_smoothing : int
                     Smoothing of edges.
                     Value Suggestion: 50
                     Assertion: EdgeSmoothing >= 0

    gen_param_name : MaybeSequence[str]
                     Parameter name(s) for the multi-scanline algorithm.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, int]]
                      Parameter value(s) for the multi-scanline algorithm.
                      Value Suggestion: []

    Returns
    -------

    distance : HObject
               Distance image.

    score : HObject
            Score of the calculated disparity.

    See Also
    --------
    map_image, gen_binocular_rectification_map, binocular_calibration,
    disparity_to_distance, distance_to_disparity, disparity_image_to_xyz

    Alternatives
    ------------
    binocular_distance, binocular_distance_mg, binocular_disparity,
    binocular_disparity_mg, binocular_disparity_ms

    Predecessors
    ------------
    map_image

    Successors
    ----------
    threshold

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For a stereo setup of mixed type (i.e., for a stereo setup in which
    one of the original cameras is a perspective camera and the other
    camera is a telecentric camera; see gen_binocular_rectification_map),
    the rectifying plane of the two cameras is in a position with respect
    to the object that would lead to very unintuitive distances.
    Therefore, binocular_distance_ms does not support a stereo setup of
    mixed type.  For stereo setups of mixed type, please use
    reconstruct_surface_stereo, in which the reference coordinate system
    can be chosen arbitrarily.  Alternatively, binocular_disparity_ms and
    disparity_image_to_xyz might be used.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(346) as proc:
        proc.set_input_object(1, image_rect_1)
        proc.set_input_object(2, image_rect_2)
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, min_disparity)
        proc.set_input_tuple(4, max_disparity)
        proc.set_input_tuple(5, surface_smoothing)
        proc.set_input_tuple(6, edge_smoothing)
        proc.set_input_tuple(7, gen_param_name)
        proc.set_input_tuple(8, gen_param_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # distance
            HObject(proc.get_output_object_key(2))   # score
        )  # type: ignore


def binomial_filter(
    image: HObject,
    mask_width: int,
    mask_height: int
) -> HObject:
    """
    Smooth an image using the binomial filter.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_width : int
                 Filter width.
                 Value Suggestion: 5

    mask_height : int
                  Filter height.
                  Value Suggestion: 5

    Returns
    -------

    image_binomial : HObject
                     Smoothed image.

    See Also
    --------
    mean_image, anisotropic_diffusion, sigma_image, gen_lowpass

    Alternatives
    ------------
    gauss_filter, smooth_image, derivate_gauss, isotropic_diffusion

    Predecessors
    ------------
    read_image, grab_image

    Successors
    ----------
    regiongrowing, threshold, sub_image, dyn_threshold, auto_threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1420) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.execute()
        image_binomial = HObject(proc.get_output_object_key(1))
        return image_binomial  # type: ignore


def bit_and(image_1: HObject, image_2: HObject) -> HObject:
    """
    Bit-by-bit AND of all pixels of the input images.

    Parameters
    ----------

    image_1 : HObject
              Input image(s) 1.

    image_2 : HObject
              Input image(s) 2.

    Returns
    -------

    image_and : HObject
                Result image(s) by AND-operation.

    See Also
    --------
    bit_mask, add_image, max_image

    Alternatives
    ------------
    bit_mask, add_image, max_image
    """
    with HalconOperator(1592) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.execute()
        image_and = HObject(proc.get_output_object_key(1))
        return image_and  # type: ignore


def bit_lshift(image: HObject, shift: int) -> HObject:
    """
    Left shift of all pixels of the image.

    Parameters
    ----------

    image : HObject
            Input image(s).

    shift : int
            Shift value.
            Value Suggestion: 3
            Assertion: Shift >= 1 && Shift <= 31

    Returns
    -------

    image_lshift : HObject
                   Result image(s) by shift operation.

    See Also
    --------
    bit_rshift

    Alternatives
    ------------
    scale_image
    """
    with HalconOperator(1588) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, shift)
        proc.execute()
        image_lshift = HObject(proc.get_output_object_key(1))
        return image_lshift  # type: ignore


def bit_mask(image: HObject, bit_mask: int) -> HObject:
    """
    Logical ``AND'' of each pixel using a bit mask.

    Parameters
    ----------

    image : HObject
            Input image(s).

    bit_mask : int
               Bit field
               Value Suggestion: 128

    Returns
    -------

    image_mask : HObject
                 Result image(s) by combination with mask.

    See Also
    --------
    bit_and, bit_lshift

    Alternatives
    ------------
    bit_slice

    Successors
    ----------
    threshold, bit_or
    """
    with HalconOperator(1585) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bit_mask)
        proc.execute()
        image_mask = HObject(proc.get_output_object_key(1))
        return image_mask  # type: ignore


def bit_not(image: HObject) -> HObject:
    """
    Complement all bits of the pixels.

    Parameters
    ----------

    image : HObject
            Input image(s).

    Returns
    -------

    image_not : HObject
                Result image(s) by complement operation.

    See Also
    --------
    bit_slice, bit_mask

    Alternatives
    ------------
    bit_or, bit_and, add_image
    """
    with HalconOperator(1589) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_not = HObject(proc.get_output_object_key(1))
        return image_not  # type: ignore


def bit_or(image_1: HObject, image_2: HObject) -> HObject:
    """
    Bit-by-bit OR of all pixels of the input images.

    Parameters
    ----------

    image_1 : HObject
              Input image(s) 1.

    image_2 : HObject
              Input image(s) 2.

    Returns
    -------

    image_or : HObject
               Result image(s) by OR-operation.

    See Also
    --------
    bit_xor, bit_and

    Alternatives
    ------------
    bit_and, add_image
    """
    with HalconOperator(1591) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.execute()
        image_or = HObject(proc.get_output_object_key(1))
        return image_or  # type: ignore


def bit_rshift(image: HObject, shift: int) -> HObject:
    """
    Right shift of all pixels of the image.

    Parameters
    ----------

    image : HObject
            Input image(s).

    shift : int
            shift value
            Value Suggestion: 3
            Assertion: Shift >= 1 && Shift <= 31

    Returns
    -------

    image_rshift : HObject
                   Result image(s) by shift operation.

    See Also
    --------
    bit_lshift

    Alternatives
    ------------
    scale_image
    """
    with HalconOperator(1587) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, shift)
        proc.execute()
        image_rshift = HObject(proc.get_output_object_key(1))
        return image_rshift  # type: ignore


def bit_slice(image: HObject, bit: int) -> HObject:
    """
    Extract a bit from the pixels.

    Parameters
    ----------

    image : HObject
            Input image(s).

    bit : int
          Bit to be selected.
          Value Suggestion: 8
          Assertion: Bit >= 1 && Bit <= 32

    Returns
    -------

    image_slice : HObject
                  Result image(s) by extraction.

    See Also
    --------
    bit_and, bit_lshift

    Alternatives
    ------------
    bit_mask

    Successors
    ----------
    threshold, bit_or
    """
    with HalconOperator(1586) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bit)
        proc.execute()
        image_slice = HObject(proc.get_output_object_key(1))
        return image_slice  # type: ignore


def bit_xor(image_1: HObject, image_2: HObject) -> HObject:
    """
    Bit-by-bit XOR of all pixels of the input images.

    Parameters
    ----------

    image_1 : HObject
              Input image(s) 1.

    image_2 : HObject
              Input image(s) 2.

    Returns
    -------

    image_xor : HObject
                Result image(s) by XOR-operation.

    See Also
    --------
    bit_or, bit_and

    Alternatives
    ------------
    bit_or, bit_and, add_image
    """
    with HalconOperator(1590) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.execute()
        image_xor = HObject(proc.get_output_object_key(1))
        return image_xor  # type: ignore


def bottom_hat(region: HObject, struct_element: HObject) -> HObject:
    """
    Compute the bottom hat of regions.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_element : HObject
                     Structuring element (position independent).

    Returns
    -------

    region_bottom_hat : HObject
                        Result of the bottom hat operator.

    See Also
    --------
    top_hat, gray_bothat, opening

    Alternatives
    ------------
    closing, difference

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(753) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.execute()
        region_bottom_hat = HObject(proc.get_output_object_key(1))
        return region_bottom_hat  # type: ignore


def boundary(region: HObject, boundary_type: str) -> HObject:
    """
    Reduce a region to its boundary.

    Parameters
    ----------

    region : HObject
             Regions for which the boundary is to be computed.

    boundary_type : str
                    Boundary type.
                    Value Suggestion: inner

    Returns
    -------

    region_border : HObject
                    Resulting boundaries.

    See Also
    --------
    fill_up

    Alternatives
    ------------
    dilation_circle, erosion_circle, difference

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(736) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, boundary_type)
        proc.execute()
        region_border = HObject(proc.get_output_object_key(1))
        return region_border  # type: ignore


def broadcast_condition(condition_handle: HHandle) -> None:
    """
    Signal a condition synchronization object.

    Parameters
    ----------

    condition_handle : HHandle
                       Condition synchronization object.

    See Also
    --------
    wait_condition, timed_wait_condition

    Predecessors
    ------------
    create_condition, wait_condition
    """
    with HalconOperator(544) as proc:
        proc.set_input_tuple(0, condition_handle)
        proc.execute()


def bundle_adjust_mosaic(
    num_images: int,
    reference_image: int,
    mapping_source: Sequence[int],
    mapping_dest: Sequence[int],
    hom_matrices_2d: Sequence[float],
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    num_correspondences: Sequence[int],
    transformation: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Perform a bundle adjustment of an image mosaic.

    Parameters
    ----------

    num_images : int
                 Number of different images that are used for the
                 calibration.
                 Assertion: NumImages >= 2

    reference_image : int
                      Index of the reference image.

    mapping_source : Sequence[int]
                     Indices of the source images of the transformations.

    mapping_dest : Sequence[int]
                   Indices of the target images of the transformations.

    hom_matrices_2d : Sequence[float]
                      Array of $3- projective transformation matrices.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             source images.

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             source images.

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             destination images.

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             destination images.

    num_correspondences : Sequence[int]
                          Number of point correspondences in the
                          respective image pair.

    transformation : str
                     Transformation class to be used.
                     Value Suggestion: projective

    Returns
    -------

    mosaic_matrices_2d : Sequence[float]
                         Array of $3- projective transformation matrices
                         that determine the position of the images in the
                         mosaic.

    rows : Sequence[float]
           Row coordinates of the points reconstructed by the bundle
           adjustment.

    cols : Sequence[float]
           Column coordinates of the points reconstructed by the bundle
           adjustment.

    error : Sequence[float]
            Average error per reconstructed point.

    See Also
    --------
    gen_projective_mosaic

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided

    Successors
    ----------
    gen_bundle_adjusted_mosaic
    """
    with HalconOperator(255) as proc:
        proc.set_input_tuple(0, num_images)
        proc.set_input_tuple(1, reference_image)
        proc.set_input_tuple(2, mapping_source)
        proc.set_input_tuple(3, mapping_dest)
        proc.set_input_tuple(4, hom_matrices_2d)
        proc.set_input_tuple(5, rows_1)
        proc.set_input_tuple(6, cols_1)
        proc.set_input_tuple(7, rows_2)
        proc.set_input_tuple(8, cols_2)
        proc.set_input_tuple(9, num_correspondences)
        proc.set_input_tuple(10, transformation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # mosaic_matrices_2d
            proc.get_output_tuple_m(1),  # rows
            proc.get_output_tuple_m(2),  # cols
            proc.get_output_tuple_m(3)   # error
        )  # type: ignore


def bundle_adjust_mosaic_s(
    num_images: int,
    reference_image: int,
    mapping_source: Sequence[int],
    mapping_dest: Sequence[int],
    hom_matrices_2d: Sequence[float],
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    num_correspondences: Sequence[int],
    transformation: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], float]:
    """
    Perform a bundle adjustment of an image mosaic.

    Parameters
    ----------

    num_images : int
                 Number of different images that are used for the
                 calibration.
                 Assertion: NumImages >= 2

    reference_image : int
                      Index of the reference image.

    mapping_source : Sequence[int]
                     Indices of the source images of the transformations.

    mapping_dest : Sequence[int]
                   Indices of the target images of the transformations.

    hom_matrices_2d : Sequence[float]
                      Array of $3- projective transformation matrices.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             source images.

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             source images.

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             destination images.

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             destination images.

    num_correspondences : Sequence[int]
                          Number of point correspondences in the
                          respective image pair.

    transformation : str
                     Transformation class to be used.
                     Value Suggestion: projective

    Returns
    -------

    mosaic_matrices_2d : Sequence[float]
                         Array of $3- projective transformation matrices
                         that determine the position of the images in the
                         mosaic.

    rows : Sequence[float]
           Row coordinates of the points reconstructed by the bundle
           adjustment.

    cols : Sequence[float]
           Column coordinates of the points reconstructed by the bundle
           adjustment.

    error : float
            Average error per reconstructed point.

    See Also
    --------
    gen_projective_mosaic

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided

    Successors
    ----------
    gen_bundle_adjusted_mosaic
    """
    with HalconOperator(255) as proc:
        proc.set_input_tuple(0, num_images)
        proc.set_input_tuple(1, reference_image)
        proc.set_input_tuple(2, mapping_source)
        proc.set_input_tuple(3, mapping_dest)
        proc.set_input_tuple(4, hom_matrices_2d)
        proc.set_input_tuple(5, rows_1)
        proc.set_input_tuple(6, cols_1)
        proc.set_input_tuple(7, rows_2)
        proc.set_input_tuple(8, cols_2)
        proc.set_input_tuple(9, num_correspondences)
        proc.set_input_tuple(10, transformation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # mosaic_matrices_2d
            proc.get_output_tuple_m(1),  # rows
            proc.get_output_tuple_m(2),  # cols
            proc.get_output_tuple_s(3)   # error
        )  # type: ignore


def calibrate_cameras(calib_data_id: HHandle) -> float:
    """
    Determine all camera parameters by a simultaneous minimization process.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    Returns
    -------

    error : float
            Back projection root mean square error (RMSE) of the
            optimization.

    Predecessors
    ------------
    create_calib_data, set_calib_data_cam_param,
    set_calib_data_calib_object, set_calib_data_observ_points,
    find_calib_object, set_calib_data, remove_calib_data_observ

    Successors
    ----------
    get_calib_data
    """
    with HalconOperator(1966) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.init_oct(0)
        proc.execute()
        error = proc.get_output_tuple_s(0)
        return error  # type: ignore


def calibrate_hand_eye(calib_data_id: HHandle) -> Sequence[float]:
    """
    Perform a hand-eye calibration.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    Returns
    -------

    errors : Sequence[float]
             Average residual error of the optimization.

    Predecessors
    ------------
    create_calib_data, set_calib_data_cam_param,
    set_calib_data_calib_object, set_calib_data_observ_pose,
    find_calib_object, set_calib_data, remove_calib_data,
    remove_calib_data_observ

    Successors
    ----------
    get_calib_data
    """
    with HalconOperator(1965) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.init_oct(0)
        proc.execute()
        errors = proc.get_output_tuple_m(0)
        return errors  # type: ignore


def calibrate_sheet_of_light(sheet_of_light_model_id: HHandle) -> float:
    """
    Calibrate a sheet-of-light setup with a 3D calibration object.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    Returns
    -------

    error : float
            Average back projection error of the optimization.

    Predecessors
    ------------
    create_sheet_of_light_model, set_sheet_of_light_param,
    set_profile_sheet_of_light, measure_profile_sheet_of_light

    Successors
    ----------
    set_profile_sheet_of_light, apply_sheet_of_light_calibration
    """
    with HalconOperator(379) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.init_oct(0)
        proc.execute()
        error = proc.get_output_tuple_s(0)
        return error  # type: ignore


def caltab_points(
    cal_plate_descr: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Read the mark center points from the calibration plate description
    file.

    Parameters
    ----------

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: calplate_320mm.cpd

    Returns
    -------

    x : Sequence[float]
        X coordinates of the mark center points in the coordinate system
        of the calibration plate.

    y : Sequence[float]
        Y coordinates of the mark center points in the coordinate system
        of the calibration plate.

    z : Sequence[float]
        Z coordinates of the mark center points in the coordinate system
        of the calibration plate.

    See Also
    --------
    find_caltab, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab, project_3d_point, get_line_of_sight, gen_caltab

    Successors
    ----------
    camera_calibration
    """
    with HalconOperator(1928) as proc:
        proc.set_input_tuple(0, cal_plate_descr)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1),  # y
            proc.get_output_tuple_m(2)   # z
        )  # type: ignore


def cam_mat_to_cam_par(
    camera_matrix: Sequence[float],
    kappa: float,
    image_width: int,
    image_height: int
) -> Sequence[Union[int, float, str]]:
    """
    Compute the internal camera parameters from a camera matrix.

    Parameters
    ----------

    camera_matrix : Sequence[float]
                    $3- projective camera matrix that determines the
                    internal camera parameters.

    kappa : float
            Kappa.

    image_width : int
                  Width of the images that correspond to CameraMatrix.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images that correspond to CameraMatrix.
                   Assertion: ImageHeight > 0

    Returns
    -------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    See Also
    --------
    camera_calibration, cam_par_to_cam_mat

    Predecessors
    ------------
    stationary_camera_self_calibration
    """
    with HalconOperator(1906) as proc:
        proc.set_input_tuple(0, camera_matrix)
        proc.set_input_tuple(1, kappa)
        proc.set_input_tuple(2, image_width)
        proc.set_input_tuple(3, image_height)
        proc.init_oct(0)
        proc.execute()
        camera_param = proc.get_output_tuple_m(0)
        return camera_param  # type: ignore


def cam_par_pose_to_hom_mat3d(
    camera_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]]
) -> Sequence[float]:
    """
    Convert internal camera parameters and a 3D pose into a 34
    projection matrix.

    Parameters
    ----------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    pose : Sequence[Union[int, float]]
           3D pose.

    Returns
    -------

    hom_mat_3d : Sequence[float]
                 34 projection matrix.

    See Also
    --------
    create_pose, hom_mat3d_to_pose, project_3d_point, get_line_of_sight

    Predecessors
    ------------
    calibrate_cameras, change_radial_distortion_cam_par

    Successors
    ----------
    project_point_hom_mat3d, project_hom_point_hom_mat3d
    """
    with HalconOperator(1933) as proc:
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, pose)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3d = proc.get_output_tuple_m(0)
        return hom_mat_3d  # type: ignore


def cam_par_to_cam_mat(
    camera_param: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[float], int, int]:
    """
    Compute a camera matrix from internal camera parameters.

    Parameters
    ----------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    Returns
    -------

    camera_matrix : Sequence[float]
                    $3- projective camera matrix that corresponds to
                    CameraParam.

    image_width : int
                  Width of the images that correspond to CameraMatrix.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images that correspond to CameraMatrix.
                   Assertion: ImageHeight > 0

    See Also
    --------
    stationary_camera_self_calibration, cam_mat_to_cam_par

    Predecessors
    ------------
    camera_calibration
    """
    with HalconOperator(1905) as proc:
        proc.set_input_tuple(0, camera_param)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_matrix
            proc.get_output_tuple_s(1),  # image_width
            proc.get_output_tuple_s(2)   # image_height
        )  # type: ignore


def camera_calibration(
    nx: Sequence[Union[float, int]],
    ny: Sequence[Union[float, int]],
    nz: Sequence[Union[float, int]],
    nrow: Sequence[Union[float, int]],
    ncol: Sequence[Union[float, int]],
    start_cam_param: Sequence[Union[float, int, str]],
    nstart_pose: Sequence[Union[float, int]],
    estimate_params: Sequence[str]
) -> Tuple[Sequence[Union[float, int, str]], Sequence[Union[float, int]], Sequence[float]]:
    """
    Determine all camera parameters by a simultaneous minimization process.

    Parameters
    ----------

    nx : Sequence[Union[float, int]]
         Ordered tuple with all x coordinates of the calibration marks (in
         meters).

    ny : Sequence[Union[float, int]]
         Ordered tuple with all y coordinates of the calibration marks (in
         meters).

    nz : Sequence[Union[float, int]]
         Ordered tuple with all z coordinates of the calibration marks (in
         meters).

    nrow : Sequence[Union[float, int]]
           Ordered tuple with all row coordinates of the extracted
           calibration marks (in pixels).

    ncol : Sequence[Union[float, int]]
           Ordered tuple with all column coordinates of the extracted
           calibration marks (in pixels).

    start_cam_param : Sequence[Union[float, int, str]]
                      Initial values for the internal camera parameters.

    nstart_pose : Sequence[Union[float, int]]
                  Ordered tuple with all initial values for the external
                  camera parameters.

    estimate_params : Sequence[str]
                      Camera parameters to be estimated.
                      Value Suggestion: all

    Returns
    -------

    camera_param : Sequence[Union[float, int, str]]
                   Internal camera parameters.

    nfinal_pose : Sequence[Union[float, int]]
                  Ordered tuple with all external camera parameters.

    errors : Sequence[float]
             Average error distance in pixels.

    See Also
    --------
    find_caltab, find_marks_and_pose, disp_caltab, sim_caltab,
    write_cam_par, read_cam_par, create_pose, convert_pose_type,
    write_pose, read_pose, pose_to_hom_mat3d, hom_mat3d_to_pose,
    caltab_points, gen_caltab, calibrate_cameras

    Alternatives
    ------------
    calibrate_cameras

    Predecessors
    ------------
    find_marks_and_pose, caltab_points, read_cam_par

    Successors
    ----------
    write_pose, pose_to_hom_mat3d, disp_caltab, sim_caltab

    Notes
    -----
    The minimization process of the calibration depends on the initial
    values of the internal (StartCamParam) and external (NStartPose)
    camera parameters. The computed average errors Errors give an
    impression of the accuracy of the calibration. The errors (deviations
    in x- and y-coordinates) are measured in pixels.
    For line scan cameras, it is possible to set the start value for the
    internal camera parameter Sy to the value 0.0.  In this case, it is
    not possible to determine the position of the principal point in
    y-direction.  Therefore, EstimateParams must contain the term
    '~cy''126cy'}.  The effective distance of the principle point from the
    sensor line is then always pv = -Sy*Cy = 0.0$p_{v}$ = $S_{y} - C_{y} =
    0.0$. Further information can be found in the section ``Further
    Limitations Related  to Specific Camera Types'' of Calibration.
    """
    with HalconOperator(1946) as proc:
        proc.set_input_tuple(0, nx)
        proc.set_input_tuple(1, ny)
        proc.set_input_tuple(2, nz)
        proc.set_input_tuple(3, nrow)
        proc.set_input_tuple(4, ncol)
        proc.set_input_tuple(5, start_cam_param)
        proc.set_input_tuple(6, nstart_pose)
        proc.set_input_tuple(7, estimate_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_param
            proc.get_output_tuple_m(1),  # nfinal_pose
            proc.get_output_tuple_m(2)   # errors
        )  # type: ignore


def camera_calibration_s(
    nx: Sequence[Union[float, int]],
    ny: Sequence[Union[float, int]],
    nz: Sequence[Union[float, int]],
    nrow: Sequence[Union[float, int]],
    ncol: Sequence[Union[float, int]],
    start_cam_param: Sequence[Union[float, int, str]],
    nstart_pose: Sequence[Union[float, int]],
    estimate_params: Sequence[str]
) -> Tuple[Sequence[Union[float, int, str]], Sequence[Union[float, int]], float]:
    """
    Determine all camera parameters by a simultaneous minimization process.

    Parameters
    ----------

    nx : Sequence[Union[float, int]]
         Ordered tuple with all x coordinates of the calibration marks (in
         meters).

    ny : Sequence[Union[float, int]]
         Ordered tuple with all y coordinates of the calibration marks (in
         meters).

    nz : Sequence[Union[float, int]]
         Ordered tuple with all z coordinates of the calibration marks (in
         meters).

    nrow : Sequence[Union[float, int]]
           Ordered tuple with all row coordinates of the extracted
           calibration marks (in pixels).

    ncol : Sequence[Union[float, int]]
           Ordered tuple with all column coordinates of the extracted
           calibration marks (in pixels).

    start_cam_param : Sequence[Union[float, int, str]]
                      Initial values for the internal camera parameters.

    nstart_pose : Sequence[Union[float, int]]
                  Ordered tuple with all initial values for the external
                  camera parameters.

    estimate_params : Sequence[str]
                      Camera parameters to be estimated.
                      Value Suggestion: all

    Returns
    -------

    camera_param : Sequence[Union[float, int, str]]
                   Internal camera parameters.

    nfinal_pose : Sequence[Union[float, int]]
                  Ordered tuple with all external camera parameters.

    errors : float
             Average error distance in pixels.

    See Also
    --------
    find_caltab, find_marks_and_pose, disp_caltab, sim_caltab,
    write_cam_par, read_cam_par, create_pose, convert_pose_type,
    write_pose, read_pose, pose_to_hom_mat3d, hom_mat3d_to_pose,
    caltab_points, gen_caltab, calibrate_cameras

    Alternatives
    ------------
    calibrate_cameras

    Predecessors
    ------------
    find_marks_and_pose, caltab_points, read_cam_par

    Successors
    ----------
    write_pose, pose_to_hom_mat3d, disp_caltab, sim_caltab

    Notes
    -----
    The minimization process of the calibration depends on the initial
    values of the internal (StartCamParam) and external (NStartPose)
    camera parameters. The computed average errors Errors give an
    impression of the accuracy of the calibration. The errors (deviations
    in x- and y-coordinates) are measured in pixels.
    For line scan cameras, it is possible to set the start value for the
    internal camera parameter Sy to the value 0.0.  In this case, it is
    not possible to determine the position of the principal point in
    y-direction.  Therefore, EstimateParams must contain the term
    '~cy''126cy'}.  The effective distance of the principle point from the
    sensor line is then always pv = -Sy*Cy = 0.0$p_{v}$ = $S_{y} - C_{y} =
    0.0$. Further information can be found in the section ``Further
    Limitations Related  to Specific Camera Types'' of Calibration.
    """
    with HalconOperator(1946) as proc:
        proc.set_input_tuple(0, nx)
        proc.set_input_tuple(1, ny)
        proc.set_input_tuple(2, nz)
        proc.set_input_tuple(3, nrow)
        proc.set_input_tuple(4, ncol)
        proc.set_input_tuple(5, start_cam_param)
        proc.set_input_tuple(6, nstart_pose)
        proc.set_input_tuple(7, estimate_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_param
            proc.get_output_tuple_m(1),  # nfinal_pose
            proc.get_output_tuple_s(2)   # errors
        )  # type: ignore


def cfa_to_rgb(
    cfaimage: HObject,
    cfatype: str,
    interpolation: str
) -> HObject:
    """
    Convert a single-channel color filter array image into an RGB image.

    Parameters
    ----------

    cfaimage : HObject
               Input image.

    cfatype : str
              Color filter array type.
              Value Suggestion: bayer_gb

    interpolation : str
                    Interpolation type.
                    Value Suggestion: bilinear

    Returns
    -------

    rgbimage : HObject
               Output image.

    See Also
    --------
    trans_from_rgb

    Predecessors
    ------------
    gen_image1_extern, gen_image1, grab_image

    Successors
    ----------
    decompose3
    """
    with HalconOperator(1580) as proc:
        proc.set_input_object(1, cfaimage)
        proc.set_input_tuple(0, cfatype)
        proc.set_input_tuple(1, interpolation)
        proc.execute()
        rgbimage = HObject(proc.get_output_object_key(1))
        return rgbimage  # type: ignore


def change_domain(image: HObject, new_domain: HObject) -> HObject:
    """
    Change definition domain of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    new_domain : HObject
                 New definition domain.

    Returns
    -------

    image_new : HObject
                Image with new definition domain.

    See Also
    --------
    full_domain, get_domain, intersection

    Alternatives
    ------------
    reduce_domain

    Predecessors
    ------------
    get_domain

    Notes
    -----
    Due to running time the transferred region is not checked for
    consistency (i.e., whether it fits with the image matrix). Incorrect
    regions lead to system hang-ups during subsequent operations.
    """
    with HalconOperator(1143) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, new_domain)
        proc.execute()
        image_new = HObject(proc.get_output_object_key(1))
        return image_new  # type: ignore


def change_format(image: HObject, width: int, height: int) -> HObject:
    """
    Change image size.

    Parameters
    ----------

    image : HObject
            Input image.

    width : int
            Width of new image.
            Value Suggestion: 512

    height : int
             Height of new image.
             Value Suggestion: 512

    Returns
    -------

    image_part : HObject
                 Image with new format.

    See Also
    --------
    zoom_image_size, zoom_image_factor

    Alternatives
    ------------
    crop_part

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1142) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        image_part = HObject(proc.get_output_object_key(1))
        return image_part  # type: ignore


def change_radial_distortion_cam_par(
    mode: str,
    cam_param_in: Sequence[Union[int, float, str]],
    distortion_coeffs: MaybeSequence[Union[float, int]]
) -> Sequence[Union[int, float, str]]:
    """
    Determine new camera parameters in accordance to the specified radial
    distortion.

    Parameters
    ----------

    mode : str
           Mode
           Value Suggestion: adaptive

    cam_param_in : Sequence[Union[int, float, str]]
                   Internal camera parameters (original).

    distortion_coeffs : MaybeSequence[Union[float, int]]
                        Desired radial distortions.
                        Value Suggestion: 0.0

    Returns
    -------

    cam_param_out : Sequence[Union[int, float, str]]
                    Internal camera parameters (modified).

    See Also
    --------
    camera_calibration, read_cam_par, change_radial_distortion_image,
    change_radial_distortion_contours_xld, change_radial_distortion_points

    Predecessors
    ------------
    camera_calibration, read_cam_par

    Successors
    ----------
    change_radial_distortion_image, change_radial_distortion_contours_xld,
    gen_radial_distortion_map
    """
    with HalconOperator(1925) as proc:
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, cam_param_in)
        proc.set_input_tuple(2, distortion_coeffs)
        proc.init_oct(0)
        proc.execute()
        cam_param_out = proc.get_output_tuple_m(0)
        return cam_param_out  # type: ignore


def change_radial_distortion_contours_xld(
    contours: HObject,
    cam_param_in: Sequence[Union[int, float, str]],
    cam_param_out: Sequence[Union[int, float, str]]
) -> HObject:
    """
    Change the radial distortion of contours.

    Parameters
    ----------

    contours : HObject
               Original contours.

    cam_param_in : Sequence[Union[int, float, str]]
                   Internal camera parameter for Contours.

    cam_param_out : Sequence[Union[int, float, str]]
                    Internal camera parameter for ContoursRectified.

    Returns
    -------

    contours_rectified : HObject
                         Resulting contours with modified radial
                         distortion.

    See Also
    --------
    change_radial_distortion_cam_par, camera_calibration, read_cam_par,
    change_radial_distortion_image, change_radial_distortion_points

    Predecessors
    ------------
    change_radial_distortion_cam_par, gen_contours_skeleton_xld,
    edges_sub_pix, smooth_contours_xld

    Successors
    ----------
    gen_polygons_xld, smooth_contours_xld
    """
    with HalconOperator(1922) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, cam_param_in)
        proc.set_input_tuple(1, cam_param_out)
        proc.execute()
        contours_rectified = HObject(proc.get_output_object_key(1))
        return contours_rectified  # type: ignore


def change_radial_distortion_image(
    image: HObject,
    region: HObject,
    cam_param_in: Sequence[Union[int, float, str]],
    cam_param_out: Sequence[Union[int, float, str]]
) -> HObject:
    """
    Change the radial distortion of an image.

    Parameters
    ----------

    image : HObject
            Original image.

    region : HObject
             Region of interest in ImageRectified.

    cam_param_in : Sequence[Union[int, float, str]]
                   Internal camera parameter for Image.

    cam_param_out : Sequence[Union[int, float, str]]
                    Internal camera parameter for Image.

    Returns
    -------

    image_rectified : HObject
                      Resulting image with modified radial distortion.

    See Also
    --------
    change_radial_distortion_cam_par, camera_calibration, read_cam_par,
    change_radial_distortion_contours_xld, change_radial_distortion_points

    Predecessors
    ------------
    change_radial_distortion_cam_par, read_image, grab_image

    Successors
    ----------
    edges_image, threshold

    Notes
    -----
    change_radial_distortion_image can be executed on OpenCL devices if
    the input image does not exceed the maximum size of image objects of
    the selected device. As the OpenCL implementation uses single
    precision arithmetic, the results can differ from the CPU
    implementation.
    """
    with HalconOperator(1924) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, cam_param_in)
        proc.set_input_tuple(1, cam_param_out)
        proc.execute()
        image_rectified = HObject(proc.get_output_object_key(1))
        return image_rectified  # type: ignore


def change_radial_distortion_points(
    row: Sequence[float],
    col: Sequence[float],
    cam_param_in: Sequence[Union[int, float, str]],
    cam_param_out: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Change the radial distortion of pixel coordinates.

    Parameters
    ----------

    row : Sequence[float]
          Original row component of pixel coordinates.

    col : Sequence[float]
          Original column component of pixel coordinates.

    cam_param_in : Sequence[Union[int, float, str]]
                   The inner camera parameters of the camera used to
                   create the input pixel coordinates.

    cam_param_out : Sequence[Union[int, float, str]]
                    The inner camera parameters of a camera.

    Returns
    -------

    row_changed : Sequence[float]
                  Row component of pixel coordinates after changing the
                  radial distortion.

    col_changed : Sequence[float]
                  Column component of pixel coordinates after changing the
                  radial distortion.

    See Also
    --------
    change_radial_distortion_cam_par, camera_calibration, read_cam_par,
    change_radial_distortion_contours_xld, change_radial_distortion_image
    """
    with HalconOperator(1923) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, col)
        proc.set_input_tuple(2, cam_param_in)
        proc.set_input_tuple(3, cam_param_out)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_changed
            proc.get_output_tuple_m(1)   # col_changed
        )  # type: ignore


def channels_to_image(images: HObject) -> HObject:
    """
    Convert one-channel images into a multi-channel image

    Parameters
    ----------

    images : HObject
             One-channel images to be combined into a one-channel image.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    image_to_channels

    Successors
    ----------
    count_channels, disp_image
    """
    with HalconOperator(1119) as proc:
        proc.set_input_object(1, images)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def char_threshold(
    image: HObject,
    histo_region: HObject,
    sigma: float,
    percent: Union[int, float]
) -> Tuple[HObject, Sequence[int]]:
    """
    Perform a threshold segmentation for extracting characters.

    Parameters
    ----------

    image : HObject
            Input image.

    histo_region : HObject
                   Region in which the histogram is computed.

    sigma : float
            Sigma for the Gaussian smoothing of the histogram.
            Value Suggestion: 2.0

    percent : Union[int, float]
              Percentage for the gray value difference.
              Value Suggestion: 95

    Returns
    -------

    characters : HObject
                 Dark regions (characters).

    threshold : Sequence[int]
                Calculated threshold.

    Alternatives
    ------------
    binary_threshold, auto_threshold, gray_histo, smooth_funct_1d_gauss,
    threshold

    Predecessors
    ------------
    anisotropic_diffusion, median_image, illuminate

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(444) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, histo_region)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, percent)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # characters
            proc.get_output_tuple_m(0)   # threshold
        )  # type: ignore


def char_threshold_s(
    image: HObject,
    histo_region: HObject,
    sigma: float,
    percent: Union[int, float]
) -> Tuple[HObject, int]:
    """
    Perform a threshold segmentation for extracting characters.

    Parameters
    ----------

    image : HObject
            Input image.

    histo_region : HObject
                   Region in which the histogram is computed.

    sigma : float
            Sigma for the Gaussian smoothing of the histogram.
            Value Suggestion: 2.0

    percent : Union[int, float]
              Percentage for the gray value difference.
              Value Suggestion: 95

    Returns
    -------

    characters : HObject
                 Dark regions (characters).

    threshold : int
                Calculated threshold.

    Alternatives
    ------------
    binary_threshold, auto_threshold, gray_histo, smooth_funct_1d_gauss,
    threshold

    Predecessors
    ------------
    anisotropic_diffusion, median_image, illuminate

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(444) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, histo_region)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, percent)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # characters
            proc.get_output_tuple_s(0)   # threshold
        )  # type: ignore


def check_difference(
    image: HObject,
    pattern: HObject,
    mode: str,
    diff_lower_bound: int,
    diff_upper_bound: int,
    gray_offset: int,
    add_row: int,
    add_col: int
) -> HObject:
    """
    Compare two images pixel by pixel.

    Parameters
    ----------

    image : HObject
            Input image.

    pattern : HObject
              Comparison image.

    mode : str
           Mode: return similar or different pixels.
           Value Suggestion: diff_outside

    diff_lower_bound : int
                       Lower bound of the tolerated gray value difference.
                       Value Suggestion: -5
                       Assertion: -255 <= DiffLowerBound && DiffLowerBound <= 255

    diff_upper_bound : int
                       Upper bound of the tolerated gray value difference.
                       Value Suggestion: 5
                       Assertion: -255 <= DiffUpperBound && DiffUpperBound <= 255

    gray_offset : int
                  Offset gray value subtracted from the input image.
                  Value Suggestion: 0
                  Assertion: -255 <= GrayOffset && GrayOffset <= 255

    add_row : int
              Row coordinate by which the comparison image is translated.
              Value Suggestion: 0

    add_col : int
              Column coordinate by which the comparison image is
              translated.
              Value Suggestion: 0

    Returns
    -------

    selected : HObject
               Points in which the two images are similar/different.

    Alternatives
    ------------
    sub_image, dyn_threshold

    Successors
    ----------
    connection, select_shape, reduce_domain, select_gray, rank_region,
    dilation1, opening
    """
    with HalconOperator(443) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, pattern)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, diff_lower_bound)
        proc.set_input_tuple(2, diff_upper_bound)
        proc.set_input_tuple(3, gray_offset)
        proc.set_input_tuple(4, add_row)
        proc.set_input_tuple(5, add_col)
        proc.execute()
        selected = HObject(proc.get_output_object_key(1))
        return selected  # type: ignore


def circularity(regions: HObject) -> Sequence[float]:
    """
    Shape factor for the circularity (similarity to a circle) of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    circularity : Sequence[float]
                  Circularity of the input region(s).
                  Assertion: 0 <= Circularity && Circularity <= 1.0

    See Also
    --------
    area_center, select_shape

    Alternatives
    ------------
    roundness, compactness, convexity, eccentricity

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1729) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        circularity = proc.get_output_tuple_m(0)
        return circularity  # type: ignore


def circularity_s(regions: HObject) -> float:
    """
    Shape factor for the circularity (similarity to a circle) of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    circularity : float
                  Circularity of the input region(s).
                  Assertion: 0 <= Circularity && Circularity <= 1.0

    See Also
    --------
    area_center, select_shape

    Alternatives
    ------------
    roundness, compactness, convexity, eccentricity

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1729) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        circularity = proc.get_output_tuple_s(0)
        return circularity  # type: ignore


def circularity_xld(xld: HObject) -> Sequence[float]:
    """
    Shape factor for the circularity (similarity to a circle) of contours
    or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    circularity : Sequence[float]
                  Roundness of the input contours or polygons.
                  Assertion: 0 <= Circularity && Circularity <= 1.0

    See Also
    --------
    area_center_xld, select_shape_xld

    Alternatives
    ------------
    compactness_xld, convexity_xld, eccentricity_xld, rectangularity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1684) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        circularity = proc.get_output_tuple_m(0)
        return circularity  # type: ignore


def circularity_xld_s(xld: HObject) -> float:
    """
    Shape factor for the circularity (similarity to a circle) of contours
    or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    circularity : float
                  Roundness of the input contours or polygons.
                  Assertion: 0 <= Circularity && Circularity <= 1.0

    See Also
    --------
    area_center_xld, select_shape_xld

    Alternatives
    ------------
    compactness_xld, convexity_xld, eccentricity_xld, rectangularity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1684) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        circularity = proc.get_output_tuple_s(0)
        return circularity  # type: ignore


def class_2dim_sup(
    image_col: HObject,
    image_row: HObject,
    feature_space: HObject
) -> HObject:
    """
    Segment an image using two-dimensional pixel classification.

    Parameters
    ----------

    image_col : HObject
                Input image (first channel).

    image_row : HObject
                Input image (second channel).

    feature_space : HObject
                    Region defining the feature space.

    Returns
    -------

    region_class_2dim : HObject
                        Classified regions.

    See Also
    --------
    histo_2dim

    Alternatives
    ------------
    class_ndim_norm, threshold

    Predecessors
    ------------
    histo_2dim, threshold, draw_region, dilation1, opening, shape_trans

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(441) as proc:
        proc.set_input_object(1, image_col)
        proc.set_input_object(2, image_row)
        proc.set_input_object(3, feature_space)
        proc.execute()
        region_class_2dim = HObject(proc.get_output_object_key(1))
        return region_class_2dim  # type: ignore


def class_2dim_unsup(
    image_1: HObject,
    image_2: HObject,
    threshold: int,
    num_classes: int
) -> HObject:
    """
    Segment two images by clustering.

    Parameters
    ----------

    image_1 : HObject
              First input image.

    image_2 : HObject
              Second input image.

    threshold : int
                Threshold (maximum distance to the cluster's center).
                Value Suggestion: 15

    num_classes : int
                  Number of classes (cluster centers).
                  Value Suggestion: 5

    Returns
    -------

    classes : HObject
              Classification result.

    Alternatives
    ------------
    threshold, histo_2dim, class_2dim_sup, class_ndim_norm

    Predecessors
    ------------
    decompose2, decompose3, median_image, anisotropic_diffusion,
    reduce_domain

    Successors
    ----------
    select_shape, select_gray, connection

    Notes
    -----
    Both input images must have the same size.
    """
    with HalconOperator(442) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, threshold)
        proc.set_input_tuple(1, num_classes)
        proc.execute()
        classes = HObject(proc.get_output_object_key(1))
        return classes  # type: ignore


def class_ndim_box(
    multi_channel_image: HObject,
    classif_handle: HHandle
) -> HObject:
    """
    Classify pixels using hyper-cuboids.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi channel input image.

    classif_handle : HHandle
                     Handle of the classifier.

    Returns
    -------

    regions : HObject
              Classification result.

    See Also
    --------
    descript_class_box

    Alternatives
    ------------
    class_ndim_norm, class_2dim_sup, class_2dim_unsup

    Predecessors
    ------------
    create_class_box, learn_class_box, median_image, compose2, compose3,
    compose4, compose5, compose6, compose7

    Warnings
    --------
    class_ndim_box is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(439) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.set_input_tuple(0, classif_handle)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def class_ndim_norm(
    multi_channel_image: HObject,
    metric: str,
    single_multiple: str,
    radius: MaybeSequence[Union[int, float]],
    center: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Classify pixels using hyper-spheres or hyper-cubes.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi channel input image.

    metric : str
             Metric to be used.
             Value Suggestion: euclid

    single_multiple : str
                      Return one region or one region for each cluster.
                      Value Suggestion: single

    radius : MaybeSequence[Union[int, float]]
             Cluster radii or half edge lengths (returned by
             learn_ndim_norm).

    center : MaybeSequence[Union[int, float]]
             Coordinates of the cluster centers (returned by
             learn_ndim_norm).

    Returns
    -------

    regions : HObject
              Classification result.

    Alternatives
    ------------
    class_2dim_sup, class_2dim_unsup

    Predecessors
    ------------
    learn_ndim_norm, compose2, compose3, compose4, compose5, compose6,
    compose7

    Successors
    ----------
    connection, select_shape, reduce_domain, select_gray
    """
    with HalconOperator(440) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.set_input_tuple(0, metric)
        proc.set_input_tuple(1, single_multiple)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, center)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def classify_class_gmm(
    gmmhandle: HHandle,
    features: Sequence[float],
    num: int
) -> Tuple[Sequence[int], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the class of a feature vector by a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    features : Sequence[float]
               Feature vector.

    num : int
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_id : Sequence[int]
               Result of classifying the feature vector with the GMM.

    class_prob : Sequence[float]
                 A-posteriori probability of the classes.

    density : Sequence[float]
              Probability density of the feature vector.

    ksigma_prob : Sequence[float]
                  Normalized k-sigma-probability for the feature vector.

    See Also
    --------
    create_class_gmm

    Alternatives
    ------------
    evaluate_class_gmm

    Predecessors
    ------------
    train_class_gmm, read_class_gmm
    """
    with HalconOperator(1832) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_id
            proc.get_output_tuple_m(1),  # class_prob
            proc.get_output_tuple_m(2),  # density
            proc.get_output_tuple_m(3)   # ksigma_prob
        )  # type: ignore


def classify_class_gmm_s(
    gmmhandle: HHandle,
    features: Sequence[float],
    num: int
) -> Tuple[int, Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the class of a feature vector by a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    features : Sequence[float]
               Feature vector.

    num : int
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_id : int
               Result of classifying the feature vector with the GMM.

    class_prob : Sequence[float]
                 A-posteriori probability of the classes.

    density : Sequence[float]
              Probability density of the feature vector.

    ksigma_prob : Sequence[float]
                  Normalized k-sigma-probability for the feature vector.

    See Also
    --------
    create_class_gmm

    Alternatives
    ------------
    evaluate_class_gmm

    Predecessors
    ------------
    train_class_gmm, read_class_gmm
    """
    with HalconOperator(1832) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_id
            proc.get_output_tuple_m(1),  # class_prob
            proc.get_output_tuple_m(2),  # density
            proc.get_output_tuple_m(3)   # ksigma_prob
        )  # type: ignore


def classify_class_knn(
    knnhandle: HHandle,
    features: Sequence[float]
) -> Tuple[Sequence[int], Sequence[float]]:
    """
    Search for the next neighbors for a given feature vector.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    features : Sequence[float]
               Features that should be classified.

    Returns
    -------

    result : Sequence[int]
             The classification result, either class IDs or sample
             indices.

    rating : Sequence[float]
             A rating for the results. This value contains either a
             distance, a frequency or a weighted frequency.

    See Also
    --------
    create_class_knn, read_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn, set_params_class_knn

    Successors
    ----------
    clear_class_knn
    """
    with HalconOperator(1813) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, features)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # result
            proc.get_output_tuple_m(1)   # rating
        )  # type: ignore


def classify_class_mlp(
    mlphandle: HHandle,
    features: Sequence[float],
    num: Sequence[int]
) -> Tuple[Sequence[int], Sequence[float]]:
    """
    Calculate the class of a feature vector by a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    features : Sequence[float]
               Feature vector.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : Sequence[int]
                Result of classifying the feature vector with the MLP.

    confidence : Sequence[float]
                 Confidence(s) of the class(es) of the feature vector.

    See Also
    --------
    create_class_mlp

    Alternatives
    ------------
    apply_dl_classifier, evaluate_class_mlp

    Predecessors
    ------------
    train_class_mlp, read_class_mlp
    """
    with HalconOperator(1871) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def classify_class_mlp_s(
    mlphandle: HHandle,
    features: Sequence[float],
    num: Sequence[int]
) -> Tuple[int, float]:
    """
    Calculate the class of a feature vector by a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    features : Sequence[float]
               Feature vector.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : int
                Result of classifying the feature vector with the MLP.

    confidence : float
                 Confidence(s) of the class(es) of the feature vector.

    See Also
    --------
    create_class_mlp

    Alternatives
    ------------
    apply_dl_classifier, evaluate_class_mlp

    Predecessors
    ------------
    train_class_mlp, read_class_mlp
    """
    with HalconOperator(1871) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def classify_class_svm(
    svmhandle: HHandle,
    features: Sequence[float],
    num: Sequence[int]
) -> Sequence[int]:
    """
    Classify a feature vector by a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    features : Sequence[float]
               Feature vector.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : Sequence[int]
                Result of classifying the feature vector with the SVM.

    See Also
    --------
    create_class_svm

    Alternatives
    ------------
    apply_dl_classifier

    Predecessors
    ------------
    train_class_svm, read_class_svm
    """
    with HalconOperator(1851) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, num)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_m(0)
        return class_val  # type: ignore


def classify_class_svm_s(
    svmhandle: HHandle,
    features: Sequence[float],
    num: Sequence[int]
) -> int:
    """
    Classify a feature vector by a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    features : Sequence[float]
               Feature vector.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : int
                Result of classifying the feature vector with the SVM.

    See Also
    --------
    create_class_svm

    Alternatives
    ------------
    apply_dl_classifier

    Predecessors
    ------------
    train_class_svm, read_class_svm
    """
    with HalconOperator(1851) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, num)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_s(0)
        return class_val  # type: ignore


def classify_image_class_gmm(
    image: HObject,
    gmmhandle: HHandle,
    rejection_threshold: float
) -> HObject:
    """
    Classify an image with a Gaussian Mixture Model.

    Parameters
    ----------

    image : HObject
            Input image.

    gmmhandle : HHandle
                GMM handle.

    rejection_threshold : float
                          Threshold for the rejection of the
                          classification.
                          Value Suggestion: 0.5
                          Assertion: RejectionThreshold >= 0.0 && RejectionThreshold <= 1.0

    Returns
    -------

    class_regions : HObject
                    Segmented classes.

    See Also
    --------
    add_samples_image_class_gmm, create_class_gmm

    Alternatives
    ------------
    classify_image_class_knn, classify_image_class_mlp,
    classify_image_class_svm, classify_image_class_lut, class_ndim_norm,
    class_2dim_sup

    Predecessors
    ------------
    train_class_gmm, read_class_gmm
    """
    with HalconOperator(431) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, rejection_threshold)
        proc.execute()
        class_regions = HObject(proc.get_output_object_key(1))
        return class_regions  # type: ignore


def classify_image_class_knn(
    image: HObject,
    knnhandle: HHandle,
    rejection_threshold: float
) -> Tuple[HObject, HObject]:
    """
    Classify an image with a k-Nearest-Neighbor classifier.

    Parameters
    ----------

    image : HObject
            Input image.

    knnhandle : HHandle
                Handle of the k-NN classifier.

    rejection_threshold : float
                          Threshold for the rejection of the
                          classification.
                          Value Suggestion: 0.5
                          Assertion: RejectionThreshold >= 0.0

    Returns
    -------

    class_regions : HObject
                    Segmented classes.

    distance_image : HObject
                     Distance of the pixel's nearest neighbor.

    See Also
    --------
    add_samples_image_class_knn, create_class_knn

    Alternatives
    ------------
    classify_image_class_svm, classify_image_class_mlp,
    classify_image_class_gmm, classify_image_class_lut, class_ndim_norm,
    class_2dim_sup

    Predecessors
    ------------
    train_class_knn, read_class_knn
    """
    with HalconOperator(429) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, rejection_threshold)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # class_regions
            HObject(proc.get_output_object_key(2))   # distance_image
        )  # type: ignore


def classify_image_class_lut(
    image: HObject,
    class_luthandle: HHandle
) -> HObject:
    """
    Classify a byte image using a look-up table.

    Parameters
    ----------

    image : HObject
            Input image.

    class_luthandle : HHandle
                      Handle of the LUT classifier.

    Returns
    -------

    class_regions : HObject
                    Segmented classes.

    See Also
    --------
    create_class_lut_gmm, create_class_lut_knn, create_class_lut_mlp,
    create_class_lut_svm, create_class_lut_gmm

    Alternatives
    ------------
    classify_image_class_gmm, classify_image_class_knn,
    classify_image_class_mlp, classify_image_class_svm

    Predecessors
    ------------
    create_class_lut_gmm, create_class_lut_knn, create_class_lut_mlp,
    create_class_lut_svm
    """
    with HalconOperator(428) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, class_luthandle)
        proc.execute()
        class_regions = HObject(proc.get_output_object_key(1))
        return class_regions  # type: ignore


def classify_image_class_mlp(
    image: HObject,
    mlphandle: HHandle,
    rejection_threshold: float
) -> HObject:
    """
    Classify an image with a multilayer perceptron.

    Parameters
    ----------

    image : HObject
            Input image.

    mlphandle : HHandle
                MLP handle.

    rejection_threshold : float
                          Threshold for the rejection of the
                          classification.
                          Value Suggestion: 0.5
                          Assertion: RejectionThreshold >= 0.0 && RejectionThreshold <= 1.0

    Returns
    -------

    class_regions : HObject
                    Segmented classes.

    See Also
    --------
    add_samples_image_class_mlp, create_class_mlp

    Alternatives
    ------------
    classify_image_class_gmm, classify_image_class_knn,
    classify_image_class_svm, classify_image_class_lut, class_ndim_norm,
    class_2dim_sup

    Predecessors
    ------------
    train_class_mlp, read_class_mlp
    """
    with HalconOperator(435) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, rejection_threshold)
        proc.execute()
        class_regions = HObject(proc.get_output_object_key(1))
        return class_regions  # type: ignore


def classify_image_class_svm(
    image: HObject,
    svmhandle: HHandle
) -> HObject:
    """
    Classify an image with a support vector machine.

    Parameters
    ----------

    image : HObject
            Input image.

    svmhandle : HHandle
                SVM handle.

    Returns
    -------

    class_regions : HObject
                    Segmented classes.

    See Also
    --------
    add_samples_image_class_svm, create_class_svm

    Alternatives
    ------------
    classify_image_class_gmm, classify_image_class_knn,
    classify_image_class_mlp, classify_image_class_lut, class_ndim_norm,
    class_2dim_sup

    Predecessors
    ------------
    train_class_svm, read_class_svm, reduce_class_svm
    """
    with HalconOperator(433) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, svmhandle)
        proc.execute()
        class_regions = HObject(proc.get_output_object_key(1))
        return class_regions  # type: ignore


def clear_all_bar_code_models() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all bar code models and free the allocated memory

    Warnings
    --------
    clear_all_bar_code_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_bar_code_models, the operator will be removed
    in future versions.

    Notes
    -----
    clear_all_bar_code_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_bar_code_models must not be used in any application.
    """
    with HalconOperator(1999) as proc:
        proc.execute()


def clear_all_barriers() -> None:
    """
    This operator is inoperable. It had the following function: Destroy
    all barrier synchronization objects.

    Warnings
    --------
    clear_all_barriers is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_barriers, the operator will be removed in future versions.

    Notes
    -----
    clear_all_barriers exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_barriers must
    not be used in any application.
    """
    with HalconOperator(549) as proc:
        proc.execute()


def clear_all_calib_data() -> None:
    """
    Free the memory of all calibration data models.

    Warnings
    --------
    clear_all_calib_data is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    clear_all_calib_data, the operator will be removed in future versions.

    Notes
    -----
    clear_all_calib_data exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_calib_data must
    not be used in any application.
    """
    with HalconOperator(1959) as proc:
        proc.execute()


def clear_all_camera_setup_models() -> None:
    """
    Free the memory of all camera setup models.

    Warnings
    --------
    clear_all_camera_setup_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility.  New applications
    should not use clear_all_camera_setup_models, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_camera_setup_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_camera_setup_models must not be used in any application.
    """
    with HalconOperator(1949) as proc:
        proc.execute()


def clear_all_class_gmm() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    Gaussian Mixture Models.

    Warnings
    --------
    clear_all_class_gmm is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_class_gmm, the operator will be removed in future versions.

    Notes
    -----
    clear_all_class_gmm exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_class_gmm must
    not be used in any application.
    """
    with HalconOperator(1823) as proc:
        proc.execute()


def clear_all_class_knn() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    k-NN classifiers.

    Warnings
    --------
    clear_all_class_knn is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_class_knn, the operator will be removed in future versions.

    Notes
    -----
    clear_all_class_knn exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_class_knn must
    not be used in any application.
    """
    with HalconOperator(1803) as proc:
        proc.execute()


def clear_all_class_lut() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    look-up table classifiers.

    Warnings
    --------
    clear_all_class_lut is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_class_lut, the operator will be removed in future versions.

    Notes
    -----
    clear_all_class_lut exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_class_lut must
    not be used in any application.
    """
    with HalconOperator(1817) as proc:
        proc.execute()


def clear_all_class_mlp() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    multilayer perceptrons.

    Warnings
    --------
    clear_all_class_mlp is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    clear_all_class_mlp, the operator will be removed in future versions.

    Notes
    -----
    clear_all_class_mlp exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_class_mlp must
    not be used in any application.
    """
    with HalconOperator(1862) as proc:
        proc.execute()


def clear_all_class_svm() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    support vector machines.

    Warnings
    --------
    clear_all_class_svm is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_class_svm, the operator will be removed in future versions.

    Notes
    -----
    clear_all_class_svm exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_class_svm must
    not be used in any application.
    """
    with HalconOperator(1841) as proc:
        proc.execute()


def clear_all_class_train_data() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    training data for classifiers.

    Warnings
    --------
    clear_all_class_train_data is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_class_train_data, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_class_train_data exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    """
    with HalconOperator(1795) as proc:
        proc.execute()


def clear_all_color_trans_luts() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all look-up-tables of the color space transformation.

    Warnings
    --------
    clear_all_color_trans_luts is obsolete, inoperable,  and is only
    provided for reasons of backward compatibility.  New applications
    should not use clear_all_color_trans_luts, the operator will be
    removed in future versions.

    Notes
    -----
    After execution of clear_all_color_trans_luts all handles to
    look-up-tables become invalid. clear_all_color_trans_luts exists
    solely for the purpose of implementing the ``reset program''
    functionality in HDevelop. clear_all_color_trans_luts must not be used
    in any application.
    """
    with HalconOperator(1576) as proc:
        proc.execute()


def clear_all_component_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all component models.

    Warnings
    --------
    clear_all_component_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_component_models, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_component_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_component_models must not be used in any application.
    """
    with HalconOperator(996) as proc:
        proc.execute()


def clear_all_conditions() -> None:
    """
    This operator is inoperable. It had the following function:  Destroy
    all condition synchronization objects.

    Warnings
    --------
    clear_all_conditions is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    close_all_framegrabbers, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_conditions exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_conditions must
    not be used in any application.
    """
    with HalconOperator(542) as proc:
        proc.execute()


def clear_all_data_code_2d_models() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all 2D data code models and free the allocated memory.

    Warnings
    --------
    clear_all_data_code_2d_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility.  New applications
    should not use clear_all_data_code_2d_models, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_data_code_2d_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_data_code_2d_models must not be used in any application.
    """
    with HalconOperator(1776) as proc:
        proc.execute()


def clear_all_deformable_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all deformable models.

    Warnings
    --------
    clear_all_deformable_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_deformable_models, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_deformable_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_deformable_models must not be used in any application.
    """
    with HalconOperator(967) as proc:
        proc.execute()


def clear_all_descriptor_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all descriptor models in RAM.

    Warnings
    --------
    clear_all_descriptor_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_descriptor_models, the operator will be
    removed in future versions.
    """
    with HalconOperator(942) as proc:
        proc.execute()


def clear_all_events() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    event synchronization objects.

    Warnings
    --------
    clear_all_events is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    clear_all_events, the operator will be removed in future versions.

    Notes
    -----
    clear_all_events exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_events must not
    be used in any application.
    """
    with HalconOperator(553) as proc:
        proc.execute()


def clear_all_lexica() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    lexica.

    Warnings
    --------
    clear_all_lexica is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    clear_all_lexica, the operator will be removed in future versions.

    Notes
    -----
    clear_all_lexica exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_lexica must not
    be used in any application.
    """
    with HalconOperator(665) as proc:
        proc.execute()


def clear_all_matrices() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    matrices from memory.

    Warnings
    --------
    clear_all_matrices is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_matrices, the operator will be removed in future versions.

    Notes
    -----
    clear_all_matrices exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_matrices must
    not be used in any application.
    """
    with HalconOperator(895) as proc:
        proc.execute()


def clear_all_metrology_models() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all metrology models and free the allocated memory.

    Warnings
    --------
    clear_all_metrology_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_metrology_models, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_metrology_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_metrology_models must not be used in any application.
    """
    with HalconOperator(816) as proc:
        proc.execute()


def clear_all_mutexes() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    mutex synchronization objects.

    Warnings
    --------
    clear_all_mutexes is obsolete, inoperable. and is only provided for
    reasons of backward compatibility. New applications should not use
    clear_all_mutexes, the operator will be removed in future versions.

    Notes
    -----
    clear_all_mutexes exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_mutexes must
    not be used in any application.
    """
    with HalconOperator(559) as proc:
        proc.execute()


def clear_all_ncc_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all NCC models.

    Warnings
    --------
    clear_all_ncc_models is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    clear_all_ncc_models, the operator will be removed in future versions.

    Notes
    -----
    clear_all_ncc_models exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_ncc_models must
    not be used in any application.
    """
    with HalconOperator(981) as proc:
        proc.execute()


def clear_all_object_model_3d() -> None:
    """
    This operator is inoperable. It had the following function: Free the
    memory of all 3D object models.

    Warnings
    --------
    clear_all_object_model_3d is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_object_model_3d, the operator will be removed
    in future versions.

    Notes
    -----
    clear_all_object_model_3d exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_object_model_3d must not be used in any application.
    """
    with HalconOperator(1099) as proc:
        proc.execute()


def clear_all_ocr_class_knn() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    OCR classifiers.

    Warnings
    --------
    clear_all_ocr_class_knn is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_ocr_class_knn, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_ocr_class_knn exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_ocr_class_knn must not be used in any application.
    """
    with HalconOperator(652) as proc:
        proc.execute()


def clear_all_ocr_class_mlp() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    OCR classifiers.

    Warnings
    --------
    clear_all_ocr_class_mlp is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_ocr_class_mlp, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_ocr_class_mlp exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_ocr_class_mlp must not be used in any application.
    """
    with HalconOperator(690) as proc:
        proc.execute()


def clear_all_ocr_class_svm() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    SVM based OCR classifiers.

    Warnings
    --------
    clear_all_ocr_class_svm is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_ocr_class_svm, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_ocr_class_svm exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_ocr_class_svm must not be used in any application.
    """
    with HalconOperator(672) as proc:
        proc.execute()


def clear_all_sample_identifiers() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all sample identifiers.

    Warnings
    --------
    clear_all_sample_identifiers is obsolete, inoperable, and is only
    provided for reasons of backward compatibility.  New applications
    should not use clear_all_sample_identifiers,  the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_sample_identifiers exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_sample_identifiers must not be used in any application.
    """
    with HalconOperator(898) as proc:
        proc.execute()


def clear_all_scattered_data_interpolators() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    scattered data interpolators.

    Warnings
    --------
    clear_all_scattered_data_interpolators is obsolete, inoperable, and is
    only provided for reasons of backward compatibility. New applications
    should not use clear_all_scattered_data_interpolators, the operator
    will be removed in future versions.

    Notes
    -----
    clear_all_scattered_data_interpolators exists solely for the purpose
    of implementing the ``reset program'' functionality in HDevelop.
    clear_all_scattered_data_interpolators must not be used  in any
    application.
    """
    with HalconOperator(289) as proc:
        proc.execute()


def clear_all_serialized_items() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all current existing serialized items.

    Warnings
    --------
    clear_all_serialized_items is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_serialized_items, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_serialized_items exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_serialized_items must not be used in any application.
    """
    with HalconOperator(407) as proc:
        proc.execute()


def clear_all_shape_model_3d() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all 3D shape models.

    Warnings
    --------
    clear_all_shape_model_3d is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_shape_model_3d, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_shape_model_3d exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_shape_model_3d must not be used in any application.
    """
    with HalconOperator(1048) as proc:
        proc.execute()


def clear_all_shape_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all shape models.

    Warnings
    --------
    clear_all_shape_models is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_shape_models, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_shape_models exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_shape_models must not be used in any application.
    """
    with HalconOperator(920) as proc:
        proc.execute()


def clear_all_sheet_of_light_models() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all sheet-of-light models and free the allocated memory.

    Warnings
    --------
    clear_all_sheet_of_light_models is obsolete, inoperable, and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_sheet_of_light_models,  the operator will be
    removed in future versions..

    Notes
    -----
    clear_all_sheet_of_light_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_sheet_of_light_models must not be used in any application.
    """
    with HalconOperator(389) as proc:
        proc.execute()


def clear_all_stereo_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all stereo models.

    Warnings
    --------
    clear_all_stereo_models is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_stereo_models, the operator will be removed in future
    versions..

    Notes
    -----
    clear_all_stereo_models exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_stereo_models must not be used in any application.
    """
    with HalconOperator(518) as proc:
        proc.execute()


def clear_all_surface_matching_results() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all surface matching results.

    Warnings
    --------
    clear_all_surface_matching_results is obsolete, inoperable, and is
    only provided for reasons of backward compatibility. New applications
    should not use clear_all_surface_matching_results, the operator will
    be removed in future versions.

    Notes
    -----
    clear_all_surface_matching_results exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_surface_matching_results must not be used in any application.
    """
    with HalconOperator(1033) as proc:
        proc.execute()


def clear_all_surface_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all surface models.

    Warnings
    --------
    clear_all_surface_models is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_surface_models, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_surface_models exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_surface_models must not be used in any application.
    """
    with HalconOperator(1035) as proc:
        proc.execute()


def clear_all_templates() -> None:
    """
    This operator is inoperable. It had the following function:
    Deallocation of the memory of all templates.

    Warnings
    --------
    clear_all_templates is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    clear_all_templates, the operator will be removed in future versions.

    Notes
    -----
    clear_all_templates exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. clear_all_templates must
    not be used in any application.
    """
    with HalconOperator(1494) as proc:
        proc.execute()


def clear_all_text_models() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    text models.

    Warnings
    --------
    clear_all_text_models is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_text_models, the operator will be removed in future
    versions..

    Notes
    -----
    clear_all_text_models exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop. clear_all_text_models
    must not be used in any application.
    """
    with HalconOperator(420) as proc:
        proc.execute()


def clear_all_text_results() -> None:
    """
    This operator is inoperable. It had the following function: Clear all
    text results.

    Warnings
    --------
    clear_all_text_results is obsolete, inoperable, and is only provided
    for reasons of backward compatibility. New applications should not use
    clear_all_text_results, the operator will be removed in future
    versions.

    Notes
    -----
    clear_all_text_results exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    clear_all_text_results must not be used in any application.
    """
    with HalconOperator(413) as proc:
        proc.execute()


def clear_all_training_components() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all component training results.

    Warnings
    --------
    clear_all_training_components is obsolete, inoperable, and is only
    provided for reasons of backward compatibility.  New applications
    should not use clear_all_training_components, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_training_components exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_training_components must not be used in any application.
    """
    with HalconOperator(1006) as proc:
        proc.execute()


def clear_all_variation_models() -> None:
    """
    This operator is inoperable. It had the following function:  Free the
    memory of all variation models.

    Warnings
    --------
    clear_all_variation_models is obsolete, inoperable and is only
    provided for reasons of backward compatibility. New applications
    should not use clear_all_variation_models, the operator will be
    removed in future versions.

    Notes
    -----
    clear_all_variation_models exists solely for the purpose of
    implementing the ``reset program'' functionality in HDevelop.
    clear_all_variation_models must not be used in any application.
    """
    with HalconOperator(92) as proc:
        proc.execute()


def clear_bar_code_model(bar_code_handle: MaybeSequence[HHandle]) -> None:
    """
    Delete a bar code model and free the allocated memory

    Parameters
    ----------

    bar_code_handle : MaybeSequence[HHandle]
                      Handle of the bar code model.

    See Also
    --------
    find_bar_code
    """
    with HalconOperator(2000) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.execute()


def clear_barrier(barrier_handle: HHandle) -> None:
    """
    Destroy a barrier synchronization object.

    Parameters
    ----------

    barrier_handle : HHandle
                     Barrier synchronization object.

    See Also
    --------
    create_barrier

    Predecessors
    ------------
    create_barrier
    """
    with HalconOperator(550) as proc:
        proc.set_input_tuple(0, barrier_handle)
        proc.execute()


def clear_bead_inspection_model(bead_inspection_model: HHandle) -> None:
    """
    Delete the bead inspection model and free the allocated memory.

    Parameters
    ----------

    bead_inspection_model : HHandle
                            Handle of the bead inspection model.

    See Also
    --------
    create_bead_inspection_model

    Predecessors
    ------------
    create_bead_inspection_model
    """
    with HalconOperator(1984) as proc:
        proc.set_input_tuple(0, bead_inspection_model)
        proc.execute()


def clear_calib_data(calib_data_id: HHandle) -> None:
    """
    Free the memory of a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.
    """
    with HalconOperator(1960) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.execute()


def clear_camera_setup_model(camera_setup_model_id: HHandle) -> None:
    """
    Free the memory of a calibration setup model.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle of the camera setup model.
    """
    with HalconOperator(1950) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.execute()


def clear_class_gmm(gmmhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : MaybeSequence[HHandle]
                GMM handle.

    See Also
    --------
    create_class_gmm, read_class_gmm, write_class_gmm, train_class_gmm

    Predecessors
    ------------
    classify_class_gmm, evaluate_class_gmm
    """
    with HalconOperator(1824) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.execute()


def clear_class_knn(knnhandle: HHandle) -> None:
    """
    Clear a k-NN classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    See Also
    --------
    create_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn
    """
    with HalconOperator(1804) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.execute()


def clear_class_lut(class_luthandle: MaybeSequence[HHandle]) -> None:
    """
    Clear a look-up table classifier.

    Parameters
    ----------

    class_luthandle : MaybeSequence[HHandle]
                      Handle of the LUT classifier.

    See Also
    --------
    create_class_lut_mlp, create_class_lut_svm, create_class_lut_gmm

    Predecessors
    ------------
    classify_image_class_lut
    """
    with HalconOperator(1818) as proc:
        proc.set_input_tuple(0, class_luthandle)
        proc.execute()


def clear_class_mlp(mlphandle: MaybeSequence[HHandle]) -> None:
    """
    Clear a multilayer perceptron.

    Parameters
    ----------

    mlphandle : MaybeSequence[HHandle]
                MLP handle.

    See Also
    --------
    create_class_mlp, read_class_mlp, write_class_mlp, train_class_mlp

    Predecessors
    ------------
    classify_class_mlp, evaluate_class_mlp
    """
    with HalconOperator(1863) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.execute()


def clear_class_svm(svmhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear a support vector machine.

    Parameters
    ----------

    svmhandle : MaybeSequence[HHandle]
                SVM handle.

    See Also
    --------
    create_class_svm, read_class_svm, write_class_svm, train_class_svm

    Predecessors
    ------------
    classify_class_svm
    """
    with HalconOperator(1842) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.execute()


def clear_class_train_data(class_train_data_handle: HHandle) -> None:
    """
    Clears training data for classifiers.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of training data for a classifier.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    create_class_train_data
    """
    with HalconOperator(1796) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.execute()


def clear_color_trans_lut(color_trans_luthandle: HHandle) -> None:
    """
    Release the look-up-table needed for color space transformation.

    Parameters
    ----------

    color_trans_luthandle : HHandle
                            Handle of the look-up-table handle for the
                            color space transformation.

    See Also
    --------
    create_color_trans_lut, apply_color_trans_lut

    Predecessors
    ------------
    create_color_trans_lut, apply_color_trans_lut
    """
    with HalconOperator(1577) as proc:
        proc.set_input_tuple(0, color_trans_luthandle)
        proc.execute()


def clear_component_model(component_model_id: HHandle) -> None:
    """
    Free the memory of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    Predecessors
    ------------
    create_component_model, create_trained_component_model,
    read_component_model, write_component_model
    """
    with HalconOperator(997) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.execute()


def clear_condition(condition_handle: HHandle) -> None:
    """
    Destroy a condition synchronization object.

    Parameters
    ----------

    condition_handle : HHandle
                       Condition synchronization object.

    See Also
    --------
    create_condition

    Predecessors
    ------------
    create_condition
    """
    with HalconOperator(543) as proc:
        proc.set_input_tuple(0, condition_handle)
        proc.execute()


def clear_data_code_2d_model(data_code_handle: HHandle) -> None:
    """
    Delete a 2D data code model and free the allocated memory.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    See Also
    --------
    create_data_code_2d_model, read_data_code_2d_model
    """
    with HalconOperator(1777) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.execute()


def clear_deformable_model(model_id: MaybeSequence[HHandle]) -> None:
    """
    Free the memory of a deformable model.

    Parameters
    ----------

    model_id : MaybeSequence[HHandle]
               Handle of the model.

    See Also
    --------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model
    """
    with HalconOperator(968) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()


def clear_deformable_surface_matching_result(
    deformable_surface_matching_result: MaybeSequence[HHandle]
) -> None:
    """
    Free the memory of a deformable surface matching result.

    Parameters
    ----------

    deformable_surface_matching_result : MaybeSequence[HHandle]
                                         Handle of the deformable surface
                                         matching result.

    See Also
    --------
    find_deformable_surface_model, refine_deformable_surface_model

    Predecessors
    ------------
    find_deformable_surface_model, refine_deformable_surface_model
    """
    with HalconOperator(1020) as proc:
        proc.set_input_tuple(0, deformable_surface_matching_result)
        proc.execute()


def clear_deformable_surface_model(
    deformable_surface_model: MaybeSequence[HHandle]
) -> None:
    """
    Free the memory of a deformable surface model.

    Parameters
    ----------

    deformable_surface_model : MaybeSequence[HHandle]
                               Handle of the deformable surface model.

    See Also
    --------
    read_deformable_surface_model, create_deformable_surface_model

    Predecessors
    ------------
    read_deformable_surface_model, create_deformable_surface_model
    """
    with HalconOperator(1021) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.execute()


def clear_descriptor_model(model_id: MaybeSequence[HHandle]) -> None:
    """
    Free the memory of a descriptor model.

    Parameters
    ----------

    model_id : MaybeSequence[HHandle]
               Handle of the descriptor model.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model
    """
    with HalconOperator(943) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()


def clear_distance_transform_xld(distance_transform_id: HHandle) -> None:
    """
    Clear a XLD distance transform.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    See Also
    --------
    apply_distance_transform_xld, get_distance_transform_xld_contour,
    get_distance_transform_xld_param, set_distance_transform_xld_param,
    read_distance_transform_xld, deserialize_distance_transform_xld

    Predecessors
    ------------
    create_distance_transform_xld, write_distance_transform_xld,
    serialize_distance_transform_xld
    """
    with HalconOperator(1351) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.execute()


def clear_dl_classifier(
    dlclassifier_handle: MaybeSequence[HHandle]
) -> None:
    """
    Clear a deep-learning-based classifier.

    Parameters
    ----------

    dlclassifier_handle : MaybeSequence[HHandle]
                          Handle of the deep-learning-based classifier.

    Predecessors
    ------------
    read_dl_classifier, apply_dl_classifier, train_dl_classifier_batch

    Warnings
    --------
    clear_dl_classifier is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the common used
    CNN-based operator clear_dl_model instead.
    """
    with HalconOperator(2103) as proc:
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.execute()


def clear_dl_classifier_result(
    dlclassifier_result_handle: MaybeSequence[HHandle]
) -> None:
    """
    Clear a handle containing the results of the deep-learning-based
    classification.

    Parameters
    ----------

    dlclassifier_result_handle : MaybeSequence[HHandle]
                                 Handle of the deep learning
                                 classification  results.

    Predecessors
    ------------
    get_dl_classifier_result, apply_dl_classifier

    Warnings
    --------
    clear_dl_classifier_result is obsolete and is only provided for
    reasons of backward compatibility.
    """
    with HalconOperator(2104) as proc:
        proc.set_input_tuple(0, dlclassifier_result_handle)
        proc.execute()


def clear_dl_classifier_train_result(
    dlclassifier_train_result_handle: MaybeSequence[HHandle]
) -> None:
    """
    Clear the handle of a deep-learning-based classifier training result.

    Parameters
    ----------

    dlclassifier_train_result_handle : MaybeSequence[HHandle]
                                       Handle of the training results from
                                       the  deep-learning-based classifier.

    Predecessors
    ------------
    train_dl_classifier_batch, get_dl_classifier_train_result

    Warnings
    --------
    clear_dl_classifier_train_result is obsolete and is only provided for
    reasons of backward compatibility.
    """
    with HalconOperator(2105) as proc:
        proc.set_input_tuple(0, dlclassifier_train_result_handle)
        proc.execute()


def clear_dl_model(dlmodel_handle: MaybeSequence[HHandle]) -> None:
    """
    Clear a deep learning model.

    Parameters
    ----------

    dlmodel_handle : MaybeSequence[HHandle]
                     Handle of the deep learning model.

    Predecessors
    ------------
    read_dl_model, apply_dl_model, train_dl_model_batch,
    train_dl_model_anomaly_dataset
    """
    with HalconOperator(2147) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.execute()


def clear_drawing_object(draw_id: HHandle) -> None:
    """
    Delete drawing object.

    Parameters
    ----------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle_sector,
    create_drawing_object_ellipse_sector, create_drawing_object_xld,
    create_drawing_object_line, create_drawing_object_circle,
    create_drawing_object_text

    Predecessors
    ------------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle_sector,
    create_drawing_object_ellipse_sector, create_drawing_object_xld,
    create_drawing_object_line, create_drawing_object_circle,
    create_drawing_object_text, detach_drawing_object_from_window,
    attach_drawing_object_to_window

    Successors
    ----------
    clear_window, close_window
    """
    with HalconOperator(1303) as proc:
        proc.set_input_tuple(0, draw_id)
        proc.execute()


def clear_event(event_handle: HHandle) -> None:
    """
    Clear the event synchronization object.

    Parameters
    ----------

    event_handle : HHandle
                   Event synchronization object.

    See Also
    --------
    create_event

    Predecessors
    ------------
    create_event
    """
    with HalconOperator(554) as proc:
        proc.set_input_tuple(0, event_handle)
        proc.execute()


def clear_handle(handle: MaybeSequence[HHandle]) -> None:
    """
    Clear the content of a handle.

    Parameters
    ----------

    handle : MaybeSequence[HHandle]
             Handle to clear.

    See Also
    --------
    tuple_is_valid_handle
    """
    with HalconOperator(2134) as proc:
        proc.set_input_tuple(0, handle)
        proc.execute()


def clear_lexicon(lexicon_handle: HHandle) -> None:
    """
    Clear a lexicon.

    Parameters
    ----------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    See Also
    --------
    create_lexicon
    """
    with HalconOperator(666) as proc:
        proc.set_input_tuple(0, lexicon_handle)
        proc.execute()


def clear_matrix(matrix_id: MaybeSequence[HHandle]) -> None:
    """
    Free the memory of a matrix.

    Parameters
    ----------

    matrix_id : MaybeSequence[HHandle]
                Matrix handle.

    Predecessors
    ------------
    create_matrix
    """
    with HalconOperator(896) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.execute()


def clear_message(message_handle: MaybeSequence[HHandle]) -> None:
    """
    Close a message handle and release all associated resources.

    Parameters
    ----------

    message_handle : MaybeSequence[HHandle]
                     Message handle(s) to be closed.
                     Assertion: MessageHandle != 0

    See Also
    --------
    create_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Predecessors
    ------------
    create_message, dequeue_message

    Notes
    -----
    The handle(s) must not be used again after being invalidated using
    clear_message. Using an invalid handle results in  undefined behavior.
    """
    with HalconOperator(540) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.execute()


def clear_message_queue(queue_handle: MaybeSequence[HHandle]) -> None:
    """
    Close a message queue handle and release all associated resources.

    Parameters
    ----------

    queue_handle : MaybeSequence[HHandle]
                   Message queue handle(s) to be closed.
                   Assertion: QueueHandle != 0

    See Also
    --------
    create_message_queue, enqueue_message, dequeue_message,
    set_message_queue_param, get_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Predecessors
    ------------
    create_message_queue, set_message_queue_param

    Notes
    -----
    The handle(s) must not be used again after being invalidated using
    clear_message_queue. Using an invalid handle results in  undefined
    behavior. Operator clear_message_queue must not be called while the
    handle is used concurrently from other threads, because this would
    result in undefined behavior.
    """
    with HalconOperator(532) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.execute()


def clear_metrology_model(metrology_handle: HHandle) -> None:
    """
    Delete a metrology model and free the allocated memory.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    Predecessors
    ------------
    get_metrology_object_result, write_metrology_model
    """
    with HalconOperator(817) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.execute()


def clear_metrology_object(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]]
) -> None:
    """
    Delete metrology objects and free the allocated memory.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all
    """
    with HalconOperator(818) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.execute()


def clear_mutex(mutex_handle: HHandle) -> None:
    """
    Clear the mutex synchronization object.

    Parameters
    ----------

    mutex_handle : HHandle
                   Mutex synchronization object.

    See Also
    --------
    create_mutex

    Predecessors
    ------------
    create_mutex
    """
    with HalconOperator(560) as proc:
        proc.set_input_tuple(0, mutex_handle)
        proc.execute()


def clear_ncc_model(model_id: HHandle) -> None:
    """
    Free the memory of an NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Predecessors
    ------------
    create_ncc_model, read_ncc_model, write_ncc_model, find_ncc_model,
    find_ncc_models
    """
    with HalconOperator(982) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()


def clear_obj(objects: HObject) -> None:
    """
    Delete an iconic object from the HALCON database.

    Parameters
    ----------

    objects : HObject
              Objects to be deleted.

    See Also
    --------
    set_check

    Alternatives
    ------------
    reset_obj_db

    Notes
    -----
    Regarding the use of local variables in HALCON/C: When exiting a
    subroutine, the local variables are deleted, but the HALCON database
    is not updated. To update the database and thus free the memory, you
    must explicitly clear the local objects from the database before
    exiting the subroutine.
    """
    with HalconOperator(585) as proc:
        proc.set_input_object(1, objects)
        proc.execute()


def clear_object_model_3d(object_model_3d: MaybeSequence[HHandle]) -> None:
    """
    Free the memory of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d
    """
    with HalconOperator(1100) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.execute()


def clear_ocr_class_cnn(ocrhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear an CNN-based OCR classifier.

    Parameters
    ----------

    ocrhandle : MaybeSequence[HHandle]
                Handle of the OCR classifier.

    See Also
    --------
    read_ocr_class_cnn

    Predecessors
    ------------
    do_ocr_single_class_cnn, do_ocr_multi_class_cnn, do_ocr_word_cnn
    """
    with HalconOperator(2046) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.execute()


def clear_ocr_class_knn(ocrhandle: HHandle) -> None:
    """
    Clear an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(653) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.execute()


def clear_ocr_class_mlp(ocrhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear an OCR classifier.

    Parameters
    ----------

    ocrhandle : MaybeSequence[HHandle]
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_mlp, read_ocr_class_mlp, write_ocr_class_mlp,
    trainf_ocr_class_mlp

    Predecessors
    ------------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(691) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.execute()


def clear_ocr_class_svm(ocrhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear an SVM-based OCR classifier.

    Parameters
    ----------

    ocrhandle : MaybeSequence[HHandle]
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_svm, read_ocr_class_svm, write_ocr_class_svm,
    trainf_ocr_class_svm

    Predecessors
    ------------
    do_ocr_single_class_svm, do_ocr_multi_class_svm
    """
    with HalconOperator(673) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.execute()


def clear_rectangle(
    window_handle: HHandle,
    row_1: MaybeSequence[int],
    column_1: MaybeSequence[int],
    row_2: MaybeSequence[int],
    column_2: MaybeSequence[int]
) -> None:
    """
    Delete a rectangle on the output window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1 : MaybeSequence[int]
            Line index of upper left corner.
            Value Suggestion: 10

    column_1 : MaybeSequence[int]
               Column index of upper left corner.
               Value Suggestion: 10

    row_2 : MaybeSequence[int]
            Row index of lower right corner.
            Value Suggestion: 118
            Assertion: Row2 > Row1

    column_2 : MaybeSequence[int]
               Column index of lower right corner.
               Value Suggestion: 118
               Assertion: Column2 >= Column1

    See Also
    --------
    open_window

    Alternatives
    ------------
    clear_window, disp_rectangle1

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    set_rgb, set_hsi, draw_rectangle1

    Warnings
    --------
    clear_rectangle is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1189) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1)
        proc.set_input_tuple(2, column_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.execute()


def clear_sample_identifier(sample_identifier: HHandle) -> None:
    """
    Free the memory of a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, add_sample_identifier_training_data,
    train_sample_identifier, apply_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, read_sample_identifier,
    deserialize_sample_identifier, set_sample_identifier_object_info

    Predecessors
    ------------
    write_sample_identifier, serialize_sample_identifier
    """
    with HalconOperator(899) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.execute()


def clear_samples_class_gmm(gmmhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear the training data of a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : MaybeSequence[HHandle]
                GMM handle.

    See Also
    --------
    create_class_gmm, clear_class_gmm, add_sample_class_gmm,
    read_samples_class_gmm

    Predecessors
    ------------
    train_class_gmm, write_samples_class_gmm
    """
    with HalconOperator(1825) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.execute()


def clear_samples_class_mlp(mlphandle: MaybeSequence[HHandle]) -> None:
    """
    Clear the training data of a multilayer perceptron.

    Parameters
    ----------

    mlphandle : MaybeSequence[HHandle]
                MLP handle.

    See Also
    --------
    create_class_mlp, clear_class_mlp, add_sample_class_mlp,
    read_samples_class_mlp

    Predecessors
    ------------
    train_class_mlp, write_samples_class_mlp
    """
    with HalconOperator(1864) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.execute()


def clear_samples_class_svm(svmhandle: MaybeSequence[HHandle]) -> None:
    """
    Clear the training data of a support vector machine.

    Parameters
    ----------

    svmhandle : MaybeSequence[HHandle]
                SVM handle.

    See Also
    --------
    create_class_svm, clear_class_svm, add_sample_class_svm,
    read_samples_class_svm

    Predecessors
    ------------
    train_class_svm, write_samples_class_svm
    """
    with HalconOperator(1843) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.execute()


def clear_sampset(samp_key: HHandle) -> None:
    """
    Free memory of a data set.

    Parameters
    ----------

    samp_key : HHandle
               Number of the data set.

    See Also
    --------
    test_sampset_box, learn_sampset_box, read_sampset

    Predecessors
    ------------
    create_class_box, enquire_class_box, learn_class_box, write_class_box

    Warnings
    --------
    clear_sampset is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  MLP, SVM, KNN or GMM
    operators instead.
    """
    with HalconOperator(1893) as proc:
        proc.set_input_tuple(0, samp_key)
        proc.execute()


def clear_scattered_data_interpolator(
    scattered_data_interpolator_handle: MaybeSequence[HHandle]
) -> None:
    """
    Clear a scattered data interpolator.

    Parameters
    ----------

    scattered_data_interpolator_handle : MaybeSequence[HHandle]
                                         Handle of the scattered data
                                         interpolator

    Predecessors
    ------------
    create_scattered_data_interpolator, interpolate_scattered_data
    """
    with HalconOperator(290) as proc:
        proc.set_input_tuple(0, scattered_data_interpolator_handle)
        proc.execute()


def clear_scene_3d(scene_3d: MaybeSequence[HHandle]) -> None:
    """
    Delete a 3D scene and free all allocated memory.

    Parameters
    ----------

    scene_3d : MaybeSequence[HHandle]
               Handle of the 3D scene.

    Predecessors
    ------------
    display_scene_3d
    """
    with HalconOperator(1219) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.execute()


def clear_serial(serial_handle: HHandle, channel: str) -> None:
    """
    Clear the buffer of a serial connection.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    channel : str
              Buffer to be cleared.
              Value Suggestion: input

    See Also
    --------
    read_serial

    Predecessors
    ------------
    open_serial

    Successors
    ----------
    read_serial, write_serial
    """
    with HalconOperator(307) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.set_input_tuple(1, channel)
        proc.execute()


def clear_serialized_item(
    serialized_item_handle: MaybeSequence[HHandle]
) -> None:
    """
    Delete a serialized item.

    Parameters
    ----------

    serialized_item_handle : MaybeSequence[HHandle]
                             Handle of the serialized item.

    Predecessors
    ------------
    fwrite_serialized_item, receive_serialized_item
    """
    with HalconOperator(408) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.execute()


def clear_shape_model(model_id: HHandle) -> None:
    """
    Free the memory of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, read_shape_model, write_shape_model
    """
    with HalconOperator(921) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()


def clear_shape_model_3d(shape_model_3did: MaybeSequence[HHandle]) -> None:
    """
    Free the memory of a 3D shape model.

    Parameters
    ----------

    shape_model_3did : MaybeSequence[HHandle]
                       Handle of the 3D shape model.

    Predecessors
    ------------
    create_shape_model_3d, read_shape_model_3d, write_shape_model_3d
    """
    with HalconOperator(1049) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.execute()


def clear_sheet_of_light_model(sheet_of_light_model_id: HHandle) -> None:
    """
    Delete a sheet-of-light model and free the allocated memory.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    See Also
    --------
    create_sheet_of_light_model
    """
    with HalconOperator(390) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.execute()


def clear_stereo_model(stereo_model_id: HHandle) -> None:
    """
    Free the memory of a stereo model.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.
    """
    with HalconOperator(519) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.execute()


def clear_structured_light_model(
    structured_light_model: MaybeSequence[HHandle]
) -> None:
    """
    Clear a structured light model and free the allocated memory.

    Parameters
    ----------

    structured_light_model : MaybeSequence[HHandle]
                             Handle of the structured light model.

    See Also
    --------
    create_structured_light_model
    """
    with HalconOperator(2106) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.execute()


def clear_surface_matching_result(
    surface_matching_result_id: MaybeSequence[HHandle]
) -> None:
    """
    Free the memory of a surface matching result.

    Parameters
    ----------

    surface_matching_result_id : MaybeSequence[HHandle]
                                 Handle of the surface matching result.

    See Also
    --------
    find_surface_model, refine_surface_model_pose

    Predecessors
    ------------
    find_surface_model, refine_surface_model_pose
    """
    with HalconOperator(1034) as proc:
        proc.set_input_tuple(0, surface_matching_result_id)
        proc.execute()


def clear_surface_model(surface_model_id: MaybeSequence[HHandle]) -> None:
    """
    Free the memory of a surface model.

    Parameters
    ----------

    surface_model_id : MaybeSequence[HHandle]
                       Handle of the surface model.

    See Also
    --------
    read_surface_model, create_surface_model

    Predecessors
    ------------
    read_surface_model, create_surface_model
    """
    with HalconOperator(1036) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.execute()


def clear_template(template_id: HHandle) -> None:
    """
    Deallocation of the memory of a template.

    Parameters
    ----------

    template_id : HHandle
                  Template number.

    Predecessors
    ------------
    create_template, create_template_rot, read_template, write_template

    Warnings
    --------
    clear_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1495) as proc:
        proc.set_input_tuple(0, template_id)
        proc.execute()


def clear_text_model(text_model: MaybeSequence[HHandle]) -> None:
    """
    Clear a text model.

    Parameters
    ----------

    text_model : MaybeSequence[HHandle]
                 Text model to be cleared.

    See Also
    --------
    create_text_model_reader
    """
    with HalconOperator(421) as proc:
        proc.set_input_tuple(0, text_model)
        proc.execute()


def clear_text_result(text_result_id: MaybeSequence[HHandle]) -> None:
    """
    Clear a text result.

    Parameters
    ----------

    text_result_id : MaybeSequence[HHandle]
                     Text result to be cleared.
    """
    with HalconOperator(414) as proc:
        proc.set_input_tuple(0, text_result_id)
        proc.execute()


def clear_texture_inspection_model(
    texture_inspection_model: MaybeSequence[HHandle]
) -> None:
    """
    Clear a texture inspection model and free the allocated memory.

    Parameters
    ----------

    texture_inspection_model : MaybeSequence[HHandle]
                               Handle of the texture inspection model.

    See Also
    --------
    create_texture_inspection_model
    """
    with HalconOperator(2047) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.execute()


def clear_texture_inspection_result(
    texture_inspection_result_id: MaybeSequence[HHandle]
) -> None:
    """
    Clear a texture inspection result handle and free the allocated
    memory.

    Parameters
    ----------

    texture_inspection_result_id : MaybeSequence[HHandle]
                                   Handle of the texture inspection
                                   results.

    Predecessors
    ------------
    apply_texture_inspection_model
    """
    with HalconOperator(2048) as proc:
        proc.set_input_tuple(0, texture_inspection_result_id)
        proc.execute()


def clear_train_data_variation_model(model_id: HHandle) -> None:
    """
    Free the memory of the training data of a variation model.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    Predecessors
    ------------
    prepare_variation_model

    Successors
    ----------
    compare_variation_model, compare_ext_variation_model,
    write_variation_model
    """
    with HalconOperator(94) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()


def clear_training_components(component_training_id: HHandle) -> None:
    """
    Free the memory of a component training result.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    Predecessors
    ------------
    train_model_components, write_training_components
    """
    with HalconOperator(1007) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.execute()


def clear_variation_model(model_id: HHandle) -> None:
    """
    Free the memory of a variation model.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    Predecessors
    ------------
    create_variation_model
    """
    with HalconOperator(93) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()


def clear_window(window_handle: HHandle) -> None:
    """
    Delete the contents of an output window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    open_window

    Alternatives
    ------------
    clear_rectangle, disp_rectangle1

    Predecessors
    ------------
    open_window
    """
    with HalconOperator(1188) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def clip_contours_xld(
    contours: HObject,
    row_1: int,
    column_1: int,
    row_2: int,
    column_2: int
) -> HObject:
    """
    Clip an XLD contour.

    Parameters
    ----------

    contours : HObject
               Contours to be clipped.

    row_1 : int
            Row coordinate of the upper left corner of the clip rectangle.
            Value Suggestion: 0

    column_1 : int
               Column coordinate of the upper left corner of the clip
               rectangle.
               Value Suggestion: 0

    row_2 : int
            Row coordinate of the lower right corner of the clip rectangle.
            Value Suggestion: 512

    column_2 : int
               Column coordinate of the lower right corner of the clip
               rectangle.
               Value Suggestion: 512

    Returns
    -------

    clipped_contours : HObject
                       Clipped contours.

    See Also
    --------
    clip_region, crop_part, crop_contours_xld

    Alternatives
    ------------
    crop_contours_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    gen_polygons_xld
    """
    with HalconOperator(52) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.execute()
        clipped_contours = HObject(proc.get_output_object_key(1))
        return clipped_contours  # type: ignore


def clip_end_points_contours_xld(
    contours: HObject,
    mode: str,
    length: Union[int, float]
) -> HObject:
    """
    Clip the end points of an XLD contour.

    Parameters
    ----------

    contours : HObject
               Input contour

    mode : str
           Clipping mode.
           Value Suggestion: num_points

    length : Union[int, float]
             Clipping length in unit pixels (Mode $=$ 'length') or number
             (Mode $=$ 'num_points')
             Value Suggestion: 3

    Returns
    -------

    clipped_contours : HObject
                       Clipped contour

    See Also
    --------
    clip_contours_xld, crop_contours_xld

    Predecessors
    ------------
    segment_contours_xld
    """
    with HalconOperator(51) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, length)
        proc.execute()
        clipped_contours = HObject(proc.get_output_object_key(1))
        return clipped_contours  # type: ignore


def clip_region(
    region: HObject,
    row_1: int,
    column_1: int,
    row_2: int,
    column_2: int
) -> HObject:
    """
    Clip a region to a rectangle.

    Parameters
    ----------

    region : HObject
             Region to be clipped.

    row_1 : int
            Row coordinate of the upper left corner of the rectangle.
            Value Suggestion: 0

    column_1 : int
               Column coordinate of the upper left corner of the rectangle.
               Value Suggestion: 0

    row_2 : int
            Row coordinate of the lower right corner of the rectangle.
            Value Suggestion: 256

    column_2 : int
               Column coordinate of the lower right corner of the
               rectangle.
               Value Suggestion: 256

    Returns
    -------

    region_clipped : HObject
                     Clipped regions.

    Alternatives
    ------------
    intersection, gen_rectangle1, clip_region_rel

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(499) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.execute()
        region_clipped = HObject(proc.get_output_object_key(1))
        return region_clipped  # type: ignore


def clip_region_rel(
    region: HObject,
    top: int,
    bottom: int,
    left: int,
    right: int
) -> HObject:
    """
    Clip a region relative to its smallest surrounding rectangle.

    Parameters
    ----------

    region : HObject
             Regions to be clipped.

    top : int
          Number of rows clipped at the top.
          Value Suggestion: 1

    bottom : int
             Number of rows clipped at the bottom.
             Value Suggestion: 1

    left : int
           Number of columns clipped at the left.
           Value Suggestion: 1

    right : int
            Number of columns clipped at the right.
            Value Suggestion: 1

    Returns
    -------

    region_clipped : HObject
                     Clipped regions.

    Alternatives
    ------------
    smallest_rectangle1, intersection, gen_rectangle1, clip_region

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(498) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, top)
        proc.set_input_tuple(1, bottom)
        proc.set_input_tuple(2, left)
        proc.set_input_tuple(3, right)
        proc.execute()
        region_clipped = HObject(proc.get_output_object_key(1))
        return region_clipped  # type: ignore


def close_all_bg_esti() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all background estimation data sets.

    Warnings
    --------
    close_all_bg_esti is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    close_all_bg_esti, the operator will be removed in future versions.

    Notes
    -----
    close_all_bg_esti exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_bg_esti must
    not be used in any application.
    """
    with HalconOperator(2009) as proc:
        proc.execute()


def close_all_class_box() -> None:
    """
    This operator is inoperable. It had the following function:  Destroy
    all classifiers.

    Warnings
    --------
    close_all_class_box is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    close_all_class_box, the operator will be removed in future version.

    Notes
    -----
    close_all_class_box exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_class_box must
    not be used in any application.
    """
    with HalconOperator(1900) as proc:
        proc.execute()


def close_all_files() -> None:
    """
    This operator is inoperable. It had the following function: Close all
    open files.

    Warnings
    --------
    close_all_files is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    close_all_files, the operator will be removed in future version.

    Notes
    -----
    close_all_files exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_files must not
    be used in any application.
    """
    with HalconOperator(1666) as proc:
        proc.execute()


def close_all_framegrabbers() -> None:
    """
    This operator is inoperable. It had the following function:  Close all
    image acquisition devices.

    Warnings
    --------
    close_all_framegrabbers is obsolete, inoperable, and is only provided
    for reasons of backward compatibility.  New applications should not
    use close_all_framegrabbers, the operator will be removed in future
    versions.

    Notes
    -----
    close_all_framegrabbers exists solely for the purpose of implementing
    the ``reset program'' functionality in HDevelop.
    close_all_framegrabbers must not be used in any application.
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    Thus, info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers block the concurrent execution of all other
    operators within this group, but run in parallel with all
    non-exclusive operators outside of this group.
    """
    with HalconOperator(2035) as proc:
        proc.execute()


def close_all_measures() -> None:
    """
    This operator is inoperable. It had the following function:  Delete
    all measure objects.

    Warnings
    --------
    close_all_measures is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    close_all_measures, the operator will be removed in future versions.

    Notes
    -----
    close_all_measures exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_measures must
    not be used in any application.
    """
    with HalconOperator(826) as proc:
        proc.execute()


def close_all_ocrs() -> None:
    """
    This operator is inoperable. It had the following function: Destroy
    all OCR classifiers.

    Warnings
    --------
    close_all_ocrs is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    close_all_ocrs, the operator will be removed in future versions.

    Notes
    -----
    close_all_ocrs exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_ocrs must not
    be used in any application.
    """
    with HalconOperator(724) as proc:
        proc.execute()


def close_all_ocvs() -> None:
    """
    This operator is inoperable. It had the following function:  Clear all
    OCV tools.

    Warnings
    --------
    close_all_ocvs is obsolete, inoperable, and is only provided for
    reasons of backward compatibility.  New applications should not use
    close_all_ocvs, the operator will be removed in future versions.

    Notes
    -----
    close_all_ocvs exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_ocvs must not
    be used in any application.
    """
    with HalconOperator(644) as proc:
        proc.execute()


def close_all_serials() -> None:
    """
    This operator is inoperable. It had the following function: Close all
    serial devices.

    Warnings
    --------
    close_all_serials is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    close_all_serials, the operator will be removed in future versions.

    Notes
    -----
    close_all_serials exists solely for the purpose of implementing the
    ``reset program'' functionality in HDevelop. close_all_serials must
    not be used in any application.
    """
    with HalconOperator(312) as proc:
        proc.execute()


def close_all_sockets() -> None:
    """
    This operator is inoperable. It had the following function: Close all
    opened sockets.

    Warnings
    --------
    close_all_sockets is obsolete, inoperable, and is only provided for
    reasons of backward compatibility. New applications should not use
    close_all_sockets, the operator will be removed in future versions.
    """
    with HalconOperator(339) as proc:
        proc.execute()


def close_bg_esti(bg_esti_handle: HHandle) -> None:
    """
    Delete the background estimation data set.

    Parameters
    ----------

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    See Also
    --------
    create_bg_esti

    Predecessors
    ------------
    run_bg_esti
    """
    with HalconOperator(2002) as proc:
        proc.set_input_tuple(0, bg_esti_handle)
        proc.execute()


def close_class_box(classif_handle: HHandle) -> None:
    """
    Destroy the classifier.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    See Also
    --------
    create_class_box, enquire_class_box, learn_class_box

    Predecessors
    ------------
    create_class_box, enquire_class_box, learn_class_box, write_class_box

    Warnings
    --------
    close_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1894) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.execute()


def close_contours_xld(contours: HObject) -> HObject:
    """
    Close an XLD contour.

    Parameters
    ----------

    contours : HObject
               Contours to be closed.

    Returns
    -------

    closed_contours : HObject
                      Closed contours.

    Predecessors
    ------------
    select_contours_xld

    Successors
    ----------
    area_center_xld, circularity_xld, compactness_xld, convexity_xld,
    eccentricity_xld, elliptic_axis_xld, moments_xld, moments_any_xld,
    orientation_xld, select_shape_xld, test_xld_point
    """
    with HalconOperator(50) as proc:
        proc.set_input_object(1, contours)
        proc.execute()
        closed_contours = HObject(proc.get_output_object_key(1))
        return closed_contours  # type: ignore


def close_edges(
    edges: HObject,
    edge_image: HObject,
    min_amplitude: int
) -> HObject:
    """
    Close edge gaps using the edge amplitude image.

    Parameters
    ----------

    edges : HObject
            Region containing one pixel thick edges.

    edge_image : HObject
                 Edge amplitude (gradient) image.

    min_amplitude : int
                    Minimum edge amplitude.
                    Value Suggestion: 16
                    Assertion: MinAmplitude >= 0

    Returns
    -------

    region_result : HObject
                    Region containing closed edges.

    See Also
    --------
    gray_skeleton

    Alternatives
    ------------
    close_edges_length, dilation1, closing

    Predecessors
    ------------
    edges_image, sobel_amp, threshold, skeleton

    Successors
    ----------
    skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1574) as proc:
        proc.set_input_object(1, edges)
        proc.set_input_object(2, edge_image)
        proc.set_input_tuple(0, min_amplitude)
        proc.execute()
        region_result = HObject(proc.get_output_object_key(1))
        return region_result  # type: ignore


def close_edges_length(
    edges: HObject,
    gradient: HObject,
    min_amplitude: int,
    max_gap_length: int
) -> HObject:
    """
    Close edge gaps using the edge amplitude image.

    Parameters
    ----------

    edges : HObject
            Region containing one pixel thick edges.

    gradient : HObject
               Edge amplitude (gradient) image.

    min_amplitude : int
                    Minimum edge amplitude.
                    Value Suggestion: 16
                    Assertion: MinAmplitude >= 0

    max_gap_length : int
                     Maximal number of points by which edges are extended.
                     Value Suggestion: 3
                     Assertion: MaxGapLength > 0 && MaxGapLength <= 127

    Returns
    -------

    closed_edges : HObject
                   Region containing closed edges.

    Alternatives
    ------------
    close_edges, dilation1, closing

    Predecessors
    ------------
    edges_image, sobel_amp, threshold, skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1573) as proc:
        proc.set_input_object(1, edges)
        proc.set_input_object(2, gradient)
        proc.set_input_tuple(0, min_amplitude)
        proc.set_input_tuple(1, max_gap_length)
        proc.execute()
        closed_edges = HObject(proc.get_output_object_key(1))
        return closed_edges  # type: ignore


def close_file(file_handle: MaybeSequence[HHandle]) -> None:
    """
    Closing a text file.

    Parameters
    ----------

    file_handle : MaybeSequence[HHandle]
                  File handle.

    See Also
    --------
    open_file

    Predecessors
    ------------
    open_file
    """
    with HalconOperator(1665) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.execute()


def close_framegrabber(acq_handle: HHandle) -> None:
    """
    Close specified image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the image acquisition device to be closed.

    See Also
    --------
    open_framegrabber

    Predecessors
    ------------
    grab_image, grab_image_async

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    Thus, info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers block the concurrent execution of all other
    operators within this group, but run in parallel with all
    non-exclusive operators outside of this group.
    """
    with HalconOperator(2036) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.execute()


def close_io_channel(iochannel_handle: MaybeSequence[HHandle]) -> None:
    """
    Close I/O channels.

    Parameters
    ----------

    iochannel_handle : MaybeSequence[HHandle]
                       Handles of the opened I/O channels.

    Predecessors
    ------------
    open_io_channel

    Successors
    ----------
    close_io_device
    """
    with HalconOperator(2015) as proc:
        proc.set_input_tuple(0, iochannel_handle)
        proc.execute()


def close_io_device(iodevice_handle: HHandle) -> None:
    """
    Close the specified I/O device.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    Predecessors
    ------------
    open_io_device
    """
    with HalconOperator(2021) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.execute()


def close_measure(measure_handle: HHandle) -> None:
    """
    Delete a measure object.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc, measure_pos, measure_pairs
    """
    with HalconOperator(827) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.execute()


def close_ocr(ocr_handle: HHandle) -> None:
    """
    Deallocation of the memory of an OCR classifier.

    Parameters
    ----------

    ocr_handle : HHandle
                 ID of the OCR classifier to be deleted.

    Predecessors
    ------------
    write_ocr_trainf

    Successors
    ----------
    read_ocr

    Warnings
    --------
    close_ocr is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.

    Notes
    -----
    All data of the classifier will be deleted in main memory (not on the
    hard disk).
    """
    with HalconOperator(722) as proc:
        proc.set_input_tuple(0, ocr_handle)
        proc.execute()


def close_ocv(ocvhandle: HHandle) -> None:
    """
    Clear an OCV tool.

    Parameters
    ----------

    ocvhandle : HHandle
                Handle of the OCV tool which has to be freed.

    See Also
    --------
    close_ocr

    Predecessors
    ------------
    read_ocv, create_ocv_proj
    """
    with HalconOperator(645) as proc:
        proc.set_input_tuple(0, ocvhandle)
        proc.execute()


def close_serial(serial_handle: HHandle) -> None:
    """
    Close a serial device.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    See Also
    --------
    open_serial, close_file

    Predecessors
    ------------
    open_serial
    """
    with HalconOperator(313) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.execute()


def close_socket(socket: HHandle) -> None:
    """
    Close a socket.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Predecessors
    ------------
    open_socket_accept, open_socket_connect, socket_accept_connect
    """
    with HalconOperator(340) as proc:
        proc.set_input_tuple(0, socket)
        proc.execute()


def close_window(window_handle: MaybeSequence[HHandle]) -> None:
    """
    Close an output window.

    Parameters
    ----------

    window_handle : MaybeSequence[HHandle]
                    Window handle.

    See Also
    --------
    open_window

    Predecessors
    ------------
    open_window
    """
    with HalconOperator(1187) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def closest_point_transform(
    region: HObject,
    metric: str,
    foreground: str,
    closest_point_mode: str,
    width: int,
    height: int
) -> Tuple[HObject, HObject]:
    """
    Compute the closest-point transformation of a region.

    Parameters
    ----------

    region : HObject
             Region for which the distance to the border is computed.

    metric : str
             Type of metric to be used for the closest-point
             transformation.
             Value Suggestion: city-block

    foreground : str
                 Compute the distance for pixels inside (true) or outside
                 (false) the input region.
                 Value Suggestion: true

    closest_point_mode : str
                         Mode in which the coordinates of the closest
                         points are returned.
                         Value Suggestion: absolute

    width : int
            Width of the output images.
            Value Suggestion: 640

    height : int
             Height of the output images.
             Value Suggestion: 480

    Returns
    -------

    distances : HObject
                Image containing the distance information.

    closest_points : HObject
                     Image containing the coordinates of the closest
                     points.

    See Also
    --------
    skeleton

    Alternatives
    ------------
    distance_transform

    Predecessors
    ------------
    threshold, dyn_threshold, regiongrowing

    Successors
    ----------
    threshold, vector_field_to_real

    Notes
    -----
    It should be noted that the closest points are usually not unique,
    i.e., for each pixel in the image Distances, there usually exist
    several points on the outer border of the region that have the
    respective distance to that pixel.  For example, all points on the
    skeleton of the region in the chosen metric have the same distance to
    at least two distinct points on the outer border of the region.
    closest_point_transform returns one of these points that is determined
    by the implementation of the algorithm.  In particular, invariances
    with respect to rotation or mirroring of the region should not be
    expected.
    Furthermore, it should be noted that for Foreground $=$ 'true', point
    coordinates that lie outside the image defined by Width and Height are
    returned if the input region Region touches the border of this image,
    since in this case the outside border of the region lies one pixel
    outside of the image.  If the returned coordinates should be used for
    a direct access to an image, a suitable border treatment must be
    implemented.
    """
    with HalconOperator(484) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, metric)
        proc.set_input_tuple(1, foreground)
        proc.set_input_tuple(2, closest_point_mode)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # distances
            HObject(proc.get_output_object_key(2))   # closest_points
        )  # type: ignore


def closing(region: HObject, struct_element: HObject) -> HObject:
    """
    Close a region.

    Parameters
    ----------

    region : HObject
             Regions to be closed.

    struct_element : HObject
                     Structuring element (position-invariant).

    Returns
    -------

    region_closing : HObject
                     Closed regions.

    See Also
    --------
    dilation1, erosion1, opening, minkowski_sub1

    Alternatives
    ------------
    closing_circle

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    closing is applied to each input region separately.  If gaps between
    different regions are to be closed, union1 or union2 has to be called
    first.
    """
    with HalconOperator(762) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.execute()
        region_closing = HObject(proc.get_output_object_key(1))
        return region_closing  # type: ignore


def closing_circle(
    region: HObject,
    radius: Union[float, int]
) -> HObject:
    """
    Close a region with a circular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be closed.

    radius : Union[float, int]
             Radius of the circular structuring element.
             Value Suggestion: 3.5

    Returns
    -------

    region_closing : HObject
                     Closed regions.

    See Also
    --------
    dilation1, minkowski_sub1, erosion1, opening

    Alternatives
    ------------
    rank_region, fill_up, closing

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    closing_circle is applied to each input region separately.  If gaps
    between different regions are to be closed, union1 or union2 has to be
    called first.
    """
    with HalconOperator(761) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, radius)
        proc.execute()
        region_closing = HObject(proc.get_output_object_key(1))
        return region_closing  # type: ignore


def closing_golay(
    region: HObject,
    golay_element: str,
    rotation: int
) -> HObject:
    """
    Close a region with an element from the Golay alphabet.

    Parameters
    ----------

    region : HObject
             Regions to be closed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_closing : HObject
                     Closed regions.

    See Also
    --------
    erosion_golay, dilation_golay, opening_golay, hit_or_miss_golay,
    thinning_golay, thickening_golay, golay_elements

    Alternatives
    ------------
    closing

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    closing_golay is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.  For some
    of the values of Rotation, the resulting regions are identical to the
    input regions.
    """
    with HalconOperator(760) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, rotation)
        proc.execute()
        region_closing = HObject(proc.get_output_object_key(1))
        return region_closing  # type: ignore


def closing_rectangle1(
    region: HObject,
    width: int,
    height: int
) -> HObject:
    """
    Close a region with a rectangular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be closed.

    width : int
            Width of the structuring rectangle.
            Value Suggestion: 10

    height : int
             Height of the structuring rectangle.
             Value Suggestion: 10

    Returns
    -------

    region_closing : HObject
                     Closed regions.

    See Also
    --------
    dilation_rectangle1, erosion_rectangle1, opening_rectangle1,
    gen_rectangle1

    Alternatives
    ------------
    closing

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    closing_rectangle1 is applied to each input region separately.  If
    gaps between different regions are to be closed, union1 or union2 has
    to be called first.
    """
    with HalconOperator(759) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        region_closing = HObject(proc.get_output_object_key(1))
        return region_closing  # type: ignore


def cluster_model_components(
    training_images: HObject,
    component_training_id: HHandle,
    ambiguity_criterion: str,
    max_contour_overlap: float,
    cluster_threshold: float
) -> HObject:
    """
    Adopt new parameters that are used to create the model components into
    the training result.

    Parameters
    ----------

    training_images : HObject
                      Training images that were used for training the
                      model components.

    component_training_id : HHandle
                            Handle of the training result.

    ambiguity_criterion : str
                          Criterion for solving the ambiguities.
                          Value Suggestion: rigidity

    max_contour_overlap : float
                          Maximum contour overlap of the found initial
                          components.
                          Value Suggestion: 0.2
                          Assertion: 0 <= MaxContourOverlap && MaxContourOverlap <= 1

    cluster_threshold : float
                        Threshold for clustering the initial components.
                        Value Suggestion: 0.5
                        Assertion: 0 <= ClusterThreshold && ClusterThreshold <= 1

    Returns
    -------

    model_components : HObject
                       Contour regions of rigid model components.

    Predecessors
    ------------
    train_model_components, inspect_clustered_components

    Successors
    ----------
    get_training_components, create_trained_component_model,
    modify_component_relations, write_training_components,
    get_component_relations, clear_training_components
    """
    with HalconOperator(1015) as proc:
        proc.set_input_object(1, training_images)
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, ambiguity_criterion)
        proc.set_input_tuple(2, max_contour_overlap)
        proc.set_input_tuple(3, cluster_threshold)
        proc.execute()
        model_components = HObject(proc.get_output_object_key(1))
        return model_components  # type: ignore


def coherence_enhancing_diff(
    image: HObject,
    sigma: float,
    rho: float,
    theta: float,
    iterations: int
) -> HObject:
    """
    Perform a coherence enhancing diffusion of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : float
            Smoothing for derivative operator.
            Value Suggestion: 0.5
            Assertion: Sigma >= 0

    rho : float
          Smoothing for diffusion coefficients.
          Value Suggestion: 3.0
          Assertion: Rho >= 0

    theta : float
            Time step.
            Value Suggestion: 0.5
            Assertion: 0 < Theta <= 0.5

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    Returns
    -------

    image_ced : HObject
                Output image.

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1547) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, rho)
        proc.set_input_tuple(2, theta)
        proc.set_input_tuple(3, iterations)
        proc.execute()
        image_ced = HObject(proc.get_output_object_key(1))
        return image_ced  # type: ignore


def combine_roads_xld(
    edge_polygons: HObject,
    mod_parallels: HObject,
    ext_parallels: HObject,
    center_lines: HObject,
    max_angle_parallel: Union[float, int],
    max_angle_colinear: Union[float, int],
    max_distance_parallel: Union[float, int],
    max_distance_colinear: Union[float, int]
) -> HObject:
    """
    Combine road hypotheses from two resolution levels.

    Parameters
    ----------

    edge_polygons : HObject
                    XLD polygons to be examined.

    mod_parallels : HObject
                    Modified parallels obtained from EdgePolygons.

    ext_parallels : HObject
                    Extended parallels obtained from EdgePolygons.

    center_lines : HObject
                   Road-center-line polygons to be examined.

    max_angle_parallel : Union[float, int]
                         Maximum angle between two parallel line segments.
                         Value Suggestion: 0.523598775598
                         Assertion: 0 <= MaxAngleParallel <= pi / 2

    max_angle_colinear : Union[float, int]
                         Maximum angle between two collinear line segments.
                         Value Suggestion: 0.261799387799
                         Assertion: 0 <= MaxAngleColinear <= pi / 2

    max_distance_parallel : Union[float, int]
                            Maximum distance between two parallel line
                            segments.
                            Value Suggestion: 40
                            Assertion: MaxDistanceParallel > 0

    max_distance_colinear : Union[float, int]
                            Maximum distance between two collinear line
                            segments.
                            Value Suggestion: 40
                            Assertion: MaxDistanceColinear > 0

    Returns
    -------

    road_sides : HObject
                 Roadsides found.

    See Also
    --------
    lines_gauss, lines_facet, get_channel_info, edges_sub_pix

    Predecessors
    ------------
    mod_parallels_xld, gen_polygons_xld, affine_trans_contour_xld

    Successors
    ----------
    get_polygon_xld, get_lines_xld
    """
    with HalconOperator(37) as proc:
        proc.set_input_object(1, edge_polygons)
        proc.set_input_object(2, mod_parallels)
        proc.set_input_object(3, ext_parallels)
        proc.set_input_object(4, center_lines)
        proc.set_input_tuple(0, max_angle_parallel)
        proc.set_input_tuple(1, max_angle_colinear)
        proc.set_input_tuple(2, max_distance_parallel)
        proc.set_input_tuple(3, max_distance_colinear)
        proc.execute()
        road_sides = HObject(proc.get_output_object_key(1))
        return road_sides  # type: ignore


def compactness(regions: HObject) -> Sequence[float]:
    """
    Shape factor for the compactness of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    compactness : Sequence[float]
                  Compactness of the input region(s).
                  Assertion: Compactness >= 1.0 || Compactness == 0

    See Also
    --------
    contlength, area_center, select_shape

    Alternatives
    ------------
    convexity, eccentricity

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1728) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        compactness = proc.get_output_tuple_m(0)
        return compactness  # type: ignore


def compactness_s(regions: HObject) -> float:
    """
    Shape factor for the compactness of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    compactness : float
                  Compactness of the input region(s).
                  Assertion: Compactness >= 1.0 || Compactness == 0

    See Also
    --------
    contlength, area_center, select_shape

    Alternatives
    ------------
    convexity, eccentricity

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1728) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        compactness = proc.get_output_tuple_s(0)
        return compactness  # type: ignore


def compactness_xld(xld: HObject) -> Sequence[float]:
    """
    Shape factor for the compactness of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    compactness : Sequence[float]
                  Compactness of the input contours or polygons.
                  Assertion: Compactness >= 1.0 || Compactness == 0

    See Also
    --------
    area_center_xld, select_shape_xld

    Alternatives
    ------------
    circularity_xld, convexity_xld, eccentricity_xld, rectangularity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1681) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        compactness = proc.get_output_tuple_m(0)
        return compactness  # type: ignore


def compactness_xld_s(xld: HObject) -> float:
    """
    Shape factor for the compactness of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    compactness : float
                  Compactness of the input contours or polygons.
                  Assertion: Compactness >= 1.0 || Compactness == 0

    See Also
    --------
    area_center_xld, select_shape_xld

    Alternatives
    ------------
    circularity_xld, convexity_xld, eccentricity_xld, rectangularity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1681) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        compactness = proc.get_output_tuple_s(0)
        return compactness  # type: ignore


def compare_ext_variation_model(
    image: HObject,
    model_id: HHandle,
    mode: str
) -> HObject:
    """
    Compare an image to a variation model.

    Parameters
    ----------

    image : HObject
            Image of the object to be compared.

    model_id : HHandle
               ID of the variation model.

    mode : str
           Method used for comparing the variation model.
           Value Suggestion: absolute

    Returns
    -------

    region : HObject
             Region containing the points that differ substantially from
             the model.

    See Also
    --------
    get_thresh_images_variation_model

    Alternatives
    ------------
    compare_variation_model, dyn_threshold

    Predecessors
    ------------
    prepare_variation_model, prepare_direct_variation_model

    Successors
    ----------
    select_obj, connection
    """
    with HalconOperator(87) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, mode)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def compare_obj(
    objects_1: HObject,
    objects_2: HObject,
    epsilon: Union[float, int]
) -> int:
    """
    Compare iconic objects regarding equality.

    Parameters
    ----------

    objects_1 : HObject
                Reference objects.

    objects_2 : HObject
                Test objects.

    epsilon : Union[float, int]
              Maximum allowed difference between two gray values or
              coordinates etc.
              Value Suggestion: 0.0

    Returns
    -------

    is_equal : int
               Boolean result value.

    See Also
    --------
    test_equal_obj, test_equal_region
    """
    with HalconOperator(588) as proc:
        proc.set_input_object(1, objects_1)
        proc.set_input_object(2, objects_2)
        proc.set_input_tuple(0, epsilon)
        proc.init_oct(0)
        proc.execute()
        is_equal = proc.get_output_tuple_s(0)
        return is_equal  # type: ignore


def compare_variation_model(
    image: HObject,
    model_id: HHandle
) -> HObject:
    """
    Compare an image to a variation model.

    Parameters
    ----------

    image : HObject
            Image of the object to be compared.

    model_id : HHandle
               ID of the variation model.

    Returns
    -------

    region : HObject
             Region containing the points that differ substantially from
             the model.

    See Also
    --------
    get_thresh_images_variation_model

    Alternatives
    ------------
    compare_ext_variation_model, dyn_threshold

    Predecessors
    ------------
    prepare_variation_model, prepare_direct_variation_model

    Successors
    ----------
    connection
    """
    with HalconOperator(88) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def complement(region: HObject) -> HObject:
    """
    Return the complement of a region.

    Parameters
    ----------

    region : HObject
             Input region(s).

    Returns
    -------

    region_complement : HObject
                        Complemented regions.

    See Also
    --------
    difference, union1, union2, intersection, reset_obj_db, set_system

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape
    """
    with HalconOperator(504) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        region_complement = HObject(proc.get_output_object_key(1))
        return region_complement  # type: ignore


def complex_to_real(
    image_complex: HObject
) -> Tuple[HObject, HObject]:
    """
    Convert a complex image into two real images.

    Parameters
    ----------

    image_complex : HObject
                    Complex image.

    Returns
    -------

    image_real : HObject
                 Real part.

    image_imaginary : HObject
                      Imaginary part.

    See Also
    --------
    real_to_complex
    """
    with HalconOperator(1475) as proc:
        proc.set_input_object(1, image_complex)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_real
            HObject(proc.get_output_object_key(2))   # image_imaginary
        )  # type: ignore


def compose2(image_1: HObject, image_2: HObject) -> HObject:
    """
    Convert two images into a two-channel image.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    decompose2

    Alternatives
    ------------
    append_channel

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1126) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def compose3(
    image_1: HObject,
    image_2: HObject,
    image_3: HObject
) -> HObject:
    """
    Convert 3 images into a three-channel image.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    image_3 : HObject
              Input image 3.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    decompose3

    Alternatives
    ------------
    append_channel

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1125) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_object(3, image_3)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def compose4(
    image_1: HObject,
    image_2: HObject,
    image_3: HObject,
    image_4: HObject
) -> HObject:
    """
    Convert 4 images into a four-channel image.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    image_3 : HObject
              Input image 3.

    image_4 : HObject
              Input image 4.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    decompose4

    Alternatives
    ------------
    append_channel

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1124) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_object(3, image_3)
        proc.set_input_object(4, image_4)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def compose5(
    image_1: HObject,
    image_2: HObject,
    image_3: HObject,
    image_4: HObject,
    image_5: HObject
) -> HObject:
    """
    Convert 5 images into a five-channel image.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    image_3 : HObject
              Input image 3.

    image_4 : HObject
              Input image 4.

    image_5 : HObject
              Input image 5.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    decompose5

    Alternatives
    ------------
    append_channel

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1123) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_object(3, image_3)
        proc.set_input_object(4, image_4)
        proc.set_input_object(5, image_5)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def compose6(
    image_1: HObject,
    image_2: HObject,
    image_3: HObject,
    image_4: HObject,
    image_5: HObject,
    image_6: HObject
) -> HObject:
    """
    Convert 6 images into a six-channel image.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    image_3 : HObject
              Input image 3.

    image_4 : HObject
              Input image 4.

    image_5 : HObject
              Input image 5.

    image_6 : HObject
              Input image 6.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    decompose6

    Alternatives
    ------------
    append_channel

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1122) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_object(3, image_3)
        proc.set_input_object(4, image_4)
        proc.set_input_object(5, image_5)
        proc.set_input_object(6, image_6)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def compose7(
    image_1: HObject,
    image_2: HObject,
    image_3: HObject,
    image_4: HObject,
    image_5: HObject,
    image_6: HObject,
    image_7: HObject
) -> HObject:
    """
    Convert 7 images into a seven-channel image.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    image_3 : HObject
              Input image 3.

    image_4 : HObject
              Input image 4.

    image_5 : HObject
              Input image 5.

    image_6 : HObject
              Input image 6.

    image_7 : HObject
              Input image 7.

    Returns
    -------

    multi_channel_image : HObject
                          Multi-channel image.

    See Also
    --------
    decompose7

    Alternatives
    ------------
    append_channel

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1121) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_object(3, image_3)
        proc.set_input_object(4, image_4)
        proc.set_input_object(5, image_5)
        proc.set_input_object(6, image_6)
        proc.set_input_object(7, image_7)
        proc.execute()
        multi_channel_image = HObject(proc.get_output_object_key(1))
        return multi_channel_image  # type: ignore


def compose_funct_1d(
    function_1: Sequence[Union[float, int]],
    function_2: Sequence[Union[float, int]],
    border: str
) -> Sequence[Union[float, int]]:
    """
    Compose two functions.

    Parameters
    ----------

    function_1 : Sequence[Union[float, int]]
                 Input function 1.

    function_2 : Sequence[Union[float, int]]
                 Input function 2.

    border : str
             Border treatment for the input functions.
             Value Suggestion: constant

    Returns
    -------

    composed_function : Sequence[Union[float, int]]
                        Composed function.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1377) as proc:
        proc.set_input_tuple(0, function_1)
        proc.set_input_tuple(1, function_2)
        proc.set_input_tuple(2, border)
        proc.init_oct(0)
        proc.execute()
        composed_function = proc.get_output_tuple_m(0)
        return composed_function  # type: ignore


def concat_obj(objects_1: HObject, objects_2: HObject) -> HObject:
    """
    Concatenate two iconic object tuples.

    Parameters
    ----------

    objects_1 : HObject
                Object tuple 1.

    objects_2 : HObject
                Object tuple 2.

    Returns
    -------

    objects_concat : HObject
                     Concatenated objects.

    See Also
    --------
    count_obj, copy_obj, select_obj, disp_obj
    """
    with HalconOperator(584) as proc:
        proc.set_input_object(1, objects_1)
        proc.set_input_object(2, objects_2)
        proc.execute()
        objects_concat = HObject(proc.get_output_object_key(1))
        return objects_concat  # type: ignore


def concat_ocr_trainf(
    single_files: MaybeSequence[str],
    composed_file: str
) -> None:
    """
    Concat training files.

    Parameters
    ----------

    single_files : MaybeSequence[str]
                   Names of the single training files.
                   Value Suggestion: ''

    composed_file : str
                    Name of the composed training file.
                    Value Suggestion: all_characters

    Predecessors
    ------------
    write_ocr_trainf, append_ocr_trainf

    Successors
    ----------
    trainf_ocr_class_mlp, trainf_ocr_class_svm, write_ocr_trainf
    """
    with HalconOperator(728) as proc:
        proc.set_input_tuple(0, single_files)
        proc.set_input_tuple(1, composed_file)
        proc.execute()


def connect_and_holes(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Number of connection components and holes

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    num_connected : Sequence[int]
                    Number of connection components of a region.

    num_holes : Sequence[int]
                Number of holes of a region.

    See Also
    --------
    connection, fill_up, fill_up_shape, union1

    Alternatives
    ------------
    euler_number

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1726) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # num_connected
            proc.get_output_tuple_m(1)   # num_holes
        )  # type: ignore


def connect_and_holes_s(regions: HObject) -> Tuple[int, int]:
    """
    Number of connection components and holes

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    num_connected : int
                    Number of connection components of a region.

    num_holes : int
                Number of holes of a region.

    See Also
    --------
    connection, fill_up, fill_up_shape, union1

    Alternatives
    ------------
    euler_number

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1726) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_connected
            proc.get_output_tuple_s(1)   # num_holes
        )  # type: ignore


def connect_grid_points(
    image: HObject,
    row: Sequence[float],
    column: Sequence[float],
    sigma: MaybeSequence[Union[float, int]],
    max_dist: Union[float, int]
) -> HObject:
    """
    Establish connections between the grid points of the rectification
    grid.

    Parameters
    ----------

    image : HObject
            Input image.

    row : Sequence[float]
          Row coordinates of the grid points.

    column : Sequence[float]
             Column coordinates of the grid points.
             Assertion: number(Column) == number(Row)

    sigma : MaybeSequence[Union[float, int]]
            Size of the applied Gaussians.
            Value Suggestion: 0.9
            Assertion: 0.7 <= Sigma

    max_dist : Union[float, int]
               Maximum distance of the connecting lines from the grid
               points.
               Value Suggestion: 5.5
               Assertion: 0.0 <= MaxDist

    Returns
    -------

    connecting_lines : HObject
                       Output contours.

    Predecessors
    ------------
    saddle_points_sub_pix

    Successors
    ----------
    gen_grid_rectification_map

    Notes
    -----
    For a reliable determination of the type of bright-dark transition as
    well as for the following rectification, it is necessary that each
    connecting line has at least three contour points. Therefore,
    connecting lines with only two contour points are not returned. Note,
    that the parameter MaxDist has a substantial influence on the length
    of the returned connecting lines, because all contour points of a
    possible connecting line that are closer than MaxDist to a grid point
    are replaced by one single contour point. If MaxDist is too big, some
    of the connecting lines might get lost.
    """
    with HalconOperator(1158) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, sigma)
        proc.set_input_tuple(3, max_dist)
        proc.execute()
        connecting_lines = HObject(proc.get_output_object_key(1))
        return connecting_lines  # type: ignore


def connection(region: HObject) -> HObject:
    """
    Compute connected components of a region.

    Parameters
    ----------

    region : HObject
             Input region.

    Returns
    -------

    connected_regions : HObject
                        Connected components.

    See Also
    --------
    set_system, union1

    Alternatives
    ------------
    background_seg

    Predecessors
    ------------
    auto_threshold, threshold, dyn_threshold, erosion1

    Successors
    ----------
    select_shape, select_gray, shape_trans, set_colored, dilation1,
    count_obj, reduce_domain, add_channels
    """
    with HalconOperator(501) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        connected_regions = HObject(proc.get_output_object_key(1))
        return connected_regions  # type: ignore


def connection_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    feature: MaybeSequence[str],
    value: MaybeSequence[Union[int, float]]
) -> Sequence[HHandle]:
    """
    Determine the connected components of the 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    feature : MaybeSequence[str]
              Attribute used to calculate the connected components.
              Value Suggestion: 'distance_3d'

    value : MaybeSequence[Union[int, float]]
            Maximum value for the distance between two connected
            components.
            Value Suggestion: 1.0

    Returns
    -------

    object_model_3dconnected : Sequence[HHandle]
                               Handle of the 3D object models that
                               represent the connected components.

    See Also
    --------
    select_points_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    select_points_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz
    """
    with HalconOperator(1085) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, feature)
        proc.set_input_tuple(2, value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dconnected = proc.get_output_tuple_m(0)
        return object_model_3dconnected  # type: ignore


def contlength(regions: HObject) -> Sequence[float]:
    """
    Contour length of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    cont_length : Sequence[float]
                  Contour length of the input region(s).
                  Assertion: ContLength >= 0

    See Also
    --------
    area_center, get_region_contour

    Alternatives
    ------------
    compactness

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    get_region_contour

    Notes
    -----
    The contour of holes is not calculated.
    """
    with HalconOperator(1725) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        cont_length = proc.get_output_tuple_m(0)
        return cont_length  # type: ignore


def contlength_s(regions: HObject) -> float:
    """
    Contour length of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    cont_length : float
                  Contour length of the input region(s).
                  Assertion: ContLength >= 0

    See Also
    --------
    area_center, get_region_contour

    Alternatives
    ------------
    compactness

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    get_region_contour

    Notes
    -----
    The contour of holes is not calculated.
    """
    with HalconOperator(1725) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        cont_length = proc.get_output_tuple_s(0)
        return cont_length  # type: ignore


def contour_point_num_xld(contour: HObject) -> Sequence[int]:
    """
    Return the number of points in an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input XLD contour.

    Returns
    -------

    length : Sequence[int]
             Number of contour points.

    See Also
    --------
    query_contour_attribs_xld

    Alternatives
    ------------
    get_regress_params_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    get_contour_xld, get_contour_attrib_xld
    """
    with HalconOperator(64) as proc:
        proc.set_input_object(1, contour)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_m(0)
        return length  # type: ignore


def contour_point_num_xld_s(contour: HObject) -> int:
    """
    Return the number of points in an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input XLD contour.

    Returns
    -------

    length : int
             Number of contour points.

    See Also
    --------
    query_contour_attribs_xld

    Alternatives
    ------------
    get_regress_params_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    get_contour_xld, get_contour_attrib_xld
    """
    with HalconOperator(64) as proc:
        proc.set_input_object(1, contour)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_s(0)
        return length  # type: ignore


def contour_to_world_plane_xld(
    contours: HObject,
    camera_param: Sequence[Union[int, float, str]],
    world_pose: Sequence[Union[int, float]],
    scale: Union[int, float, str]
) -> HObject:
    """
    Transform an XLD contour into the plane z=0 of a world coordinate
    system.

    Parameters
    ----------

    contours : HObject
               Input XLD contours to be transformed in image coordinates.

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    world_pose : Sequence[Union[int, float]]
                 3D pose of the world coordinate system in camera
                 coordinates.

    scale : Union[int, float, str]
            Scale or dimension
            Value Suggestion: m
            Assertion: Scale > 0

    Returns
    -------

    contours_trans : HObject
                     Transformed XLD contours in world coordinates.

    See Also
    --------
    image_points_to_world_plane

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration, set_origin_pose
    """
    with HalconOperator(1915) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, world_pose)
        proc.set_input_tuple(2, scale)
        proc.execute()
        contours_trans = HObject(proc.get_output_object_key(1))
        return contours_trans  # type: ignore


def control_io_channel(
    iochannel_handle: MaybeSequence[HHandle],
    param_action: str,
    param_argument: Sequence[Union[int, float, str]]
) -> Sequence[Union[int, float, str]]:
    """
    Perform an action on I/O channels.

    Parameters
    ----------

    iochannel_handle : MaybeSequence[HHandle]
                       Handles of the opened I/O channels.

    param_action : str
                   Name of the action to perform.

    param_argument : Sequence[Union[int, float, str]]
                     List of arguments for the action.
                     Value Suggestion: []

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      List of values returned by the action.

    Predecessors
    ------------
    open_io_channel
    """
    with HalconOperator(2010) as proc:
        proc.set_input_tuple(0, iochannel_handle)
        proc.set_input_tuple(1, param_action)
        proc.set_input_tuple(2, param_argument)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def control_io_device(
    iodevice_handle: HHandle,
    action: str,
    argument: MaybeSequence[Union[int, float, str]]
) -> Sequence[Union[int, float, str]]:
    """
    Perform an action on the I/O device.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    action : str
             Name of the action to perform.

    argument : MaybeSequence[Union[int, float, str]]
               List of arguments for the action.
               Value Suggestion: []

    Returns
    -------

    result : Sequence[Union[int, float, str]]
             List of result values returned by the action.

    Predecessors
    ------------
    open_io_device
    """
    with HalconOperator(2018) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, action)
        proc.set_input_tuple(2, argument)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def control_io_interface(
    iointerface_name: str,
    action: str,
    argument: MaybeSequence[Union[int, float, str]]
) -> Sequence[Union[int, float, str]]:
    """
    Perform an action on the I/O interface.

    Parameters
    ----------

    iointerface_name : str
                       HALCON I/O interface name.
                       Value Suggestion: []

    action : str
             Name of the action to perform.

    argument : MaybeSequence[Union[int, float, str]]
               List of arguments for the action.
               Value Suggestion: []

    Returns
    -------

    result : Sequence[Union[int, float, str]]
             List of results returned by the action.

    See Also
    --------
    query_io_interface

    Notes
    -----
    On Windows Systems, error dialog boxes from the operating system can
    occur when dependency modules of the interface are not found, e.g.,
    the according SDK was not installed. The occurrence of the error boxes
    can be controlled by setting Windows' Error Mode. Please refer to the
    description of SetErrorMode within the Windows MSDN documentation.
    """
    with HalconOperator(2023) as proc:
        proc.set_input_tuple(0, iointerface_name)
        proc.set_input_tuple(1, action)
        proc.set_input_tuple(2, argument)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def convert_coordinates_image_to_window(
    window_handle: HHandle,
    row_image: MaybeSequence[float],
    column_image: MaybeSequence[float]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Convert image coordinates to window coordinates

    Parameters
    ----------

    window_handle : HHandle
                    Window handle

    row_image : MaybeSequence[float]
                Row in image coordinates.

    column_image : MaybeSequence[float]
                   Column in image coordinates.

    Returns
    -------

    row_window : Sequence[float]
                 Row (Y) in window coordinates.

    column_window : Sequence[float]
                    Column (X) in window coordinates.

    See Also
    --------
    convert_coordinates_window_to_image

    Predecessors
    ------------
    set_window_extents, set_part
    """
    with HalconOperator(2049) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_image)
        proc.set_input_tuple(2, column_image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_window
            proc.get_output_tuple_m(1)   # column_window
        )  # type: ignore


def convert_coordinates_image_to_window_s(
    window_handle: HHandle,
    row_image: MaybeSequence[float],
    column_image: MaybeSequence[float]
) -> Tuple[float, float]:
    """
    Convert image coordinates to window coordinates

    Parameters
    ----------

    window_handle : HHandle
                    Window handle

    row_image : MaybeSequence[float]
                Row in image coordinates.

    column_image : MaybeSequence[float]
                   Column in image coordinates.

    Returns
    -------

    row_window : float
                 Row (Y) in window coordinates.

    column_window : float
                    Column (X) in window coordinates.

    See Also
    --------
    convert_coordinates_window_to_image

    Predecessors
    ------------
    set_window_extents, set_part
    """
    with HalconOperator(2049) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_image)
        proc.set_input_tuple(2, column_image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_window
            proc.get_output_tuple_s(1)   # column_window
        )  # type: ignore


def convert_coordinates_window_to_image(
    window_handle: HHandle,
    row_window: MaybeSequence[float],
    column_window: MaybeSequence[float]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Convert window coordinates to image coordinates

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_window : MaybeSequence[float]
                 Row (Y) in window coordinates.

    column_window : MaybeSequence[float]
                    Column (X) in window coordinates.

    Returns
    -------

    row_image : Sequence[float]
                Row in image coordinates.

    column_image : Sequence[float]
                   Column in image coordinates.

    See Also
    --------
    convert_coordinates_image_to_window

    Predecessors
    ------------
    set_window_extents, set_part
    """
    with HalconOperator(2050) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_window)
        proc.set_input_tuple(2, column_window)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_image
            proc.get_output_tuple_m(1)   # column_image
        )  # type: ignore


def convert_coordinates_window_to_image_s(
    window_handle: HHandle,
    row_window: MaybeSequence[float],
    column_window: MaybeSequence[float]
) -> Tuple[float, float]:
    """
    Convert window coordinates to image coordinates

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_window : MaybeSequence[float]
                 Row (Y) in window coordinates.

    column_window : MaybeSequence[float]
                    Column (X) in window coordinates.

    Returns
    -------

    row_image : float
                Row in image coordinates.

    column_image : float
                   Column in image coordinates.

    See Also
    --------
    convert_coordinates_image_to_window

    Predecessors
    ------------
    set_window_extents, set_part
    """
    with HalconOperator(2050) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_window)
        proc.set_input_tuple(2, column_window)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_image
            proc.get_output_tuple_s(1)   # column_image
        )  # type: ignore


def convert_image_type(image: HObject, new_type: str) -> HObject:
    """
    Convert the type of an image.

    Parameters
    ----------

    image : HObject
            Image whose image type is to be changed.

    new_type : str
               Desired image type (i.e., type of the gray values).
               Value Suggestion: byte

    Returns
    -------

    image_converted : HObject
                      Converted image.

    See Also
    --------
    scale_image, abs_image

    Predecessors
    ------------
    scale_image

    Notes
    -----
    The conversion to the 'int8' image format is only available on 64 bit
    systems! If the source and destination image type are identical, no
    new image matrix is allocated.
    """
    with HalconOperator(1471) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, new_type)
        proc.execute()
        image_converted = HObject(proc.get_output_object_key(1))
        return image_converted  # type: ignore


def convert_map_type(
    map: HObject,
    new_type: str,
    image_width: Union[int, str]
) -> HObject:
    """
    Convert image maps into other map types.

    Parameters
    ----------

    map : HObject
          Input map.

    new_type : str
               Type of MapConverted.
               Value Suggestion: 'coord_map_sub_pix'

    image_width : Union[int, str]
                  Width of images to be mapped.
                  Value Suggestion: 'map_width'

    Returns
    -------

    map_converted : HObject
                    Converted map.

    Predecessors
    ------------
    gen_image_to_world_plane_map, gen_radial_distortion_map,
    gen_arbitrary_distortion_map, gen_grid_rectification_map,
    find_local_deformable_model

    Successors
    ----------
    map_image
    """
    with HalconOperator(1901) as proc:
        proc.set_input_object(1, map)
        proc.set_input_tuple(0, new_type)
        proc.set_input_tuple(1, image_width)
        proc.execute()
        map_converted = HObject(proc.get_output_object_key(1))
        return map_converted  # type: ignore


def convert_point_3d_cart_to_spher(
    x: MaybeSequence[float],
    y: MaybeSequence[float],
    z: MaybeSequence[float],
    equat_plane_normal: str,
    zero_meridian: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Convert Cartesian coordinates of a 3D point to spherical coordinates.

    Parameters
    ----------

    x : MaybeSequence[float]
        X coordinate of the 3D point.

    y : MaybeSequence[float]
        Y coordinate of the 3D point.

    z : MaybeSequence[float]
        Z coordinate of the 3D point.

    equat_plane_normal : str
                         Normal vector of the equatorial plane (points to
                         the north pole).
                         Value Suggestion: -y

    zero_meridian : str
                    Coordinate axis in the equatorial plane that points to
                    the zero meridian.
                    Value Suggestion: -z

    Returns
    -------

    longitude : Sequence[float]
                Longitude of the 3D point.

    latitude : Sequence[float]
               Latitude of the 3D point.

    radius : Sequence[float]
             Radius of the 3D point.

    See Also
    --------
    convert_point_3d_spher_to_cart

    Successors
    ----------
    create_shape_model_3d, find_shape_model_3d
    """
    with HalconOperator(1047) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, equat_plane_normal)
        proc.set_input_tuple(4, zero_meridian)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # longitude
            proc.get_output_tuple_m(1),  # latitude
            proc.get_output_tuple_m(2)   # radius
        )  # type: ignore


def convert_point_3d_cart_to_spher_s(
    x: MaybeSequence[float],
    y: MaybeSequence[float],
    z: MaybeSequence[float],
    equat_plane_normal: str,
    zero_meridian: str
) -> Tuple[float, float, float]:
    """
    Convert Cartesian coordinates of a 3D point to spherical coordinates.

    Parameters
    ----------

    x : MaybeSequence[float]
        X coordinate of the 3D point.

    y : MaybeSequence[float]
        Y coordinate of the 3D point.

    z : MaybeSequence[float]
        Z coordinate of the 3D point.

    equat_plane_normal : str
                         Normal vector of the equatorial plane (points to
                         the north pole).
                         Value Suggestion: -y

    zero_meridian : str
                    Coordinate axis in the equatorial plane that points to
                    the zero meridian.
                    Value Suggestion: -z

    Returns
    -------

    longitude : float
                Longitude of the 3D point.

    latitude : float
               Latitude of the 3D point.

    radius : float
             Radius of the 3D point.

    See Also
    --------
    convert_point_3d_spher_to_cart

    Successors
    ----------
    create_shape_model_3d, find_shape_model_3d
    """
    with HalconOperator(1047) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, equat_plane_normal)
        proc.set_input_tuple(4, zero_meridian)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # longitude
            proc.get_output_tuple_s(1),  # latitude
            proc.get_output_tuple_s(2)   # radius
        )  # type: ignore


def convert_point_3d_spher_to_cart(
    longitude: MaybeSequence[float],
    latitude: MaybeSequence[float],
    radius: MaybeSequence[float],
    equat_plane_normal: str,
    zero_meridian: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Convert spherical coordinates of a 3D point to Cartesian coordinates.

    Parameters
    ----------

    longitude : MaybeSequence[float]
                Longitude of the 3D point.

    latitude : MaybeSequence[float]
               Latitude of the 3D point.
               Assertion: - pi / 2 <= Latitude && Latitude <= pi / 2

    radius : MaybeSequence[float]
             Radius of the 3D point.

    equat_plane_normal : str
                         Normal vector of the equatorial plane (points to
                         the north pole).
                         Value Suggestion: -y

    zero_meridian : str
                    Coordinate axis in the equatorial plane that points to
                    the zero meridian.
                    Value Suggestion: -z

    Returns
    -------

    x : Sequence[float]
        X coordinate of the 3D point.

    y : Sequence[float]
        Y coordinate of the 3D point.

    z : Sequence[float]
        Z coordinate of the 3D point.

    See Also
    --------
    convert_point_3d_cart_to_spher

    Predecessors
    ------------
    get_shape_model_3d_params
    """
    with HalconOperator(1046) as proc:
        proc.set_input_tuple(0, longitude)
        proc.set_input_tuple(1, latitude)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, equat_plane_normal)
        proc.set_input_tuple(4, zero_meridian)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1),  # y
            proc.get_output_tuple_m(2)   # z
        )  # type: ignore


def convert_point_3d_spher_to_cart_s(
    longitude: MaybeSequence[float],
    latitude: MaybeSequence[float],
    radius: MaybeSequence[float],
    equat_plane_normal: str,
    zero_meridian: str
) -> Tuple[float, float, float]:
    """
    Convert spherical coordinates of a 3D point to Cartesian coordinates.

    Parameters
    ----------

    longitude : MaybeSequence[float]
                Longitude of the 3D point.

    latitude : MaybeSequence[float]
               Latitude of the 3D point.
               Assertion: - pi / 2 <= Latitude && Latitude <= pi / 2

    radius : MaybeSequence[float]
             Radius of the 3D point.

    equat_plane_normal : str
                         Normal vector of the equatorial plane (points to
                         the north pole).
                         Value Suggestion: -y

    zero_meridian : str
                    Coordinate axis in the equatorial plane that points to
                    the zero meridian.
                    Value Suggestion: -z

    Returns
    -------

    x : float
        X coordinate of the 3D point.

    y : float
        Y coordinate of the 3D point.

    z : float
        Z coordinate of the 3D point.

    See Also
    --------
    convert_point_3d_cart_to_spher

    Predecessors
    ------------
    get_shape_model_3d_params
    """
    with HalconOperator(1046) as proc:
        proc.set_input_tuple(0, longitude)
        proc.set_input_tuple(1, latitude)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, equat_plane_normal)
        proc.set_input_tuple(4, zero_meridian)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # x
            proc.get_output_tuple_s(1),  # y
            proc.get_output_tuple_s(2)   # z
        )  # type: ignore


def convert_pose_type(
    pose_in: Sequence[Union[int, float]],
    order_of_transform: str,
    order_of_rotation: str,
    view_of_transform: str
) -> Sequence[Union[int, float]]:
    """
    Change the representation type of a 3D pose.

    Parameters
    ----------

    pose_in : Sequence[Union[int, float]]
              Original 3D pose.

    order_of_transform : str
                         Order of rotation and translation.
                         Value Suggestion: 'Rp+T'

    order_of_rotation : str
                        Meaning of the rotation values.
                        Value Suggestion: 'gba'

    view_of_transform : str
                        View of transformation.
                        Value Suggestion: 'point'

    Returns
    -------

    pose_out : Sequence[Union[int, float]]
               3D transformation.

    See Also
    --------
    create_pose, get_pose_type, write_pose, read_pose

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration

    Successors
    ----------
    write_pose
    """
    with HalconOperator(1920) as proc:
        proc.set_input_tuple(0, pose_in)
        proc.set_input_tuple(1, order_of_transform)
        proc.set_input_tuple(2, order_of_rotation)
        proc.set_input_tuple(3, view_of_transform)
        proc.init_oct(0)
        proc.execute()
        pose_out = proc.get_output_tuple_m(0)
        return pose_out  # type: ignore


def convex_hull_object_model_3d(
    object_model_3d: MaybeSequence[HHandle]
) -> Sequence[HHandle]:
    """
    Calculate the convex hull of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    object_model_3dconvex_hull : Sequence[HHandle]
                                 Handle of the 3D object model that
                                 describes the convex hull.

    Predecessors
    ------------
    read_object_model_3d, connection_object_model_3d,
    select_points_object_model_3d

    Successors
    ----------
    project_object_model_3d
    """
    with HalconOperator(1078) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        object_model_3dconvex_hull = proc.get_output_tuple_m(0)
        return object_model_3dconvex_hull  # type: ignore


def convex_hull_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle]
) -> HHandle:
    """
    Calculate the convex hull of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    object_model_3dconvex_hull : HHandle
                                 Handle of the 3D object model that
                                 describes the convex hull.

    Predecessors
    ------------
    read_object_model_3d, connection_object_model_3d,
    select_points_object_model_3d

    Successors
    ----------
    project_object_model_3d
    """
    with HalconOperator(1078) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        object_model_3dconvex_hull = proc.get_output_tuple_s(0)
        return object_model_3dconvex_hull  # type: ignore


def convexity(regions: HObject) -> Sequence[float]:
    """
    Shape factor for the convexity of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    convexity : Sequence[float]
                Convexity of the input region(s).
                Assertion: Convexity <= 1

    See Also
    --------
    select_shape, area_center, shape_trans

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1724) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        convexity = proc.get_output_tuple_m(0)
        return convexity  # type: ignore


def convexity_s(regions: HObject) -> float:
    """
    Shape factor for the convexity of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    convexity : float
                Convexity of the input region(s).
                Assertion: Convexity <= 1

    See Also
    --------
    select_shape, area_center, shape_trans

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1724) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        convexity = proc.get_output_tuple_s(0)
        return convexity  # type: ignore


def convexity_xld(xld: HObject) -> Sequence[float]:
    """
    Shape factor for the convexity of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    convexity : Sequence[float]
                Convexity of the input contours or polygons.
                Assertion: Convexity <= 1

    See Also
    --------
    area_center_xld, select_shape_xld, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1683) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        convexity = proc.get_output_tuple_m(0)
        return convexity  # type: ignore


def convexity_xld_s(xld: HObject) -> float:
    """
    Shape factor for the convexity of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    convexity : float
                Convexity of the input contours or polygons.
                Assertion: Convexity <= 1

    See Also
    --------
    area_center_xld, select_shape_xld, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1683) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        convexity = proc.get_output_tuple_s(0)
        return convexity  # type: ignore


def convol_fft(image_fft: HObject, image_filter: HObject) -> HObject:
    """
    Convolve an image with a filter in the frequency domain.

    Parameters
    ----------

    image_fft : HObject
                Complex input image.

    image_filter : HObject
                   Filter in frequency domain.

    Returns
    -------

    image_convol : HObject
                   Result of applying the filter.

    See Also
    --------
    gen_gabor, gen_highpass, gen_lowpass, gen_bandpass, convol_gabor,
    fft_image_inv

    Alternatives
    ------------
    convol_gabor

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic, gen_highpass, gen_lowpass,
    gen_bandpass, gen_bandfilter

    Successors
    ----------
    power_byte, power_real, power_ln, fft_image_inv, fft_generic,
    rft_generic

    Notes
    -----
    The filtering is always done on the entire image, i.e., the domain of
    the image is ignored.
    """
    with HalconOperator(1534) as proc:
        proc.set_input_object(1, image_fft)
        proc.set_input_object(2, image_filter)
        proc.execute()
        image_convol = HObject(proc.get_output_object_key(1))
        return image_convol  # type: ignore


def convol_gabor(
    image_fft: HObject,
    gabor_filter: HObject
) -> Tuple[HObject, HObject]:
    """
    Convolve an image with a Gabor filter in the frequency domain.

    Parameters
    ----------

    image_fft : HObject
                Input image.

    gabor_filter : HObject
                   Gabor/Hilbert-Filter.

    Returns
    -------

    image_result_gabor : HObject
                         Result of the Gabor filter.

    image_result_hilbert : HObject
                           Result of the Hilbert filter.

    See Also
    --------
    convol_image

    Alternatives
    ------------
    convol_fft

    Predecessors
    ------------
    fft_image, fft_generic, gen_gabor

    Successors
    ----------
    power_byte, power_real, power_ln, fft_image_inv, fft_generic

    Notes
    -----
    The filtering is always done on the entire image, i.e., the domain of
    the image is ignored.
    """
    with HalconOperator(1530) as proc:
        proc.set_input_object(1, image_fft)
        proc.set_input_object(2, gabor_filter)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_result_gabor
            HObject(proc.get_output_object_key(2))   # image_result_hilbert
        )  # type: ignore


def convol_image(
    image: HObject,
    filter_mask: MaybeSequence[Union[int, float, str]],
    margin: Union[int, float, str]
) -> HObject:
    """
    Calculate the correlation between an image and an arbitrary filter mask

    Parameters
    ----------

    image : HObject
            Images for which the correlation will be calculated.

    filter_mask : MaybeSequence[Union[int, float, str]]
                  Filter mask as file name or tuple.
                  Value Suggestion: sobel

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_result : HObject
                   Result of the correlation.

    Notes
    -----
    Note that convol_image does not compute a convolution of the image
    with the given filter mask but a correlation, i.e., it uses the given
    filter mask directly, not a mirrored version of the filter mask.
    When using a 3x3 or 5x5 rectangular filter mask and the border
    treatment mirrored, convol_image can be executed on OpenCL devices.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1470) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter_mask)
        proc.set_input_tuple(1, margin)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def cooc_feature_image(
    regions: HObject,
    image: HObject,
    ld_gray: int,
    direction: Union[int, str]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate a co-occurrence matrix and derive gray value features
    thereof.

    Parameters
    ----------

    regions : HObject
              Region to be examined.

    image : HObject
            Corresponding gray values.

    ld_gray : int
              Number of gray values to be distinguished
              (2^LdGray$2^{LdGray}$).
              Value Suggestion: 6

    direction : Union[int, str]
                Direction in which the matrix is to be calculated.
                Value Suggestion: 0

    Returns
    -------

    energy : Sequence[float]
             Gray value energy.

    correlation : Sequence[float]
                  Correlation of gray values.

    homogeneity : Sequence[float]
                  Local homogeneity of gray values.

    contrast : Sequence[float]
               Gray value contrast.

    See Also
    --------
    intensity, min_max_gray, entropy_gray, select_gray

    Alternatives
    ------------
    cooc_feature_matrix

    Predecessors
    ------------
    gen_cooc_matrix

    Notes
    -----
    Note that the operator cooc_feature_image only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1759) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ld_gray)
        proc.set_input_tuple(1, direction)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # energy
            proc.get_output_tuple_m(1),  # correlation
            proc.get_output_tuple_m(2),  # homogeneity
            proc.get_output_tuple_m(3)   # contrast
        )  # type: ignore


def cooc_feature_image_s(
    regions: HObject,
    image: HObject,
    ld_gray: int,
    direction: Union[int, str]
) -> Tuple[float, float, float, float]:
    """
    Calculate a co-occurrence matrix and derive gray value features
    thereof.

    Parameters
    ----------

    regions : HObject
              Region to be examined.

    image : HObject
            Corresponding gray values.

    ld_gray : int
              Number of gray values to be distinguished
              (2^LdGray$2^{LdGray}$).
              Value Suggestion: 6

    direction : Union[int, str]
                Direction in which the matrix is to be calculated.
                Value Suggestion: 0

    Returns
    -------

    energy : float
             Gray value energy.

    correlation : float
                  Correlation of gray values.

    homogeneity : float
                  Local homogeneity of gray values.

    contrast : float
               Gray value contrast.

    See Also
    --------
    intensity, min_max_gray, entropy_gray, select_gray

    Alternatives
    ------------
    cooc_feature_matrix

    Predecessors
    ------------
    gen_cooc_matrix

    Notes
    -----
    Note that the operator cooc_feature_image only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1759) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ld_gray)
        proc.set_input_tuple(1, direction)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # energy
            proc.get_output_tuple_s(1),  # correlation
            proc.get_output_tuple_s(2),  # homogeneity
            proc.get_output_tuple_s(3)   # contrast
        )  # type: ignore


def cooc_feature_matrix(
    cooc_matrix: HObject
) -> Tuple[float, float, float, float]:
    """
    Calculate gray value features from a co-occurrence matrix.

    Parameters
    ----------

    cooc_matrix : HObject
                  Co-occurrence matrix.

    Returns
    -------

    energy : float
             Homogeneity of the gray values.

    correlation : float
                  Correlation of gray values.

    homogeneity : float
                  Local homogeneity of gray values.

    contrast : float
               Gray value contrast.

    See Also
    --------
    intensity, min_max_gray, entropy_gray, select_gray

    Alternatives
    ------------
    cooc_feature_image

    Predecessors
    ------------
    gen_cooc_matrix

    Notes
    -----
    The region of the input image is disregarded.
    """
    with HalconOperator(1758) as proc:
        proc.set_input_object(1, cooc_matrix)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # energy
            proc.get_output_tuple_s(1),  # correlation
            proc.get_output_tuple_s(2),  # homogeneity
            proc.get_output_tuple_s(3)   # contrast
        )  # type: ignore


def copy_dict(
    dict_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Copy a dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    copied_dict_handle : HHandle
                         Copied dictionary handle.

    See Also
    --------
    read_dict, write_dict, serialize_handle, deserialize_handle

    Predecessors
    ------------
    read_dict, deserialize_handle, create_dict

    Successors
    ----------
    write_dict
    """
    with HalconOperator(2148) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        copied_dict_handle = proc.get_output_tuple_s(0)
        return copied_dict_handle  # type: ignore


def copy_file(source_file: str, destination_file: str) -> None:
    """
    Copy a file to a new location.

    Parameters
    ----------

    source_file : str
                  File to be copied.

    destination_file : str
                       Target location.
    """
    with HalconOperator(1638) as proc:
        proc.set_input_tuple(0, source_file)
        proc.set_input_tuple(1, destination_file)
        proc.execute()


def copy_image(image: HObject) -> HObject:
    """
    Copy an image and allocate new memory for it.

    Parameters
    ----------

    image : HObject
            Image to be copied.

    Returns
    -------

    dup_image : HObject
                Copied image.

    See Also
    --------
    get_image_pointer1

    Alternatives
    ------------
    set_grayval, paint_gray, gen_image_const, gen_image_proto

    Predecessors
    ------------
    read_image, gen_image_const

    Successors
    ----------
    set_grayval, get_image_pointer1
    """
    with HalconOperator(586) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        dup_image = HObject(proc.get_output_object_key(1))
        return dup_image  # type: ignore


def copy_matrix(matrix_id: HHandle) -> HHandle:
    """
    Copy a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    matrix_copy_id : HHandle
                     Matrix handle of the copied matrix.

    Alternatives
    ------------
    repeat_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(886) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        matrix_copy_id = proc.get_output_tuple_s(0)
        return matrix_copy_id  # type: ignore


def copy_metrology_model(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]]
) -> int:
    """
    Copy a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    Returns
    -------

    copied_metrology_handle : int
                              Handle of the copied metrology model.
    """
    with HalconOperator(799) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        copied_metrology_handle = proc.get_output_tuple_s(0)
        return copied_metrology_handle  # type: ignore


def copy_metrology_object(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]]
) -> Sequence[int]:
    """
    Copy metrology metrology objects of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    Returns
    -------

    copied_indices : Sequence[int]
                     Indices of the copied metrology objects.

    Warnings
    --------
    copy_metrology_object is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(800) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        copied_indices = proc.get_output_tuple_m(0)
        return copied_indices  # type: ignore


def copy_metrology_object_s(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]]
) -> int:
    """
    Copy metrology metrology objects of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    Returns
    -------

    copied_indices : int
                     Indices of the copied metrology objects.

    Warnings
    --------
    copy_metrology_object is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(800) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        copied_indices = proc.get_output_tuple_s(0)
        return copied_indices  # type: ignore


def copy_obj(objects: HObject, index: int, num_obj: int) -> HObject:
    """
    Copy an iconic object in the HALCON database.

    Parameters
    ----------

    objects : HObject
              Objects to be copied.

    index : int
            Starting index of the objects to be copied.
            Value Suggestion: 1
            Assertion: Index <= number(Objects)

    num_obj : int
              Number of objects to be copied or -1.
              Value Suggestion: 1
              Assertion: NumObj + Index - 1 <= number(Objects) && NumObj != 0

    Returns
    -------

    objects_selected : HObject
                       Copied objects.

    See Also
    --------
    count_obj, concat_obj, obj_to_integer, copy_image

    Alternatives
    ------------
    select_obj

    Predecessors
    ------------
    count_obj
    """
    with HalconOperator(583) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_tuple(0, index)
        proc.set_input_tuple(1, num_obj)
        proc.execute()
        objects_selected = HObject(proc.get_output_object_key(1))
        return objects_selected  # type: ignore


def copy_object_model_3d(
    object_model_3d: HHandle,
    attributes: MaybeSequence[Union[str, float, int]]
) -> HHandle:
    """
    Copy a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the input 3D object model.

    attributes : MaybeSequence[Union[str, float, int]]
                 Attributes to be copied.
                 Value Suggestion: all

    Returns
    -------

    copied_object_model_3d : HHandle
                             Handle of the copied 3D object model.

    See Also
    --------
    remove_object_model_3d_attrib, set_object_model_3d_attrib

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    get_object_model_3d_params
    """
    with HalconOperator(1090) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attributes)
        proc.init_oct(0)
        proc.execute()
        copied_object_model_3d = proc.get_output_tuple_s(0)
        return copied_object_model_3d  # type: ignore


def copy_rectangle(
    window_handle_source: HHandle,
    window_handle_destination: HHandle,
    row_1: MaybeSequence[int],
    column_1: MaybeSequence[int],
    row_2: MaybeSequence[int],
    column_2: MaybeSequence[int],
    dest_row: MaybeSequence[int],
    dest_column: MaybeSequence[int]
) -> None:
    """
    Copy all pixels within rectangles between output windows.

    Parameters
    ----------

    window_handle_source : HHandle
                           Source window handle.

    window_handle_destination : HHandle
                                Destination window handle.

    row_1 : MaybeSequence[int]
            Row index of upper left corner in the source window.
            Value Suggestion: 0

    column_1 : MaybeSequence[int]
               Column index of upper left corner in the source window.
               Value Suggestion: 0

    row_2 : MaybeSequence[int]
            Row index of lower right corner in the source window.
            Value Suggestion: 128
            Assertion: Row2 >= Row1

    column_2 : MaybeSequence[int]
               Column index of lower right corner in the source window.
               Value Suggestion: 128
               Assertion: Column2 >= Column1

    dest_row : MaybeSequence[int]
               Row index of upper left corner in the target window.
               Value Suggestion: 0

    dest_column : MaybeSequence[int]
                  Column index of upper left corner in the target window.
                  Value Suggestion: 0

    See Also
    --------
    open_window

    Alternatives
    ------------
    move_rectangle, slide_image

    Predecessors
    ------------
    open_window

    Successors
    ----------
    close_window

    Notes
    -----
    Both windows have to reside on the same display.
    """
    with HalconOperator(1186) as proc:
        proc.set_input_tuple(0, window_handle_source)
        proc.set_input_tuple(1, window_handle_destination)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.set_input_tuple(6, dest_row)
        proc.set_input_tuple(7, dest_column)
        proc.execute()


def corner_response(
    image: HObject,
    size: int,
    weight: float
) -> HObject:
    """
    Searching corners in images.

    Parameters
    ----------

    image : HObject
            Input image.

    size : int
           Desired filtersize of the graymask.
           Value Suggestion: 3

    weight : float
             Weighting.
             Value Suggestion: 0.04

    Returns
    -------

    image_corner : HObject
                   Result of the filtering.

    See Also
    --------
    gauss_filter, sobel_amp, convert_image_type

    Successors
    ----------
    local_max, threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1507) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, size)
        proc.set_input_tuple(1, weight)
        proc.execute()
        image_corner = HObject(proc.get_output_object_key(1))
        return image_corner  # type: ignore


def correlation_fft(
    image_fft1: HObject,
    image_fft2: HObject
) -> HObject:
    """
    Compute the correlation of two images in the frequency domain.

    Parameters
    ----------

    image_fft1 : HObject
                 Fourier-transformed input image 1.

    image_fft2 : HObject
                 Fourier-transformed input image 2.

    Returns
    -------

    image_correlation : HObject
                        Correlation of the input images in the frequency
                        domain.

    Alternatives
    ------------
    phase_correlation_fft

    Predecessors
    ------------
    fft_generic, fft_image, rft_generic

    Successors
    ----------
    fft_generic, fft_image_inv, rft_generic

    Notes
    -----
    The filtering is always performed on the entire image, i.e., the
    domain of the image is ignored.
    """
    with HalconOperator(1533) as proc:
        proc.set_input_object(1, image_fft1)
        proc.set_input_object(2, image_fft2)
        proc.execute()
        image_correlation = HObject(proc.get_output_object_key(1))
        return image_correlation  # type: ignore


def cos_image(image: HObject) -> HObject:
    """
    Calculate the cosine of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    cos_image : HObject
                Output image.

    See Also
    --------
    sin_image, tan_image, asin_image, acos_image, atan_image, atan2_image

    Notes
    -----
    cos_image can be executed on OpenCL devices.
    """
    with HalconOperator(1602) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        cos_image = HObject(proc.get_output_object_key(1))
        return cos_image  # type: ignore


def count_channels(multi_channel_image: HObject) -> Sequence[int]:
    """
    Count channels of image.

    Parameters
    ----------

    multi_channel_image : HObject
                          One- or multi-channel image.

    Returns
    -------

    channels : Sequence[int]
               Number of channels.

    See Also
    --------
    append_channel, access_channel

    Successors
    ----------
    access_channel, append_channel, disp_image
    """
    with HalconOperator(1133) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.init_oct(0)
        proc.execute()
        channels = proc.get_output_tuple_m(0)
        return channels  # type: ignore


def count_channels_s(multi_channel_image: HObject) -> int:
    """
    Count channels of image.

    Parameters
    ----------

    multi_channel_image : HObject
                          One- or multi-channel image.

    Returns
    -------

    channels : int
               Number of channels.

    See Also
    --------
    append_channel, access_channel

    Successors
    ----------
    access_channel, append_channel, disp_image
    """
    with HalconOperator(1133) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.init_oct(0)
        proc.execute()
        channels = proc.get_output_tuple_s(0)
        return channels  # type: ignore


def count_obj(objects: HObject) -> int:
    """
    Number of objects in a tuple.

    Parameters
    ----------

    objects : HObject
              Objects to be examined.

    Returns
    -------

    number : int
             Number of objects in the tuple Objects.

    See Also
    --------
    copy_obj, obj_to_integer, connection, set_system
    """
    with HalconOperator(592) as proc:
        proc.set_input_object(1, objects)
        proc.init_oct(0)
        proc.execute()
        number = proc.get_output_tuple_s(0)
        return number  # type: ignore


def count_relation(relation_name: str) -> int:
    """
    Number of entries in the HALCON database.

    Parameters
    ----------

    relation_name : str
                    Relation of interest of the HALCON database.
                    Value Suggestion: object

    Returns
    -------

    num_of_tuples : int
                    Number of tuples in the relation.

    See Also
    --------
    clear_obj

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    set_system

    Notes
    -----
    Collecting database information is not threadsafe when passing iconic
    objects between threads, meaning when deleting objects in a different
    thread than generating them.
    """
    with HalconOperator(324) as proc:
        proc.set_input_tuple(0, relation_name)
        proc.init_oct(0)
        proc.execute()
        num_of_tuples = proc.get_output_tuple_s(0)
        return num_of_tuples  # type: ignore


def count_seconds() -> float:
    """
    Passed Time.

    Returns
    -------

    seconds : float
              Process time since the program start.

    See Also
    --------
    set_system

    Notes
    -----
    The time measurement is not exact and depends on the load of the
    computer.
    """
    with HalconOperator(323) as proc:
        proc.init_oct(0)
        proc.execute()
        seconds = proc.get_output_tuple_s(0)
        return seconds  # type: ignore


def create_aniso_shape_model(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: float,
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: float,
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    contrast: MaybeSequence[Union[int, str]],
    min_contrast: Union[int, str]
) -> HHandle:
    """
    Prepare an anisotropically scaled shape model for matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep >= 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in the row direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleRMin > 0

    scale_rmax : float
                 Maximum scale of the pattern in the row direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleRMax >= ScaleRMin

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in the row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep >= 0

    scale_cmin : float
                 Minimum scale of the pattern in the column direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleCMin > 0

    scale_cmax : float
                 Maximum scale of the pattern in the column direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleCMax >= ScaleCMin

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in the column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep >= 0

    optimization : MaybeSequence[str]
                   Kind of optimization and optionally method used for
                   generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : MaybeSequence[Union[int, str]]
               Threshold or hysteresis thresholds for the contrast of the
               object in the template image and optionally minimum size of
               the object parts.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    create_shape_model, create_scaled_shape_model

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    find_aniso_shape_model, find_aniso_shape_models,
    get_shape_model_params, clear_shape_model, write_shape_model,
    set_shape_model_origin, set_shape_model_clutter
    """
    with HalconOperator(938) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_rmin)
        proc.set_input_tuple(5, scale_rmax)
        proc.set_input_tuple(6, scale_rstep)
        proc.set_input_tuple(7, scale_cmin)
        proc.set_input_tuple(8, scale_cmax)
        proc.set_input_tuple(9, scale_cstep)
        proc.set_input_tuple(10, optimization)
        proc.set_input_tuple(11, metric)
        proc.set_input_tuple(12, contrast)
        proc.set_input_tuple(13, min_contrast)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_aniso_shape_model_xld(
    contours: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: float,
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: float,
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    min_contrast: int
) -> HHandle:
    """
    Prepare an anisotropically scaled shape model for matching from XLD
    contours.

    Parameters
    ----------

    contours : HObject
               Input contours that will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in the row direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleRMin > 0

    scale_rmax : float
                 Maximum scale of the pattern in the row direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleRMax >= ScaleRMin

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in the row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep > 0

    scale_cmin : float
                 Minimum scale of the pattern in the column direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleCMin > 0

    scale_cmax : float
                 Maximum scale of the pattern in the column direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleCMax >= ScaleCMin

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in the column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep > 0

    optimization : MaybeSequence[str]
                   Kind of optimization and optionally method used for
                   generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: ignore_local_polarity

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 5

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    create_shape_model_xld, create_scaled_shape_model_xld

    Predecessors
    ------------
    read_contour_xld_dxf, edges_sub_pix, select_contours_xld

    Successors
    ----------
    find_aniso_shape_model, find_aniso_shape_models,
    get_shape_model_params, clear_shape_model, write_shape_model,
    set_shape_model_origin, set_shape_model_param, set_shape_model_metric,
    set_shape_model_clutter

    Notes
    -----
    The XLD contours passed in Contours should have been scaled to
    approximately the average size of the object in the search images.
    This means that the products $ScaleRMin
    arRef{ScaleRMax}$ScaleRMin*ScaleRMax and $ScaleCMin
    arRef{ScaleCMax}$ScaleCMin*ScaleCMax should be approximately equal to
    1.
    Note that, in contrast to the operator create_aniso_shape_model, it is
    not possible to specify a minimum size of the model components. To
    avoid small model components in the shape model, short contours can be
    eliminated before calling create_aniso_shape_model_xld with the
    operator select_contours_xld.
    """
    with HalconOperator(935) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_rmin)
        proc.set_input_tuple(5, scale_rmax)
        proc.set_input_tuple(6, scale_rstep)
        proc.set_input_tuple(7, scale_cmin)
        proc.set_input_tuple(8, scale_cmax)
        proc.set_input_tuple(9, scale_cstep)
        proc.set_input_tuple(10, optimization)
        proc.set_input_tuple(11, metric)
        proc.set_input_tuple(12, min_contrast)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_bar_code_model(
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> HHandle:
    """
    Create a model of a bar code reader.

    Parameters
    ----------

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the bar code model.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Values of the generic parameters that can be
                      adjusted for the bar code model.
                      Value Suggestion: []

    Returns
    -------

    bar_code_handle : HHandle
                      Handle for using and accessing the bar code model.

    See Also
    --------
    clear_bar_code_model

    Successors
    ----------
    find_bar_code
    """
    with HalconOperator(2001) as proc:
        proc.set_input_tuple(0, gen_param_name)
        proc.set_input_tuple(1, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        bar_code_handle = proc.get_output_tuple_s(0)
        return bar_code_handle  # type: ignore


def create_barrier(
    attrib_name: MaybeSequence[Union[int, float, str]],
    attrib_value: MaybeSequence[Union[int, float, str]],
    team_size: int
) -> HHandle:
    """
    Create a barrier synchronization object.

    Parameters
    ----------

    attrib_name : MaybeSequence[Union[int, float, str]]
                  Barrier attribute.
                  Value Suggestion: []

    attrib_value : MaybeSequence[Union[int, float, str]]
                   Barrier attribute value.
                   Value Suggestion: []

    team_size : int
                Barrier team size.
                Value Suggestion: 1

    Returns
    -------

    barrier_handle : HHandle
                     Barrier synchronization object.

    Successors
    ----------
    wait_barrier, clear_barrier
    """
    with HalconOperator(552) as proc:
        proc.set_input_tuple(0, attrib_name)
        proc.set_input_tuple(1, attrib_value)
        proc.set_input_tuple(2, team_size)
        proc.init_oct(0)
        proc.execute()
        barrier_handle = proc.get_output_tuple_s(0)
        return barrier_handle  # type: ignore


def create_bead_inspection_model(
    bead_contour: HObject,
    target_thickness: Union[int, float],
    thickness_tolerance: Union[int, float],
    position_tolerance: Union[int, float],
    polarity: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a model to inspect beads or adhesive in images.

    Parameters
    ----------

    bead_contour : HObject
                   XLD contour specifying the expected bead's shape and
                   position.

    target_thickness : Union[int, float]
                       Optimal bead thickness.
                       Value Suggestion: 50

    thickness_tolerance : Union[int, float]
                          Tolerance of bead's thickness with respect to
                          TargetThickness.
                          Value Suggestion: 15

    position_tolerance : Union[int, float]
                         Tolerance of the bead's center position.
                         Value Suggestion: 15

    polarity : str
               The bead's polarity.
               Value Suggestion: light

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the bead inspection model.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the generic parameters that can be
                      adjusted for the bead inspection model.
                      Value Suggestion: []

    Returns
    -------

    bead_inspection_model : HHandle
                            Handle for using and accessing the bead
                            inspection  model.

    See Also
    --------
    clear_bead_inspection_model

    Predecessors
    ------------
    gen_contour_nurbs_xld, gen_contour_polygon_xld

    Successors
    ----------
    apply_bead_inspection_model, set_bead_inspection_param
    """
    with HalconOperator(1985) as proc:
        proc.set_input_object(1, bead_contour)
        proc.set_input_tuple(0, target_thickness)
        proc.set_input_tuple(1, thickness_tolerance)
        proc.set_input_tuple(2, position_tolerance)
        proc.set_input_tuple(3, polarity)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        bead_inspection_model = proc.get_output_tuple_s(0)
        return bead_inspection_model  # type: ignore


def create_bg_esti(
    initialize_image: HObject,
    syspar_1: float,
    syspar_2: float,
    gain_mode: str,
    gain_1: float,
    gain_2: float,
    adapt_mode: str,
    min_diff: float,
    stat_num: int,
    confidence_c: float,
    time_c: float
) -> HHandle:
    """
    Generate and initialize a data set for the background estimation.

    Parameters
    ----------

    initialize_image : HObject
                       initialization image.

    syspar_1 : float
               1. system matrix parameter.
               Value Suggestion: 0.7

    syspar_2 : float
               2. system matrix parameter.
               Value Suggestion: 0.7

    gain_mode : str
                Gain type.
                Value Suggestion: fixed

    gain_1 : float
             Kalman gain / foreground adaptation time.
             Value Suggestion: 0.002
             Assertion: 0.0 <= Gain1

    gain_2 : float
             Kalman gain / background adaptation time.
             Value Suggestion: 0.02
             Assertion: 0.0 <= Gain2

    adapt_mode : str
                 Threshold adaptation.
                 Value Suggestion: on

    min_diff : float
               Foreground/background threshold.
               Value Suggestion: 7.0

    stat_num : int
               Number of statistic data sets.
               Value Suggestion: 10

    confidence_c : float
                   Confidence constant.
                   Value Suggestion: 3.25
                   Assertion: 0.0 < ConfidenceC

    time_c : float
             Constant for decay time.
             Value Suggestion: 15.0
             Assertion: 0.0 < TimeC

    Returns
    -------

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    See Also
    --------
    set_bg_esti_params, close_bg_esti

    Successors
    ----------
    run_bg_esti

    Notes
    -----
    If GainMode was set to 'frame', the run-time can be extremely long for
    large values of Gain1 or Gain2, because the values for the gains'
    table are determined by a simple binary search.
    """
    with HalconOperator(2008) as proc:
        proc.set_input_object(1, initialize_image)
        proc.set_input_tuple(0, syspar_1)
        proc.set_input_tuple(1, syspar_2)
        proc.set_input_tuple(2, gain_mode)
        proc.set_input_tuple(3, gain_1)
        proc.set_input_tuple(4, gain_2)
        proc.set_input_tuple(5, adapt_mode)
        proc.set_input_tuple(6, min_diff)
        proc.set_input_tuple(7, stat_num)
        proc.set_input_tuple(8, confidence_c)
        proc.set_input_tuple(9, time_c)
        proc.init_oct(0)
        proc.execute()
        bg_esti_handle = proc.get_output_tuple_s(0)
        return bg_esti_handle  # type: ignore


def create_calib_data(
    calib_setup: str,
    num_cameras: int,
    num_calib_objects: int
) -> HHandle:
    """
    Create a HALCON calibration data model.

    Parameters
    ----------

    calib_setup : str
                  Type of the calibration setup.
                  Value Suggestion: calibration_object

    num_cameras : int
                  Number of cameras in the calibration setup.
                  Value Suggestion: 1
                  Assertion: NumCameras >= 0

    num_calib_objects : int
                        Number of calibration objects.
                        Value Suggestion: 1
                        Assertion: NumCalibObjects >= 0

    Returns
    -------

    calib_data_id : HHandle
                    Handle of the created calibration data model.

    Successors
    ----------
    set_calib_data_cam_param, set_calib_data_calib_object
    """
    with HalconOperator(1980) as proc:
        proc.set_input_tuple(0, calib_setup)
        proc.set_input_tuple(1, num_cameras)
        proc.set_input_tuple(2, num_calib_objects)
        proc.init_oct(0)
        proc.execute()
        calib_data_id = proc.get_output_tuple_s(0)
        return calib_data_id  # type: ignore


def create_calib_descriptor_model(
    template: HObject,
    cam_param: Sequence[Union[float, int, str]],
    reference_pose: Sequence[Union[float, int]],
    detector_type: str,
    detector_param_name: Sequence[str],
    detector_param_value: Sequence[Union[int, float, str]],
    descriptor_param_name: Sequence[str],
    descriptor_param_value: Sequence[Union[int, float, str]],
    seed: int
) -> HHandle:
    """
    Create a descriptor model for calibrated perspective matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    cam_param : Sequence[Union[float, int, str]]
                The parameters of the internal orientation of the camera.

    reference_pose : Sequence[Union[float, int]]
                     The reference pose of the object in the reference
                     image.

    detector_type : str
                    The type of the detector.
                    Value Suggestion: lepetit

    detector_param_name : Sequence[str]
                          The detector's parameter names.
                          Value Suggestion: []

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detector's parameters.
                           Value Suggestion: []

    descriptor_param_name : Sequence[str]
                            The descriptor's parameter names.
                            Value Suggestion: []

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptor's parameters.
                             Value Suggestion: []

    seed : int
           The seed for the random number generator.
           Value Suggestion: 42

    Returns
    -------

    model_id : HHandle
               The handle to the descriptor model.

    See Also
    --------
    get_descriptor_model_params, find_calib_descriptor_model

    Predecessors
    ------------
    points_lepetit, points_harris, reduce_domain

    Successors
    ----------
    get_descriptor_model_params, find_calib_descriptor_model
    """
    with HalconOperator(952) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, cam_param)
        proc.set_input_tuple(1, reference_pose)
        proc.set_input_tuple(2, detector_type)
        proc.set_input_tuple(3, detector_param_name)
        proc.set_input_tuple(4, detector_param_value)
        proc.set_input_tuple(5, descriptor_param_name)
        proc.set_input_tuple(6, descriptor_param_value)
        proc.set_input_tuple(7, seed)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_caltab(
    num_rows: int,
    marks_per_row: int,
    diameter: float,
    finder_row: MaybeSequence[int],
    finder_column: MaybeSequence[int],
    polarity: str,
    cal_plate_descr: str,
    cal_plate_psfile: str
) -> None:
    """
    Generate a calibration plate description file and a corresponding
    PostScript file for a calibration plate with hexagonally arranged
    marks.

    Parameters
    ----------

    num_rows : int
               Number of rows.
               Value Suggestion: 27
               Assertion: NumRows > 2

    marks_per_row : int
                    Number of marks per row.
                    Value Suggestion: 31
                    Assertion: MarksPerRow > 2

    diameter : float
               Diameter of the marks.
               Value Suggestion: 0.00258065

    finder_row : MaybeSequence[int]
                 Row indices of the finder patterns.
                 Value Suggestion: [13,6,6,20,20]

    finder_column : MaybeSequence[int]
                    Column indices of the finder patterns.
                    Value Suggestion: [15,6,24,6,24]

    polarity : str
               Polarity of the marks
               Value Suggestion: 'light_on_dark'

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: calplate.cpd

    cal_plate_psfile : str
                       File name of the PostScript file.
                       Value Suggestion: calplate.ps

    See Also
    --------
    find_caltab, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab

    Alternatives
    ------------
    gen_caltab

    Successors
    ----------
    read_cam_par, caltab_points

    Notes
    -----
    Depending on the accuracy of the used output device (e.g., laser
    printer), a printed calibration plate may not match the values in the
    calibration plate description file CalPlateDescr exactly. Thus, the
    coordinates of the calibration marks in the calibration plate
    description file may have to be corrected!
    """
    with HalconOperator(1927) as proc:
        proc.set_input_tuple(0, num_rows)
        proc.set_input_tuple(1, marks_per_row)
        proc.set_input_tuple(2, diameter)
        proc.set_input_tuple(3, finder_row)
        proc.set_input_tuple(4, finder_column)
        proc.set_input_tuple(5, polarity)
        proc.set_input_tuple(6, cal_plate_descr)
        proc.set_input_tuple(7, cal_plate_psfile)
        proc.execute()


def create_cam_pose_look_at_point(
    cam_pos_x: MaybeSequence[float],
    cam_pos_y: MaybeSequence[float],
    cam_pos_z: MaybeSequence[float],
    look_at_x: MaybeSequence[float],
    look_at_y: MaybeSequence[float],
    look_at_z: MaybeSequence[float],
    ref_plane_normal: Sequence[Union[str, float]],
    cam_roll: MaybeSequence[float]
) -> Sequence[Union[int, float]]:
    """
    Create a 3D camera pose from camera center and viewing direction.

    Parameters
    ----------

    cam_pos_x : MaybeSequence[float]
                X coordinate of the optical center of the camera.

    cam_pos_y : MaybeSequence[float]
                Y coordinate of the optical center of the camera.

    cam_pos_z : MaybeSequence[float]
                Z coordinate of the optical center of the camera.

    look_at_x : MaybeSequence[float]
                X coordinate of the 3D point to which the camera is
                directed.

    look_at_y : MaybeSequence[float]
                Y coordinate of the 3D point to which the camera is
                directed.

    look_at_z : MaybeSequence[float]
                Z coordinate of the 3D point to which the camera is
                directed.

    ref_plane_normal : Sequence[Union[str, float]]
                       Normal vector of the reference plane (points up).
                       Value Suggestion: -y

    cam_roll : MaybeSequence[float]
               Camera roll angle.
               Value Suggestion: 0

    Returns
    -------

    cam_pose : Sequence[Union[int, float]]
               3D camera pose.

    Alternatives
    ------------
    create_pose

    Predecessors
    ------------
    convert_point_3d_spher_to_cart
    """
    with HalconOperator(1045) as proc:
        proc.set_input_tuple(0, cam_pos_x)
        proc.set_input_tuple(1, cam_pos_y)
        proc.set_input_tuple(2, cam_pos_z)
        proc.set_input_tuple(3, look_at_x)
        proc.set_input_tuple(4, look_at_y)
        proc.set_input_tuple(5, look_at_z)
        proc.set_input_tuple(6, ref_plane_normal)
        proc.set_input_tuple(7, cam_roll)
        proc.init_oct(0)
        proc.execute()
        cam_pose = proc.get_output_tuple_m(0)
        return cam_pose  # type: ignore


def create_camera_setup_model(num_cameras: int) -> HHandle:
    """
    Create a model for a setup of calibrated cameras.

    Parameters
    ----------

    num_cameras : int
                  Number of cameras in the setup.
                  Value Suggestion: 2
                  Assertion: NumCameras >= 1

    Returns
    -------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    Successors
    ----------
    set_camera_setup_param
    """
    with HalconOperator(1958) as proc:
        proc.set_input_tuple(0, num_cameras)
        proc.init_oct(0)
        proc.execute()
        camera_setup_model_id = proc.get_output_tuple_s(0)
        return camera_setup_model_id  # type: ignore


def create_class_box() -> HHandle:
    """
    Create a new classifier.

    Returns
    -------

    classif_handle : HHandle
                     Handle of the classifier.

    See Also
    --------
    learn_class_box, enquire_class_box, close_class_box

    Successors
    ----------
    learn_class_box, enquire_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    create_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1895) as proc:
        proc.init_oct(0)
        proc.execute()
        classif_handle = proc.get_output_tuple_s(0)
        return classif_handle  # type: ignore


def create_class_gmm(
    num_dim: int,
    num_classes: int,
    num_centers: MaybeSequence[int],
    covar_type: str,
    preprocessing: str,
    num_components: int,
    rand_seed: int
) -> HHandle:
    """
    Create a Gaussian Mixture Model for classification

    Parameters
    ----------

    num_dim : int
              Number of dimensions of the feature space.
              Value Suggestion: 3
              Assertion: NumDim >= 1

    num_classes : int
                  Number of classes of the GMM.
                  Value Suggestion: 5
                  Assertion: NumClasses >= 1

    num_centers : MaybeSequence[int]
                  Number of centers per class.
                  Value Suggestion: 1
                  Assertion: NumClasses >= 1

    covar_type : str
                 Type of the covariance matrices.
                 Value Suggestion: spherical

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: normalization

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').
                     Value Suggestion: 10
                     Assertion: NumComponents >= 1

    rand_seed : int
                Seed value of the random number generator that is used to
                initialize the GMM with random values.
                Value Suggestion: 42

    Returns
    -------

    gmmhandle : HHandle
                GMM handle.

    See Also
    --------
    clear_class_gmm, train_class_gmm, classify_class_gmm,
    evaluate_class_gmm, classify_image_class_gmm

    Alternatives
    ------------
    create_class_mlp, create_class_svm

    Successors
    ----------
    add_sample_class_gmm, add_samples_image_class_gmm
    """
    with HalconOperator(1840) as proc:
        proc.set_input_tuple(0, num_dim)
        proc.set_input_tuple(1, num_classes)
        proc.set_input_tuple(2, num_centers)
        proc.set_input_tuple(3, covar_type)
        proc.set_input_tuple(4, preprocessing)
        proc.set_input_tuple(5, num_components)
        proc.set_input_tuple(6, rand_seed)
        proc.init_oct(0)
        proc.execute()
        gmmhandle = proc.get_output_tuple_s(0)
        return gmmhandle  # type: ignore


def create_class_knn(num_dim: Sequence[int]) -> HHandle:
    """
    Create a k-nearest neighbors (k-NN) classifier.

    Parameters
    ----------

    num_dim : Sequence[int]
              Number of dimensions of the feature.
              Value Suggestion: 10

    Returns
    -------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    See Also
    --------
    select_feature_set_knn, read_class_knn

    Alternatives
    ------------
    create_class_svm, create_class_mlp

    Successors
    ----------
    add_sample_class_knn, train_class_knn
    """
    with HalconOperator(1816) as proc:
        proc.set_input_tuple(0, num_dim)
        proc.init_oct(0)
        proc.execute()
        knnhandle = proc.get_output_tuple_s(0)
        return knnhandle  # type: ignore


def create_class_lut_gmm(
    gmmhandle: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HHandle:
    """
    Create a look-up table using a gaussian mixture model to classify byte
    images.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the LUT classifier creation.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters that can be
                      adjusted for the LUT classifier creation.
                      Value Suggestion: []

    Returns
    -------

    class_luthandle : HHandle
                      Handle of the LUT classifier.

    See Also
    --------
    classify_image_class_lut, clear_class_lut

    Alternatives
    ------------
    create_class_lut_knn, create_class_lut_mlp, create_class_lut_svm

    Predecessors
    ------------
    train_class_gmm, read_class_gmm

    Successors
    ----------
    classify_image_class_lut
    """
    with HalconOperator(1820) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        class_luthandle = proc.get_output_tuple_s(0)
        return class_luthandle  # type: ignore


def create_class_lut_knn(
    knnhandle: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HHandle:
    """
    Create a look-up table using a k-nearest neighbors classifier (k-NN)
    to classify byte images.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the LUT classifier creation.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters that can be
                      adjusted for the LUT classifier creation.
                      Value Suggestion: []

    Returns
    -------

    class_luthandle : HHandle
                      Handle of the LUT classifier.

    See Also
    --------
    classify_image_class_lut, clear_class_lut

    Alternatives
    ------------
    create_class_lut_svm, create_class_lut_gmm, create_class_lut_mlp

    Predecessors
    ------------
    train_class_knn, read_class_knn

    Successors
    ----------
    classify_image_class_lut
    """
    with HalconOperator(1819) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        class_luthandle = proc.get_output_tuple_s(0)
        return class_luthandle  # type: ignore


def create_class_lut_mlp(
    mlphandle: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HHandle:
    """
    Create a look-up table using a multi-layer perceptron to classify byte
    images.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the LUT classifier creation.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters that can be
                      adjusted for the LUT classifier creation.
                      Value Suggestion: []

    Returns
    -------

    class_luthandle : HHandle
                      Handle of the LUT classifier.

    See Also
    --------
    classify_image_class_lut, clear_class_lut

    Alternatives
    ------------
    create_class_lut_gmm, create_class_lut_knn, create_class_lut_svm

    Predecessors
    ------------
    train_class_mlp, read_class_mlp

    Successors
    ----------
    classify_image_class_lut
    """
    with HalconOperator(1822) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        class_luthandle = proc.get_output_tuple_s(0)
        return class_luthandle  # type: ignore


def create_class_lut_svm(
    svmhandle: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int]]
) -> HHandle:
    """
    Create a look-up table using a Support-Vector-Machine to classify byte
    images.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the LUT classifier creation.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int]]
                      Values of the generic parameters that can be
                      adjusted for the LUT classifier creation.
                      Value Suggestion: []

    Returns
    -------

    class_luthandle : HHandle
                      Handle of the LUT classifier.

    See Also
    --------
    classify_image_class_lut, clear_class_lut

    Alternatives
    ------------
    create_class_lut_gmm, create_class_lut_knn, create_class_lut_mlp

    Predecessors
    ------------
    train_class_svm, read_class_svm

    Successors
    ----------
    classify_image_class_lut
    """
    with HalconOperator(1821) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        class_luthandle = proc.get_output_tuple_s(0)
        return class_luthandle  # type: ignore


def create_class_mlp(
    num_input: int,
    num_hidden: int,
    num_output: int,
    output_function: str,
    preprocessing: str,
    num_components: int,
    rand_seed: int
) -> HHandle:
    """
    Create a multilayer perceptron for classification or regression.

    Parameters
    ----------

    num_input : int
                Number of input variables (features) of the MLP.
                Value Suggestion: 20
                Assertion: NumInput >= 1

    num_hidden : int
                 Number of hidden units of the MLP.
                 Value Suggestion: 10
                 Assertion: NumHidden >= 1

    num_output : int
                 Number of output variables (classes) of the MLP.
                 Value Suggestion: 5
                 Assertion: NumOutput >= 1

    output_function : str
                      Type of the activation function in the output layer
                      of the MLP.
                      Value Suggestion: softmax

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: normalization

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').
                     Value Suggestion: 10
                     Assertion: NumComponents >= 1

    rand_seed : int
                Seed value of the random number generator that is used to
                initialize the MLP with random values.
                Value Suggestion: 42

    Returns
    -------

    mlphandle : HHandle
                MLP handle.

    See Also
    --------
    clear_class_mlp, train_class_mlp, classify_class_mlp,
    evaluate_class_mlp

    Alternatives
    ------------
    read_dl_classifier, create_class_svm, create_class_gmm

    Successors
    ----------
    add_sample_class_mlp, set_regularization_params_class_mlp,
    set_rejection_params_class_mlp
    """
    with HalconOperator(1883) as proc:
        proc.set_input_tuple(0, num_input)
        proc.set_input_tuple(1, num_hidden)
        proc.set_input_tuple(2, num_output)
        proc.set_input_tuple(3, output_function)
        proc.set_input_tuple(4, preprocessing)
        proc.set_input_tuple(5, num_components)
        proc.set_input_tuple(6, rand_seed)
        proc.init_oct(0)
        proc.execute()
        mlphandle = proc.get_output_tuple_s(0)
        return mlphandle  # type: ignore


def create_class_svm(
    num_features: int,
    kernel_type: str,
    kernel_param: float,
    nu: float,
    num_classes: int,
    mode: str,
    preprocessing: str,
    num_components: int
) -> HHandle:
    """
    Create a support vector machine for pattern classification.

    Parameters
    ----------

    num_features : int
                   Number of input variables (features) of the SVM.
                   Value Suggestion: 10
                   Assertion: NumFeatures >= 1

    kernel_type : str
                  The kernel type.
                  Value Suggestion: rbf

    kernel_param : float
                   Additional parameter for the kernel function. In case
                   of RBF kernel the value for gamma$- For polynomial
                   kernel the degree
                   Value Suggestion: 0.02

    nu : float
         Regularization constant of the SVM.
         Value Suggestion: 0.05
         Assertion: Nu > 0.0 && Nu < 1.0

    num_classes : int
                  Number of classes.
                  Value Suggestion: 5
                  Assertion: NumClasses >= 1

    mode : str
           The mode of the SVM.
           Value Suggestion: one-versus-one

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: normalization

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').
                     Value Suggestion: 10
                     Assertion: NumComponents >= 1

    Returns
    -------

    svmhandle : HHandle
                SVM handle.

    See Also
    --------
    clear_class_svm, train_class_svm, classify_class_svm

    Alternatives
    ------------
    read_dl_classifier, create_class_mlp, create_class_gmm

    Successors
    ----------
    add_sample_class_svm
    """
    with HalconOperator(1861) as proc:
        proc.set_input_tuple(0, num_features)
        proc.set_input_tuple(1, kernel_type)
        proc.set_input_tuple(2, kernel_param)
        proc.set_input_tuple(3, nu)
        proc.set_input_tuple(4, num_classes)
        proc.set_input_tuple(5, mode)
        proc.set_input_tuple(6, preprocessing)
        proc.set_input_tuple(7, num_components)
        proc.init_oct(0)
        proc.execute()
        svmhandle = proc.get_output_tuple_s(0)
        return svmhandle  # type: ignore


def create_class_train_data(num_dim: int) -> HHandle:
    """
    Create a handle for training data for classifiers.

    Parameters
    ----------

    num_dim : int
              Number of dimensions of the feature vector.
              Value Suggestion: 10

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data.

    See Also
    --------
    select_feature_set_knn, read_class_knn

    Alternatives
    ------------
    create_class_svm, create_class_mlp

    Successors
    ----------
    add_sample_class_knn, train_class_knn
    """
    with HalconOperator(1798) as proc:
        proc.set_input_tuple(0, num_dim)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def create_color_trans_lut(
    color_space: str,
    trans_direction: str,
    num_bits: int
) -> HHandle:
    """
    Creates the look-up-table for transformation of an image from the RGB
    color space to an arbitrary color space.

    Parameters
    ----------

    color_space : str
                  Color space of the output image.
                  Value Suggestion: hsv

    trans_direction : str
                      Direction of color space transformation.
                      Value Suggestion: from_rgb

    num_bits : int
               Number of bits of the input image.
               Value Suggestion: 8

    Returns
    -------

    color_trans_luthandle : HHandle
                            Handle of the look-up-table for color space
                            transformation.

    See Also
    --------
    apply_color_trans_lut, clear_color_trans_lut

    Successors
    ----------
    apply_color_trans_lut
    """
    with HalconOperator(1579) as proc:
        proc.set_input_tuple(0, color_space)
        proc.set_input_tuple(1, trans_direction)
        proc.set_input_tuple(2, num_bits)
        proc.init_oct(0)
        proc.execute()
        color_trans_luthandle = proc.get_output_tuple_s(0)
        return color_trans_luthandle  # type: ignore


def create_component_model(
    model_image: HObject,
    component_regions: HObject,
    variation_row: MaybeSequence[int],
    variation_column: MaybeSequence[int],
    variation_angle: MaybeSequence[float],
    angle_start: float,
    angle_extent: float,
    contrast_low_comp: MaybeSequence[Union[int, str]],
    contrast_high_comp: MaybeSequence[Union[int, str]],
    min_size_comp: MaybeSequence[Union[int, str]],
    min_contrast_comp: MaybeSequence[Union[int, str]],
    min_score_comp: MaybeSequence[float],
    num_levels_comp: MaybeSequence[Union[int, str]],
    angle_step_comp: MaybeSequence[Union[float, str]],
    optimization_comp: str,
    metric_comp: MaybeSequence[str],
    pregeneration_comp: MaybeSequence[str]
) -> Tuple[HHandle, Sequence[int]]:
    """
    Prepare a component model for matching based on explicitly specified
    components and relations.

    Parameters
    ----------

    model_image : HObject
                  Input image from which the shape models of the model
                  components should be created.

    component_regions : HObject
                        Input regions from which the shape models of the
                        model components should be created.

    variation_row : MaybeSequence[int]
                    Variation of the model components in row direction.
                    Assertion: VariationRow >= 0

    variation_column : MaybeSequence[int]
                       Variation of the model components in column
                       direction.
                       Assertion: VariationColumn >= 0

    variation_angle : MaybeSequence[float]
                      Angle variation of the model components.
                      Assertion: VariationAngle >= 0

    angle_start : float
                  Smallest rotation of the component model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation of the component model.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    contrast_low_comp : MaybeSequence[Union[int, str]]
                        Lower hysteresis threshold for the contrast of the
                        components in the model image.
                        Value Suggestion: auto
                        Assertion: ContrastLowComp > 0

    contrast_high_comp : MaybeSequence[Union[int, str]]
                         Upper hysteresis threshold for the contrast of
                         the components in the model image.
                         Value Suggestion: auto
                         Assertion: ContrastHighComp > 0 && ContrastHighComp >= ContrastLowComp

    min_size_comp : MaybeSequence[Union[int, str]]
                    Minimum size of the contour regions in the model.
                    Value Suggestion: auto
                    Assertion: MinSizeComp >= 0

    min_contrast_comp : MaybeSequence[Union[int, str]]
                        Minimum contrast of the components in the search
                        images.
                        Value Suggestion: auto
                        Assertion: MinContrastComp <= ContrastLowComp && MinContrastComp >= 0

    min_score_comp : MaybeSequence[float]
                     Minimum score of the instances of the components to
                     be found.
                     Value Suggestion: 0.5
                     Assertion: 0 <= MinScoreComp && MinScoreComp <= 1

    num_levels_comp : MaybeSequence[Union[int, str]]
                      Maximum number of pyramid levels for the components.
                      Value Suggestion: auto

    angle_step_comp : MaybeSequence[Union[float, str]]
                      Step length of the angles (resolution) for the
                      components.
                      Value Suggestion: auto
                      Assertion: AngleStepComp >= 0

    optimization_comp : str
                        Kind of optimization for the components.
                        Value Suggestion: auto

    metric_comp : MaybeSequence[str]
                  Match metric used for the components.
                  Value Suggestion: use_polarity

    pregeneration_comp : MaybeSequence[str]
                         Complete pregeneration of the shape models for
                         the components if equal to 'true'.
                         Value Suggestion: false

    Returns
    -------

    component_model_id : HHandle
                         Handle of the component model.

    root_ranking : Sequence[int]
                   Ranking of the model components expressing the
                   suitability to act as the root component.

    See Also
    --------
    create_shape_model, find_shape_model

    Alternatives
    ------------
    create_trained_component_model

    Predecessors
    ------------
    draw_region, concat_obj

    Successors
    ----------
    find_component_model
    """
    with HalconOperator(1004) as proc:
        proc.set_input_object(1, model_image)
        proc.set_input_object(2, component_regions)
        proc.set_input_tuple(0, variation_row)
        proc.set_input_tuple(1, variation_column)
        proc.set_input_tuple(2, variation_angle)
        proc.set_input_tuple(3, angle_start)
        proc.set_input_tuple(4, angle_extent)
        proc.set_input_tuple(5, contrast_low_comp)
        proc.set_input_tuple(6, contrast_high_comp)
        proc.set_input_tuple(7, min_size_comp)
        proc.set_input_tuple(8, min_contrast_comp)
        proc.set_input_tuple(9, min_score_comp)
        proc.set_input_tuple(10, num_levels_comp)
        proc.set_input_tuple(11, angle_step_comp)
        proc.set_input_tuple(12, optimization_comp)
        proc.set_input_tuple(13, metric_comp)
        proc.set_input_tuple(14, pregeneration_comp)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # component_model_id
            proc.get_output_tuple_m(1)   # root_ranking
        )  # type: ignore


def create_component_model_s(
    model_image: HObject,
    component_regions: HObject,
    variation_row: MaybeSequence[int],
    variation_column: MaybeSequence[int],
    variation_angle: MaybeSequence[float],
    angle_start: float,
    angle_extent: float,
    contrast_low_comp: MaybeSequence[Union[int, str]],
    contrast_high_comp: MaybeSequence[Union[int, str]],
    min_size_comp: MaybeSequence[Union[int, str]],
    min_contrast_comp: MaybeSequence[Union[int, str]],
    min_score_comp: MaybeSequence[float],
    num_levels_comp: MaybeSequence[Union[int, str]],
    angle_step_comp: MaybeSequence[Union[float, str]],
    optimization_comp: str,
    metric_comp: MaybeSequence[str],
    pregeneration_comp: MaybeSequence[str]
) -> Tuple[HHandle, int]:
    """
    Prepare a component model for matching based on explicitly specified
    components and relations.

    Parameters
    ----------

    model_image : HObject
                  Input image from which the shape models of the model
                  components should be created.

    component_regions : HObject
                        Input regions from which the shape models of the
                        model components should be created.

    variation_row : MaybeSequence[int]
                    Variation of the model components in row direction.
                    Assertion: VariationRow >= 0

    variation_column : MaybeSequence[int]
                       Variation of the model components in column
                       direction.
                       Assertion: VariationColumn >= 0

    variation_angle : MaybeSequence[float]
                      Angle variation of the model components.
                      Assertion: VariationAngle >= 0

    angle_start : float
                  Smallest rotation of the component model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation of the component model.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    contrast_low_comp : MaybeSequence[Union[int, str]]
                        Lower hysteresis threshold for the contrast of the
                        components in the model image.
                        Value Suggestion: auto
                        Assertion: ContrastLowComp > 0

    contrast_high_comp : MaybeSequence[Union[int, str]]
                         Upper hysteresis threshold for the contrast of
                         the components in the model image.
                         Value Suggestion: auto
                         Assertion: ContrastHighComp > 0 && ContrastHighComp >= ContrastLowComp

    min_size_comp : MaybeSequence[Union[int, str]]
                    Minimum size of the contour regions in the model.
                    Value Suggestion: auto
                    Assertion: MinSizeComp >= 0

    min_contrast_comp : MaybeSequence[Union[int, str]]
                        Minimum contrast of the components in the search
                        images.
                        Value Suggestion: auto
                        Assertion: MinContrastComp <= ContrastLowComp && MinContrastComp >= 0

    min_score_comp : MaybeSequence[float]
                     Minimum score of the instances of the components to
                     be found.
                     Value Suggestion: 0.5
                     Assertion: 0 <= MinScoreComp && MinScoreComp <= 1

    num_levels_comp : MaybeSequence[Union[int, str]]
                      Maximum number of pyramid levels for the components.
                      Value Suggestion: auto

    angle_step_comp : MaybeSequence[Union[float, str]]
                      Step length of the angles (resolution) for the
                      components.
                      Value Suggestion: auto
                      Assertion: AngleStepComp >= 0

    optimization_comp : str
                        Kind of optimization for the components.
                        Value Suggestion: auto

    metric_comp : MaybeSequence[str]
                  Match metric used for the components.
                  Value Suggestion: use_polarity

    pregeneration_comp : MaybeSequence[str]
                         Complete pregeneration of the shape models for
                         the components if equal to 'true'.
                         Value Suggestion: false

    Returns
    -------

    component_model_id : HHandle
                         Handle of the component model.

    root_ranking : int
                   Ranking of the model components expressing the
                   suitability to act as the root component.

    See Also
    --------
    create_shape_model, find_shape_model

    Alternatives
    ------------
    create_trained_component_model

    Predecessors
    ------------
    draw_region, concat_obj

    Successors
    ----------
    find_component_model
    """
    with HalconOperator(1004) as proc:
        proc.set_input_object(1, model_image)
        proc.set_input_object(2, component_regions)
        proc.set_input_tuple(0, variation_row)
        proc.set_input_tuple(1, variation_column)
        proc.set_input_tuple(2, variation_angle)
        proc.set_input_tuple(3, angle_start)
        proc.set_input_tuple(4, angle_extent)
        proc.set_input_tuple(5, contrast_low_comp)
        proc.set_input_tuple(6, contrast_high_comp)
        proc.set_input_tuple(7, min_size_comp)
        proc.set_input_tuple(8, min_contrast_comp)
        proc.set_input_tuple(9, min_score_comp)
        proc.set_input_tuple(10, num_levels_comp)
        proc.set_input_tuple(11, angle_step_comp)
        proc.set_input_tuple(12, optimization_comp)
        proc.set_input_tuple(13, metric_comp)
        proc.set_input_tuple(14, pregeneration_comp)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # component_model_id
            proc.get_output_tuple_s(1)   # root_ranking
        )  # type: ignore


def create_condition(
    attrib_name: MaybeSequence[Union[int, float, str]],
    attrib_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a condition variable synchronization object.

    Parameters
    ----------

    attrib_name : MaybeSequence[Union[int, float, str]]
                  Mutex attribute.
                  Value Suggestion: []

    attrib_value : MaybeSequence[Union[int, float, str]]
                   Mutex attribute value.
                   Value Suggestion: []

    Returns
    -------

    condition_handle : HHandle
                       Condition synchronization object.

    See Also
    --------
    clear_condition

    Successors
    ----------
    wait_condition, timed_wait_condition, signal_condition
    """
    with HalconOperator(548) as proc:
        proc.set_input_tuple(0, attrib_name)
        proc.set_input_tuple(1, attrib_value)
        proc.init_oct(0)
        proc.execute()
        condition_handle = proc.get_output_tuple_s(0)
        return condition_handle  # type: ignore


def create_data_code_2d_model(
    symbol_type: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> HHandle:
    """
    Create a model of a 2D data code class.

    Parameters
    ----------

    symbol_type : str
                  Type of the 2D data code.
                  Value Suggestion: 'Data Matrix ECC 200'

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the 2D data code model.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the 2D data code model.
                      Value Suggestion: []

    Returns
    -------

    data_code_handle : HHandle
                       Handle for using and accessing the 2D data code
                       model.

    See Also
    --------
    clear_data_code_2d_model

    Alternatives
    ------------
    read_data_code_2d_model

    Successors
    ----------
    set_data_code_2d_param, find_data_code_2d
    """
    with HalconOperator(1778) as proc:
        proc.set_input_tuple(0, symbol_type)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        data_code_handle = proc.get_output_tuple_s(0)
        return data_code_handle  # type: ignore


def create_deep_ocr(
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a Deep OCR model.

    Parameters
    ----------

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    Successors
    ----------
    apply_deep_ocr, get_deep_ocr_param, set_deep_ocr_param, clear_handle
    """
    with HalconOperator(2207) as proc:
        proc.set_input_tuple(0, gen_param_name)
        proc.set_input_tuple(1, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        deep_ocr_handle = proc.get_output_tuple_s(0)
        return deep_ocr_handle  # type: ignore


def create_deformable_surface_model(
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> HHandle:
    """
    Create the data structure needed to perform deformable surface-based
    matching.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    rel_sampling_distance : float
                            Sampling distance relative to the object's
                            diameter
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    See Also
    --------
    find_deformable_surface_model, refine_deformable_surface_model,
    read_deformable_surface_model, add_deformable_surface_model_sample,
    add_deformable_surface_model_reference_point,
    write_deformable_surface_model, clear_deformable_surface_model

    Alternatives
    ------------
    read_deformable_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params

    Successors
    ----------
    add_deformable_surface_model_sample,
    add_deformable_surface_model_reference_point,
    find_deformable_surface_model, refine_deformable_surface_model,
    get_deformable_surface_model_param, write_deformable_surface_model,
    clear_deformable_surface_model
    """
    with HalconOperator(1031) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, rel_sampling_distance)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        deformable_surface_model = proc.get_output_tuple_s(0)
        return deformable_surface_model  # type: ignore


def create_dict() -> HHandle:
    """
    Create a new empty dictionary.

    Returns
    -------

    dict_handle : HHandle
                  Handle of the newly created dictionary.

    See Also
    --------
    set_dict_tuple, get_dict_tuple, set_dict_object, get_dict_object,
    get_dict_param

    Successors
    ----------
    set_dict_tuple, set_dict_object
    """
    with HalconOperator(2149) as proc:
        proc.init_oct(0)
        proc.execute()
        dict_handle = proc.get_output_tuple_s(0)
        return dict_handle  # type: ignore


def create_distance_transform_xld(
    contour: HObject,
    mode: str,
    max_distance: Union[int, float]
) -> HHandle:
    """
    Create the XLD distance transform.

    Parameters
    ----------

    contour : HObject
              Reference contour(s).

    mode : str
           Compute the distance to points ('point_to_point') or entire
           segments ('point_to_segment').
           Value Suggestion: point_to_point

    max_distance : Union[int, float]
                   Maximum distance of interest.
                   Value Suggestion: 20.0

    Returns
    -------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    See Also
    --------
    distance_contours_xld, get_distance_transform_xld_contour,
    read_distance_transform_xld, deserialize_distance_transform_xld,
    get_distance_transform_xld_param, set_distance_transform_xld_param

    Successors
    ----------
    apply_distance_transform_xld, write_distance_transform_xld,
    serialize_distance_transform_xld, clear_distance_transform_xld
    """
    with HalconOperator(1360) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, max_distance)
        proc.init_oct(0)
        proc.execute()
        distance_transform_id = proc.get_output_tuple_s(0)
        return distance_transform_id  # type: ignore


def create_dl_model_detection(
    backbone: str,
    num_classes: int,
    dlmodel_detection_param: HHandle
) -> HHandle:
    """
    Create a deep learning network for object detection.

    Parameters
    ----------

    backbone : str
               Deep learning classifier, used as backbone network.
               Value Suggestion: pretrained_dl_classifier_compact.hdl

    num_classes : int
                  Number of classes.
                  Value Suggestion: 3

    dlmodel_detection_param : HHandle
                              Parameters for the object detection model.
                              Value Suggestion: []

    Returns
    -------

    dlmodel_handle : HHandle
                     Deep learning model for object detection.

    Alternatives
    ------------
    read_dl_model

    Successors
    ----------
    set_dl_model_param, get_dl_model_param, apply_dl_model,
    train_dl_model_batch

    Notes
    -----
    To successfully set 'gpu' parameters, cuDNN and cuBLAS are  required,
    i.e., to set the parameter GenParamName 'runtime' to 'gpu'.  For
    further details, please refer to the ``Installation Guide'',
    paragraph ``Requirements for Deep Learning and Deep-Learning-Based
    Methods''.
    """
    with HalconOperator(2150) as proc:
        proc.set_input_tuple(0, backbone)
        proc.set_input_tuple(1, num_classes)
        proc.set_input_tuple(2, dlmodel_detection_param)
        proc.init_oct(0)
        proc.execute()
        dlmodel_handle = proc.get_output_tuple_s(0)
        return dlmodel_handle  # type: ignore


def create_dl_pruning(
    dlmodel_handle: HHandle,
    mode: str,
    gen_param: HHandle
) -> HHandle:
    """
    Create a pruning data handle.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of a deep learning model.

    mode : str
           Pruning method.
           Value Suggestion: oracle

    gen_param : HHandle
                Dictionary with generic parameters.
                Value Suggestion: []

    Returns
    -------

    dlpruning_handle : HHandle
                       Pruning data handle.

    Predecessors
    ------------
    read_dl_model

    Successors
    ----------
    get_dl_pruning_param, set_dl_model_param
    """
    with HalconOperator(2208) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, mode)
        proc.set_input_tuple(2, gen_param)
        proc.init_oct(0)
        proc.execute()
        dlpruning_handle = proc.get_output_tuple_s(0)
        return dlpruning_handle  # type: ignore


def create_drawing_object_circle(
    row: float,
    column: float,
    radius: float
) -> HHandle:
    """
    Create a circle which can be modified interactively.

    Parameters
    ----------

    row : float
          Row coordinate of the center.
          Value Suggestion: 100

    column : float
             Column coordinate of the center.
             Value Suggestion: 100

    radius : float
             Radius of the circle.
             Value Suggestion: 80

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle_sector,
    create_drawing_object_ellipse_sector, create_drawing_object_xld

    Alternatives
    ------------
    draw_circle, draw_region, create_drawing_object_circle_sector,
    create_drawing_object_ellipse, create_drawing_object_ellipse_sector

    Predecessors
    ------------
    open_window

    Successors
    ----------
    attach_drawing_object_to_window, get_drawing_object_params,
    get_drawing_object_iconic
    """
    with HalconOperator(1311) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, radius)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_circle_sector(
    row: float,
    column: float,
    radius: float,
    start_angle: float,
    end_angle: float
) -> HHandle:
    """
    Create a circle sector which can be modified interactively.

    Parameters
    ----------

    row : float
          Row coordinate of the center.
          Value Suggestion: 100

    column : float
             Column coordinate of the center.
             Value Suggestion: 100

    radius : float
             Radius of the circle.
             Value Suggestion: 80

    start_angle : float
                  Start angle of the arc.
                  Value Suggestion: 0

    end_angle : float
                End angle of the arc.
                Value Suggestion: 3.14159

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle,
    create_drawing_object_ellipse_sector, create_drawing_object_xld,
    create_drawing_object_line

    Alternatives
    ------------
    draw_rectangle1_mod, draw_rectangle2, draw_region,
    create_drawing_object_circle, create_drawing_object_ellipse_sector

    Predecessors
    ------------
    open_window

    Successors
    ----------
    attach_drawing_object_to_window, get_drawing_object_params,
    get_drawing_object_iconic
    """
    with HalconOperator(1308) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, start_angle)
        proc.set_input_tuple(4, end_angle)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_ellipse(
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float
) -> HHandle:
    """
    Create an ellipse which can be modified interactively.

    Parameters
    ----------

    row : float
          Row index of the center.
          Value Suggestion: 200

    column : float
             Column index of the center.
             Value Suggestion: 200

    phi : float
          Orientation of the first half axis in radians.
          Value Suggestion: 0

    radius_1 : float
               First half axis.
               Value Suggestion: 100

    radius_2 : float
               Second half axis.
               Value Suggestion: 60

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    gen_ellipse, draw_circle, draw_rectangle2, set_insert

    Alternatives
    ------------
    draw_ellipse_mod, draw_ellipse, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    disp_region, set_colored, set_line_width, set_draw, set_insert,
    attach_drawing_object_to_window
    """
    with HalconOperator(1312) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, radius_1)
        proc.set_input_tuple(4, radius_2)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_ellipse_sector(
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float,
    start_angle: float,
    end_angle: float
) -> HHandle:
    """
    Create an elliptic sector which can be modified interactively.

    Parameters
    ----------

    row : float
          Row index of the center.
          Value Suggestion: 200

    column : float
             Column index of the center.
             Value Suggestion: 200

    phi : float
          Orientation of the first half axis in radians.
          Value Suggestion: 0

    radius_1 : float
               First half axis.
               Value Suggestion: 100

    radius_2 : float
               Second half axis.
               Value Suggestion: 60

    start_angle : float
                  Start angle of the arc.
                  Value Suggestion: 0

    end_angle : float
                End angle of the arc.
                Value Suggestion: 3.14159

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    gen_ellipse_contour_xld, create_drawing_object_rectangle1,
    create_drawing_object_rectangle2, create_drawing_object_ellipse,
    create_drawing_object_xld, create_drawing_object_line,
    create_drawing_object_circle

    Alternatives
    ------------
    draw_ellipse_mod, draw_ellipse, draw_region,
    create_drawing_object_ellipse

    Predecessors
    ------------
    open_window

    Successors
    ----------
    attach_drawing_object_to_window, get_drawing_object_params,
    get_drawing_object_iconic
    """
    with HalconOperator(1309) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, radius_1)
        proc.set_input_tuple(4, radius_2)
        proc.set_input_tuple(5, start_angle)
        proc.set_input_tuple(6, end_angle)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_line(
    row_1: float,
    column_1: float,
    row_2: float,
    column_2: float
) -> HHandle:
    """
    Create a line which can be modified interactively.

    Parameters
    ----------

    row_1 : float
            Row coordinate of the first line point.
            Value Suggestion: 100

    column_1 : float
               Column coordinate of the first line point.
               Value Suggestion: 100

    row_2 : float
            Row coordinate of the second line point.
            Value Suggestion: 200

    column_2 : float
               Column coordinate of the second line point.
               Value Suggestion: 200

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle_sector,
    create_drawing_object_ellipse_sector, create_drawing_object_xld

    Alternatives
    ------------
    draw_line, draw_line_mod, create_drawing_object_xld

    Predecessors
    ------------
    open_window

    Successors
    ----------
    attach_drawing_object_to_window, get_drawing_object_params,
    get_drawing_object_iconic
    """
    with HalconOperator(1310) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_rectangle1(
    row_1: float,
    column_1: float,
    row_2: float,
    column_2: float
) -> HHandle:
    """
    Create a rectangle parallel to the coordinate axis which can be
    modified interactively.

    Parameters
    ----------

    row_1 : float
            Row coordinate of the upper left corner.
            Value Suggestion: 100

    column_1 : float
               Column coordinate of the upper left corner.
               Value Suggestion: 100

    row_2 : float
            Row coordinate of the lower right corner.
            Value Suggestion: 200

    column_2 : float
               Column coordinate of the lower right corner.
               Value Suggestion: 200

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    gen_rectangle1, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle1_mod, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    disp_region, set_colored, set_line_width, set_draw, set_insert,
    attach_drawing_object_to_window
    """
    with HalconOperator(1314) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_rectangle2(
    row: float,
    column: float,
    phi: float,
    length_1: float,
    length_2: float
) -> HHandle:
    """
    Create a rectangle of any orientation which can be modified
    interactively.

    Parameters
    ----------

    row : float
          Row coordinate of the center.
          Value Suggestion: 150

    column : float
             Column coordinate of the center.
             Value Suggestion: 150

    phi : float
          Orientation of the first half axis in radians.
          Value Suggestion: 0

    length_1 : float
               First half axis.
               Value Suggestion: 100

    length_2 : float
               Second half axis.
               Value Suggestion: 100

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    gen_rectangle2, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle2_mod, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    disp_region, set_colored, set_line_width, set_draw, set_insert,
    attach_drawing_object_to_window
    """
    with HalconOperator(1313) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, length_1)
        proc.set_input_tuple(4, length_2)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_text(
    row: int,
    column: int,
    string: str
) -> HHandle:
    """
    Create a text object which can be moved interactively.

    Parameters
    ----------

    row : int
          Row coordinate of the text position.
          Value Suggestion: 12

    column : int
             Column coordinate of the text position.
             Value Suggestion: 12

    string : str
             Character string to be displayed.
             Value Suggestion: Text

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    write_string, attach_drawing_object_to_window

    Alternatives
    ------------
    write_string

    Predecessors
    ------------
    open_window

    Successors
    ----------
    attach_drawing_object_to_window, get_drawing_object_params,
    set_drawing_object_params
    """
    with HalconOperator(1301) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, string)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_drawing_object_xld(
    row: Sequence[Union[float, int]],
    column: Sequence[Union[float, int]]
) -> HHandle:
    """
    Create a XLD contour which can be modified interactively.

    Parameters
    ----------

    row : Sequence[Union[float, int]]
          Row coordinates of the polygon.
          Value Suggestion: [100,200,200,100]

    column : Sequence[Union[float, int]]
             Column coordinates of the polygon.
             Value Suggestion: [100,100,200,200]

    Returns
    -------

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle_sector,
    create_drawing_object_ellipse_sector, create_drawing_object_line,
    create_drawing_object_circle

    Alternatives
    ------------
    draw_xld, draw_xld_mod, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    attach_drawing_object_to_window, get_drawing_object_params,
    get_drawing_object_iconic, set_drawing_object_xld
    """
    with HalconOperator(1307) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        draw_id = proc.get_output_tuple_s(0)
        return draw_id  # type: ignore


def create_event(
    attrib_name: MaybeSequence[Union[int, float, str]],
    attrib_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create an event synchronization object.

    Parameters
    ----------

    attrib_name : MaybeSequence[Union[int, float, str]]
                  Mutex attribute.
                  Value Suggestion: []

    attrib_value : MaybeSequence[Union[int, float, str]]
                   Mutex attribute value.
                   Value Suggestion: []

    Returns
    -------

    event_handle : HHandle
                   Event synchronization object.

    See Also
    --------
    clear_event

    Successors
    ----------
    wait_event, signal_event, clear_event
    """
    with HalconOperator(558) as proc:
        proc.set_input_tuple(0, attrib_name)
        proc.set_input_tuple(1, attrib_value)
        proc.init_oct(0)
        proc.execute()
        event_handle = proc.get_output_tuple_s(0)
        return event_handle  # type: ignore


def create_funct_1d_array(
    yvalues: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Create a function from a sequence of y values.

    Parameters
    ----------

    yvalues : MaybeSequence[Union[float, int]]
              X value for function points.

    Returns
    -------

    function : Sequence[Union[float, int]]
               Created function.

    See Also
    --------
    funct_1d_to_pairs

    Alternatives
    ------------
    create_funct_1d_pairs, read_funct_1d

    Successors
    ----------
    write_funct_1d, y_range_funct_1d, get_pair_funct_1d, transform_funct_1d
    """
    with HalconOperator(1399) as proc:
        proc.set_input_tuple(0, yvalues)
        proc.init_oct(0)
        proc.execute()
        function = proc.get_output_tuple_m(0)
        return function  # type: ignore


def create_funct_1d_pairs(
    xvalues: MaybeSequence[Union[float, int]],
    yvalues: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Create a function from a set of (x,y) pairs.

    Parameters
    ----------

    xvalues : MaybeSequence[Union[float, int]]
              X value for function points.

    yvalues : MaybeSequence[Union[float, int]]
              Y value for function points.

    Returns
    -------

    function : Sequence[Union[float, int]]
               Created function.

    See Also
    --------
    funct_1d_to_pairs

    Alternatives
    ------------
    create_funct_1d_array, read_funct_1d

    Successors
    ----------
    write_funct_1d, y_range_funct_1d, get_pair_funct_1d

    Notes
    -----
    create_funct_1d_pairs examines whether the x values of type  'double'
    are ascending. Some other operators apply the same check but use  the
    type 'float' instead of 'double'. If such an operator is called as
    successor, it might happen that two consecutive x values seem to be
    equal for the 'float' variant, although they were ascending in the
    'double' variant. If this happens, an error is thrown.
    """
    with HalconOperator(1400) as proc:
        proc.set_input_tuple(0, xvalues)
        proc.set_input_tuple(1, yvalues)
        proc.init_oct(0)
        proc.execute()
        function = proc.get_output_tuple_m(0)
        return function  # type: ignore


def create_lexicon(name: str, words: Sequence[str]) -> HHandle:
    """
    Create a lexicon from a tuple of words.

    Parameters
    ----------

    name : str
           Unique name for the new lexicon.
           Value Suggestion: 'lex1'

    words : Sequence[str]
            Word list for the new lexicon.
            Value Suggestion: ['word1','word2','word3']

    Returns
    -------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    See Also
    --------
    lookup_lexicon, suggest_lexicon

    Alternatives
    ------------
    import_lexicon

    Successors
    ----------
    do_ocr_word_mlp, do_ocr_word_svm
    """
    with HalconOperator(671) as proc:
        proc.set_input_tuple(0, name)
        proc.set_input_tuple(1, words)
        proc.init_oct(0)
        proc.execute()
        lexicon_handle = proc.get_output_tuple_s(0)
        return lexicon_handle  # type: ignore


def create_local_deformable_model(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: Sequence[float],
    angle_extent: Sequence[float],
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: Sequence[float],
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: Sequence[float],
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    contrast: Sequence[Union[int, str]],
    min_contrast: Union[int, str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Creates a deformable model for local, deformable matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : Sequence[float]
                  This parameter is not used.
                  Value Suggestion: []

    angle_extent : Sequence[float]
                   This parameter is not used.
                   Value Suggestion: []

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep >= 0

    scale_cmin : float
                 Minimum scale of the pattern in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep >= 0

    optimization : MaybeSequence[str]
                   Kind of optimization used for generating the model.
                   Value Suggestion: none

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : Sequence[Union[int, str]]
               Thresholds or hysteresis thresholds for the contrast of the
               object in the template image.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    gen_param_name : Sequence[str]
                     The generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model

    Alternatives
    ------------
    read_deformable_model

    Predecessors
    ------------
    determine_deformable_model_params

    Successors
    ----------
    set_deformable_model_origin, set_deformable_model_param,
    get_deformable_model_contours, find_local_deformable_model,
    get_deformable_model_params, write_deformable_model,
    clear_deformable_model
    """
    with HalconOperator(978) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_rmin)
        proc.set_input_tuple(5, scale_rmax)
        proc.set_input_tuple(6, scale_rstep)
        proc.set_input_tuple(7, scale_cmin)
        proc.set_input_tuple(8, scale_cmax)
        proc.set_input_tuple(9, scale_cstep)
        proc.set_input_tuple(10, optimization)
        proc.set_input_tuple(11, metric)
        proc.set_input_tuple(12, contrast)
        proc.set_input_tuple(13, min_contrast)
        proc.set_input_tuple(14, gen_param_name)
        proc.set_input_tuple(15, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_local_deformable_model_xld(
    contours: HObject,
    num_levels: Union[int, str],
    angle_start: Sequence[float],
    angle_extent: Sequence[float],
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: Sequence[float],
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: Sequence[float],
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    min_contrast: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Prepare a deformable model for local deformable matching from XLD
    contours.

    Parameters
    ----------

    contours : HObject
               Input contours that will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : Sequence[float]
                  This parameter is not used.
                  Value Suggestion: []

    angle_extent : Sequence[float]
                   This parameter is not used.
                   Value Suggestion: []

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep > 0

    scale_cmin : float
                 Minimum scale of the pattern in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep > 0

    optimization : MaybeSequence[str]
                   Kind of optimization used for generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: ignore_local_polarity

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 5

    gen_param_name : Sequence[str]
                     The generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_local_deformable_model

    Predecessors
    ------------
    read_contour_xld_dxf, edges_sub_pix, select_contours_xld

    Successors
    ----------
    find_local_deformable_model

    Notes
    -----
    Note that, in contrast to the operator create_local_deformable_model,
    it is not possible to specify a minimum size of the model components.
    To avoid small model components in the model, short contours can be
    eliminated with the operator select_contours_xld before calling
    create_local_deformable_model_xld.
    """
    with HalconOperator(975) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_rmin)
        proc.set_input_tuple(5, scale_rmax)
        proc.set_input_tuple(6, scale_rstep)
        proc.set_input_tuple(7, scale_cmin)
        proc.set_input_tuple(8, scale_cmax)
        proc.set_input_tuple(9, scale_cstep)
        proc.set_input_tuple(10, optimization)
        proc.set_input_tuple(11, metric)
        proc.set_input_tuple(12, min_contrast)
        proc.set_input_tuple(13, gen_param_name)
        proc.set_input_tuple(14, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_matrix(
    rows: int,
    columns: int,
    value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a matrix.

    Parameters
    ----------

    rows : int
           Number of rows of the matrix.
           Value Suggestion: 3
           Assertion: Rows >= 1

    columns : int
              Number of columns of the matrix.
              Value Suggestion: 3
              Assertion: Columns >= 1

    value : MaybeSequence[Union[int, float, str]]
            Values for initializing the elements of the matrix.
            Value Suggestion: 0

    Returns
    -------

    matrix_id : HHandle
                Matrix handle.

    Successors
    ----------
    set_full_matrix, clear_matrix
    """
    with HalconOperator(897) as proc:
        proc.set_input_tuple(0, rows)
        proc.set_input_tuple(1, columns)
        proc.set_input_tuple(2, value)
        proc.init_oct(0)
        proc.execute()
        matrix_id = proc.get_output_tuple_s(0)
        return matrix_id  # type: ignore


def create_message() -> HHandle:
    """
    Create a new empty message.

    Returns
    -------

    message_handle : HHandle
                     Handle of the newly created message.
                     Assertion: MessageHandle != 0

    See Also
    --------
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Alternatives
    ------------
    create_dict

    Successors
    ----------
    set_message_tuple, set_message_obj
    """
    with HalconOperator(541) as proc:
        proc.init_oct(0)
        proc.execute()
        message_handle = proc.get_output_tuple_s(0)
        return message_handle  # type: ignore


def create_message_queue() -> HHandle:
    """
    Create a new empty message queue.

    Returns
    -------

    queue_handle : HHandle
                   Handle of the newly created message queue.
                   Assertion: QueueHandle != 0

    See Also
    --------
    clear_message_queue, enqueue_message, dequeue_message,
    set_message_queue_param, get_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Successors
    ----------
    enqueue_message, dequeue_message
    """
    with HalconOperator(533) as proc:
        proc.init_oct(0)
        proc.execute()
        queue_handle = proc.get_output_tuple_s(0)
        return queue_handle  # type: ignore


def create_metrology_model() -> HHandle:
    """
    Create the data structure that is needed to measure geometric shapes.

    Returns
    -------

    metrology_handle : HHandle
                       Handle of the metrology model.

    Successors
    ----------
    set_metrology_model_image_size

    Notes
    -----
    Note, that after calling the operator create_metrology_model the
    operator set_metrology_model_image_size should be called for
    efficiency reasons.
    """
    with HalconOperator(820) as proc:
        proc.init_oct(0)
        proc.execute()
        metrology_handle = proc.get_output_tuple_s(0)
        return metrology_handle  # type: ignore


def create_mutex(
    attrib_name: MaybeSequence[Union[int, float, str]],
    attrib_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a mutual exclusion synchronization object.

    Parameters
    ----------

    attrib_name : MaybeSequence[Union[int, float, str]]
                  Mutex attribute class.
                  Value Suggestion: []

    attrib_value : MaybeSequence[Union[int, float, str]]
                   Mutex attribute kind.
                   Value Suggestion: []

    Returns
    -------

    mutex_handle : HHandle
                   Mutex synchronization object.

    See Also
    --------
    clear_mutex

    Successors
    ----------
    lock_mutex, clear_mutex
    """
    with HalconOperator(564) as proc:
        proc.set_input_tuple(0, attrib_name)
        proc.set_input_tuple(1, attrib_value)
        proc.init_oct(0)
        proc.execute()
        mutex_handle = proc.get_output_tuple_s(0)
        return mutex_handle  # type: ignore


def create_ncc_model(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    metric: str
) -> HHandle:
    """
    Prepare an NCC model for matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep >= 0 && AngleStep <= pi / 16

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    Alternatives
    ------------
    create_shape_model, create_scaled_shape_model, create_aniso_shape_model

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    find_ncc_model, get_ncc_model_params, clear_ncc_model,
    write_ncc_model, set_ncc_model_origin, set_ncc_model_param,
    find_ncc_models
    """
    with HalconOperator(993) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, metric)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_ocr_class_box(
    width_pattern: int,
    height_pattern: int,
    interpolation: int,
    features: MaybeSequence[str],
    character: Sequence[str]
) -> HHandle:
    """
    Create a new OCR-classifier.

    Parameters
    ----------

    width_pattern : int
                    Width of the input layer of the network.
                    Value Suggestion: 8

    height_pattern : int
                     Height of the input layer of the network.
                     Value Suggestion: 10

    interpolation : int
                    Interpolation mode concerning scaling of characters.
                    Value Suggestion: 1

    features : MaybeSequence[str]
               Additional features.
               Value Suggestion: default

    character : Sequence[str]
                All characters of a set.
                Value Suggestion: ['a','b','c']

    Returns
    -------

    ocr_handle : HHandle
                 ID of the created OCR classifier.

    See Also
    --------
    affine_trans_image, ocr_change_char, moments_region_2nd_invar,
    moments_region_2nd_rel_invar, moments_region_3rd_invar,
    moments_region_central

    Alternatives
    ------------
    create_ocr_class_mlp, create_ocr_class_svm

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    traind_ocr_class_box, trainf_ocr_class_box, info_ocr_class_box,
    write_ocr, ocr_change_char

    Warnings
    --------
    create_ocr_class_box is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(716) as proc:
        proc.set_input_tuple(0, width_pattern)
        proc.set_input_tuple(1, height_pattern)
        proc.set_input_tuple(2, interpolation)
        proc.set_input_tuple(3, features)
        proc.set_input_tuple(4, character)
        proc.init_oct(0)
        proc.execute()
        ocr_handle = proc.get_output_tuple_s(0)
        return ocr_handle  # type: ignore


def create_ocr_class_knn(
    width_character: int,
    height_character: int,
    interpolation: str,
    features: MaybeSequence[str],
    characters: Sequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str]]
) -> HHandle:
    """
    Create an OCR classifier using a k-Nearest Neighbor (k-NN) classifier.

    Parameters
    ----------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.
                      Value Suggestion: 8

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.
                       Value Suggestion: 10

    interpolation : str
                    Interpolation mode for the zooming of the characters.
                    Value Suggestion: constant

    features : MaybeSequence[str]
               Features to be used for classification.
               Value Suggestion: default

    characters : Sequence[str]
                 All characters of the character set to be read.
                 Value Suggestion: ['0','1','2','3','4','5','6','7','8','9']

    gen_param_name : Sequence[str]
                     This parameter is not yet supported.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str]]
                      This parameter is not yet supported.
                      Value Suggestion: []

    Returns
    -------

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    See Also
    --------
    do_ocr_single_class_knn, do_ocr_multi_class_knn, clear_class_knn,
    create_class_knn, trainf_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    create_ocr_class_svm

    Successors
    ----------
    trainf_ocr_class_knn
    """
    with HalconOperator(654) as proc:
        proc.set_input_tuple(0, width_character)
        proc.set_input_tuple(1, height_character)
        proc.set_input_tuple(2, interpolation)
        proc.set_input_tuple(3, features)
        proc.set_input_tuple(4, characters)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def create_ocr_class_mlp(
    width_character: int,
    height_character: int,
    interpolation: str,
    features: MaybeSequence[str],
    characters: Sequence[str],
    num_hidden: int,
    preprocessing: str,
    num_components: int,
    rand_seed: int
) -> HHandle:
    """
    Create an OCR classifier using a multilayer perceptron.

    Parameters
    ----------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.
                      Value Suggestion: 8

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.
                       Value Suggestion: 10

    interpolation : str
                    Interpolation mode for the zooming of the characters.
                    Value Suggestion: constant

    features : MaybeSequence[str]
               Features to be used for classification.
               Value Suggestion: default

    characters : Sequence[str]
                 All characters of the character set to be read.
                 Value Suggestion: ['0','1','2','3','4','5','6','7','8','9']

    num_hidden : int
                 Number of hidden units of the MLP.
                 Value Suggestion: 80
                 Assertion: NumHidden >= 1

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: none

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').
                     Value Suggestion: 10
                     Assertion: NumComponents >= 1

    rand_seed : int
                Seed value of the random number generator that is used to
                initialize the MLP with random values.
                Value Suggestion: 42

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp, clear_ocr_class_mlp,
    create_class_mlp, train_class_mlp, classify_class_mlp

    Alternatives
    ------------
    create_ocr_class_svm

    Successors
    ----------
    trainf_ocr_class_mlp, set_regularization_params_ocr_class_mlp,
    set_rejection_params_ocr_class_mlp
    """
    with HalconOperator(708) as proc:
        proc.set_input_tuple(0, width_character)
        proc.set_input_tuple(1, height_character)
        proc.set_input_tuple(2, interpolation)
        proc.set_input_tuple(3, features)
        proc.set_input_tuple(4, characters)
        proc.set_input_tuple(5, num_hidden)
        proc.set_input_tuple(6, preprocessing)
        proc.set_input_tuple(7, num_components)
        proc.set_input_tuple(8, rand_seed)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def create_ocr_class_svm(
    width_character: int,
    height_character: int,
    interpolation: str,
    features: MaybeSequence[str],
    characters: Sequence[str],
    kernel_type: str,
    kernel_param: float,
    nu: float,
    mode: str,
    preprocessing: str,
    num_components: int
) -> HHandle:
    """
    Create an OCR classifier using a support vector machine.

    Parameters
    ----------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.
                      Value Suggestion: 8

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.
                       Value Suggestion: 10

    interpolation : str
                    Interpolation mode for the zooming of the characters.
                    Value Suggestion: constant

    features : MaybeSequence[str]
               Features to be used for classification.
               Value Suggestion: default

    characters : Sequence[str]
                 All characters of the character set to be read.
                 Value Suggestion: ['0','1','2','3','4','5','6','7','8','9']

    kernel_type : str
                  The kernel type.
                  Value Suggestion: rbf

    kernel_param : float
                   Additional parameter for the kernel function.
                   Value Suggestion: 0.02

    nu : float
         Regularization constant of the SVM.
         Value Suggestion: 0.05
         Assertion: Nu > 0.0 && Nu < 1.0

    mode : str
           The mode of the SVM.
           Value Suggestion: one-versus-one

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: normalization

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').
                     Value Suggestion: 10
                     Assertion: NumComponents >= 1

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    do_ocr_single_class_svm, do_ocr_multi_class_svm, clear_ocr_class_svm,
    create_class_svm, train_class_svm, classify_class_svm

    Alternatives
    ------------
    create_ocr_class_mlp

    Successors
    ----------
    trainf_ocr_class_svm
    """
    with HalconOperator(689) as proc:
        proc.set_input_tuple(0, width_character)
        proc.set_input_tuple(1, height_character)
        proc.set_input_tuple(2, interpolation)
        proc.set_input_tuple(3, features)
        proc.set_input_tuple(4, characters)
        proc.set_input_tuple(5, kernel_type)
        proc.set_input_tuple(6, kernel_param)
        proc.set_input_tuple(7, nu)
        proc.set_input_tuple(8, mode)
        proc.set_input_tuple(9, preprocessing)
        proc.set_input_tuple(10, num_components)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def create_ocv_proj(pattern_names: MaybeSequence[str]) -> HHandle:
    """
    Create a new OCV tool based on gray value projections.

    Parameters
    ----------

    pattern_names : MaybeSequence[str]
                    List of names for patterns to be trained.
                    Value Suggestion: 'a'

    Returns
    -------

    ocvhandle : HHandle
                Handle of the created OCV tool.

    See Also
    --------
    create_ocr_class_box

    Alternatives
    ------------
    read_ocv

    Successors
    ----------
    traind_ocv_proj, write_ocv, close_ocv
    """
    with HalconOperator(646) as proc:
        proc.set_input_tuple(0, pattern_names)
        proc.init_oct(0)
        proc.execute()
        ocvhandle = proc.get_output_tuple_s(0)
        return ocvhandle  # type: ignore


def create_planar_calib_deformable_model(
    template: HObject,
    cam_param: Sequence[Union[float, int, str]],
    reference_pose: Sequence[Union[float, int]],
    num_levels: Union[int, str],
    angle_start: Sequence[float],
    angle_extent: Sequence[float],
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: Sequence[float],
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: Sequence[float],
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    contrast: Sequence[Union[int, str]],
    min_contrast: Union[int, str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a deformable model for calibrated perspective matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    cam_param : Sequence[Union[float, int, str]]
                The parameters of the internal orientation of the camera.

    reference_pose : Sequence[Union[float, int]]
                     The reference pose of the object in the reference
                     image.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : Sequence[float]
                  This parameter is not used.
                  Value Suggestion: []

    angle_extent : Sequence[float]
                   This parameter is not used.
                   Value Suggestion: []

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep >= 0

    scale_cmin : float
                 Minimum scale of the pattern in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in the column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep >= 0

    optimization : MaybeSequence[str]
                   Kind of optimization used for generating the model.
                   Value Suggestion: none

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : Sequence[Union[int, str]]
               Thresholds or hysteresis thresholds for the contrast of the
               object in the template image.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    gen_param_name : Sequence[str]
                     The parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the parameters.
                      Value Suggestion: []

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_planar_uncalib_deformable_model

    Alternatives
    ------------
    read_deformable_model

    Predecessors
    ------------
    determine_deformable_model_params

    Successors
    ----------
    set_deformable_model_origin, set_deformable_model_param,
    get_deformable_model_contours, find_planar_calib_deformable_model,
    get_deformable_model_params, write_deformable_model,
    clear_deformable_model
    """
    with HalconOperator(979) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, cam_param)
        proc.set_input_tuple(1, reference_pose)
        proc.set_input_tuple(2, num_levels)
        proc.set_input_tuple(3, angle_start)
        proc.set_input_tuple(4, angle_extent)
        proc.set_input_tuple(5, angle_step)
        proc.set_input_tuple(6, scale_rmin)
        proc.set_input_tuple(7, scale_rmax)
        proc.set_input_tuple(8, scale_rstep)
        proc.set_input_tuple(9, scale_cmin)
        proc.set_input_tuple(10, scale_cmax)
        proc.set_input_tuple(11, scale_cstep)
        proc.set_input_tuple(12, optimization)
        proc.set_input_tuple(13, metric)
        proc.set_input_tuple(14, contrast)
        proc.set_input_tuple(15, min_contrast)
        proc.set_input_tuple(16, gen_param_name)
        proc.set_input_tuple(17, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_planar_calib_deformable_model_xld(
    contours: HObject,
    cam_param: Sequence[Union[float, int, str]],
    reference_pose: Sequence[Union[float, int]],
    num_levels: Union[int, str],
    angle_start: Sequence[float],
    angle_extent: Sequence[float],
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: Sequence[float],
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: Sequence[float],
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    min_contrast: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Prepare a deformable model for planar calibrated matching from XLD
    contours.

    Parameters
    ----------

    contours : HObject
               Input contours that will be used to create the model.

    cam_param : Sequence[Union[float, int, str]]
                The parameters of the internal orientation of the camera.

    reference_pose : Sequence[Union[float, int]]
                     The reference pose of the object.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : Sequence[float]
                  This parameter is not used.
                  Value Suggestion: []

    angle_extent : Sequence[float]
                   This parameter is not used.
                   Value Suggestion: []

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep > 0

    scale_cmin : float
                 Minimum scale of the pattern in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in the column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep > 0

    optimization : MaybeSequence[str]
                   Kind of optimization used for generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: ignore_local_polarity

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 5

    gen_param_name : Sequence[str]
                     The generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_planar_calib_deformable_model

    Predecessors
    ------------
    read_contour_xld_dxf, edges_sub_pix, select_contours_xld

    Successors
    ----------
    find_planar_calib_deformable_model

    Notes
    -----
    Note that, in contrast to the operator
    create_planar_calib_deformable_model, it is not possible to specify a
    minimum size of the model components. To avoid small model components
    in the model, short contours can be eliminated before calling
    create_planar_calib_deformable_model_xld with the operator
    select_contours_xld.
    """
    with HalconOperator(976) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, cam_param)
        proc.set_input_tuple(1, reference_pose)
        proc.set_input_tuple(2, num_levels)
        proc.set_input_tuple(3, angle_start)
        proc.set_input_tuple(4, angle_extent)
        proc.set_input_tuple(5, angle_step)
        proc.set_input_tuple(6, scale_rmin)
        proc.set_input_tuple(7, scale_rmax)
        proc.set_input_tuple(8, scale_rstep)
        proc.set_input_tuple(9, scale_cmin)
        proc.set_input_tuple(10, scale_cmax)
        proc.set_input_tuple(11, scale_cstep)
        proc.set_input_tuple(12, optimization)
        proc.set_input_tuple(13, metric)
        proc.set_input_tuple(14, min_contrast)
        proc.set_input_tuple(15, gen_param_name)
        proc.set_input_tuple(16, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_planar_uncalib_deformable_model(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: Sequence[float],
    angle_extent: Sequence[float],
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: Sequence[float],
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: Sequence[float],
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    contrast: Sequence[Union[int, str]],
    min_contrast: Union[int, str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Creates a deformable model for uncalibrated, perspective matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : Sequence[float]
                  This parameter is not used.
                  Value Suggestion: []

    angle_extent : Sequence[float]
                   This parameter is not used.
                   Value Suggestion: []

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep >= 0

    scale_cmin : float
                 Minimum scale of the pattern in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep >= 0

    optimization : MaybeSequence[str]
                   Kind of optimization used for generating the model.
                   Value Suggestion: none

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : Sequence[Union[int, str]]
               Thresholds or hysteresis thresholds for the contrast of the
               object in the template image.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    gen_param_name : Sequence[str]
                     The generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    Alternatives
    ------------
    read_deformable_model

    Predecessors
    ------------
    determine_deformable_model_params

    Successors
    ----------
    set_deformable_model_origin, set_deformable_model_param,
    get_deformable_model_contours, find_planar_uncalib_deformable_model,
    get_deformable_model_params, write_deformable_model,
    clear_deformable_model
    """
    with HalconOperator(980) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_rmin)
        proc.set_input_tuple(5, scale_rmax)
        proc.set_input_tuple(6, scale_rstep)
        proc.set_input_tuple(7, scale_cmin)
        proc.set_input_tuple(8, scale_cmax)
        proc.set_input_tuple(9, scale_cstep)
        proc.set_input_tuple(10, optimization)
        proc.set_input_tuple(11, metric)
        proc.set_input_tuple(12, contrast)
        proc.set_input_tuple(13, min_contrast)
        proc.set_input_tuple(14, gen_param_name)
        proc.set_input_tuple(15, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_planar_uncalib_deformable_model_xld(
    contours: HObject,
    num_levels: Union[int, str],
    angle_start: Sequence[float],
    angle_extent: Sequence[float],
    angle_step: Union[float, str],
    scale_rmin: float,
    scale_rmax: Sequence[float],
    scale_rstep: Union[float, str],
    scale_cmin: float,
    scale_cmax: Sequence[float],
    scale_cstep: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    min_contrast: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Prepare a deformable model for planar uncalibrated matching from XLD
    contours.

    Parameters
    ----------

    contours : HObject
               Input contours that will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : Sequence[float]
                  This parameter is not used.
                  Value Suggestion: []

    angle_extent : Sequence[float]
                   This parameter is not used.
                   Value Suggestion: []

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_rmin : float
                 Minimum scale of the pattern in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_rstep : Union[float, str]
                  Scale step length (resolution) in row direction.
                  Value Suggestion: auto
                  Assertion: ScaleRStep > 0

    scale_cmin : float
                 Minimum scale of the pattern in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : Sequence[float]
                 This parameter is not used.
                 Value Suggestion: []

    scale_cstep : Union[float, str]
                  Scale step length (resolution) in the column direction.
                  Value Suggestion: auto
                  Assertion: ScaleCStep > 0

    optimization : MaybeSequence[str]
                   Kind of optimization used for generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: ignore_local_polarity

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 5

    gen_param_name : Sequence[str]
                     The generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_planar_uncalib_deformable_model

    Predecessors
    ------------
    read_contour_xld_dxf, edges_sub_pix, select_contours_xld

    Successors
    ----------
    find_planar_uncalib_deformable_model

    Notes
    -----
    Note that, in contrast to the operator
    create_planar_uncalib_deformable_model, it is not possible to specify
    a minimum size of the model components. To avoid small model
    components in the model, short contours can be eliminated before
    calling create_planar_uncalib_deformable_model_xld with the operator
    select_contours_xld.
    """
    with HalconOperator(977) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_rmin)
        proc.set_input_tuple(5, scale_rmax)
        proc.set_input_tuple(6, scale_rstep)
        proc.set_input_tuple(7, scale_cmin)
        proc.set_input_tuple(8, scale_cmax)
        proc.set_input_tuple(9, scale_cstep)
        proc.set_input_tuple(10, optimization)
        proc.set_input_tuple(11, metric)
        proc.set_input_tuple(12, min_contrast)
        proc.set_input_tuple(13, gen_param_name)
        proc.set_input_tuple(14, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_pose(
    trans_x: float,
    trans_y: float,
    trans_z: float,
    rot_x: float,
    rot_y: float,
    rot_z: float,
    order_of_transform: str,
    order_of_rotation: str,
    view_of_transform: str
) -> Sequence[Union[int, float]]:
    """
    Create a 3D pose.

    Parameters
    ----------

    trans_x : float
              Translation along the x-axis (in [m]).
              Value Suggestion: 0.1

    trans_y : float
              Translation along the y-axis (in [m]).
              Value Suggestion: 0.1

    trans_z : float
              Translation along the z-axis (in [m]).
              Value Suggestion: 0.1

    rot_x : float
            Rotation around x-axis or x component of the Rodriguez vector
            (in [] or without unit).
            Value Suggestion: 90.0

    rot_y : float
            Rotation around y-axis or y component of the Rodriguez vector
            (in [] or without unit).
            Value Suggestion: 90.0

    rot_z : float
            Rotation around z-axis or z component of the Rodriguez vector
            (in [] or without unit).
            Value Suggestion: 90.0

    order_of_transform : str
                         Order of rotation and translation.
                         Value Suggestion: 'Rp+T'

    order_of_rotation : str
                        Meaning of the rotation values.
                        Value Suggestion: 'gba'

    view_of_transform : str
                        View of transformation.
                        Value Suggestion: 'point'

    Returns
    -------

    pose : Sequence[Union[int, float]]
           3D pose.

    See Also
    --------
    hom_mat3d_rotate, hom_mat3d_translate, convert_pose_type,
    get_pose_type, hom_mat3d_to_pose, pose_to_hom_mat3d, write_pose,
    read_pose

    Alternatives
    ------------
    read_pose, hom_mat3d_to_pose

    Successors
    ----------
    pose_to_hom_mat3d, write_pose, camera_calibration, hand_eye_calibration
    """
    with HalconOperator(1921) as proc:
        proc.set_input_tuple(0, trans_x)
        proc.set_input_tuple(1, trans_y)
        proc.set_input_tuple(2, trans_z)
        proc.set_input_tuple(3, rot_x)
        proc.set_input_tuple(4, rot_y)
        proc.set_input_tuple(5, rot_z)
        proc.set_input_tuple(6, order_of_transform)
        proc.set_input_tuple(7, order_of_rotation)
        proc.set_input_tuple(8, view_of_transform)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def create_rectification_grid(
    width: float,
    num_squares: int,
    grid_file: str
) -> None:
    """
    Generate a PostScript file, which describes the rectification grid.

    Parameters
    ----------

    width : float
            Width of the checkered pattern in meters (without the two
            frames).
            Value Suggestion: 0.17
            Assertion: 0.0 < Width

    num_squares : int
                  Number of squares per row and column.
                  Value Suggestion: 17
                  Assertion: 2 <= NumSquares

    grid_file : str
                File name of the PostScript file.
                Value Suggestion: rectification_grid.ps

    See Also
    --------
    find_rectification_grid, saddle_points_sub_pix, connect_grid_points,
    gen_grid_rectification_map
    """
    with HalconOperator(1157) as proc:
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, num_squares)
        proc.set_input_tuple(2, grid_file)
        proc.execute()


def create_sample_identifier(
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> HHandle:
    """
    Create a new sample identifier.

    Parameters
    ----------

    gen_param_name : Sequence[str]
                     Parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Parameter value.
                      Value Suggestion: []

    Returns
    -------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    See Also
    --------
    prepare_sample_identifier, add_sample_identifier_training_data,
    train_sample_identifier, apply_sample_identifier,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Successors
    ----------
    add_sample_identifier_preparation_data, set_sample_identifier_param
    """
    with HalconOperator(915) as proc:
        proc.set_input_tuple(0, gen_param_name)
        proc.set_input_tuple(1, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        sample_identifier = proc.get_output_tuple_s(0)
        return sample_identifier  # type: ignore


def create_scaled_shape_model(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    scale_min: float,
    scale_max: float,
    scale_step: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    contrast: MaybeSequence[Union[int, str]],
    min_contrast: Union[int, str]
) -> HHandle:
    """
    Prepare an isotropically scaled shape model for matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep >= 0 && AngleStep <= pi / 16

    scale_min : float
                Minimum scale of the pattern.
                Value Suggestion: 0.9
                Assertion: ScaleMin > 0

    scale_max : float
                Maximum scale of the pattern.
                Value Suggestion: 1.1
                Assertion: ScaleMax >= ScaleMin

    scale_step : Union[float, str]
                 Scale step length (resolution).
                 Value Suggestion: auto
                 Assertion: ScaleStep >= 0

    optimization : MaybeSequence[str]
                   Kind of optimization and optionally method used for
                   generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : MaybeSequence[Union[int, str]]
               Threshold or hysteresis thresholds for the contrast of the
               object in the template image and optionally minimum size of
               the object parts.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    create_shape_model, create_aniso_shape_model

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    find_scaled_shape_model, find_scaled_shape_models,
    get_shape_model_params, clear_shape_model, write_shape_model,
    set_shape_model_origin, set_shape_model_clutter
    """
    with HalconOperator(939) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_min)
        proc.set_input_tuple(5, scale_max)
        proc.set_input_tuple(6, scale_step)
        proc.set_input_tuple(7, optimization)
        proc.set_input_tuple(8, metric)
        proc.set_input_tuple(9, contrast)
        proc.set_input_tuple(10, min_contrast)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_scaled_shape_model_xld(
    contours: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    scale_min: float,
    scale_max: float,
    scale_step: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    min_contrast: int
) -> HHandle:
    """
    Prepare an isotropically scaled shape model for matching from XLD
    contours.

    Parameters
    ----------

    contours : HObject
               Input contours that will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    scale_min : float
                Minimum scale of the pattern.
                Value Suggestion: 0.9
                Assertion: ScaleMin > 0

    scale_max : float
                Maximum scale of the pattern.
                Value Suggestion: 1.1
                Assertion: ScaleMax >= ScaleMin

    scale_step : Union[float, str]
                 Scale step length (resolution).
                 Value Suggestion: auto
                 Assertion: ScaleStep > 0

    optimization : MaybeSequence[str]
                   Kind of optimization and optionally method used for
                   generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: ignore_local_polarity

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 5

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    create_shape_model_xld, create_aniso_shape_model_xld

    Predecessors
    ------------
    read_contour_xld_dxf, edges_sub_pix, select_contours_xld

    Successors
    ----------
    find_scaled_shape_model, find_scaled_shape_models,
    get_shape_model_params, clear_shape_model, write_shape_model,
    set_shape_model_origin, set_shape_model_param, set_shape_model_metric,
    set_shape_model_clutter

    Notes
    -----
    The XLD contours passed in Contours should have been scaled to
    approximately the average size of the object in the search images.
    This means that the product $ScaleMin
    arRef{ScaleMax}$ScaleMin*ScaleMax should be approximately equal to 1.
    Note that, in contrast to the operator create_scaled_shape_model, it
    is not possible to specify a minimum size of the model components. To
    avoid small model components in the shape model, short contours can be
    eliminated before calling create_scaled_shape_model_xld with the
    operator select_contours_xld.
    """
    with HalconOperator(936) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, scale_min)
        proc.set_input_tuple(5, scale_max)
        proc.set_input_tuple(6, scale_step)
        proc.set_input_tuple(7, optimization)
        proc.set_input_tuple(8, metric)
        proc.set_input_tuple(9, min_contrast)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_scattered_data_interpolator(
    method: str,
    rows: Sequence[Union[float, int]],
    columns: Sequence[Union[float, int]],
    values: Sequence[Union[float, int]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HHandle:
    """
    Creates an interpolator for the interpolation of scattered data.

    Parameters
    ----------

    method : str
             Method for the interpolation
             Value Suggestion: 'thin_plate_splines'

    rows : Sequence[Union[float, int]]
           Row coordinates of the points used  for the interpolation

    columns : Sequence[Union[float, int]]
              Column coordinates of the points used  for the interpolation

    values : Sequence[Union[float, int]]
             Values of the points used  for the interpolation

    gen_param_name : Sequence[str]
                     Names of the generic parameters  that can be adjusted
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters that can be adjusted
                      Value Suggestion: []

    Returns
    -------

    scattered_data_interpolator_handle : HHandle
                                         Handle of the scattered data
                                         interpolator

    Successors
    ----------
    interpolate_scattered_data
    """
    with HalconOperator(292) as proc:
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, rows)
        proc.set_input_tuple(2, columns)
        proc.set_input_tuple(3, values)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        scattered_data_interpolator_handle = proc.get_output_tuple_s(0)
        return scattered_data_interpolator_handle  # type: ignore


def create_scene_3d() -> HHandle:
    """
    Create the data structure that is needed to visualize collections of
    3D objects.

    Returns
    -------

    scene_3d : HHandle
               Handle of the 3D scene.

    See Also
    --------
    clear_scene_3d

    Successors
    ----------
    add_scene_3d_instance, add_scene_3d_light, add_scene_3d_camera,
    set_scene_3d_param
    """
    with HalconOperator(1220) as proc:
        proc.init_oct(0)
        proc.execute()
        scene_3d = proc.get_output_tuple_s(0)
        return scene_3d  # type: ignore


def create_serialized_item_ptr(
    pointer: int,
    size: int,
    copy: str
) -> HHandle:
    """
    Create a serialized item.

    Parameters
    ----------

    pointer : int
              Data pointer of the serialized item.

    size : int
           Size of the serialized item.

    copy : str
           Copy mode of the serialized item.
           Value Suggestion: true

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    get_serialized_item_ptr

    Warnings
    --------
    It is not recommended to use the operator create_serialized_item_ptr
    in HDevelop.

    Notes
    -----
    If the parameter Copy is set to 'false', the data pointer of the
    serialized item must not be deleted during using the new serialized
    item.
    """
    with HalconOperator(410) as proc:
        proc.set_input_tuple(0, pointer)
        proc.set_input_tuple(1, size)
        proc.set_input_tuple(2, copy)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def create_shape_model(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    contrast: MaybeSequence[Union[int, str]],
    min_contrast: Union[int, str]
) -> HHandle:
    """
    Prepare a shape model for matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep >= 0 && AngleStep <= pi / 16

    optimization : MaybeSequence[str]
                   Kind of optimization and optionally method used for
                   generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : MaybeSequence[Union[int, str]]
               Threshold or hysteresis thresholds for the contrast of the
               object in the template image and optionally minimum size of
               the object parts.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    create_scaled_shape_model, create_aniso_shape_model

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    find_shape_model, find_shape_models, get_shape_model_params,
    clear_shape_model, write_shape_model, set_shape_model_origin,
    set_shape_model_clutter
    """
    with HalconOperator(940) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, optimization)
        proc.set_input_tuple(5, metric)
        proc.set_input_tuple(6, contrast)
        proc.set_input_tuple(7, min_contrast)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_shape_model_3d(
    object_model_3d: HHandle,
    cam_param: Sequence[Union[int, float, str]],
    ref_rot_x: float,
    ref_rot_y: float,
    ref_rot_z: float,
    order_of_rotation: str,
    longitude_min: float,
    longitude_max: float,
    latitude_min: float,
    latitude_max: float,
    cam_roll_min: float,
    cam_roll_max: float,
    dist_min: float,
    dist_max: float,
    min_contrast: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Prepare a 3D object model for matching.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    cam_param : Sequence[Union[int, float, str]]
                Internal camera parameters.

    ref_rot_x : float
                Reference orientation: Rotation around x-axis or x
                component of the Rodriguez vector (in radians or without
                unit).
                Value Suggestion: 0

    ref_rot_y : float
                Reference orientation: Rotation around y-axis or y
                component of the Rodriguez vector (in radians or without
                unit).
                Value Suggestion: 0

    ref_rot_z : float
                Reference orientation: Rotation around z-axis or z
                component of the Rodriguez vector (in radians or without
                unit).
                Value Suggestion: 0

    order_of_rotation : str
                        Meaning of the rotation values of the reference
                        orientation.
                        Value Suggestion: 'gba'

    longitude_min : float
                    Minimum longitude of the model views.
                    Value Suggestion: -0.35

    longitude_max : float
                    Maximum longitude of the model views.
                    Value Suggestion: 0.35
                    Assertion: LongitudeMax >= LongitudeMin

    latitude_min : float
                   Minimum latitude of the model views.
                   Value Suggestion: -0.35
                   Assertion: - pi / 2 <= LatitudeMin && LatitudeMin <= pi / 2

    latitude_max : float
                   Maximum latitude of the model views.
                   Value Suggestion: 0.35
                   Assertion: - pi / 2 <= LatitudeMax && LatitudeMax <= pi / 2 && LatitudeMax >= LatitudeMin

    cam_roll_min : float
                   Minimum camera roll angle of the model views.
                   Value Suggestion: -3.1416

    cam_roll_max : float
                   Maximum camera roll angle of the model views.
                   Value Suggestion: 3.1416
                   Assertion: CamRollMax >= CamRollMin

    dist_min : float
               Minimum camera-object-distance of the model views.
               Value Suggestion: 0.3
               Assertion: DistMin > 0

    dist_max : float
               Maximum camera-object-distance of the model views.
               Value Suggestion: 0.4
               Assertion: DistMax >= DistMin

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 10

    gen_param_name : MaybeSequence[str]
                     Names of (optional) parameters for controlling the
                     behavior of the operator.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the optional generic parameters.
                      Value Suggestion: []

    Returns
    -------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    See Also
    --------
    convert_point_3d_cart_to_spher, convert_point_3d_spher_to_cart,
    create_cam_pose_look_at_point, trans_pose_shape_model_3d

    Predecessors
    ------------
    read_object_model_3d, project_object_model_3d,
    get_object_model_3d_params

    Successors
    ----------
    find_shape_model_3d, write_shape_model_3d, project_shape_model_3d,
    get_shape_model_3d_params, get_shape_model_3d_contours
    """
    with HalconOperator(1059) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, cam_param)
        proc.set_input_tuple(2, ref_rot_x)
        proc.set_input_tuple(3, ref_rot_y)
        proc.set_input_tuple(4, ref_rot_z)
        proc.set_input_tuple(5, order_of_rotation)
        proc.set_input_tuple(6, longitude_min)
        proc.set_input_tuple(7, longitude_max)
        proc.set_input_tuple(8, latitude_min)
        proc.set_input_tuple(9, latitude_max)
        proc.set_input_tuple(10, cam_roll_min)
        proc.set_input_tuple(11, cam_roll_max)
        proc.set_input_tuple(12, dist_min)
        proc.set_input_tuple(13, dist_max)
        proc.set_input_tuple(14, min_contrast)
        proc.set_input_tuple(15, gen_param_name)
        proc.set_input_tuple(16, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        shape_model_3did = proc.get_output_tuple_s(0)
        return shape_model_3did  # type: ignore


def create_shape_model_xld(
    contours: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    angle_step: Union[float, str],
    optimization: MaybeSequence[str],
    metric: str,
    min_contrast: int
) -> HHandle:
    """
    Prepare a shape model for matching from XLD contours.

    Parameters
    ----------

    contours : HObject
               Input contours that will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    angle_step : Union[float, str]
                 Step length of the angles (resolution).
                 Value Suggestion: auto
                 Assertion: AngleStep > 0 && AngleStep <= pi / 16

    optimization : MaybeSequence[str]
                   Kind of optimization and optionally method used for
                   generating the model.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: ignore_local_polarity

    min_contrast : int
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: 5

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    create_scaled_shape_model_xld, create_aniso_shape_model_xld

    Predecessors
    ------------
    read_contour_xld_dxf, edges_sub_pix, select_contours_xld

    Successors
    ----------
    find_shape_model, find_shape_models, get_shape_model_params,
    clear_shape_model, write_shape_model, set_shape_model_origin,
    set_shape_model_param, set_shape_model_metric, set_shape_model_clutter

    Notes
    -----
    Note that, in contrast to the operator create_shape_model, it is not
    possible to specify a minimum size of the model components. To avoid
    small model components in the shape model, short contours can be
    eliminated before calling create_shape_model_xld with the operator
    select_contours_xld.
    """
    with HalconOperator(937) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, optimization)
        proc.set_input_tuple(5, metric)
        proc.set_input_tuple(6, min_contrast)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_sheet_of_light_calib_object(
    width: float,
    length: float,
    height_min: float,
    height_max: float,
    file_name: str
) -> None:
    """
    Create a calibration object for sheet-of-light calibration.

    Parameters
    ----------

    width : float
            Width of the object.
            Value Suggestion: 0.1

    length : float
             Length of the object.
             Value Suggestion: 0.15

    height_min : float
                 Minimum height of the ramp.
                 Value Suggestion: 0.005

    height_max : float
                 Maximum height of the ramp.
                 Value Suggestion: 0.04

    file_name : str
                Filename of the model of the calibration object.
                Value Suggestion: 'calib_object.dxf'
    """
    with HalconOperator(378) as proc:
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, length)
        proc.set_input_tuple(2, height_min)
        proc.set_input_tuple(3, height_max)
        proc.set_input_tuple(4, file_name)
        proc.execute()


def create_sheet_of_light_model(
    profile_region: HObject,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Create a model to perform 3D-measurements using the sheet-of-light
    technique.

    Parameters
    ----------

    profile_region : HObject
                     Region of the images containing the profiles to be
                     processed. If the provided region is not rectangular,
                     its smallest enclosing rectangle will be used.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the sheet-of-light model.
                     Value Suggestion: min_gray

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the generic parameters that can be
                      adjusted for the sheet-of-light model.
                      Value Suggestion: 50

    Returns
    -------

    sheet_of_light_model_id : HHandle
                              Handle for using and accessing the
                              sheet-of-light model.

    See Also
    --------
    clear_sheet_of_light_model, calibrate_sheet_of_light

    Predecessors
    ------------
    gen_rectangle1

    Successors
    ----------
    set_sheet_of_light_param, measure_profile_sheet_of_light
    """
    with HalconOperator(391) as proc:
        proc.set_input_object(1, profile_region)
        proc.set_input_tuple(0, gen_param_name)
        proc.set_input_tuple(1, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        sheet_of_light_model_id = proc.get_output_tuple_s(0)
        return sheet_of_light_model_id  # type: ignore


def create_stereo_model(
    camera_setup_model_id: HHandle,
    method: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> HHandle:
    """
    Create a HALCON stereo model.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    method : str
             Reconstruction method.
             Value Suggestion: surface_pairwise

    gen_param_name : MaybeSequence[str]
                     Name of the model parameter to be set.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Value of the model parameter to be set.
                      Value Suggestion: []

    Returns
    -------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    Successors
    ----------
    set_stereo_model_param, set_stereo_model_image_pairs,
    reconstruct_surface_stereo, reconstruct_points_stereo
    """
    with HalconOperator(527) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        stereo_model_id = proc.get_output_tuple_s(0)
        return stereo_model_id  # type: ignore


def create_structured_light_model(model_type: str) -> HHandle:
    """
    Create a structured light model.

    Parameters
    ----------

    model_type : str
                 The type of the created structured light model.
                 Value Suggestion: deflectometry

    Returns
    -------

    structured_light_model : HHandle
                             Handle for using and accessing the structured
                             light model.

    Successors
    ----------
    set_structured_light_model_param, get_structured_light_model_param
    """
    with HalconOperator(2107) as proc:
        proc.set_input_tuple(0, model_type)
        proc.init_oct(0)
        proc.execute()
        structured_light_model = proc.get_output_tuple_s(0)
        return structured_light_model  # type: ignore


def create_surface_model(
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> HHandle:
    """
    Create the data structure needed to perform surface-based matching.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    rel_sampling_distance : float
                            Sampling distance relative to the object's
                            diameter
                            Value Suggestion: 0.03
                            Assertion: 0 < RelSamplingDistance < 1

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    surface_model_id : HHandle
                       Handle of the surface model.

    See Also
    --------
    find_surface_model, refine_surface_model_pose, read_surface_model,
    write_surface_model, clear_surface_model, set_surface_model_param

    Alternatives
    ------------
    read_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, surface_normals_object_model_3d

    Successors
    ----------
    find_surface_model, refine_surface_model_pose,
    get_surface_model_param, write_surface_model, clear_surface_model,
    set_surface_model_param
    """
    with HalconOperator(1044) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, rel_sampling_distance)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        surface_model_id = proc.get_output_tuple_s(0)
        return surface_model_id  # type: ignore


def create_template(
    template: HObject,
    first_error: int,
    num_level: int,
    optimize: str,
    gray_values: str
) -> HHandle:
    """
    Preparing a pattern for template matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be processed for the pattern
               matching.

    first_error : int
                  Not yet in use.
                  Value Suggestion: 255

    num_level : int
                Maximal number of pyramid levels.
                Value Suggestion: 4

    optimize : str
               Kind of optimizing.
               Value Suggestion: sort

    gray_values : str
                  Kind of gray values.
                  Value Suggestion: original

    Returns
    -------

    template_id : HHandle
                  Template number.

    Alternatives
    ------------
    create_ncc_model, create_template_rot, read_template

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    adapt_template, set_reference_template, clear_template,
    write_template, set_offset_template, best_match, best_match_mg,
    fast_match, fast_match_mg

    Warnings
    --------
    create_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1489) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, first_error)
        proc.set_input_tuple(1, num_level)
        proc.set_input_tuple(2, optimize)
        proc.set_input_tuple(3, gray_values)
        proc.init_oct(0)
        proc.execute()
        template_id = proc.get_output_tuple_s(0)
        return template_id  # type: ignore


def create_template_rot(
    template: HObject,
    num_level: int,
    angle_start: float,
    angle_extend: float,
    angle_step: float,
    optimize: str,
    gray_values: str
) -> HHandle:
    """
    Preparing a pattern for template matching with rotation.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be processed for the pattern
               matching.

    num_level : int
                Maximal number of pyramid levels.
                Value Suggestion: 4

    angle_start : float
                  Smallest Rotation of the pattern.
                  Value Suggestion: -0.39

    angle_extend : float
                   Maximum positive Extension of AngleStart.
                   Value Suggestion: 0.79
                   Assertion: AngleExtend > 0

    angle_step : float
                 Step rate (angle precision) of matching.
                 Value Suggestion: 0.0982
                 Assertion: AngleStep > 0

    optimize : str
               Kind of optimizing.
               Value Suggestion: sort

    gray_values : str
                  Kind of gray values.
                  Value Suggestion: original

    Returns
    -------

    template_id : HHandle
                  Template number.

    Alternatives
    ------------
    create_ncc_model, create_template

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    best_match_rot, best_match_rot_mg, adapt_template,
    set_reference_template, clear_template, set_offset_template,
    write_template

    Warnings
    --------
    create_template_rot is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.

    Notes
    -----
    You have to be aware, that depending on the resolution a large number
    of pre calculated patterns have to be created which might result in a
    large amount of memory needed.
    """
    with HalconOperator(1488) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_level)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extend)
        proc.set_input_tuple(3, angle_step)
        proc.set_input_tuple(4, optimize)
        proc.set_input_tuple(5, gray_values)
        proc.init_oct(0)
        proc.execute()
        template_id = proc.get_output_tuple_s(0)
        return template_id  # type: ignore


def create_text_model() -> HHandle:
    """
    Create a text model.

    Returns
    -------

    text_model : HHandle
                 New text model.

    Warnings
    --------
    create_text_model is obsolete and is only provided for reasons of
    backward compatibility. New applications should use
    create_text_model_reader instead.
    """
    with HalconOperator(423) as proc:
        proc.init_oct(0)
        proc.execute()
        text_model = proc.get_output_tuple_s(0)
        return text_model  # type: ignore


def create_text_model_reader(
    mode: str,
    ocrclassifier: Union[int, str]
) -> HHandle:
    """
    Create a text model.

    Parameters
    ----------

    mode : str
           The Mode of the text model.
           Value Suggestion: auto

    ocrclassifier : Union[int, str]
                    OCR Classifier.
                    Value Suggestion: Universal_Rej.occ

    Returns
    -------

    text_model : HHandle
                 New text model.

    See Also
    --------
    clear_text_model

    Successors
    ----------
    set_text_model_param, get_text_model_param, find_text
    """
    with HalconOperator(422) as proc:
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, ocrclassifier)
        proc.init_oct(0)
        proc.execute()
        text_model = proc.get_output_tuple_s(0)
        return text_model  # type: ignore


def create_texture_inspection_model(model_type: str) -> HHandle:
    """
    Create a texture inspection model.

    Parameters
    ----------

    model_type : str
                 The type of the created texture inspection model.
                 Value Suggestion: basic

    Returns
    -------

    texture_inspection_model : HHandle
                               Handle for using and accessing the texture
                               inspection model.

    Successors
    ----------
    set_texture_inspection_model_param,
    get_texture_inspection_model_param, add_texture_inspection_model_image
    """
    with HalconOperator(2051) as proc:
        proc.set_input_tuple(0, model_type)
        proc.init_oct(0)
        proc.execute()
        texture_inspection_model = proc.get_output_tuple_s(0)
        return texture_inspection_model  # type: ignore


def create_trained_component_model(
    component_training_id: HHandle,
    angle_start: float,
    angle_extent: float,
    min_contrast_comp: MaybeSequence[Union[int, str]],
    min_score_comp: MaybeSequence[float],
    num_levels_comp: MaybeSequence[Union[int, str]],
    angle_step_comp: MaybeSequence[Union[float, str]],
    optimization_comp: str,
    metric_comp: MaybeSequence[str],
    pregeneration_comp: MaybeSequence[str]
) -> Tuple[HHandle, Sequence[int]]:
    """
    Prepare a component model for matching based on trained components.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    angle_start : float
                  Smallest rotation of the component model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation of the component model.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    min_contrast_comp : MaybeSequence[Union[int, str]]
                        Minimum contrast of the components in the search
                        images.
                        Value Suggestion: auto
                        Assertion: MinContrastComp >= 0

    min_score_comp : MaybeSequence[float]
                     Minimum score of the instances of the components to
                     be found.
                     Value Suggestion: 0.5
                     Assertion: 0 <= MinScoreComp && MinScoreComp <= 1

    num_levels_comp : MaybeSequence[Union[int, str]]
                      Maximum number of pyramid levels for the components.
                      Value Suggestion: auto

    angle_step_comp : MaybeSequence[Union[float, str]]
                      Step length of the angles (resolution) for the
                      components.
                      Value Suggestion: auto
                      Assertion: AngleStepComp >= 0

    optimization_comp : str
                        Kind of optimization for the components.
                        Value Suggestion: auto

    metric_comp : MaybeSequence[str]
                  Match metric used for the components.
                  Value Suggestion: use_polarity

    pregeneration_comp : MaybeSequence[str]
                         Complete pregeneration of the shape models for
                         the components if equal to 'true'.
                         Value Suggestion: false

    Returns
    -------

    component_model_id : HHandle
                         Handle of the component model.

    root_ranking : Sequence[int]
                   Ranking of the model components expressing the
                   suitability to act as the root component.

    See Also
    --------
    create_shape_model, find_shape_model

    Alternatives
    ------------
    create_component_model

    Predecessors
    ------------
    train_model_components, read_training_components

    Successors
    ----------
    find_component_model
    """
    with HalconOperator(1005) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, min_contrast_comp)
        proc.set_input_tuple(4, min_score_comp)
        proc.set_input_tuple(5, num_levels_comp)
        proc.set_input_tuple(6, angle_step_comp)
        proc.set_input_tuple(7, optimization_comp)
        proc.set_input_tuple(8, metric_comp)
        proc.set_input_tuple(9, pregeneration_comp)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # component_model_id
            proc.get_output_tuple_m(1)   # root_ranking
        )  # type: ignore


def create_trained_component_model_s(
    component_training_id: HHandle,
    angle_start: float,
    angle_extent: float,
    min_contrast_comp: MaybeSequence[Union[int, str]],
    min_score_comp: MaybeSequence[float],
    num_levels_comp: MaybeSequence[Union[int, str]],
    angle_step_comp: MaybeSequence[Union[float, str]],
    optimization_comp: str,
    metric_comp: MaybeSequence[str],
    pregeneration_comp: MaybeSequence[str]
) -> Tuple[HHandle, int]:
    """
    Prepare a component model for matching based on trained components.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    angle_start : float
                  Smallest rotation of the component model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation of the component model.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    min_contrast_comp : MaybeSequence[Union[int, str]]
                        Minimum contrast of the components in the search
                        images.
                        Value Suggestion: auto
                        Assertion: MinContrastComp >= 0

    min_score_comp : MaybeSequence[float]
                     Minimum score of the instances of the components to
                     be found.
                     Value Suggestion: 0.5
                     Assertion: 0 <= MinScoreComp && MinScoreComp <= 1

    num_levels_comp : MaybeSequence[Union[int, str]]
                      Maximum number of pyramid levels for the components.
                      Value Suggestion: auto

    angle_step_comp : MaybeSequence[Union[float, str]]
                      Step length of the angles (resolution) for the
                      components.
                      Value Suggestion: auto
                      Assertion: AngleStepComp >= 0

    optimization_comp : str
                        Kind of optimization for the components.
                        Value Suggestion: auto

    metric_comp : MaybeSequence[str]
                  Match metric used for the components.
                  Value Suggestion: use_polarity

    pregeneration_comp : MaybeSequence[str]
                         Complete pregeneration of the shape models for
                         the components if equal to 'true'.
                         Value Suggestion: false

    Returns
    -------

    component_model_id : HHandle
                         Handle of the component model.

    root_ranking : int
                   Ranking of the model components expressing the
                   suitability to act as the root component.

    See Also
    --------
    create_shape_model, find_shape_model

    Alternatives
    ------------
    create_component_model

    Predecessors
    ------------
    train_model_components, read_training_components

    Successors
    ----------
    find_component_model
    """
    with HalconOperator(1005) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, min_contrast_comp)
        proc.set_input_tuple(4, min_score_comp)
        proc.set_input_tuple(5, num_levels_comp)
        proc.set_input_tuple(6, angle_step_comp)
        proc.set_input_tuple(7, optimization_comp)
        proc.set_input_tuple(8, metric_comp)
        proc.set_input_tuple(9, pregeneration_comp)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # component_model_id
            proc.get_output_tuple_s(1)   # root_ranking
        )  # type: ignore


def create_uncalib_descriptor_model(
    template: HObject,
    detector_type: str,
    detector_param_name: Sequence[str],
    detector_param_value: Sequence[Union[int, float, str]],
    descriptor_param_name: Sequence[str],
    descriptor_param_value: Sequence[Union[int, float, str]],
    seed: int
) -> HHandle:
    """
    Prepare a descriptor model for interest point matching.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    detector_type : str
                    The type of the detector.
                    Value Suggestion: lepetit

    detector_param_name : Sequence[str]
                          The detector's parameter names.
                          Value Suggestion: []

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detector's parameters.
                           Value Suggestion: []

    descriptor_param_name : Sequence[str]
                            The descriptor's parameter names.
                            Value Suggestion: []

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptor's parameters.
                             Value Suggestion: []

    seed : int
           The seed for the random number generator.
           Value Suggestion: 42

    Returns
    -------

    model_id : HHandle
               The handle to the descriptor model.

    See Also
    --------
    get_descriptor_model_params, find_uncalib_descriptor_model

    Predecessors
    ------------
    points_lepetit, points_harris, reduce_domain

    Successors
    ----------
    get_descriptor_model_params, find_uncalib_descriptor_model
    """
    with HalconOperator(953) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, detector_type)
        proc.set_input_tuple(1, detector_param_name)
        proc.set_input_tuple(2, detector_param_value)
        proc.set_input_tuple(3, descriptor_param_name)
        proc.set_input_tuple(4, descriptor_param_value)
        proc.set_input_tuple(5, seed)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def create_variation_model(
    width: int,
    height: int,
    type: str,
    mode: str
) -> HHandle:
    """
    Create a variation model for image comparison.

    Parameters
    ----------

    width : int
            Width of the images to be compared.
            Value Suggestion: 640

    height : int
             Height of the images to be compared.
             Value Suggestion: 480

    type : str
           Type of the images to be compared.
           Value Suggestion: byte

    mode : str
           Method used for computing the variation model.
           Value Suggestion: standard

    Returns
    -------

    model_id : HHandle
               ID of the variation model.

    See Also
    --------
    prepare_variation_model, clear_variation_model,
    clear_train_data_variation_model, find_shape_model, affine_trans_image

    Successors
    ----------
    train_variation_model, prepare_direct_variation_model
    """
    with HalconOperator(95) as proc:
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, type)
        proc.set_input_tuple(3, mode)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def critical_points_sub_pix(
    image: HObject,
    filter: str,
    sigma: float,
    threshold: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Subpixel precise detection of critical points in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Method for the calculation of the partial derivatives.
             Value Suggestion: facet

    sigma : float
            Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0
            to avoid the smoothing of the input image.
            Assertion: Sigma >= 0.0

    threshold : float
                Minimum absolute value of the eigenvalues of the Hessian
                matrix.
                Value Suggestion: 5.0
                Assertion: Threshold >= 0.0

    Returns
    -------

    row_min : Sequence[float]
              Row coordinates of the detected minima.

    column_min : Sequence[float]
                 Column coordinates of the detected minima.

    row_max : Sequence[float]
              Row coordinates of the detected maxima.

    column_max : Sequence[float]
                 Column coordinates of the detected maxima.

    row_saddle : Sequence[float]
                 Row coordinates of the detected saddle points.

    column_saddle : Sequence[float]
                    Column coordinates of the detected saddle points.

    See Also
    --------
    local_min, local_max, plateaus, plateaus_center, lowlands,
    lowlands_center

    Alternatives
    ------------
    local_min_sub_pix, local_max_sub_pix, saddle_points_sub_pix

    Successors
    ----------
    gen_cross_contour_xld, disp_cross

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1434) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_min
            proc.get_output_tuple_m(1),  # column_min
            proc.get_output_tuple_m(2),  # row_max
            proc.get_output_tuple_m(3),  # column_max
            proc.get_output_tuple_m(4),  # row_saddle
            proc.get_output_tuple_m(5)   # column_saddle
        )  # type: ignore


def crop_contours_xld(
    contours: HObject,
    row_1: Union[float, int],
    col_1: Union[float, int],
    row_2: Union[float, int],
    col_2: Union[float, int],
    close_contours: str
) -> HObject:
    """
    Crop an XLD contour.

    Parameters
    ----------

    contours : HObject
               Input contours.

    row_1 : Union[float, int]
            Upper border of the cropping rectangle.
            Value Suggestion: 0

    col_1 : Union[float, int]
            Left border of the cropping rectangle.
            Value Suggestion: 0

    row_2 : Union[float, int]
            Lower border of the cropping rectangle.
            Value Suggestion: 512

    col_2 : Union[float, int]
            Right border of the cropping rectangle.
            Value Suggestion: 512

    close_contours : str
                     Should closed contours produce closed output contours?
                     Value Suggestion: true

    Returns
    -------

    cropped_contours : HObject
                       Output contours.

    See Also
    --------
    clip_region, crop_part, clip_contours_xld

    Alternatives
    ------------
    clip_contours_xld
    """
    with HalconOperator(14) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, col_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, col_2)
        proc.set_input_tuple(4, close_contours)
        proc.execute()
        cropped_contours = HObject(proc.get_output_object_key(1))
        return cropped_contours  # type: ignore


def crop_domain(image: HObject) -> HObject:
    """
    Cut out of defined gray values.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_part : HObject
                 Image area.

    See Also
    --------
    zoom_image_size, zoom_image_factor

    Alternatives
    ------------
    crop_part, crop_rectangle1, change_format, reduce_domain

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1139) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_part = HObject(proc.get_output_object_key(1))
        return image_part  # type: ignore


def crop_domain_rel(
    image: HObject,
    top: int,
    left: int,
    bottom: int,
    right: int
) -> HObject:
    """
    Cut out an image area relative to the domain.

    Parameters
    ----------

    image : HObject
            Input image.

    top : int
          Number of rows clipped at the top.
          Value Suggestion: -1

    left : int
           Number of columns clipped at the left.
           Value Suggestion: -1

    bottom : int
             Number of rows clipped at the bottom.
             Value Suggestion: -1

    right : int
            Number of columns clipped at the right.
            Value Suggestion: -1

    Returns
    -------

    image_part : HObject
                 Image area.

    See Also
    --------
    smallest_rectangle1, intersection, gen_rectangle1, clip_region

    Alternatives
    ------------
    crop_domain, crop_rectangle1

    Predecessors
    ------------
    reduce_domain, threshold, connection, regiongrowing, pouring
    """
    with HalconOperator(726) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, top)
        proc.set_input_tuple(1, left)
        proc.set_input_tuple(2, bottom)
        proc.set_input_tuple(3, right)
        proc.execute()
        image_part = HObject(proc.get_output_object_key(1))
        return image_part  # type: ignore


def crop_part(
    image: HObject,
    row: MaybeSequence[int],
    column: MaybeSequence[int],
    width: MaybeSequence[int],
    height: MaybeSequence[int]
) -> HObject:
    """
    Cut out one or more rectangular image areas.

    Parameters
    ----------

    image : HObject
            Input image.

    row : MaybeSequence[int]
          Line index of upper left corner of image area.
          Value Suggestion: 100

    column : MaybeSequence[int]
             Column index of upper left corner of image area.
             Value Suggestion: 100

    width : MaybeSequence[int]
            Width of new image.
            Value Suggestion: 128

    height : MaybeSequence[int]
             Height of new image.
             Value Suggestion: 128

    Returns
    -------

    image_part : HObject
                 Image area.

    See Also
    --------
    zoom_image_size, zoom_image_factor

    Alternatives
    ------------
    crop_rectangle1, crop_domain, change_format, reduce_domain

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1141) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.execute()
        image_part = HObject(proc.get_output_object_key(1))
        return image_part  # type: ignore


def crop_rectangle1(
    image: HObject,
    row_1: MaybeSequence[int],
    column_1: MaybeSequence[int],
    row_2: MaybeSequence[int],
    column_2: MaybeSequence[int]
) -> HObject:
    """
    Cut out one or more rectangular image areas.

    Parameters
    ----------

    image : HObject
            Input image.

    row_1 : MaybeSequence[int]
            Line index of upper left corner of image area.
            Value Suggestion: 100

    column_1 : MaybeSequence[int]
               Column index of upper left corner of image area.
               Value Suggestion: 100

    row_2 : MaybeSequence[int]
            Line index of lower right corner of image area.
            Value Suggestion: 200

    column_2 : MaybeSequence[int]
               Column index of lower right corner of image area.
               Value Suggestion: 200

    Returns
    -------

    image_part : HObject
                 Image area.

    See Also
    --------
    zoom_image_size, zoom_image_factor

    Alternatives
    ------------
    crop_part, crop_domain, change_format, reduce_domain

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1140) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.execute()
        image_part = HObject(proc.get_output_object_key(1))
        return image_part  # type: ignore


def crop_rectangle2(
    image: HObject,
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    length_1: MaybeSequence[Union[int, float]],
    length_2: MaybeSequence[Union[int, float]],
    align_to_axis: str,
    interpolation: str
) -> HObject:
    """
    Cut out one or more arbitrarily oriented rectangular image areas.

    Parameters
    ----------

    image : HObject
            Input image(s).

    row : MaybeSequence[Union[int, float]]
          Row index of the image crop center.
          Value Suggestion: 300.0

    column : MaybeSequence[Union[int, float]]
             Column index of the image crop center.
             Value Suggestion: 200.0

    phi : MaybeSequence[Union[int, float]]
          Orientation of the rectangle (arc measure).
          Value Suggestion: 0.0

    length_1 : MaybeSequence[Union[int, float]]
               First half edge length of the rectangle.
               Value Suggestion: 100.0

    length_2 : MaybeSequence[Union[int, float]]
               Second half edge length of the rectangle.
               Value Suggestion: 20.0

    align_to_axis : str
                    Determines whether the cropped image part is aligned
                    with the coordinate axes.
                    Value Suggestion: true

    interpolation : str
                    Interpolation method.
                    Value Suggestion: constant

    Returns
    -------

    image_part : HObject
                 Cropped image part(s).

    See Also
    --------
    zoom_image_size, zoom_image_factor

    Alternatives
    ------------
    crop_domain, crop_rectangle1, crop_part, change_format, reduce_domain

    Successors
    ----------
    disp_image
    """
    with HalconOperator(2209) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, length_1)
        proc.set_input_tuple(4, length_2)
        proc.set_input_tuple(5, align_to_axis)
        proc.set_input_tuple(6, interpolation)
        proc.execute()
        image_part = HObject(proc.get_output_object_key(1))
        return image_part  # type: ignore


def deactivate_all_compute_devices() -> None:
    """
    Deactivate all compute devices.

    See Also
    --------
    activate_compute_device, deactivate_compute_device
    """
    with HalconOperator(300) as proc:
        proc.execute()


def deactivate_compute_device(device_handle: HHandle) -> None:
    """
    Deactivate a compute device.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    See Also
    --------
    deactivate_all_compute_devices

    Predecessors
    ------------
    activate_compute_device
    """
    with HalconOperator(301) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.execute()


def decode_bar_code_rectangle2(
    image: HObject,
    bar_code_handle: HHandle,
    code_type: MaybeSequence[str],
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    length_1: MaybeSequence[Union[int, float]],
    length_2: MaybeSequence[Union[int, float]]
) -> Sequence[str]:
    """
    Decode bar code symbols within a rectangle.

    Parameters
    ----------

    image : HObject
            Input image.

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_type : MaybeSequence[str]
                Type of the searched bar code.
                Value Suggestion: 'EAN-13'

    row : MaybeSequence[Union[int, float]]
          Row index of the center.
          Value Suggestion: 50.0

    column : MaybeSequence[Union[int, float]]
             Column index of the center.
             Value Suggestion: 100.0

    phi : MaybeSequence[Union[int, float]]
          Orientation of rectangle in radians.
          Value Suggestion: 0.0

    length_1 : MaybeSequence[Union[int, float]]
               Half of the length of the rectangle along the reading
               direction of the bar code.
               Value Suggestion: 200.0

    length_2 : MaybeSequence[Union[int, float]]
               Half of the length of the rectangle perpendicular to the
               reading direction of the bar code.
               Value Suggestion: 100.0

    Returns
    -------

    decoded_data_strings : Sequence[str]
                           Data strings of all successfully decoded bar
                           codes.

    See Also
    --------
    gen_rectangle2

    Alternatives
    ------------
    find_bar_code

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param, smallest_rectangle2

    Successors
    ----------
    get_bar_code_result, get_bar_code_object, clear_bar_code_model
    """
    with HalconOperator(1992) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_type)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, phi)
        proc.set_input_tuple(5, length_1)
        proc.set_input_tuple(6, length_2)
        proc.init_oct(0)
        proc.execute()
        decoded_data_strings = proc.get_output_tuple_m(0)
        return decoded_data_strings  # type: ignore


def decode_bar_code_rectangle2_s(
    image: HObject,
    bar_code_handle: HHandle,
    code_type: MaybeSequence[str],
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    length_1: MaybeSequence[Union[int, float]],
    length_2: MaybeSequence[Union[int, float]]
) -> str:
    """
    Decode bar code symbols within a rectangle.

    Parameters
    ----------

    image : HObject
            Input image.

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_type : MaybeSequence[str]
                Type of the searched bar code.
                Value Suggestion: 'EAN-13'

    row : MaybeSequence[Union[int, float]]
          Row index of the center.
          Value Suggestion: 50.0

    column : MaybeSequence[Union[int, float]]
             Column index of the center.
             Value Suggestion: 100.0

    phi : MaybeSequence[Union[int, float]]
          Orientation of rectangle in radians.
          Value Suggestion: 0.0

    length_1 : MaybeSequence[Union[int, float]]
               Half of the length of the rectangle along the reading
               direction of the bar code.
               Value Suggestion: 200.0

    length_2 : MaybeSequence[Union[int, float]]
               Half of the length of the rectangle perpendicular to the
               reading direction of the bar code.
               Value Suggestion: 100.0

    Returns
    -------

    decoded_data_strings : str
                           Data strings of all successfully decoded bar
                           codes.

    See Also
    --------
    gen_rectangle2

    Alternatives
    ------------
    find_bar_code

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param, smallest_rectangle2

    Successors
    ----------
    get_bar_code_result, get_bar_code_object, clear_bar_code_model
    """
    with HalconOperator(1992) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_type)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, phi)
        proc.set_input_tuple(5, length_1)
        proc.set_input_tuple(6, length_2)
        proc.init_oct(0)
        proc.execute()
        decoded_data_strings = proc.get_output_tuple_s(0)
        return decoded_data_strings  # type: ignore


def decode_structured_light_pattern(
    camera_images: HObject,
    structured_light_model: HHandle
) -> None:
    """
    Decode the camera images acquired with a structured light setup.

    Parameters
    ----------

    camera_images : HObject
                    Acquired camera images.

    structured_light_model : HHandle
                             Handle of the structured light model.

    See Also
    --------
    create_structured_light_model, set_structured_light_model_param

    Predecessors
    ------------
    gen_structured_light_pattern

    Successors
    ----------
    get_structured_light_object
    """
    with HalconOperator(2108) as proc:
        proc.set_input_object(1, camera_images)
        proc.set_input_tuple(0, structured_light_model)
        proc.execute()


def decompose2(
    multi_channel_image: HObject
) -> Tuple[HObject, HObject]:
    """
    Convert a two-channel image into two images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    Returns
    -------

    image_1 : HObject
              Output image 1.

    image_2 : HObject
              Output image 2.

    See Also
    --------
    compose2

    Alternatives
    ------------
    access_channel, image_to_channels

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1132) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_1
            HObject(proc.get_output_object_key(2))   # image_2
        )  # type: ignore


def decompose3(
    multi_channel_image: HObject
) -> Tuple[HObject, HObject, HObject]:
    """
    Convert a three-channel image into three images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    Returns
    -------

    image_1 : HObject
              Output image 1.

    image_2 : HObject
              Output image 2.

    image_3 : HObject
              Output image 3.

    See Also
    --------
    compose3

    Alternatives
    ------------
    access_channel, image_to_channels

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1131) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_1
            HObject(proc.get_output_object_key(2)),  # image_2
            HObject(proc.get_output_object_key(3))   # image_3
        )  # type: ignore


def decompose4(
    multi_channel_image: HObject
) -> Tuple[HObject, HObject, HObject, HObject]:
    """
    Convert a four-channel image into four images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    Returns
    -------

    image_1 : HObject
              Output image 1.

    image_2 : HObject
              Output image 2.

    image_3 : HObject
              Output image 3.

    image_4 : HObject
              Output image 4.

    See Also
    --------
    compose4

    Alternatives
    ------------
    access_channel, image_to_channels

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1130) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_1
            HObject(proc.get_output_object_key(2)),  # image_2
            HObject(proc.get_output_object_key(3)),  # image_3
            HObject(proc.get_output_object_key(4))   # image_4
        )  # type: ignore


def decompose5(
    multi_channel_image: HObject
) -> Tuple[HObject, HObject, HObject, HObject, HObject]:
    """
    Convert a five-channel image into five images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    Returns
    -------

    image_1 : HObject
              Output image 1.

    image_2 : HObject
              Output image 2.

    image_3 : HObject
              Output image 3.

    image_4 : HObject
              Output image 4.

    image_5 : HObject
              Output image 5.

    See Also
    --------
    compose5

    Alternatives
    ------------
    access_channel, image_to_channels

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1129) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_1
            HObject(proc.get_output_object_key(2)),  # image_2
            HObject(proc.get_output_object_key(3)),  # image_3
            HObject(proc.get_output_object_key(4)),  # image_4
            HObject(proc.get_output_object_key(5))   # image_5
        )  # type: ignore


def decompose6(
    multi_channel_image: HObject
) -> Tuple[HObject, HObject, HObject, HObject, HObject, HObject]:
    """
    Convert a six-channel image into six images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    Returns
    -------

    image_1 : HObject
              Output image 1.

    image_2 : HObject
              Output image 2.

    image_3 : HObject
              Output image 3.

    image_4 : HObject
              Output image 4.

    image_5 : HObject
              Output image 5.

    image_6 : HObject
              Output image 6.

    See Also
    --------
    compose6

    Alternatives
    ------------
    access_channel, image_to_channels

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1128) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_1
            HObject(proc.get_output_object_key(2)),  # image_2
            HObject(proc.get_output_object_key(3)),  # image_3
            HObject(proc.get_output_object_key(4)),  # image_4
            HObject(proc.get_output_object_key(5)),  # image_5
            HObject(proc.get_output_object_key(6))   # image_6
        )  # type: ignore


def decompose7(
    multi_channel_image: HObject
) -> Tuple[HObject, HObject, HObject, HObject, HObject, HObject, HObject]:
    """
    Convert a seven-channel image into seven images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image.

    Returns
    -------

    image_1 : HObject
              Output image 1.

    image_2 : HObject
              Output image 2.

    image_3 : HObject
              Output image 3.

    image_4 : HObject
              Output image 4.

    image_5 : HObject
              Output image 5.

    image_6 : HObject
              Output image 6.

    image_7 : HObject
              Output image 7.

    See Also
    --------
    compose7

    Alternatives
    ------------
    access_channel, image_to_channels

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1127) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_1
            HObject(proc.get_output_object_key(2)),  # image_2
            HObject(proc.get_output_object_key(3)),  # image_3
            HObject(proc.get_output_object_key(4)),  # image_4
            HObject(proc.get_output_object_key(5)),  # image_5
            HObject(proc.get_output_object_key(6)),  # image_6
            HObject(proc.get_output_object_key(7))   # image_7
        )  # type: ignore


def decompose_matrix(
    matrix_id: HHandle,
    matrix_type: str
) -> Tuple[HHandle, HHandle]:
    """
    Decompose a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_type : str
                  Type of the input matrix.
                  Value Suggestion: general

    Returns
    -------

    matrix_1id : HHandle
                 Matrix handle with the output matrix 1.

    matrix_2id : HHandle
                 Matrix handle with the output matrix 2.

    Alternatives
    ------------
    orthogonal_decompose_matrix, solve_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    For MatrixType = 'symmetric' or 'positive_definite', the upper
    triangular part of the input Matrix must contain the relevant
    information of the matrix. The strictly lower triangular part of the
    matrix is not referenced. For MatrixType = 'tridiagonal', only the
    main diagonal, the superdiagonal, and the subdiagonal of the input
    Matrix are used.  The other parts of the matrix are not referenced.
    If the referenced part of the input Matrix is not of the specified
    type, an exception is raised.
    """
    with HalconOperator(845) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # matrix_1id
            proc.get_output_tuple_s(1)   # matrix_2id
        )  # type: ignore


def delete_file(file_name: str) -> None:
    """
    Delete a file.

    Parameters
    ----------

    file_name : str
                File to be deleted.
    """
    with HalconOperator(1644) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()


def depth_from_focus(
    multi_focus_image: HObject,
    filter: MaybeSequence[Union[str, int]],
    selection: MaybeSequence[str]
) -> Tuple[HObject, HObject]:
    """
    Extract depth using multiple focus levels.

    Parameters
    ----------

    multi_focus_image : HObject
                        Multichannel gray image consisting of multiple
                        focus levels.

    filter : MaybeSequence[Union[str, int]]
             Filter used to find sharp pixels.
             Value Suggestion: highpass

    selection : MaybeSequence[str]
                Method used to find sharp pixels.
                Value Suggestion: next_maximum

    Returns
    -------

    depth : HObject
            Depth image.

    confidence : HObject
                 Confidence of depth estimation.

    See Also
    --------
    count_channels

    Predecessors
    ------------
    compose2, compose3, compose4, add_channels, read_image, read_sequence

    Successors
    ----------
    select_grayvalues_from_channels, mean_image, binomial_filter,
    gauss_filter, threshold

    Notes
    -----
    If MultiFocusImage contains more than 255 channels (focus levels),
    Depth is clipped at 255, i.e. depth values higher than 255 are
    ignored.
    If the filter mask for Filter is specified with even values, the
    routine uses the next larger odd values instead (this way the center
    of the filter mask is always explicitly determined).
    If Selection is set to 'local' and Filter is set to 'highpass' or
    'bandpass', depth_from_focus can be executed on OpenCL devices. If
    smoothing is enabled, the same restrictions and limitations as for
    mean_image apply.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1480) as proc:
        proc.set_input_object(1, multi_focus_image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, selection)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # depth
            HObject(proc.get_output_object_key(2))   # confidence
        )  # type: ignore


def dequeue_message(
    queue_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> Sequence[HHandle]:
    """
    Receive one or more messages from the message queue.

    Parameters
    ----------

    queue_handle : HHandle
                   Message queue handle.
                   Assertion: QueueHandle != 0

    gen_param_name : MaybeSequence[str]
                     Names of optional generic parameters
                     Value Suggestion: timeout

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of optional generic parameters
                      Value Suggestion: infinite

    Returns
    -------

    message_handle : Sequence[HHandle]
                     Handle(s) of the dequeued message(s).
                     Assertion: MessageHandle != 0

    See Also
    --------
    create_message_queue, clear_message_queue, enqueue_message,
    set_message_queue_param, get_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Successors
    ----------
    get_message_tuple, get_message_obj, get_message_param
    """
    with HalconOperator(530) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        message_handle = proc.get_output_tuple_m(0)
        return message_handle  # type: ignore


def dequeue_message_s(
    queue_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Receive one or more messages from the message queue.

    Parameters
    ----------

    queue_handle : HHandle
                   Message queue handle.
                   Assertion: QueueHandle != 0

    gen_param_name : MaybeSequence[str]
                     Names of optional generic parameters
                     Value Suggestion: timeout

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of optional generic parameters
                      Value Suggestion: infinite

    Returns
    -------

    message_handle : HHandle
                     Handle(s) of the dequeued message(s).
                     Assertion: MessageHandle != 0

    See Also
    --------
    create_message_queue, clear_message_queue, enqueue_message,
    set_message_queue_param, get_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Successors
    ----------
    get_message_tuple, get_message_obj, get_message_param
    """
    with HalconOperator(530) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        message_handle = proc.get_output_tuple_s(0)
        return message_handle  # type: ignore


def derivate_funct_1d(
    function: Sequence[Union[float, int]],
    mode: str
) -> Sequence[Union[float, int]]:
    """
    Calculate the derivatives of a function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function

    mode : str
           Type of derivative
           Value Suggestion: first

    Returns
    -------

    derivative : Sequence[Union[float, int]]
                 Derivative of the input function

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array, smooth_funct_1d_gauss,
    smooth_funct_1d_mean
    """
    with HalconOperator(1379) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, mode)
        proc.init_oct(0)
        proc.execute()
        derivative = proc.get_output_tuple_m(0)
        return derivative  # type: ignore


def derivate_gauss(
    image: HObject,
    sigma: MaybeSequence[float],
    component: str
) -> HObject:
    """
    Convolve an image with derivatives of the Gaussian.

    Parameters
    ----------

    image : HObject
            Input images.

    sigma : MaybeSequence[float]
            Sigma of the Gaussian.
            Value Suggestion: 1.0
            Assertion: 0.01 <= Sigma <= 50.0

    component : str
                Derivative or feature to be calculated.
                Value Suggestion: x

    Returns
    -------

    deriv_gauss : HObject
                  Filtered result images.

    See Also
    --------
    zero_crossing, dual_threshold

    Alternatives
    ------------
    laplace, laplace_of_gauss, binomial_filter, gauss_filter,
    smooth_image, isotropic_diffusion

    Successors
    ----------
    zero_crossing, dual_threshold

    Notes
    -----
    Besides the pure C version there are specific implementations of
    derivate_gauss for speed up. Such an optimization is applied in case
    it is supported by the system and the respective system parameter
    *_enable is set to 'true', see set_system. The following optimizations
    are supported (listed according to their priority): itemize - using
    AVX512f instructions ('avx512f_enable') - using AVX instructions
    ('avx_enable') - using SSE2 instructions ('sse2_enable') itemize These
    implementations are slightly inaccurate compared to the pure C version
    due to numerical issues. For example, using SSE2 instructions the
    inaccuracy is in order of magnitude of $1.0e-5$ for 'byte' images and
    Component set to 'none', 'x', or 'y'.
    In case accuracy is preferred over performance, set all corresponding
    system parameter to 'false' (using set_system) before calling
    derivate_gauss. This way derivate_gauss does not use the
    accelerations. Do not forget to set the parameter back to 'true'
    afterwards.
    derivate_gauss is only executed on an OpenCL device if Sigma induces a
    filter width respectively height of up to 129 pixels. This corresponds
    to a Sigma of less than $20.7$ for Component = 'none'. The OpenCL
    implementation is slightly inaccurate compared to the pure C version
    due to numerical issues.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1570) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, component)
        proc.execute()
        deriv_gauss = HObject(proc.get_output_object_key(1))
        return deriv_gauss  # type: ignore


def derivate_vector_field(
    vector_field: HObject,
    sigma: MaybeSequence[float],
    component: str
) -> HObject:
    """
    Convolve a vector field with derivatives of the Gaussian.

    Parameters
    ----------

    vector_field : HObject
                   Input vector field.

    sigma : MaybeSequence[float]
            Sigma of the Gaussian.
            Value Suggestion: 1.0
            Assertion: 0.01 <= Sigma <= 50.0

    component : str
                Component to be calculated.
                Value Suggestion: mean_curvature

    Returns
    -------

    result : HObject
             Filtered result images.

    Predecessors
    ------------
    optical_flow_mg, photometric_stereo

    Successors
    ----------
    threshold
    """
    with HalconOperator(1484) as proc:
        proc.set_input_object(1, vector_field)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, component)
        proc.execute()
        result = HObject(proc.get_output_object_key(1))
        return result  # type: ignore


def descript_class_box(
    classif_handle: HHandle,
    dimensions: int
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Describe the classes of a box classifier.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    dimensions : int
                 Highest dimension for output.
                 Value Suggestion: 3

    Returns
    -------

    class_idx : Sequence[int]
                Indices of the classes.

    box_idx : Sequence[int]
              Indices of the boxes.

    box_lower_bound : Sequence[int]
                      Lower bounds of the boxes (for each dimension).

    box_higher_bound : Sequence[int]
                       Higher bounds of the boxes (for each dimension).

    box_num_samples_train : Sequence[int]
                            Number of training samples that were used to
                            define this box (for each dimension).

    box_num_samples_wrong : Sequence[int]
                            Number of training samples that were assigned
                            incorrectly to the box.

    See Also
    --------
    create_class_box, enquire_class_box, learn_class_box, read_class_box,
    write_class_box

    Predecessors
    ------------
    create_class_box, learn_class_box, set_class_box_param

    Successors
    ----------
    enquire_class_box, learn_class_box, write_class_box, close_class_box

    Warnings
    --------
    descript_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1896) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, dimensions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_idx
            proc.get_output_tuple_m(1),  # box_idx
            proc.get_output_tuple_m(2),  # box_lower_bound
            proc.get_output_tuple_m(3),  # box_higher_bound
            proc.get_output_tuple_m(4),  # box_num_samples_train
            proc.get_output_tuple_m(5)   # box_num_samples_wrong
        )  # type: ignore


def descript_class_box_s(
    classif_handle: HHandle,
    dimensions: int
) -> Tuple[int, int, int, int, int, int]:
    """
    Describe the classes of a box classifier.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    dimensions : int
                 Highest dimension for output.
                 Value Suggestion: 3

    Returns
    -------

    class_idx : int
                Indices of the classes.

    box_idx : int
              Indices of the boxes.

    box_lower_bound : int
                      Lower bounds of the boxes (for each dimension).

    box_higher_bound : int
                       Higher bounds of the boxes (for each dimension).

    box_num_samples_train : int
                            Number of training samples that were used to
                            define this box (for each dimension).

    box_num_samples_wrong : int
                            Number of training samples that were assigned
                            incorrectly to the box.

    See Also
    --------
    create_class_box, enquire_class_box, learn_class_box, read_class_box,
    write_class_box

    Predecessors
    ------------
    create_class_box, learn_class_box, set_class_box_param

    Successors
    ----------
    enquire_class_box, learn_class_box, write_class_box, close_class_box

    Warnings
    --------
    descript_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1896) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, dimensions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_idx
            proc.get_output_tuple_s(1),  # box_idx
            proc.get_output_tuple_s(2),  # box_lower_bound
            proc.get_output_tuple_s(3),  # box_higher_bound
            proc.get_output_tuple_s(4),  # box_num_samples_train
            proc.get_output_tuple_s(5)   # box_num_samples_wrong
        )  # type: ignore


def deserialize_bar_code_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a bar code model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    See Also
    --------
    serialize_bar_code_model, clear_bar_code_model

    Alternatives
    ------------
    create_bar_code_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_bar_code_model

    Successors
    ----------
    find_bar_code
    """
    with HalconOperator(1986) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        bar_code_handle = proc.get_output_tuple_s(0)
        return bar_code_handle  # type: ignore


def deserialize_calib_data(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized calibration data model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_calib_data
    """
    with HalconOperator(1961) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        calib_data_id = proc.get_output_tuple_s(0)
        return calib_data_id  # type: ignore


def deserialize_cam_par(
    serialized_item_handle: HHandle
) -> Sequence[Union[int, float, str]]:
    """
    Deserialize the serialized internal camera parameters.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_cam_par
    """
    with HalconOperator(1936) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        camera_param = proc.get_output_tuple_m(0)
        return camera_param  # type: ignore


def deserialize_camera_setup_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized camera setup model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_camera_setup_model
    """
    with HalconOperator(1952) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        camera_setup_model_id = proc.get_output_tuple_s(0)
        return camera_setup_model_id  # type: ignore


def deserialize_class_box(
    classif_handle: HHandle,
    serialized_item_handle: HHandle
) -> None:
    """
    Deserialize a serialized classifier.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_box, serialize_class_box

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_class_box,
    create_class_box

    Successors
    ----------
    test_sampset_box, enquire_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    deserialize_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.

    Notes
    -----
    All values of the classifier are going to be overwritten.
    """
    with HalconOperator(1884) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, serialized_item_handle)
        proc.execute()


def deserialize_class_gmm(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized Gaussian Mixture Model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    gmmhandle : HHandle
                GMM handle.

    See Also
    --------
    create_class_gmm, write_class_gmm, serialize_class_gmm

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_class_gmm

    Successors
    ----------
    classify_class_gmm, evaluate_class_gmm, create_class_lut_gmm
    """
    with HalconOperator(1826) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        gmmhandle = proc.get_output_tuple_s(0)
        return gmmhandle  # type: ignore


def deserialize_class_knn(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized k-NN classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    See Also
    --------
    create_class_knn

    Alternatives
    ------------
    serialize_class_knn

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_class_knn

    Successors
    ----------
    classify_class_knn
    """
    with HalconOperator(1807) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        knnhandle = proc.get_output_tuple_s(0)
        return knnhandle  # type: ignore


def deserialize_class_mlp(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized multilayer perceptron.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    mlphandle : HHandle
                MLP handle.

    See Also
    --------
    create_class_mlp, write_class_mlp, serialize_class_mlp

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_class_mlp

    Successors
    ----------
    classify_class_mlp, evaluate_class_mlp, create_class_lut_mlp
    """
    with HalconOperator(1865) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        mlphandle = proc.get_output_tuple_s(0)
        return mlphandle  # type: ignore


def deserialize_class_svm(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized support vector machine (SVM).

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    svmhandle : HHandle
                SVM handle.

    See Also
    --------
    create_class_svm, write_class_svm, serialize_class_svm

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_class_svm

    Successors
    ----------
    classify_class_svm, create_class_lut_svm
    """
    with HalconOperator(1844) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        svmhandle = proc.get_output_tuple_s(0)
        return svmhandle  # type: ignore


def deserialize_class_train_data(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize serialized training data for classifiers.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    serialize_class_train_data

    Successors
    ----------
    fwrite_serialized_item
    """
    with HalconOperator(1779) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def deserialize_component_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized component model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    component_model_id : HHandle
                         Handle of the component model.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_component_model

    Successors
    ----------
    find_component_model
    """
    with HalconOperator(1000) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        component_model_id = proc.get_output_tuple_s(0)
        return component_model_id  # type: ignore


def deserialize_data_code_2d_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized 2D data code model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    See Also
    --------
    serialize_data_code_2d_model, clear_data_code_2d_model

    Alternatives
    ------------
    create_data_code_2d_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_data_code_2d_model

    Successors
    ----------
    find_data_code_2d
    """
    with HalconOperator(1772) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        data_code_handle = proc.get_output_tuple_s(0)
        return data_code_handle  # type: ignore


def deserialize_deformable_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a deformable model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model, find_local_deformable_model
    """
    with HalconOperator(963) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def deserialize_deformable_surface_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a deformable surface model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    See Also
    --------
    create_deformable_surface_model, read_deformable_surface_model,
    write_deformable_surface_model, serialize_deformable_surface_model

    Alternatives
    ------------
    create_deformable_surface_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_deformable_surface_model

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    get_deformable_surface_model_param, clear_deformable_surface_model
    """
    with HalconOperator(1022) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        deformable_surface_model = proc.get_output_tuple_s(0)
        return deformable_surface_model  # type: ignore


def deserialize_descriptor_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a descriptor model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_calib_descriptor_model, create_uncalib_descriptor_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_descriptor_model

    Successors
    ----------
    find_uncalib_descriptor_model, find_calib_descriptor_model
    """
    with HalconOperator(944) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def deserialize_distance_transform_xld(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize an XLD distance transform.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized XLD distance
                             transform.

    Returns
    -------

    distance_transform_id : HHandle
                            Handle of the deserialized XLD distance
                            transform.

    See Also
    --------
    serialize_distance_transform_xld, write_distance_transform_xld,
    read_distance_transform_xld, create_distance_transform_xld,
    set_distance_transform_xld_param, clear_distance_transform_xld

    Successors
    ----------
    apply_distance_transform_xld, get_distance_transform_xld_contour,
    get_distance_transform_xld_param
    """
    with HalconOperator(1354) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        distance_transform_id = proc.get_output_tuple_s(0)
        return distance_transform_id  # type: ignore


def deserialize_dl_classifier(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a deep-learning-based classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    See Also
    --------
    serialize_dl_classifier

    Alternatives
    ------------
    deserialize_dl_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_dl_classifier

    Successors
    ----------
    apply_dl_classifier, train_dl_classifier_batch,
    set_dl_classifier_param, get_dl_classifier_param

    Warnings
    --------
    deserialize_dl_classifier is obsolete and is only provided for reasons
    of backward compatibility.  New applications should use the common
    CNN-based operator deserialize_dl_model.
    """
    with HalconOperator(2109) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        dlclassifier_handle = proc.get_output_tuple_s(0)
        return dlclassifier_handle  # type: ignore


def deserialize_dl_model(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a deep learning model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    See Also
    --------
    serialize_dl_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_dl_model

    Successors
    ----------
    apply_dl_model, train_dl_model_batch, train_dl_model_anomaly_dataset,
    set_dl_model_param, get_dl_model_param
    """
    with HalconOperator(2151) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        dlmodel_handle = proc.get_output_tuple_s(0)
        return dlmodel_handle  # type: ignore


def deserialize_dual_quat(
    serialized_item_handle: HHandle
) -> Sequence[Union[float, int]]:
    """
    Deserialize a serialized dual quaternion.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    dual_quaternion : Sequence[Union[float, int]]
                      Dual quaternion.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_quat

    Successors
    ----------
    dual_quat_to_hom_mat3d, dual_quat_to_pose, dual_quat_compose
    """
    with HalconOperator(2052) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion = proc.get_output_tuple_m(0)
        return dual_quaternion  # type: ignore


def deserialize_fft_optimization_data(
    serialized_item_handle: HHandle
) -> None:
    """
    Deserialize FFT speed optimization data.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    serialize_fft_optimization_data

    Alternatives
    ------------
    optimize_fft_speed, optimize_rft_speed

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_fft_optimization_data

    Successors
    ----------
    fft_generic, fft_image, fft_image_inv, rft_generic, wiener_filter,
    wiener_filter_ni, photometric_stereo, sfs_pentland, sfs_mod_lr,
    sfs_orig_lr
    """
    with HalconOperator(1535) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.execute()


def deserialize_handle(serialized_item: HHandle) -> HHandle:
    """
    Deserialize a serialized item.

    Parameters
    ----------

    serialized_item : HHandle
                      Handle containing the serialized item to be
                      deserialized.

    Returns
    -------

    handle : HHandle
             Handle containing the deserialized item.

    Predecessors
    ------------
    serialize_handle, fread_serialized_item, receive_serialized_item
    """
    with HalconOperator(2135) as proc:
        proc.set_input_tuple(0, serialized_item)
        proc.init_oct(0)
        proc.execute()
        handle = proc.get_output_tuple_s(0)
        return handle  # type: ignore


def deserialize_hom_mat2d(
    serialized_item_handle: HHandle
) -> Sequence[float]:
    """
    Deserialize a serialized homogeneous 2D transformation matrix.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_hom_mat2d
    """
    with HalconOperator(235) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def deserialize_hom_mat3d(
    serialized_item_handle: HHandle
) -> Sequence[float]:
    """
    Deserialize a serialized homogeneous 3D transformation matrix.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    hom_mat_3d : Sequence[float]
                 Transformation matrix.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_hom_mat3d
    """
    with HalconOperator(233) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3d = proc.get_output_tuple_m(0)
        return hom_mat_3d  # type: ignore


def deserialize_image(serialized_item_handle: HHandle) -> HObject:
    """
    Deserialize a serialized image object.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    image : HObject
            Image object.

    See Also
    --------
    serialize_image

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_image

    Successors
    ----------
    disp_image, threshold, regiongrowing, count_channels, decompose3,
    class_ndim_norm, gauss_filter, fill_interlace, zoom_image_size,
    zoom_image_factor, crop_part, write_image, rgb1_to_gray
    """
    with HalconOperator(1650) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def deserialize_matrix(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized matrix.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    matrix_id : HHandle
                Matrix handle.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_matrix

    Successors
    ----------
    get_full_matrix
    """
    with HalconOperator(840) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        matrix_id = proc.get_output_tuple_s(0)
        return matrix_id  # type: ignore


def deserialize_measure(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized measure object.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    measure_handle : HHandle
                     Measure object handle.

    See Also
    --------
    read_measure, write_measure

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_measure

    Successors
    ----------
    measure_pos, measure_pairs
    """
    with HalconOperator(822) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        measure_handle = proc.get_output_tuple_s(0)
        return measure_handle  # type: ignore


def deserialize_metrology_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized metrology model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    metrology_handle : HHandle
                       Handle of the metrology model.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_metrology_model

    Successors
    ----------
    get_metrology_object_param, get_metrology_object_fuzzy_param,
    apply_metrology_model
    """
    with HalconOperator(794) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        metrology_handle = proc.get_output_tuple_s(0)
        return metrology_handle  # type: ignore


def deserialize_ncc_model(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize an NCC model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_ncc_model, clear_ncc_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_ncc_model

    Successors
    ----------
    find_ncc_model
    """
    with HalconOperator(983) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def deserialize_object(serialized_item_handle: HHandle) -> HObject:
    """
    Deserialize a serialized iconic object.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    object : HObject
             Iconic object.

    See Also
    --------
    serialize_object

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_object
    """
    with HalconOperator(1648) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def deserialize_object_model_3d(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized 3D object model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    See Also
    --------
    write_object_model_3d, clear_object_model_3d

    Alternatives
    ------------
    xyz_to_object_model_3d

    Predecessors
    ------------
    write_object_model_3d, fread_serialized_item, receive_serialized_item,
    serialize_object_model_3d

    Successors
    ----------
    affine_trans_object_model_3d, object_model_3d_to_xyz,
    prepare_object_model_3d
    """
    with HalconOperator(1102) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def deserialize_ocr(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized OCR classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    ocr_handle : HHandle
                 ID of the OCR classifier.

    See Also
    --------
    serialize_ocr, do_ocr_multi, traind_ocr_class_box, trainf_ocr_class_box

    Predecessors
    ------------
    reset_obj_db, fread_serialized_item, receive_serialized_item,
    serialize_ocr

    Successors
    ----------
    do_ocr_multi, do_ocr_single, traind_ocr_class_box, trainf_ocr_class_box

    Warnings
    --------
    deserialize_ocr is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(710) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        ocr_handle = proc.get_output_tuple_s(0)
        return ocr_handle  # type: ignore


def deserialize_ocr_class_cnn(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized CNN-based OCR classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_ocr_class_cnn

    Successors
    ----------
    do_ocr_single_class_cnn, do_ocr_multi_class_cnn
    """
    with HalconOperator(2053) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def deserialize_ocr_class_knn(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized k-NN-based OCR classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_knn, serialize_ocr_class_knn

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_ocr_class_knn

    Successors
    ----------
    classify_class_knn
    """
    with HalconOperator(648) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def deserialize_ocr_class_mlp(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized MLP-based OCR classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_mlp, write_ocr_class_mlp, read_class_mlp,
    write_class_mlp, serialize_ocr_class_mlp

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_ocr_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(692) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def deserialize_ocr_class_svm(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized SVM-based OCR classifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_svm, write_ocr_class_svm, read_class_svm,
    write_class_svm, serialize_ocr_class_svm

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_ocr_class_svm

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm
    """
    with HalconOperator(674) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def deserialize_ocv(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized OCV tool.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    ocvhandle : HHandle
                Handle of the OCV tool.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_ocv

    Successors
    ----------
    do_ocv_simple, close_ocv
    """
    with HalconOperator(640) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        ocvhandle = proc.get_output_tuple_s(0)
        return ocvhandle  # type: ignore


def deserialize_pose(
    serialized_item_handle: HHandle
) -> Sequence[Union[int, float]]:
    """
    Deserialize a serialized pose.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    pose : Sequence[Union[int, float]]
           3D pose.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_pose
    """
    with HalconOperator(1938) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def deserialize_quat(
    serialized_item_handle: HHandle
) -> Sequence[Union[float, int]]:
    """
    Deserialize a serialized quaternion.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    quaternion : Sequence[Union[float, int]]
                 Quaternion.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_quat

    Successors
    ----------
    quat_to_hom_mat3d, quat_to_pose, quat_rotate_point_3d, quat_compose
    """
    with HalconOperator(237) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        quaternion = proc.get_output_tuple_m(0)
        return quaternion  # type: ignore


def deserialize_region(serialized_item_handle: HHandle) -> HObject:
    """
    Deserialize a serialized region.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    region : HObject
             Region.

    See Also
    --------
    serialize_region

    Predecessors
    ------------
    read_image, fread_serialized_item, receive_serialized_item,
    serialize_region

    Successors
    ----------
    reduce_domain, disp_region
    """
    with HalconOperator(1652) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def deserialize_sample_identifier(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized sample identifier.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, train_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, clear_sample_identifier,
    set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Successors
    ----------
    apply_sample_identifier, add_sample_identifier_training_data
    """
    with HalconOperator(900) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        sample_identifier = proc.get_output_tuple_s(0)
        return sample_identifier  # type: ignore


def deserialize_shape_model(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized shape model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, clear_shape_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_shape_model

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models,
    get_shape_model_clutter
    """
    with HalconOperator(916) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def deserialize_shape_model_3d(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized 3D shape model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    See Also
    --------
    create_shape_model_3d, clear_shape_model_3d

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_shape_model_3d

    Successors
    ----------
    find_shape_model_3d, get_shape_model_3d_params
    """
    with HalconOperator(1050) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        shape_model_3did = proc.get_output_tuple_s(0)
        return shape_model_3did  # type: ignore


def deserialize_sheet_of_light_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a sheet-of-light model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    See Also
    --------
    serialize_sheet_of_light_model

    Alternatives
    ------------
    create_sheet_of_light_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_sheet_of_light_model

    Successors
    ----------
    measure_profile_sheet_of_light
    """
    with HalconOperator(376) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        sheet_of_light_model_id = proc.get_output_tuple_s(0)
        return sheet_of_light_model_id  # type: ignore


def deserialize_structured_light_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a structured light model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    structured_light_model : HHandle
                             Handle of the structured light model.

    See Also
    --------
    create_structured_light_model, write_structured_light_model,
    serialize_structured_light_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_structured_light_model
    """
    with HalconOperator(2110) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        structured_light_model = proc.get_output_tuple_s(0)
        return structured_light_model  # type: ignore


def deserialize_surface_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a surface model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    surface_model_id : HHandle
                       Handle of the surface model.

    See Also
    --------
    create_surface_model, read_surface_model, write_surface_model

    Alternatives
    ------------
    create_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d, fread_serialized_item,
    receive_serialized_item, serialize_surface_model

    Successors
    ----------
    find_surface_model, refine_surface_model_pose,
    get_surface_model_param, clear_surface_model,
    find_surface_model_image, refine_surface_model_pose_image
    """
    with HalconOperator(1037) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        surface_model_id = proc.get_output_tuple_s(0)
        return surface_model_id  # type: ignore


def deserialize_template(serialized_item_handle: HHandle) -> HHandle:
    """
    Deserialize a serialized template.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    template_id : HHandle
                  Template number.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_template

    Successors
    ----------
    adapt_template, set_reference_template, set_offset_template,
    best_match, fast_match, best_match_rot

    Warnings
    --------
    deserialize_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1491) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        template_id = proc.get_output_tuple_s(0)
        return template_id  # type: ignore


def deserialize_texture_inspection_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a serialized texture inspection model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    See Also
    --------
    create_texture_inspection_model, write_texture_inspection_model,
    serialize_texture_inspection_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_texture_inspection_model

    Successors
    ----------
    apply_texture_inspection_model
    """
    with HalconOperator(2054) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        texture_inspection_model = proc.get_output_tuple_s(0)
        return texture_inspection_model  # type: ignore


def deserialize_training_components(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a component training result.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    component_training_id : HHandle
                            Handle of the training result.

    See Also
    --------
    train_model_components, clear_training_components

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_training_components

    Successors
    ----------
    create_trained_component_model
    """
    with HalconOperator(1011) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        component_training_id = proc.get_output_tuple_s(0)
        return component_training_id  # type: ignore


def deserialize_tuple(
    serialized_item_handle: HHandle
) -> Sequence[HTupleElementType]:
    """
    Deserialize a serialized tuple.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    tuple : Sequence[HTupleElementType]
            Tuple.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_tuple
    """
    with HalconOperator(217) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_m(0)
        return tuple  # type: ignore


def deserialize_tuple_s(
    serialized_item_handle: HHandle
) -> HTupleElementType:
    """
    Deserialize a serialized tuple.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    tuple : HTupleElementType
            Tuple.

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item, serialize_tuple
    """
    with HalconOperator(217) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_s(0)
        return tuple  # type: ignore


def deserialize_variation_model(
    serialized_item_handle: HHandle
) -> HHandle:
    """
    Deserialize a variation model.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    model_id : HHandle
               ID of the variation model.

    See Also
    --------
    read_variation_model, write_variation_model

    Predecessors
    ------------
    fread_serialized_item, receive_serialized_item,
    serialize_variation_model

    Successors
    ----------
    compare_variation_model, compare_ext_variation_model
    """
    with HalconOperator(81) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def deserialize_xld(serialized_item_handle: HHandle) -> HObject:
    """
    Deserialize a serialized XLD object.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    xld : HObject
          XLD object.

    See Also
    --------
    serialize_xld

    Predecessors
    ------------
    read_image, fread_serialized_item, receive_serialized_item,
    serialize_xld

    Successors
    ----------
    clip_contours_xld, split_contours_xld
    """
    with HalconOperator(1632) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.execute()
        xld = HObject(proc.get_output_object_key(1))
        return xld  # type: ignore


def detach_background_from_window(window_handle: HHandle) -> None:
    """
    Detach the background image from a HALCON window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Predecessors
    ------------
    attach_background_to_window
    """
    with HalconOperator(1163) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def detach_drawing_object_from_window(
    window_handle: HHandle,
    draw_handle: HHandle
) -> None:
    """
    Detach an existing drawing object from a HALCON window.

    Parameters
    ----------

    window_handle : HHandle
                    Window Handle.

    draw_handle : HHandle
                  Handle of the drawing object.

    See Also
    --------
    attach_drawing_object_to_window

    Predecessors
    ------------
    attach_drawing_object_to_window, get_drawing_object_iconic,
    get_drawing_object_params

    Successors
    ----------
    close_window, clear_drawing_object
    """
    with HalconOperator(1165) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, draw_handle)
        proc.execute()


def detect_edge_segments(
    image: HObject,
    sobel_size: int,
    min_amplitude: int,
    max_distance: int,
    min_length: int
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Detect straight edge segments.

    Parameters
    ----------

    image : HObject
            Input image.

    sobel_size : int
                 Mask size of the Sobel operator.
                 Value Suggestion: 5

    min_amplitude : int
                    Minimum edge strength.
                    Value Suggestion: 32
                    Assertion: MinAmplitude >= 0

    max_distance : int
                   Maximum distance of the approximating line to its
                   original edge.
                   Value Suggestion: 3
                   Assertion: MaxDistance >= 0

    min_length : int
                 Minimum length of to resulting line segments.
                 Value Suggestion: 10
                 Assertion: MinLength >= 0

    Returns
    -------

    begin_row : Sequence[int]
                Row coordinate of the line segments' start points.

    begin_col : Sequence[int]
                Column coordinate of the line segments' start points.

    end_row : Sequence[int]
              Row coordinate of the line segments' end points.

    end_col : Sequence[int]
              Column coordinate of the line segments' end points.

    Alternatives
    ------------
    sobel_amp, threshold, skeleton

    Predecessors
    ------------
    sigma_image, median_image

    Successors
    ----------
    partition_lines, line_position, line_orientation

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1575) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sobel_size)
        proc.set_input_tuple(1, min_amplitude)
        proc.set_input_tuple(2, max_distance)
        proc.set_input_tuple(3, min_length)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # begin_row
            proc.get_output_tuple_m(1),  # begin_col
            proc.get_output_tuple_m(2),  # end_row
            proc.get_output_tuple_m(3)   # end_col
        )  # type: ignore


def determinant_matrix(matrix_id: HHandle, matrix_type: str) -> float:
    """
    Compute the determinant of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_type : str
                  The type of the input matrix.
                  Value Suggestion: general

    Returns
    -------

    value : float
            Determinant of the input matrix.

    Predecessors
    ------------
    create_matrix

    Notes
    -----
    For MatrixType = 'symmetric', 'positive_definite', or
    'upper_triangular' the upper triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly lower
    triangular part of the matrix is not referenced.  For MatrixType =
    'lower_triangular' the lower triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly upper
    triangular part of the matrix is not referenced.  For MatrixType =
    'tridiagonal', only the main diagonal, the superdiagonal, and the
    subdiagonal of the input Matrix are used.  The other parts of the
    matrix are not referenced.  If the referenced part of the input Matrix
    is not of the specified type, an exception is raised.
    """
    with HalconOperator(852) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_type)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def determine_deformable_model_params(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    scale_min: MaybeSequence[float],
    scale_max: MaybeSequence[float],
    optimization: str,
    metric: str,
    contrast: MaybeSequence[Union[int, str]],
    min_contrast: Union[int, str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]],
    parameters: MaybeSequence[str]
) -> Tuple[Sequence[str], Sequence[Union[int, float]]]:
    """
    Determine the parameters of a deformable model.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    scale_min : MaybeSequence[float]
                Minimum scale of the model.
                Value Suggestion: 0.9
                Assertion: ScaleMin > 0

    scale_max : MaybeSequence[float]
                Maximum scale of the model.
                Value Suggestion: 1.1
                Assertion: ScaleMax >= ScaleMin

    optimization : str
                   Kind of optimization.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : MaybeSequence[Union[int, str]]
               Threshold or hysteresis thresholds for the contrast of the
               object in the template image and optionally minimum size of
               the object parts.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    gen_param_name : Sequence[str]
                     The general parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the general parameter.
                      Value Suggestion: []

    parameters : MaybeSequence[str]
                 Parameters to be determined automatically.
                 Value Suggestion: all

    Returns
    -------

    parameter_name : Sequence[str]
                     Name of the automatically determined parameter.

    parameter_value : Sequence[Union[int, float]]
                      Value of the automatically determined parameter.

    See Also
    --------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model

    Successors
    ----------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model
    """
    with HalconOperator(962) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_min)
        proc.set_input_tuple(4, scale_max)
        proc.set_input_tuple(5, optimization)
        proc.set_input_tuple(6, metric)
        proc.set_input_tuple(7, contrast)
        proc.set_input_tuple(8, min_contrast)
        proc.set_input_tuple(9, gen_param_name)
        proc.set_input_tuple(10, gen_param_value)
        proc.set_input_tuple(11, parameters)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # parameter_name
            proc.get_output_tuple_m(1)   # parameter_value
        )  # type: ignore


def determine_ncc_model_params(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    metric: str,
    parameters: MaybeSequence[str]
) -> Tuple[Sequence[str], Sequence[Union[int, float]]]:
    """
    Determine the parameters of an NCC model.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    parameters : MaybeSequence[str]
                 Parameters to be determined automatically.
                 Value Suggestion: all

    Returns
    -------

    parameter_name : Sequence[str]
                     Name of the automatically determined parameter.

    parameter_value : Sequence[Union[int, float]]
                      Value of the automatically determined parameter.

    See Also
    --------
    find_ncc_model

    Successors
    ----------
    create_ncc_model
    """
    with HalconOperator(987) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, metric)
        proc.set_input_tuple(4, parameters)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # parameter_name
            proc.get_output_tuple_m(1)   # parameter_value
        )  # type: ignore


def determine_shape_model_params(
    template: HObject,
    num_levels: Union[int, str],
    angle_start: float,
    angle_extent: float,
    scale_min: MaybeSequence[float],
    scale_max: MaybeSequence[float],
    optimization: str,
    metric: str,
    contrast: MaybeSequence[Union[int, str]],
    min_contrast: Union[int, str],
    parameters: MaybeSequence[str]
) -> Tuple[Sequence[str], Sequence[Union[int, float]]]:
    """
    Determine the parameters of a shape model.

    Parameters
    ----------

    template : HObject
               Input image whose domain will be used to create the model.

    num_levels : Union[int, str]
                 Maximum number of pyramid levels.
                 Value Suggestion: auto

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    scale_min : MaybeSequence[float]
                Minimum scale of the model.
                Value Suggestion: 0.9
                Assertion: ScaleMin > 0

    scale_max : MaybeSequence[float]
                Maximum scale of the model.
                Value Suggestion: 1.1
                Assertion: ScaleMax >= ScaleMin

    optimization : str
                   Kind of optimization.
                   Value Suggestion: auto

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    contrast : MaybeSequence[Union[int, str]]
               Threshold or hysteresis thresholds for the contrast of the
               object in the template image and optionally minimum size of
               the object parts.
               Value Suggestion: auto

    min_contrast : Union[int, str]
                   Minimum contrast of the objects in the search images.
                   Value Suggestion: auto
                   Assertion: MinContrast < Contrast

    parameters : MaybeSequence[str]
                 Parameters to be determined automatically.
                 Value Suggestion: all

    Returns
    -------

    parameter_name : Sequence[str]
                     Name of the automatically determined parameter.

    parameter_value : Sequence[Union[int, float]]
                      Value of the automatically determined parameter.

    See Also
    --------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models

    Predecessors
    ------------
    draw_region, reduce_domain, threshold

    Successors
    ----------
    create_shape_model, create_scaled_shape_model, create_aniso_shape_model

    Notes
    -----
    In some cases, the maximum number of pyramid levels that is returned
    by determine_shape_model_params is higher than the number of levels
    that are actually used in the shape model.  The latter can be queried
    by using get_shape_model_params after creating the model. This might
    happen if the model is created by using create_scaled_shape_model or
    create_aniso_shape_model and ScaleMin, ScaleRMin, or ScaleCMin is
    below 1.0.
    """
    with HalconOperator(923) as proc:
        proc.set_input_object(1, template)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_min)
        proc.set_input_tuple(4, scale_max)
        proc.set_input_tuple(5, optimization)
        proc.set_input_tuple(6, metric)
        proc.set_input_tuple(7, contrast)
        proc.set_input_tuple(8, min_contrast)
        proc.set_input_tuple(9, parameters)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # parameter_name
            proc.get_output_tuple_m(1)   # parameter_value
        )  # type: ignore


def deviation_image(image: HObject, width: int, height: int) -> HObject:
    """
    Calculate the standard deviation of gray values within rectangular
    windows.

    Parameters
    ----------

    image : HObject
            Image for which the standard deviation is to be calculated.

    width : int
            Width of the mask in which the standard deviation is
            calculated.
            Value Suggestion: 11
            Assertion: 3 <= Width && odd(Width) && Width < width(Image) * 2

    height : int
             Height of the mask in which the standard deviation is
             calculated.
             Value Suggestion: 11
             Assertion: 3 <= Height && odd(Height) && Height < height(Image) * 2

    Returns
    -------

    image_deviation : HObject
                      Image containing the standard deviation.

    See Also
    --------
    convol_image, texture_laws, intensity

    Alternatives
    ------------
    entropy_image, entropy_gray

    Successors
    ----------
    disp_image

    Notes
    -----
    deviation_image can be executed on OpenCL devices. As the same OpenCL
    code is used, the same limitations as for mean_image apply. Since
    deviation_image uses single precision floating point arithmetic
    internally, the results may differ slightly from the CPU version.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1403) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        image_deviation = HObject(proc.get_output_object_key(1))
        return image_deviation  # type: ignore


def deviation_n(image: HObject) -> HObject:
    """
    Calculate standard deviation over several channels.

    Parameters
    ----------

    image : HObject
            Multichannel gray image.

    Returns
    -------

    image_deviation : HObject
                      Result of calculation.

    See Also
    --------
    mean_n

    Predecessors
    ------------
    compose2, compose3, compose4, compose5, add_channels

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1445) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_deviation = HObject(proc.get_output_object_key(1))
        return image_deviation  # type: ignore


def diameter_region(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[float]]:
    """
    Maximal distance between two boundary points of a region.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row_1 : Sequence[int]
            Row index of the first extreme point.

    column_1 : Sequence[int]
               Column index of the first extreme point.

    row_2 : Sequence[int]
            Row index of the second extreme point.

    column_2 : Sequence[int]
               Column index of the second extreme point.

    diameter : Sequence[float]
               Distance of the two extreme points.

    Alternatives
    ------------
    smallest_rectangle2

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    disp_line

    Notes
    -----
    If the region is empty, the results of Row1, Column1, Row2 and Column2
    (all of them = 0) may lead to confusion.
    """
    with HalconOperator(1711) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_1
            proc.get_output_tuple_m(1),  # column_1
            proc.get_output_tuple_m(2),  # row_2
            proc.get_output_tuple_m(3),  # column_2
            proc.get_output_tuple_m(4)   # diameter
        )  # type: ignore


def diameter_region_s(
    regions: HObject
) -> Tuple[int, int, int, int, float]:
    """
    Maximal distance between two boundary points of a region.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row_1 : int
            Row index of the first extreme point.

    column_1 : int
               Column index of the first extreme point.

    row_2 : int
            Row index of the second extreme point.

    column_2 : int
               Column index of the second extreme point.

    diameter : float
               Distance of the two extreme points.

    Alternatives
    ------------
    smallest_rectangle2

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    disp_line

    Notes
    -----
    If the region is empty, the results of Row1, Column1, Row2 and Column2
    (all of them = 0) may lead to confusion.
    """
    with HalconOperator(1711) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3),  # column_2
            proc.get_output_tuple_s(4)   # diameter
        )  # type: ignore


def diameter_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Maximum distance between two contour or polygon points.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row_1 : Sequence[float]
            Row coordinate of the first extreme point of the contours or
            polygons.

    column_1 : Sequence[float]
               Column coordinate of the first extreme point of the
               contours or polygons.

    row_2 : Sequence[float]
            Row coordinate of the second extreme point of the contour or
            polygons.

    column_2 : Sequence[float]
               Column coordinate of the second extreme point of the
               contours or polygons.

    diameter : Sequence[float]
               Distance of the two extreme points of the contours or
               polygons.

    See Also
    --------
    area_center_xld

    Alternatives
    ------------
    smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Notes
    -----
    If the contour or polygon is empty, the results of Row1, Column1, Row2
    and Column2 (all of them = 0) may lead to confusion.
    """
    with HalconOperator(1682) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_1
            proc.get_output_tuple_m(1),  # column_1
            proc.get_output_tuple_m(2),  # row_2
            proc.get_output_tuple_m(3),  # column_2
            proc.get_output_tuple_m(4)   # diameter
        )  # type: ignore


def diameter_xld_s(
    xld: HObject
) -> Tuple[float, float, float, float, float]:
    """
    Maximum distance between two contour or polygon points.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row_1 : float
            Row coordinate of the first extreme point of the contours or
            polygons.

    column_1 : float
               Column coordinate of the first extreme point of the
               contours or polygons.

    row_2 : float
            Row coordinate of the second extreme point of the contour or
            polygons.

    column_2 : float
               Column coordinate of the second extreme point of the
               contours or polygons.

    diameter : float
               Distance of the two extreme points of the contours or
               polygons.

    See Also
    --------
    area_center_xld

    Alternatives
    ------------
    smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Notes
    -----
    If the contour or polygon is empty, the results of Row1, Column1, Row2
    and Column2 (all of them = 0) may lead to confusion.
    """
    with HalconOperator(1682) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3),  # column_2
            proc.get_output_tuple_s(4)   # diameter
        )  # type: ignore


def diff_of_gauss(
    image: HObject,
    sigma: float,
    sig_factor: float
) -> HObject:
    """
    Approximate the LoG operator (Laplace of Gaussian).

    Parameters
    ----------

    image : HObject
            Input image

    sigma : float
            Smoothing parameter of the Laplace operator to approximate.
            Value Suggestion: 3.0
            Assertion: Sigma > 0.0

    sig_factor : float
                 Ratio of the standard deviations used (Marr recommends
                 1.6).
                 Value Suggestion: 1.6
                 Assertion: SigFactor > 0.0

    Returns
    -------

    diff_of_gauss : HObject
                    LoG image.

    Alternatives
    ------------
    laplace, derivate_gauss

    Successors
    ----------
    zero_crossing, dual_threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1572) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, sig_factor)
        proc.execute()
        diff_of_gauss = HObject(proc.get_output_object_key(1))
        return diff_of_gauss  # type: ignore


def difference(region: HObject, sub: HObject) -> HObject:
    """
    Calculate the difference of two regions.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    sub : HObject
          The union of these regions is subtracted from Region.

    Returns
    -------

    region_difference : HObject
                        Resulting region.

    See Also
    --------
    intersection, union1, union2, complement, symm_difference

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape, disp_region

    Notes
    -----
    Empty regions are valid for both parameters.  On output, empty regions
    may result.  The value of the system flag 'store_empty_region'
    determines the behavior in this case.
    """
    with HalconOperator(503) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, sub)
        proc.execute()
        region_difference = HObject(proc.get_output_object_key(1))
        return region_difference  # type: ignore


def difference_closed_contours_xld(
    contours: HObject,
    sub: HObject
) -> HObject:
    """
    Compute the difference of closed contours.

    Parameters
    ----------

    contours : HObject
               Contours enclosing the region from which the second region
               is subtracted.

    sub : HObject
          Contours enclosing the region that is subtracted from the first
          region.

    Returns
    -------

    contours_difference : HObject
                          Contours enclosing the difference.

    See Also
    --------
    intersection_closed_contours_xld, symm_difference_closed_contours_xld,
    union2_closed_contours_xld, difference_closed_polygons_xld

    Alternatives
    ------------
    difference

    Predecessors
    ------------
    gen_contour_region_xld, zero_crossing_sub_pix, threshold_sub_pix
    """
    with HalconOperator(10) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_object(2, sub)
        proc.execute()
        contours_difference = HObject(proc.get_output_object_key(1))
        return contours_difference  # type: ignore


def difference_closed_polygons_xld(
    polygons: HObject,
    sub: HObject
) -> HObject:
    """
    Compute the difference of closed polygons.

    Parameters
    ----------

    polygons : HObject
               Polygons enclosing the region from which the second region
               is subtracted.

    sub : HObject
          Polygons enclosing the region that is subtracted from the first
          region.

    Returns
    -------

    polygons_difference : HObject
                          Polygons enclosing the difference.

    See Also
    --------
    intersection_closed_polygons_xld, symm_difference_closed_polygons_xld,
    union2_closed_polygons_xld, difference_closed_contours_xld

    Alternatives
    ------------
    difference

    Predecessors
    ------------
    gen_polygons_xld

    Notes
    -----
    The resulting polygons PolygonsDifference contain no references to the
    XLD contours that are possibly referenced by Polygons and Sub. Hence,
    operators that access the contours associated with a polygon, e.g.,
    split_contours_xld will not work correctly.
    """
    with HalconOperator(9) as proc:
        proc.set_input_object(1, polygons)
        proc.set_input_object(2, sub)
        proc.execute()
        polygons_difference = HObject(proc.get_output_object_key(1))
        return polygons_difference  # type: ignore


def dilation1(
    region: HObject,
    struct_element: HObject,
    iterations: int
) -> HObject:
    """
    Dilate a region.

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    struct_element : HObject
                     Structuring element.

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_dilation : HObject
                      Dilated regions.

    See Also
    --------
    erosion1, erosion2, opening, closing

    Alternatives
    ------------
    minkowski_add1, minkowski_add2, dilation2

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, add_channels, select_shape, area_center, connection

    Notes
    -----
    A dilation always results in enlarged regions.  Closely spaced regions
    which may touch or overlap as a result of the dilation are still
    treated as two separate regions.  If the desired behavior is to merge
    them into one region, the operator union1 has to be called first.
    """
    with HalconOperator(779) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, iterations)
        proc.execute()
        region_dilation = HObject(proc.get_output_object_key(1))
        return region_dilation  # type: ignore


def dilation2(
    region: HObject,
    struct_element: HObject,
    row: int,
    column: int,
    iterations: int
) -> HObject:
    """
    Dilate a region (using a reference point).

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    struct_element : HObject
                     Structuring element.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 0

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_dilation : HObject
                      Dilated regions.

    See Also
    --------
    erosion1, erosion2, opening, closing

    Alternatives
    ------------
    minkowski_add1, minkowski_add2, dilation1

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, add_channels, select_shape, area_center, connection

    Notes
    -----
    A dilation always results in enlarged regions.  Closely spaced regions
    which may touch or overlap as a result of the dilation are still
    treated as two separate regions.  If the desired behavior is to merge
    them into one region, the operator union1 has to be called first.
    """
    with HalconOperator(778) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        region_dilation = HObject(proc.get_output_object_key(1))
        return region_dilation  # type: ignore


def dilation_circle(
    region: HObject,
    radius: Union[float, int]
) -> HObject:
    """
    Dilate a region with a circular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    radius : Union[float, int]
             Radius of the circular structuring element.
             Value Suggestion: 3.5

    Returns
    -------

    region_dilation : HObject
                      Dilated regions.

    See Also
    --------
    gen_circle, erosion_circle, closing_circle, opening_circle

    Alternatives
    ------------
    minkowski_add1, minkowski_add2, expand_region, dilation1, dilation2,
    dilation_rectangle1

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    dilation_circle is applied to each input region separately.  If gaps
    between different regions are to be closed, union1 or union2 has to be
    called first.
    """
    with HalconOperator(777) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, radius)
        proc.execute()
        region_dilation = HObject(proc.get_output_object_key(1))
        return region_dilation  # type: ignore


def dilation_golay(
    region: HObject,
    golay_element: str,
    iterations: int,
    rotation: int
) -> HObject:
    """
    Dilate a region with an element from the Golay alphabet.

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_dilation : HObject
                      Dilated regions.

    See Also
    --------
    erosion_golay, opening_golay, closing_golay, hit_or_miss_golay,
    thinning_golay, thickening_golay, golay_elements

    Alternatives
    ------------
    dilation1, dilation2, dilation_seq

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    dilation_golay is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.  For some
    of the values of Rotation, the resulting regions are identical to the
    input regions.
    """
    with HalconOperator(775) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, rotation)
        proc.execute()
        region_dilation = HObject(proc.get_output_object_key(1))
        return region_dilation  # type: ignore


def dilation_rectangle1(
    region: HObject,
    width: int,
    height: int
) -> HObject:
    """
    Dilate a region with a rectangular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    width : int
            Width of the structuring rectangle.
            Value Suggestion: 11

    height : int
             Height of the structuring rectangle.
             Value Suggestion: 11

    Returns
    -------

    region_dilation : HObject
                      Dilated regions.

    See Also
    --------
    gen_rectangle1, gen_region_polygon_filled

    Alternatives
    ------------
    minkowski_add1, minkowski_add2, expand_region, dilation1, dilation2,
    dilation_circle

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    dilation_rectangle1 is applied to each input region separately.  If
    gaps between different regions are to be closed, union1 or union2 has
    to be called first.
    To enlarge a region by the same amount in all directions, Width and
    Height must be odd. If this is not the case, the region is dilated by
    a larger amount at the right or at the bottom, respectively, than at
    the left or at the top.
    """
    with HalconOperator(776) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        region_dilation = HObject(proc.get_output_object_key(1))
        return region_dilation  # type: ignore


def dilation_seq(
    region: HObject,
    golay_element: str,
    iterations: int
) -> HObject:
    """
    Dilate a region sequentially.

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_dilation : HObject
                      Dilated regions.

    See Also
    --------
    erosion_seq, hit_or_miss_seq, thinning_seq

    Alternatives
    ------------
    dilation1, dilation2, dilation_golay

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    dilation_seq is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(774) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, iterations)
        proc.execute()
        region_dilation = HObject(proc.get_output_object_key(1))
        return region_dilation  # type: ignore


def disp_arc(
    window_handle: HHandle,
    center_row: Union[int, float],
    center_col: Union[int, float],
    angle: Union[int, float],
    begin_row: MaybeSequence[Union[int, float]],
    begin_col: MaybeSequence[Union[int, float]]
) -> None:
    """
    Displays circular arcs in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    center_row : Union[int, float]
                 Row coordinate of center point.
                 Value Suggestion: 64

    center_col : Union[int, float]
                 Column coordinate of center point.
                 Value Suggestion: 64

    angle : Union[int, float]
            Angle between start and end of the arc (in radians).
            Value Suggestion: 3.1415926
            Assertion: Angle > 0.0

    begin_row : MaybeSequence[Union[int, float]]
                Row coordinate of the start of the arc.
                Value Suggestion: 32

    begin_col : MaybeSequence[Union[int, float]]
                Column coordinate of the start of the arc.
                Value Suggestion: 32

    See Also
    --------
    open_window, set_color, set_draw, set_rgb, set_hsi

    Alternatives
    ------------
    disp_circle, disp_ellipse, disp_region, gen_circle, gen_ellipse

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    set_rgb, set_hsi

    Notes
    -----
    The center point has to be within the window. The radius of the arc
    has be at least 2 pixel.
    """
    with HalconOperator(1275) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, center_row)
        proc.set_input_tuple(2, center_col)
        proc.set_input_tuple(3, angle)
        proc.set_input_tuple(4, begin_row)
        proc.set_input_tuple(5, begin_col)
        proc.execute()


def disp_arrow(
    window_handle: HHandle,
    row_1: MaybeSequence[Union[int, float]],
    column_1: MaybeSequence[Union[int, float]],
    row_2: MaybeSequence[Union[int, float]],
    column_2: MaybeSequence[Union[int, float]],
    size: Union[int, float]
) -> None:
    """
    Displays arrows in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1 : MaybeSequence[Union[int, float]]
            Row index of the start.
            Value Suggestion: 10.0

    column_1 : MaybeSequence[Union[int, float]]
               Column index of the start.
               Value Suggestion: 10.0

    row_2 : MaybeSequence[Union[int, float]]
            Row index of the end.
            Value Suggestion: 118.0

    column_2 : MaybeSequence[Union[int, float]]
               Column index of the end.
               Value Suggestion: 118.0

    size : Union[int, float]
           Size of the arrowhead.
           Value Suggestion: 1.0
           Assertion: Size > 0.0

    See Also
    --------
    open_window, set_color, set_draw, set_line_width

    Alternatives
    ------------
    disp_line, gen_region_polygon, disp_region

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    set_rgb, set_hsi

    Notes
    -----
    The start and the end of the arrows must fall within the window.
    """
    with HalconOperator(1274) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1)
        proc.set_input_tuple(2, column_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.set_input_tuple(5, size)
        proc.execute()


def disp_caltab(
    window_handle: HHandle,
    cal_plate_descr: str,
    camera_param: Sequence[Union[int, float, str]],
    cal_plate_pose: Sequence[Union[int, float]],
    scale_fac: float
) -> None:
    """
    Project and visualize the 3D model of the calibration plate in the
    image.

    Parameters
    ----------

    window_handle : HHandle
                    Window in which the calibration plate should be
                    visualized.

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: calplate_320.cpd

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    cal_plate_pose : Sequence[Union[int, float]]
                     External camera parameters (3D pose of the
                     calibration plate in camera coordinates).

    scale_fac : float
                Scaling factor for the visualization.
                Value Suggestion: 1.0
                Assertion: 0.0 < ScaleFac

    See Also
    --------
    find_marks_and_pose, camera_calibration, sim_caltab, write_cam_par,
    read_cam_par, create_pose, write_pose, read_pose, project_3d_point,
    get_line_of_sight

    Predecessors
    ------------
    camera_calibration, read_cam_par, read_pose
    """
    with HalconOperator(1945) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, cal_plate_descr)
        proc.set_input_tuple(2, camera_param)
        proc.set_input_tuple(3, cal_plate_pose)
        proc.set_input_tuple(4, scale_fac)
        proc.execute()


def disp_channel(
    multichannel_image: HObject,
    window_handle: HHandle,
    channel: MaybeSequence[int]
) -> None:
    """
    Displays images with several channels.

    Parameters
    ----------

    multichannel_image : HObject
                         Multichannel images to be displayed.

    window_handle : HHandle
                    Window handle.

    channel : MaybeSequence[int]
              Number of channel or the numbers of the RGB-channels
              Value Suggestion: 1

    See Also
    --------
    open_window, reset_obj_db, set_lut, dump_window

    Alternatives
    ------------
    disp_image, disp_color

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi
    """
    with HalconOperator(1269) as proc:
        proc.set_input_object(1, multichannel_image)
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, channel)
        proc.execute()


def disp_circle(
    window_handle: HHandle,
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    radius: MaybeSequence[Union[int, float]]
) -> None:
    """
    Displays circles in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : MaybeSequence[Union[int, float]]
          Row index of the center.
          Value Suggestion: 64

    column : MaybeSequence[Union[int, float]]
             Column index of the center.
             Value Suggestion: 64

    radius : MaybeSequence[Union[int, float]]
             Radius of the circle.
             Value Suggestion: 64
             Assertion: Radius > 0.0

    See Also
    --------
    open_window, set_color, set_draw, set_rgb, set_hsi

    Alternatives
    ------------
    disp_ellipse, disp_region, gen_circle, gen_ellipse

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    set_rgb, set_hsi

    Notes
    -----
    The center of the circle must be within the window.
    """
    with HalconOperator(1273) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, radius)
        proc.execute()


def disp_color(color_image: HObject, window_handle: HHandle) -> None:
    """
    Displays a color (RGB) image

    Parameters
    ----------

    color_image : HObject
                  Color image to display.

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    disp_image, open_window, reset_obj_db, set_lut, dump_window

    Alternatives
    ------------
    disp_channel, disp_obj

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi

    Notes
    -----
    Due to the restricted number of available colors the color appearance
    is usually different from the original.
    """
    with HalconOperator(1270) as proc:
        proc.set_input_object(1, color_image)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def disp_cross(
    window_handle: HHandle,
    row: MaybeSequence[float],
    column: MaybeSequence[float],
    size: float,
    angle: float
) -> None:
    """
    Displays crosses in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : MaybeSequence[float]
          Row coordinate of the center.
          Value Suggestion: 32.0

    column : MaybeSequence[float]
             Column coordinate of the center.
             Value Suggestion: 32.0

    size : float
           Length of the bars.
           Value Suggestion: 6.0

    angle : float
            Orientation.
            Value Suggestion: 0.0

    See Also
    --------
    open_window, set_color, set_rgb, set_hsi, set_insert, set_line_width

    Alternatives
    ------------
    disp_arrow, disp_rectangle1, disp_rectangle2, disp_circle

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, set_draw, set_color,
    set_colored, set_line_width
    """
    with HalconOperator(1267) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, size)
        proc.set_input_tuple(4, angle)
        proc.execute()


def disp_distribution(
    window_handle: HHandle,
    distribution: Sequence[float],
    row: int,
    column: int,
    scale: int
) -> None:
    """
    Displays a noise distribution.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    distribution : Sequence[float]
                   Gray value distribution (513 values).

    row : int
          Row index of center.
          Value Suggestion: 256

    column : int
             Column index of center.
             Value Suggestion: 256

    scale : int
            Size of display.
            Value Suggestion: 1

    See Also
    --------
    gen_region_histo, gauss_distribution, noise_distribution_mean

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    set_rgb, set_hsi, noise_distribution_mean, gauss_distribution

    Warnings
    --------
    disp_distribution is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1272) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, distribution)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, scale)
        proc.execute()


def disp_ellipse(
    window_handle: HHandle,
    center_row: MaybeSequence[int],
    center_col: MaybeSequence[int],
    phi: MaybeSequence[Union[int, float]],
    radius_1: MaybeSequence[Union[int, float]],
    radius_2: MaybeSequence[Union[int, float]]
) -> None:
    """
    Displays ellipses.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    center_row : MaybeSequence[int]
                 Row index of center.
                 Value Suggestion: 64

    center_col : MaybeSequence[int]
                 Column index of center.
                 Value Suggestion: 64

    phi : MaybeSequence[Union[int, float]]
          Orientation of the ellipse in radians
          Value Suggestion: 0.0

    radius_1 : MaybeSequence[Union[int, float]]
               Radius of major axis.
               Value Suggestion: 24.0

    radius_2 : MaybeSequence[Union[int, float]]
               Radius of minor axis.
               Value Suggestion: 14.0

    See Also
    --------
    open_window, set_color, set_rgb, set_hsi, set_draw, set_line_width

    Alternatives
    ------------
    disp_circle, disp_region, gen_ellipse, gen_circle

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    set_rgb, set_hsi, elliptic_axis, area_center

    Notes
    -----
    The center of the ellipse must be within the window.
    """
    with HalconOperator(1271) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, center_row)
        proc.set_input_tuple(2, center_col)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, radius_1)
        proc.set_input_tuple(5, radius_2)
        proc.execute()


def disp_image(image: HObject, window_handle: HHandle) -> None:
    """
    Displays gray value images.

    Parameters
    ----------

    image : HObject
            Gray value image to display.

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    open_window, reset_obj_db, set_paint, set_lut, paint_gray,
    scale_image, convert_image_type, dump_window

    Alternatives
    ------------
    disp_obj, disp_color

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, scale_image,
    convert_image_type, min_max_gray

    Notes
    -----
    If a wrong output mode was set by set_paint, the error will be
    reported when disp_image is used.
    """
    with HalconOperator(1268) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def disp_line(
    window_handle: HHandle,
    row_1: MaybeSequence[float],
    column_1: MaybeSequence[float],
    row_2: MaybeSequence[float],
    column_2: MaybeSequence[float]
) -> None:
    """
    Draws lines in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1 : MaybeSequence[float]
            Row index of the start.
            Value Suggestion: 32.0

    column_1 : MaybeSequence[float]
               Column index of the start.
               Value Suggestion: 32.0

    row_2 : MaybeSequence[float]
            Row index of end.
            Value Suggestion: 64.0

    column_2 : MaybeSequence[float]
               Column index of end.
               Value Suggestion: 64.0

    See Also
    --------
    open_window, set_color, set_rgb, set_hsi, set_insert, set_line_width

    Alternatives
    ------------
    disp_arrow, disp_rectangle1, disp_rectangle2, disp_region,
    gen_region_polygon, gen_region_points

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, set_draw, set_color,
    set_colored, set_line_width

    Notes
    -----
    The starting points and the ending points of the lines must be in the
    window.
    """
    with HalconOperator(1266) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1)
        proc.set_input_tuple(2, column_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.execute()


def disp_lut(
    window_handle: HHandle,
    row: int,
    column: int,
    scale: int
) -> None:
    """
    Graphical view of the look-up-table (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : int
          Row of center of the graphic.
          Value Suggestion: 128

    column : int
             Column of center of the graphic.
             Value Suggestion: 128

    scale : int
            Scaling of the graphic.
            Value Suggestion: 1

    See Also
    --------
    open_window, set_lut, set_fix, set_pixel, write_lut, get_lut, set_color

    Predecessors
    ------------
    set_lut

    Warnings
    --------
    disp_lut is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1285) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, scale)
        proc.execute()


def disp_obj(object: HObject, window_handle: HHandle) -> None:
    """
    Displays image objects (image, region, XLD).

    Parameters
    ----------

    object : HObject
             Image object to be displayed.

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    open_window, reset_obj_db, set_paint, set_lut, paint_gray,
    scale_image, convert_image_type, dump_window

    Alternatives
    ------------
    disp_color, disp_image, disp_xld, disp_region

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, scale_image,
    convert_image_type, min_max_gray
    """
    with HalconOperator(1276) as proc:
        proc.set_input_object(1, object)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def disp_object_model_3d(
    window_handle: HHandle,
    object_model_3d: MaybeSequence[HHandle],
    cam_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> None:
    """
    Display 3D object models.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    cam_param : Sequence[Union[int, float, str]]
                Camera parameters of the scene.
                Value Suggestion: []

    pose : Sequence[Union[int, float]]
           3D poses of the objects.
           Value Suggestion: []

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters.
                      Value Suggestion: []

    See Also
    --------
    render_object_model_3d, project_object_model_3d,
    project_shape_model_3d, object_model_3d_to_xyz

    Predecessors
    ------------
    find_surface_model, fit_primitives_object_model_3d,
    read_object_model_3d, segment_object_model_3d

    Successors
    ----------
    get_disp_object_model_3d_info

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1089) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, cam_param)
        proc.set_input_tuple(3, pose)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.execute()


def disp_polygon(
    window_handle: HHandle,
    row: Sequence[Union[int, float]],
    column: Sequence[Union[int, float]]
) -> None:
    """
    Displays a polyline.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : Sequence[Union[int, float]]
          Row index
          Value Suggestion: [16,80,80]

    column : Sequence[Union[int, float]]
             Column index
             Value Suggestion: [48,16,80]

    See Also
    --------
    open_window, set_color, set_rgb, set_hsi, set_insert, set_line_width

    Alternatives
    ------------
    disp_line, gen_region_polygon, disp_region

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, set_draw, set_color,
    set_colored, set_line_width

    Notes
    -----
    The given coordinates must lie within the window.
    """
    with HalconOperator(1265) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def disp_rectangle1(
    window_handle: HHandle,
    row_1: MaybeSequence[Union[int, float]],
    column_1: MaybeSequence[Union[int, float]],
    row_2: MaybeSequence[Union[int, float]],
    column_2: MaybeSequence[Union[int, float]]
) -> None:
    """
    Display of rectangles aligned to the coordinate axes.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1 : MaybeSequence[Union[int, float]]
            Row index of the upper left corner.
            Value Suggestion: 16

    column_1 : MaybeSequence[Union[int, float]]
               Column index of the upper left corner.
               Value Suggestion: 16

    row_2 : MaybeSequence[Union[int, float]]
            Row index of the lower right corner.
            Value Suggestion: 48
            Assertion: Row2 >= Row1

    column_2 : MaybeSequence[Union[int, float]]
               Column index of the lower right corner.
               Value Suggestion: 80
               Assertion: Column2 >= Column1

    See Also
    --------
    open_window, set_color, set_draw, set_line_width

    Alternatives
    ------------
    disp_rectangle2, gen_rectangle1, disp_region, disp_line, set_shape

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, set_draw, set_color,
    set_colored, set_line_width
    """
    with HalconOperator(1264) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1)
        proc.set_input_tuple(2, column_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.execute()


def disp_rectangle2(
    window_handle: HHandle,
    center_row: MaybeSequence[Union[int, float]],
    center_col: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    length_1: MaybeSequence[Union[int, float]],
    length_2: MaybeSequence[Union[int, float]]
) -> None:
    """
    Displays arbitrarily oriented rectangles.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    center_row : MaybeSequence[Union[int, float]]
                 Row index of the center.
                 Value Suggestion: 48

    center_col : MaybeSequence[Union[int, float]]
                 Column index of the center.
                 Value Suggestion: 64

    phi : MaybeSequence[Union[int, float]]
          Orientation of rectangle in radians.
          Value Suggestion: 0.0

    length_1 : MaybeSequence[Union[int, float]]
               Half of the length of the longer side.
               Value Suggestion: 48

    length_2 : MaybeSequence[Union[int, float]]
               Half of the length of the shorter side.
               Value Suggestion: 32
               Assertion: Length2 < Length1

    See Also
    --------
    open_window, disp_region, set_color, set_draw, set_line_width

    Alternatives
    ------------
    disp_region, gen_rectangle2, disp_rectangle1, set_shape

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, set_draw, set_color,
    set_colored, set_line_width

    Notes
    -----
    The center must lie within the window boundaries.
    """
    with HalconOperator(1263) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, center_row)
        proc.set_input_tuple(2, center_col)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, length_1)
        proc.set_input_tuple(5, length_2)
        proc.execute()


def disp_region(disp_regions: HObject, window_handle: HHandle) -> None:
    """
    Displays regions in a window.

    Parameters
    ----------

    disp_regions : HObject
                   Regions to display.

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    open_window, set_color, set_colored, set_draw, set_shape, set_paint,
    set_gray, set_rgb, set_hsi, set_line_width, set_line_style,
    set_insert, paint_region, dump_window

    Alternatives
    ------------
    disp_obj, disp_arrow, disp_line, disp_circle, disp_rectangle1,
    disp_rectangle2, disp_ellipse

    Predecessors
    ------------
    open_window, set_rgb, set_lut, set_hsi, set_shape, set_line_style,
    set_insert, set_draw, set_color, set_colored, set_line_width
    """
    with HalconOperator(1262) as proc:
        proc.set_input_object(1, disp_regions)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def disp_text(
    window_handle: HHandle,
    string: MaybeSequence[str],
    coord_system: str,
    row: MaybeSequence[Union[int, float, str]],
    column: MaybeSequence[Union[int, float, str]],
    color: MaybeSequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> None:
    """
    Display text in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    string : MaybeSequence[str]
             A tuple of strings containing the text message to be
             displayed. Each value of the tuple will be displayed in a
             single line.
             Value Suggestion: hello

    coord_system : str
                   If set to 'window', the text position is given with
                   respect to the window coordinate system. If set to
                   'image', image coordinates are used (this may be useful
                   in zoomed images).
                   Value Suggestion: window

    row : MaybeSequence[Union[int, float, str]]
          The vertical text alignment or the row coordinate of the desired
          text position.
          Value Suggestion: 12

    column : MaybeSequence[Union[int, float, str]]
             The horizontal text alignment or the column coordinate of
             the desired text position.
             Value Suggestion: 12

    color : MaybeSequence[str]
            A tuple of strings defining the colors of the texts.
            Value Suggestion: black

    gen_param_name : Sequence[str]
                     Generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Generic parameter values.
                      Value Suggestion: []

    See Also
    --------
    get_string_extents, set_font

    Alternatives
    ------------
    write_string

    Predecessors
    ------------
    open_window, set_font, get_string_extents

    Notes
    -----
    disp_text depends on the library libcanvas, which might not be
    available on embedded systems.
    """
    with HalconOperator(2055) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, string)
        proc.set_input_tuple(2, coord_system)
        proc.set_input_tuple(3, row)
        proc.set_input_tuple(4, column)
        proc.set_input_tuple(5, color)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.execute()


def disp_xld(xldobject: HObject, window_handle: HHandle) -> None:
    """
    Display an XLD object.

    Parameters
    ----------

    xldobject : HObject
                XLD object to display.

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    disp_image, disp_region, disp_channel, disp_color, disp_line, disp_arc
    """
    with HalconOperator(74) as proc:
        proc.set_input_object(1, xldobject)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def disparity_image_to_xyz(
    disparity: HObject,
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]]
) -> Tuple[HObject, HObject, HObject]:
    """
    Transform a disparity image into 3D points in a rectified stereo
    system.

    Parameters
    ----------

    disparity : HObject
                Disparity image.

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Internal camera parameters of the rectified camera
                       2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Pose of the rectified camera 2 in relation to the
                    rectified camera 1.

    Returns
    -------

    x : HObject
        X coordinates of the points in the rectified camera system 1.

    y : HObject
        Y coordinates of the points in the rectified camera system 1.

    z : HObject
        Z coordinates of the points in the rectified camera system 1.

    See Also
    --------
    binocular_calibration, gen_binocular_rectification_map,
    intersect_lines_of_sight

    Alternatives
    ------------
    disparity_to_point_3d, binocular_distance

    Predecessors
    ------------
    binocular_disparity

    Successors
    ----------
    threshold, write_image

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.
    """
    with HalconOperator(365) as proc:
        proc.set_input_object(1, disparity)
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # x
            HObject(proc.get_output_object_key(2)),  # y
            HObject(proc.get_output_object_key(3))   # z
        )  # type: ignore


def disparity_to_distance(
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    disparity: MaybeSequence[Union[int, float]]
) -> Sequence[float]:
    """
    Transform a disparity value into a distance value in a rectified
    binocular stereo system.

    Parameters
    ----------

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    disparity : MaybeSequence[Union[int, float]]
                Disparity between the images of the world point.

    Returns
    -------

    distance : Sequence[float]
               Distance of a world point to the rectified camera system.

    See Also
    --------
    distance_to_disparity, disparity_to_point_3d

    Alternatives
    ------------
    binocular_distance

    Predecessors
    ------------
    binocular_calibration, gen_binocular_rectification_map, map_image,
    binocular_disparity

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For a stereo setup of mixed type (i.e., for a stereo setup in which
    one of the original cameras is a perspective camera and the other
    camera is a telecentric camera; see gen_binocular_rectification_map),
    the rectifying plane of the two cameras is in a position with respect
    to the object that would lead to very unintuitive distances.
    Therefore, disparity_to_distance does not support stereo setups of
    mixed type.  For stereo setups of mixed type, disparity_to_point_3d
    should be used instead.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(367) as proc:
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, disparity)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_m(0)
        return distance  # type: ignore


def disparity_to_distance_s(
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    disparity: MaybeSequence[Union[int, float]]
) -> float:
    """
    Transform a disparity value into a distance value in a rectified
    binocular stereo system.

    Parameters
    ----------

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    disparity : MaybeSequence[Union[int, float]]
                Disparity between the images of the world point.

    Returns
    -------

    distance : float
               Distance of a world point to the rectified camera system.

    See Also
    --------
    distance_to_disparity, disparity_to_point_3d

    Alternatives
    ------------
    binocular_distance

    Predecessors
    ------------
    binocular_calibration, gen_binocular_rectification_map, map_image,
    binocular_disparity

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For a stereo setup of mixed type (i.e., for a stereo setup in which
    one of the original cameras is a perspective camera and the other
    camera is a telecentric camera; see gen_binocular_rectification_map),
    the rectifying plane of the two cameras is in a position with respect
    to the object that would lead to very unintuitive distances.
    Therefore, disparity_to_distance does not support stereo setups of
    mixed type.  For stereo setups of mixed type, disparity_to_point_3d
    should be used instead.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(367) as proc:
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, disparity)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_s(0)
        return distance  # type: ignore


def disparity_to_point_3d(
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    row_1: MaybeSequence[Union[int, float]],
    col_1: MaybeSequence[Union[int, float]],
    disparity: MaybeSequence[Union[int, float]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Transform an image point and its disparity into a 3D point in a
    rectified stereo system.

    Parameters
    ----------

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Pose of the rectified camera 2 in relation to the
                    rectified camera 1.

    row_1 : MaybeSequence[Union[int, float]]
            Row coordinate of a point in the rectified image 1.

    col_1 : MaybeSequence[Union[int, float]]
            Column coordinate of a point in the rectified image 1.

    disparity : MaybeSequence[Union[int, float]]
                Disparity of the images of the world point.

    Returns
    -------

    x : Sequence[float]
        X coordinate of the 3D point.

    y : Sequence[float]
        Y coordinate of the 3D point.

    z : Sequence[float]
        Z coordinate of the 3D point.

    See Also
    --------
    binocular_disparity, binocular_distance, intersect_lines_of_sight

    Alternatives
    ------------
    disparity_image_to_xyz

    Predecessors
    ------------
    binocular_calibration, gen_binocular_rectification_map

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.
    """
    with HalconOperator(366) as proc:
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, row_1)
        proc.set_input_tuple(4, col_1)
        proc.set_input_tuple(5, disparity)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1),  # y
            proc.get_output_tuple_m(2)   # z
        )  # type: ignore


def disparity_to_point_3d_s(
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    row_1: MaybeSequence[Union[int, float]],
    col_1: MaybeSequence[Union[int, float]],
    disparity: MaybeSequence[Union[int, float]]
) -> Tuple[float, float, float]:
    """
    Transform an image point and its disparity into a 3D point in a
    rectified stereo system.

    Parameters
    ----------

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Pose of the rectified camera 2 in relation to the
                    rectified camera 1.

    row_1 : MaybeSequence[Union[int, float]]
            Row coordinate of a point in the rectified image 1.

    col_1 : MaybeSequence[Union[int, float]]
            Column coordinate of a point in the rectified image 1.

    disparity : MaybeSequence[Union[int, float]]
                Disparity of the images of the world point.

    Returns
    -------

    x : float
        X coordinate of the 3D point.

    y : float
        Y coordinate of the 3D point.

    z : float
        Z coordinate of the 3D point.

    See Also
    --------
    binocular_disparity, binocular_distance, intersect_lines_of_sight

    Alternatives
    ------------
    disparity_image_to_xyz

    Predecessors
    ------------
    binocular_calibration, gen_binocular_rectification_map

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.
    """
    with HalconOperator(366) as proc:
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, row_1)
        proc.set_input_tuple(4, col_1)
        proc.set_input_tuple(5, disparity)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # x
            proc.get_output_tuple_s(1),  # y
            proc.get_output_tuple_s(2)   # z
        )  # type: ignore


def display_scene_3d(
    window_handle: HHandle,
    scene_3d: HHandle,
    camera_index: Union[int, str]
) -> None:
    """
    Display a 3D scene.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    scene_3d : HHandle
               Handle of the 3D scene.

    camera_index : Union[int, str]
                   Index of the camera used to display the scene.

    See Also
    --------
    create_scene_3d, render_scene_3d
    """
    with HalconOperator(1215) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, scene_3d)
        proc.set_input_tuple(2, camera_index)
        proc.execute()


def dist_ellipse_contour_points_xld(
    contour: HObject,
    distance_mode: str,
    clipping_end_points: int,
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float
) -> Sequence[float]:
    """
    Compute the distances of all contour points to an ellipse.

    Parameters
    ----------

    contour : HObject
              Input contours.

    distance_mode : str
                    Mode for unsigned or signed distance values.
                    Value Suggestion: unsigned

    clipping_end_points : int
                          Number of points at the beginning and the end of
                          the contours to be ignored for the computation
                          of distances.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    row : float
          Row coordinate of the center of the ellipse.

    column : float
             Column coordinate of the center of the ellipse.

    phi : float
          Orientation of the main axis in radian.
          Assertion: Phi >= 0 && Phi <= 6.283185307

    radius_1 : float
               Length of the larger half axis.
               Assertion: Radius1 > 0

    radius_2 : float
               Length of the smaller half axis.
               Assertion: Radius2 >= 0 && Radius2 <= Radius1

    Returns
    -------

    distances : Sequence[float]
                Distances of the contour points to the ellipse.

    Alternatives
    ------------
    dist_ellipse_contour_xld

    Predecessors
    ------------
    fit_ellipse_contour_xld
    """
    with HalconOperator(31) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, distance_mode)
        proc.set_input_tuple(1, clipping_end_points)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, phi)
        proc.set_input_tuple(5, radius_1)
        proc.set_input_tuple(6, radius_2)
        proc.init_oct(0)
        proc.execute()
        distances = proc.get_output_tuple_m(0)
        return distances  # type: ignore


def dist_ellipse_contour_xld(
    contours: HObject,
    mode: str,
    max_num_points: int,
    clipping_end_points: int,
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the distance of contours to an ellipse.

    Parameters
    ----------

    contours : HObject
               Input contours.

    mode : str
           Method for the determination of the distances.
           Value Suggestion: geometric

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 3

    clipping_end_points : int
                          Number of points at the beginning and the end of
                          the contours to be ignored for the computation
                          of distances.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    row : float
          Row coordinate of the center of the ellipse.

    column : float
             Column coordinate of the center of the ellipse.

    phi : float
          Orientation of the main axis in radian.
          Assertion: Phi >= 0 && Phi <= 6.283185307

    radius_1 : float
               Length of the larger half axis.
               Assertion: Radius1 > 0

    radius_2 : float
               Length of the smaller half axis.
               Assertion: Radius2 >= 0 && Radius2 <= Radius1

    Returns
    -------

    min_dist : Sequence[float]
               Minimum distance.

    max_dist : Sequence[float]
               Maximum distance.

    avg_dist : Sequence[float]
               Mean distance.

    sigma_dist : Sequence[float]
                 Standard deviation of the distance.

    Alternatives
    ------------
    dist_ellipse_contour_points_xld

    Predecessors
    ------------
    fit_ellipse_contour_xld
    """
    with HalconOperator(32) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, clipping_end_points)
        proc.set_input_tuple(3, row)
        proc.set_input_tuple(4, column)
        proc.set_input_tuple(5, phi)
        proc.set_input_tuple(6, radius_1)
        proc.set_input_tuple(7, radius_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # min_dist
            proc.get_output_tuple_m(1),  # max_dist
            proc.get_output_tuple_m(2),  # avg_dist
            proc.get_output_tuple_m(3)   # sigma_dist
        )  # type: ignore


def dist_ellipse_contour_xld_s(
    contours: HObject,
    mode: str,
    max_num_points: int,
    clipping_end_points: int,
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float
) -> Tuple[float, float, float, float]:
    """
    Compute the distance of contours to an ellipse.

    Parameters
    ----------

    contours : HObject
               Input contours.

    mode : str
           Method for the determination of the distances.
           Value Suggestion: geometric

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 3

    clipping_end_points : int
                          Number of points at the beginning and the end of
                          the contours to be ignored for the computation
                          of distances.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    row : float
          Row coordinate of the center of the ellipse.

    column : float
             Column coordinate of the center of the ellipse.

    phi : float
          Orientation of the main axis in radian.
          Assertion: Phi >= 0 && Phi <= 6.283185307

    radius_1 : float
               Length of the larger half axis.
               Assertion: Radius1 > 0

    radius_2 : float
               Length of the smaller half axis.
               Assertion: Radius2 >= 0 && Radius2 <= Radius1

    Returns
    -------

    min_dist : float
               Minimum distance.

    max_dist : float
               Maximum distance.

    avg_dist : float
               Mean distance.

    sigma_dist : float
                 Standard deviation of the distance.

    Alternatives
    ------------
    dist_ellipse_contour_points_xld

    Predecessors
    ------------
    fit_ellipse_contour_xld
    """
    with HalconOperator(32) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, clipping_end_points)
        proc.set_input_tuple(3, row)
        proc.set_input_tuple(4, column)
        proc.set_input_tuple(5, phi)
        proc.set_input_tuple(6, radius_1)
        proc.set_input_tuple(7, radius_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # min_dist
            proc.get_output_tuple_s(1),  # max_dist
            proc.get_output_tuple_s(2),  # avg_dist
            proc.get_output_tuple_s(3)   # sigma_dist
        )  # type: ignore


def dist_rectangle2_contour_points_xld(
    contour: HObject,
    clipping_end_points: int,
    row: float,
    column: float,
    phi: float,
    length_1: float,
    length_2: float
) -> Sequence[float]:
    """
    Compute the distances of all contour points to a rectangle.

    Parameters
    ----------

    contour : HObject
              Input contour.

    clipping_end_points : int
                          Number of points at the beginning and the end of
                          the contours to be ignored for the computation
                          of distances.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    row : float
          Row coordinate of the center of the rectangle.

    column : float
             Column coordinate of the center of the rectangle.

    phi : float
          Orientation of the main axis of the rectangle [rad].

    length_1 : float
               First radius (half length) of the rectangle.
               Assertion: Length1 > 0

    length_2 : float
               Second radius (half width) of the rectangle.
               Assertion: Length2 >= 0

    Returns
    -------

    distances : Sequence[float]
                Distances of the contour points to the rectangle.

    Predecessors
    ------------
    fit_rectangle2_contour_xld
    """
    with HalconOperator(25) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, clipping_end_points)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, length_1)
        proc.set_input_tuple(5, length_2)
        proc.init_oct(0)
        proc.execute()
        distances = proc.get_output_tuple_m(0)
        return distances  # type: ignore


def distance_cc(
    contour_1: HObject,
    contour_2: HObject,
    mode: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between two contours.

    Parameters
    ----------

    contour_1 : HObject
                First input contour.

    contour_2 : HObject
                Second input contour.

    mode : str
           Distance calculation mode.
           Value Suggestion: point_to_point

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between both contours.

    distance_max : Sequence[float]
                   Maximum distance between both contours.

    See Also
    --------
    distance_sr, distance_pr

    Alternatives
    ------------
    distance_sc, distance_pc, distance_cc_min, distance_contours_xld

    Notes
    -----
    Both iconic input parameters must contain the same number of contours.
    """
    with HalconOperator(1363) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_cc_min(
    contour_1: HObject,
    contour_2: HObject,
    mode: str
) -> Sequence[float]:
    """
    Calculate the minimum distance between two contours.

    Parameters
    ----------

    contour_1 : HObject
                First input contour.

    contour_2 : HObject
                Second input contour.

    mode : str
           Distance calculation mode.
           Value Suggestion: fast_point_to_segment

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the two contours.

    See Also
    --------
    distance_sr, distance_pr

    Alternatives
    ------------
    distance_sc, distance_pc, distance_cc, distance_contours_xld

    Notes
    -----
    Both iconic input parameters must contain the same number of contours.
    """
    with HalconOperator(1362) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.execute()
        distance_min = proc.get_output_tuple_m(0)
        return distance_min  # type: ignore


def distance_cc_min_points(
    contour_1: HObject,
    contour_2: HObject,
    mode: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the minimum distance between two contours and the points
    used for  the calculation.

    Parameters
    ----------

    contour_1 : HObject
                First input contour.

    contour_2 : HObject
                Second input contour.

    mode : str
           Distance calculation mode.
           Value Suggestion: fast_point_to_segment

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the two contours.

    row_1 : Sequence[float]
            Row coordinate of the point on Contour1.

    column_1 : Sequence[float]
               Column coordinate of the point on Contour1.

    row_2 : Sequence[float]
            Row coordinate of the point on Contour2.

    column_2 : Sequence[float]
               Column coordinate of the point on Contour2.

    See Also
    --------
    distance_sr, distance_pr

    Alternatives
    ------------
    distance_sc, distance_pc, distance_cc, distance_contours_xld,
    distance_cc_min

    Notes
    -----
    Both iconic input parameters must contain the same number of contours.
    """
    with HalconOperator(2111) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1),  # row_1
            proc.get_output_tuple_m(2),  # column_1
            proc.get_output_tuple_m(3),  # row_2
            proc.get_output_tuple_m(4)   # column_2
        )  # type: ignore


def distance_cc_min_points_s(
    contour_1: HObject,
    contour_2: HObject,
    mode: str
) -> Tuple[float, float, float, float, float]:
    """
    Calculate the minimum distance between two contours and the points
    used for  the calculation.

    Parameters
    ----------

    contour_1 : HObject
                First input contour.

    contour_2 : HObject
                Second input contour.

    mode : str
           Distance calculation mode.
           Value Suggestion: fast_point_to_segment

    Returns
    -------

    distance_min : float
                   Minimum distance between the two contours.

    row_1 : float
            Row coordinate of the point on Contour1.

    column_1 : float
               Column coordinate of the point on Contour1.

    row_2 : float
            Row coordinate of the point on Contour2.

    column_2 : float
               Column coordinate of the point on Contour2.

    See Also
    --------
    distance_sr, distance_pr

    Alternatives
    ------------
    distance_sc, distance_pc, distance_cc, distance_contours_xld,
    distance_cc_min

    Notes
    -----
    Both iconic input parameters must contain the same number of contours.
    """
    with HalconOperator(2111) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1),  # row_1
            proc.get_output_tuple_s(2),  # column_1
            proc.get_output_tuple_s(3),  # row_2
            proc.get_output_tuple_s(4)   # column_2
        )  # type: ignore


def distance_cc_min_s(
    contour_1: HObject,
    contour_2: HObject,
    mode: str
) -> float:
    """
    Calculate the minimum distance between two contours.

    Parameters
    ----------

    contour_1 : HObject
                First input contour.

    contour_2 : HObject
                Second input contour.

    mode : str
           Distance calculation mode.
           Value Suggestion: fast_point_to_segment

    Returns
    -------

    distance_min : float
                   Minimum distance between the two contours.

    See Also
    --------
    distance_sr, distance_pr

    Alternatives
    ------------
    distance_sc, distance_pc, distance_cc, distance_contours_xld

    Notes
    -----
    Both iconic input parameters must contain the same number of contours.
    """
    with HalconOperator(1362) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.execute()
        distance_min = proc.get_output_tuple_s(0)
        return distance_min  # type: ignore


def distance_cc_s(
    contour_1: HObject,
    contour_2: HObject,
    mode: str
) -> Tuple[float, float]:
    """
    Calculate the distance between two contours.

    Parameters
    ----------

    contour_1 : HObject
                First input contour.

    contour_2 : HObject
                Second input contour.

    mode : str
           Distance calculation mode.
           Value Suggestion: point_to_point

    Returns
    -------

    distance_min : float
                   Minimum distance between both contours.

    distance_max : float
                   Maximum distance between both contours.

    See Also
    --------
    distance_sr, distance_pr

    Alternatives
    ------------
    distance_sc, distance_pc, distance_cc_min, distance_contours_xld

    Notes
    -----
    Both iconic input parameters must contain the same number of contours.
    """
    with HalconOperator(1363) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_contours_xld(
    contour_from: HObject,
    contour_to: HObject,
    mode: str
) -> HObject:
    """
    Calculate the pointwise distance from one contour to another.

    Parameters
    ----------

    contour_from : HObject
                   Contours for whose points the distances are calculated.

    contour_to : HObject
                 Contours to which the distances are calculated to.

    mode : str
           Compute the distance to points ('point_to_point') or to entire
           segments ('point_to_segment').
           Value Suggestion: point_to_point

    Returns
    -------

    contour_out : HObject
                  Copy of ContourFrom containing the distances as an
                  attribute.

    Alternatives
    ------------
    apply_distance_transform_xld, distance_cc, distance_cc_min

    Successors
    ----------
    get_contour_attrib_xld, segment_contour_attrib_xld
    """
    with HalconOperator(1361) as proc:
        proc.set_input_object(1, contour_from)
        proc.set_input_object(2, contour_to)
        proc.set_input_tuple(0, mode)
        proc.execute()
        contour_out = HObject(proc.get_output_object_key(1))
        return contour_out  # type: ignore


def distance_funct_1d(
    function_1: Sequence[Union[float, int]],
    function_2: Sequence[Union[float, int]],
    mode: MaybeSequence[str],
    sigma: MaybeSequence[float]
) -> Sequence[Union[float, int]]:
    """
    Compute the distance of two functions.

    Parameters
    ----------

    function_1 : Sequence[Union[float, int]]
                 Input function 1.

    function_2 : Sequence[Union[float, int]]
                 Input function 2.

    mode : MaybeSequence[str]
           Modes of invariants.
           Value Suggestion: length

    sigma : MaybeSequence[float]
            Variance of the optional smoothing with a Gaussian filter.
            Value Suggestion: 0.0

    Returns
    -------

    distance : Sequence[Union[float, int]]
               Distance of the functions.
    """
    with HalconOperator(1394) as proc:
        proc.set_input_tuple(0, function_1)
        proc.set_input_tuple(1, function_2)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, sigma)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_m(0)
        return distance  # type: ignore


def distance_lc(
    contour: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between a line and one contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the line and the contour.

    distance_max : Sequence[float]
                   Maximum distance between the line and the contour.

    See Also
    --------
    distance_lr, distance_pr, distance_sr

    Alternatives
    ------------
    distance_pc, distance_sc, distance_cc, distance_cc_min
    """
    with HalconOperator(1365) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_lc_s(
    contour: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distance between a line and one contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : float
                   Minimum distance between the line and the contour.

    distance_max : float
                   Maximum distance between the line and the contour.

    See Also
    --------
    distance_lr, distance_pr, distance_sr

    Alternatives
    ------------
    distance_pc, distance_sc, distance_cc, distance_cc_min
    """
    with HalconOperator(1365) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_lr(
    region: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between a line and a region.

    Parameters
    ----------

    region : HObject
             Input region.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the line and the region

    distance_max : Sequence[float]
                   Maximum distance between the line and the region

    See Also
    --------
    hamming_distance, select_region_point, test_region_point,
    smallest_rectangle2

    Alternatives
    ------------
    distance_lc, distance_pr, distance_sr, diameter_region

    Notes
    -----
    Due to efficiency of distance_lr holes are ignored.
    """
    with HalconOperator(1368) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_lr_s(
    region: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distance between a line and a region.

    Parameters
    ----------

    region : HObject
             Input region.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : float
                   Minimum distance between the line and the region

    distance_max : float
                   Maximum distance between the line and the region

    See Also
    --------
    hamming_distance, select_region_point, test_region_point,
    smallest_rectangle2

    Alternatives
    ------------
    distance_lc, distance_pr, distance_sr, diameter_region

    Notes
    -----
    Due to efficiency of distance_lr holes are ignored.
    """
    with HalconOperator(1368) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_object_model_3d(
    object_model_3dfrom: HHandle,
    object_model_3dto: HHandle,
    pose: Sequence[Union[float, int]],
    max_distance: Union[float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> None:
    """
    Compute the distances of the points of one 3D object model to another
    3D object model.

    Parameters
    ----------

    object_model_3dfrom : HHandle
                          Handle of the source 3D object model.

    object_model_3dto : HHandle
                        Handle of the target 3D object model.

    pose : Sequence[Union[float, int]]
           Pose of the source 3D object model in the target 3D object
           model.
           Value Suggestion: []

    max_distance : Union[float, int]
                   Maximum distance of interest.
                   Value Suggestion: 0

    gen_param_name : MaybeSequence[str]
                     Names of the generic input parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic input parameters.
                      Value Suggestion: []

    See Also
    --------
    prepare_object_model_3d

    Predecessors
    ------------
    prepare_object_model_3d, read_object_model_3d, find_surface_model,
    xyz_to_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, render_object_model_3d,
    disp_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(1061) as proc:
        proc.set_input_tuple(0, object_model_3dfrom)
        proc.set_input_tuple(1, object_model_3dto)
        proc.set_input_tuple(2, pose)
        proc.set_input_tuple(3, max_distance)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.execute()


def distance_pc(
    contour: HObject,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between a point and one contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the point.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the point and the contour.

    distance_max : Sequence[float]
                   Maximum distance between the point and the contour.

    See Also
    --------
    distance_pr, distance_lr, distance_sr, hamming_distance,
    select_xld_point, test_xld_point

    Alternatives
    ------------
    distance_lc, distance_sc, distance_cc, distance_cc_min
    """
    with HalconOperator(1366) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_pc_s(
    contour: HObject,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distance between a point and one contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the point.

    Returns
    -------

    distance_min : float
                   Minimum distance between the point and the contour.

    distance_max : float
                   Maximum distance between the point and the contour.

    See Also
    --------
    distance_pr, distance_lr, distance_sr, hamming_distance,
    select_xld_point, test_xld_point

    Alternatives
    ------------
    distance_lc, distance_sc, distance_cc, distance_cc_min
    """
    with HalconOperator(1366) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_pl(
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the distance between one point and one line.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column of the point.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    distance : Sequence[float]
               Distance between the points.

    See Also
    --------
    distance_pp, distance_pr

    Alternatives
    ------------
    distance_ps
    """
    with HalconOperator(1375) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_m(0)
        return distance  # type: ignore


def distance_pl_s(
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the distance between one point and one line.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column of the point.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line.

    Returns
    -------

    distance : float
               Distance between the points.

    See Also
    --------
    distance_pp, distance_pr

    Alternatives
    ------------
    distance_ps
    """
    with HalconOperator(1375) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_s(0)
        return distance  # type: ignore


def distance_pp(
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the distance between two points.

    Parameters
    ----------

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point.

    Returns
    -------

    distance : Sequence[float]
               Distance between the points.

    See Also
    --------
    distance_pl, distance_pr

    Alternatives
    ------------
    distance_ps
    """
    with HalconOperator(1376) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_m(0)
        return distance  # type: ignore


def distance_pp_s(
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the distance between two points.

    Parameters
    ----------

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point.

    Returns
    -------

    distance : float
               Distance between the points.

    See Also
    --------
    distance_pl, distance_pr

    Alternatives
    ------------
    distance_ps
    """
    with HalconOperator(1376) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.execute()
        distance = proc.get_output_tuple_s(0)
        return distance  # type: ignore


def distance_pr(
    region: HObject,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between a point and a region.

    Parameters
    ----------

    region : HObject
             Input region.

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the point.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the point and the region.

    distance_max : Sequence[float]
                   Maximum distance between the point and the region.

    See Also
    --------
    hamming_distance, select_region_point, test_region_point,
    smallest_rectangle2

    Alternatives
    ------------
    distance_pc, distance_lr, distance_sr, diameter_region
    """
    with HalconOperator(1369) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_pr_s(
    region: HObject,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distance between a point and a region.

    Parameters
    ----------

    region : HObject
             Input region.

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the point.

    Returns
    -------

    distance_min : float
                   Minimum distance between the point and the region.

    distance_max : float
                   Maximum distance between the point and the region.

    See Also
    --------
    hamming_distance, select_region_point, test_region_point,
    smallest_rectangle2

    Alternatives
    ------------
    distance_pc, distance_lr, distance_sr, diameter_region
    """
    with HalconOperator(1369) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_ps(
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distances between a point and a line segment.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the first point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the first point.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line segment.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line segment.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line segment.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line segment.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the point and the line segment.

    distance_max : Sequence[float]
                   Maximum distance between the point and the line segment.

    See Also
    --------
    distance_pp, distance_pr

    Alternatives
    ------------
    distance_pl
    """
    with HalconOperator(1374) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_ps_s(
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distances between a point and a line segment.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the first point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the first point.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line segment.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line segment.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line segment.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line segment.

    Returns
    -------

    distance_min : float
                   Minimum distance between the point and the line segment.

    distance_max : float
                   Maximum distance between the point and the line segment.

    See Also
    --------
    distance_pp, distance_pr

    Alternatives
    ------------
    distance_pl
    """
    with HalconOperator(1374) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_rr_min(
    regions_1: HObject,
    regions_2: HObject
) -> Tuple[Sequence[float], Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Minimum distance between the contour pixels of two regions each.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Regions to be examined.

    Returns
    -------

    min_distance : Sequence[float]
                   Minimum distance between contours of the regions.
                   Assertion: 0 <= MinDistance

    row_1 : Sequence[int]
            Line index on contour in Regions1.

    column_1 : Sequence[int]
               Column index on contour in Regions1.

    row_2 : Sequence[int]
            Line index on contour in Regions2.

    column_2 : Sequence[int]
               Column index on contour in Regions2.

    Alternatives
    ------------
    distance_rr_min_dil, dilation1, intersection

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Both input parameters must contain the same number of regions.  The
    regions must not be empty.
    """
    with HalconOperator(1709) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # min_distance
            proc.get_output_tuple_m(1),  # row_1
            proc.get_output_tuple_m(2),  # column_1
            proc.get_output_tuple_m(3),  # row_2
            proc.get_output_tuple_m(4)   # column_2
        )  # type: ignore


def distance_rr_min_dil(
    regions_1: HObject,
    regions_2: HObject
) -> Sequence[int]:
    """
    Minimum distance between two regions with the help of dilation.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Regions to be examined.

    Returns
    -------

    min_distance : Sequence[int]
                   Minimum distances of the regions.
                   Assertion: -1 <= MinDistance

    Alternatives
    ------------
    distance_rr_min, dilation1, intersection

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Both parameters must contain the same number of regions. The regions
    must not be empty.
    """
    with HalconOperator(1710) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.execute()
        min_distance = proc.get_output_tuple_m(0)
        return min_distance  # type: ignore


def distance_rr_min_dil_s(
    regions_1: HObject,
    regions_2: HObject
) -> int:
    """
    Minimum distance between two regions with the help of dilation.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Regions to be examined.

    Returns
    -------

    min_distance : int
                   Minimum distances of the regions.
                   Assertion: -1 <= MinDistance

    Alternatives
    ------------
    distance_rr_min, dilation1, intersection

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Both parameters must contain the same number of regions. The regions
    must not be empty.
    """
    with HalconOperator(1710) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.execute()
        min_distance = proc.get_output_tuple_s(0)
        return min_distance  # type: ignore


def distance_rr_min_s(
    regions_1: HObject,
    regions_2: HObject
) -> Tuple[float, int, int, int, int]:
    """
    Minimum distance between the contour pixels of two regions each.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Regions to be examined.

    Returns
    -------

    min_distance : float
                   Minimum distance between contours of the regions.
                   Assertion: 0 <= MinDistance

    row_1 : int
            Line index on contour in Regions1.

    column_1 : int
               Column index on contour in Regions1.

    row_2 : int
            Line index on contour in Regions2.

    column_2 : int
               Column index on contour in Regions2.

    Alternatives
    ------------
    distance_rr_min_dil, dilation1, intersection

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Both input parameters must contain the same number of regions.  The
    regions must not be empty.
    """
    with HalconOperator(1709) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # min_distance
            proc.get_output_tuple_s(1),  # row_1
            proc.get_output_tuple_s(2),  # column_1
            proc.get_output_tuple_s(3),  # row_2
            proc.get_output_tuple_s(4)   # column_2
        )  # type: ignore


def distance_sc(
    contour: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between a line segment and one contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line segment.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line segment.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line segment.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line segment.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the line segment and the
                   contour.

    distance_max : Sequence[float]
                   Maximum distance between the line segment and the
                   contour.

    See Also
    --------
    distance_sr, distance_lr, distance_pr, select_xld_point, test_xld_point

    Alternatives
    ------------
    distance_lc, distance_pc, distance_cc, distance_cc_min
    """
    with HalconOperator(1364) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_sc_s(
    contour: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distance between a line segment and one contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line segment.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line segment.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line segment.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line segment.

    Returns
    -------

    distance_min : float
                   Minimum distance between the line segment and the
                   contour.

    distance_max : float
                   Maximum distance between the line segment and the
                   contour.

    See Also
    --------
    distance_sr, distance_lr, distance_pr, select_xld_point, test_xld_point

    Alternatives
    ------------
    distance_lc, distance_pc, distance_cc, distance_cc_min
    """
    with HalconOperator(1364) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_sl(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distances between a line segment and a line.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line segment.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the line segment.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line segment.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line segment.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the line segment and the line.

    distance_max : Sequence[float]
                   Maximum distance between the line segment and the line.

    See Also
    --------
    distance_ps, distance_pp

    Alternatives
    ------------
    distance_pl
    """
    with HalconOperator(1372) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_sl_s(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distances between a line segment and a line.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line segment.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the line segment.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line segment.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line segment.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : float
                   Minimum distance between the line segment and the line.

    distance_max : float
                   Maximum distance between the line segment and the line.

    See Also
    --------
    distance_ps, distance_pp

    Alternatives
    ------------
    distance_pl
    """
    with HalconOperator(1372) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_sr(
    region: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distance between a line segment and one region.

    Parameters
    ----------

    region : HObject
             Input region.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line segment.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line segment.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line segment.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line segment.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the line segment and the
                   region.

    distance_max : Sequence[float]
                   Maximum distance between the line segment and the
                   region.

    See Also
    --------
    hamming_distance, select_region_point, test_region_point,
    smallest_rectangle2

    Alternatives
    ------------
    distance_sc, distance_lr, distance_pr, diameter_region

    Notes
    -----
    To enhance distance_sr, holes are ignored.
    """
    with HalconOperator(1367) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_sr_s(
    region: HObject,
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distance between a line segment and one region.

    Parameters
    ----------

    region : HObject
             Input region.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point of the line segment.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point of the line segment.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point of the line segment.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point of the line segment.

    Returns
    -------

    distance_min : float
                   Minimum distance between the line segment and the
                   region.

    distance_max : float
                   Maximum distance between the line segment and the
                   region.

    See Also
    --------
    hamming_distance, select_region_point, test_region_point,
    smallest_rectangle2

    Alternatives
    ------------
    distance_sc, distance_lr, distance_pr, diameter_region

    Notes
    -----
    To enhance distance_sr, holes are ignored.
    """
    with HalconOperator(1367) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_ss(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the distances between two line segments.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line segment.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the line segment.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line segment.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line segment.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column of the first point of the line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : Sequence[float]
                   Minimum distance between the line segments.

    distance_max : Sequence[float]
                   Maximum distance between the line segments.

    See Also
    --------
    distance_pl, distance_ps

    Alternatives
    ------------
    distance_pp
    """
    with HalconOperator(1373) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance_min
            proc.get_output_tuple_m(1)   # distance_max
        )  # type: ignore


def distance_ss_s(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the distances between two line segments.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line segment.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the line segment.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line segment.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line segment.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column of the first point of the line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the line.

    Returns
    -------

    distance_min : float
                   Minimum distance between the line segments.

    distance_max : float
                   Maximum distance between the line segments.

    See Also
    --------
    distance_pl, distance_ps

    Alternatives
    ------------
    distance_pp
    """
    with HalconOperator(1373) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance_min
            proc.get_output_tuple_s(1)   # distance_max
        )  # type: ignore


def distance_to_disparity(
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    distance: MaybeSequence[float]
) -> Sequence[Union[int, float]]:
    """
    Transform a distance value into a disparity in a rectified stereo
    system.

    Parameters
    ----------

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    distance : MaybeSequence[float]
               Distance of a world point to camera 1.

    Returns
    -------

    disparity : Sequence[Union[int, float]]
                Disparity between the images of the point.

    Predecessors
    ------------
    binocular_calibration, gen_binocular_rectification_map

    Successors
    ----------
    binocular_disparity

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For stereo setups of mixed type (i.e., for a stereo setup in which one
    of the original cameras is a perspective camera and the other camera
    is a telecentric camera; see gen_binocular_rectification_map), the
    rectifying plane of the two cameras is in a position with respect to
    the object that would lead to very unintuitive distances.  Therefore,
    distance_to_disparity does not support stereo setups of mixed type.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(368) as proc:
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, distance)
        proc.init_oct(0)
        proc.execute()
        disparity = proc.get_output_tuple_m(0)
        return disparity  # type: ignore


def distance_to_disparity_s(
    cam_param_rect_1: Sequence[Union[int, float, str]],
    cam_param_rect_2: Sequence[Union[int, float, str]],
    rel_pose_rect: Sequence[Union[int, float]],
    distance: MaybeSequence[float]
) -> Union[int, float]:
    """
    Transform a distance value into a disparity in a rectified stereo
    system.

    Parameters
    ----------

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal camera parameters of camera 2.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    distance : MaybeSequence[float]
               Distance of a world point to camera 1.

    Returns
    -------

    disparity : Union[int, float]
                Disparity between the images of the point.

    Predecessors
    ------------
    binocular_calibration, gen_binocular_rectification_map

    Successors
    ----------
    binocular_disparity

    Notes
    -----
    If using cameras with telecentric lenses, the Distance is not defined
    as the distance of a point to the camera but as the distance from the
    point to the plane, defined by the y-axes of both cameras and their
    baseline (see gen_binocular_rectification_map).
    For stereo setups of mixed type (i.e., for a stereo setup in which one
    of the original cameras is a perspective camera and the other camera
    is a telecentric camera; see gen_binocular_rectification_map), the
    rectifying plane of the two cameras is in a position with respect to
    the object that would lead to very unintuitive distances.  Therefore,
    distance_to_disparity does not support stereo setups of mixed type.
    Additionally, stereo setups that contain cameras with and without
    hypercentric lenses at the same time are not supported.
    """
    with HalconOperator(368) as proc:
        proc.set_input_tuple(0, cam_param_rect_1)
        proc.set_input_tuple(1, cam_param_rect_2)
        proc.set_input_tuple(2, rel_pose_rect)
        proc.set_input_tuple(3, distance)
        proc.init_oct(0)
        proc.execute()
        disparity = proc.get_output_tuple_s(0)
        return disparity  # type: ignore


def distance_transform(
    region: HObject,
    metric: str,
    foreground: str,
    width: int,
    height: int
) -> HObject:
    """
    Compute the distance transformation of a region.

    Parameters
    ----------

    region : HObject
             Region for which the distance to the border is computed.

    metric : str
             Type of metric to be used for the distance transformation.
             Value Suggestion: 'city-block'

    foreground : str
                 Compute the distance for pixels inside (true) or outside
                 (false) the input region.
                 Value Suggestion: true

    width : int
            Width of the output image.
            Value Suggestion: 640

    height : int
             Height of the output image.
             Value Suggestion: 480

    Returns
    -------

    distance_image : HObject
                     Image containing the distance information.

    See Also
    --------
    skeleton

    Alternatives
    ------------
    closest_point_transform

    Predecessors
    ------------
    threshold, dyn_threshold, regiongrowing

    Successors
    ----------
    threshold
    """
    with HalconOperator(485) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, metric)
        proc.set_input_tuple(1, foreground)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.execute()
        distance_image = HObject(proc.get_output_object_key(1))
        return distance_image  # type: ignore


def div_element_matrix(
    matrix_aid: HHandle,
    matrix_bid: HHandle
) -> HHandle:
    """
    Divide matrices element-by-element.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    Returns
    -------

    matrix_div_id : HHandle
                    Matrix handle with the divided values of input
                    matrices.

    See Also
    --------
    mult_element_matrix, mult_element_matrix_mod, scale_matrix,
    scale_matrix_mod

    Alternatives
    ------------
    div_element_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(873) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.init_oct(0)
        proc.execute()
        matrix_div_id = proc.get_output_tuple_s(0)
        return matrix_div_id  # type: ignore


def div_element_matrix_mod(
    matrix_aid: HHandle,
    matrix_bid: HHandle
) -> None:
    """
    Divide matrices element-by-element.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    See Also
    --------
    mult_element_matrix, mult_element_matrix_mod, scale_matrix,
    scale_matrix_mod

    Alternatives
    ------------
    div_element_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(872) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.execute()


def div_image(
    image_1: HObject,
    image_2: HObject,
    mult: Union[int, float],
    add: Union[int, float]
) -> HObject:
    """
    Divide two images.

    Parameters
    ----------

    image_1 : HObject
              Image(s) 1.

    image_2 : HObject
              Image(s) 2.

    mult : Union[int, float]
           Factor for gray range adaption.
           Value Suggestion: 255

    add : Union[int, float]
          Value for gray range adaption.
          Value Suggestion: 0

    Returns
    -------

    image_result : HObject
                   Result image(s) by the division.

    See Also
    --------
    add_image, sub_image, mult_image

    Alternatives
    ------------
    add_image, sub_image, mult_image
    """
    with HalconOperator(1608) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, mult)
        proc.set_input_tuple(1, add)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def do_ocr_multi(
    character: HObject,
    image: HObject,
    ocr_handle: HHandle
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify characters.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values for the characters.

    ocr_handle : HHandle
                 ID of the OCR classifier.

    Returns
    -------

    class_val : Sequence[str]
                Class (name) of the characters.

    confidence : Sequence[float]
                 Confidence values of the characters.

    See Also
    --------
    write_ocr

    Alternatives
    ------------
    do_ocr_single

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box, read_ocr, connection,
    sort_region

    Warnings
    --------
    do_ocr_multi is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.
    """
    with HalconOperator(714) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocr_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_cnn(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify multiple characters with an CNN-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the CNN.

    confidence : Sequence[float]
                 Confidence of the class of the characters.

    Alternatives
    ------------
    do_ocr_word_cnn, do_ocr_single_class_cnn

    Predecessors
    ------------
    read_ocr_class_cnn
    """
    with HalconOperator(2056) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_cnn_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Tuple[str, float]:
    """
    Classify multiple characters with an CNN-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    class_val : str
                Result of classifying the characters with the CNN.

    confidence : float
                 Confidence of the class of the characters.

    Alternatives
    ------------
    do_ocr_word_cnn, do_ocr_single_class_cnn

    Predecessors
    ------------
    read_ocr_class_cnn
    """
    with HalconOperator(2056) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_knn(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify multiple characters with an k-NN classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the k-NN.

    confidence : Sequence[float]
                 Confidence of the class of the characters.

    See Also
    --------
    create_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    do_ocr_single_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(658) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_knn_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Tuple[str, float]:
    """
    Classify multiple characters with an k-NN classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    Returns
    -------

    class_val : str
                Result of classifying the characters with the k-NN.

    confidence : float
                 Confidence of the class of the characters.

    See Also
    --------
    create_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    do_ocr_single_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(658) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_mlp(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify multiple characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the MLP.

    confidence : Sequence[float]
                 Confidence of the class of the characters.

    See Also
    --------
    create_ocr_class_mlp, classify_class_mlp

    Alternatives
    ------------
    do_ocr_word_mlp, do_ocr_single_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp, read_ocr_class_mlp
    """
    with HalconOperator(698) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_mlp_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Tuple[str, float]:
    """
    Classify multiple characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    class_val : str
                Result of classifying the characters with the MLP.

    confidence : float
                 Confidence of the class of the characters.

    See Also
    --------
    create_ocr_class_mlp, classify_class_mlp

    Alternatives
    ------------
    do_ocr_word_mlp, do_ocr_single_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp, read_ocr_class_mlp
    """
    with HalconOperator(698) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_multi_class_svm(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> Sequence[str]:
    """
    Classify multiple characters with an SVM-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the SVM.

    See Also
    --------
    create_ocr_class_svm, classify_class_svm

    Alternatives
    ------------
    do_ocr_single_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, read_ocr_class_svm
    """
    with HalconOperator(680) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_m(0)
        return class_val  # type: ignore


def do_ocr_multi_class_svm_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle
) -> str:
    """
    Classify multiple characters with an SVM-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    class_val : str
                Result of classifying the characters with the SVM.

    See Also
    --------
    create_ocr_class_svm, classify_class_svm

    Alternatives
    ------------
    do_ocr_single_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, read_ocr_class_svm
    """
    with HalconOperator(680) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_s(0)
        return class_val  # type: ignore


def do_ocr_multi_s(
    character: HObject,
    image: HObject,
    ocr_handle: HHandle
) -> Tuple[str, float]:
    """
    Classify characters.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values for the characters.

    ocr_handle : HHandle
                 ID of the OCR classifier.

    Returns
    -------

    class_val : str
                Class (name) of the characters.

    confidence : float
                 Confidence values of the characters.

    See Also
    --------
    write_ocr

    Alternatives
    ------------
    do_ocr_single

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box, read_ocr, connection,
    sort_region

    Warnings
    --------
    do_ocr_multi is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.
    """
    with HalconOperator(714) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocr_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_single(
    character: HObject,
    image: HObject,
    ocr_handle: HHandle
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify one character.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the characters.

    ocr_handle : HHandle
                 ID of the OCR classifier.

    Returns
    -------

    classes : Sequence[str]
              Classes (names) of the characters.

    confidences : Sequence[float]
                  Confidence values of the characters.

    See Also
    --------
    write_ocr

    Alternatives
    ------------
    do_ocr_multi

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box, read_ocr, connection,
    sort_region

    Warnings
    --------
    do_ocr_single is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.
    """
    with HalconOperator(713) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocr_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # classes
            proc.get_output_tuple_m(1)   # confidences
        )  # type: ignore


def do_ocr_single_class_cnn(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num: Sequence[int]
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify a single character with an CNN-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the character with the CNN.

    confidence : Sequence[float]
                 Confidence(s) of the class(es) of the character.

    Alternatives
    ------------
    do_ocr_multi_class_cnn

    Predecessors
    ------------
    read_ocr_class_cnn
    """
    with HalconOperator(2057) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_single_class_cnn_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num: Sequence[int]
) -> Tuple[str, float]:
    """
    Classify a single character with an CNN-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : str
                Result of classifying the character with the CNN.

    confidence : float
                 Confidence(s) of the class(es) of the character.

    Alternatives
    ------------
    do_ocr_multi_class_cnn

    Predecessors
    ------------
    read_ocr_class_cnn
    """
    with HalconOperator(2057) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_single_class_knn(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num_classes: Sequence[int],
    num_neighbors: Sequence[int]
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify a single character with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    num_classes : Sequence[int]
                  Number of maximal classes to determine.
                  Value Suggestion: 1

    num_neighbors : Sequence[int]
                    Number of neighbors to consider.
                    Value Suggestion: 1

    Returns
    -------

    class_val : Sequence[str]
                Results of classifying the character with the k-NN.

    confidence : Sequence[float]
                 Confidence(s) of the class(es) of the character.

    See Also
    --------
    create_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    do_ocr_multi_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(659) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num_classes)
        proc.set_input_tuple(2, num_neighbors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_single_class_knn_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num_classes: Sequence[int],
    num_neighbors: Sequence[int]
) -> Tuple[str, float]:
    """
    Classify a single character with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    num_classes : Sequence[int]
                  Number of maximal classes to determine.
                  Value Suggestion: 1

    num_neighbors : Sequence[int]
                    Number of neighbors to consider.
                    Value Suggestion: 1

    Returns
    -------

    class_val : str
                Results of classifying the character with the k-NN.

    confidence : float
                 Confidence(s) of the class(es) of the character.

    See Also
    --------
    create_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    do_ocr_multi_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(659) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num_classes)
        proc.set_input_tuple(2, num_neighbors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_single_class_mlp(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num: Sequence[int]
) -> Tuple[Sequence[str], Sequence[float]]:
    """
    Classify a single character with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the character with the MLP.

    confidence : Sequence[float]
                 Confidence(s) of the class(es) of the character.

    See Also
    --------
    create_ocr_class_mlp, classify_class_mlp

    Alternatives
    ------------
    do_ocr_multi_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp, read_ocr_class_mlp
    """
    with HalconOperator(699) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1)   # confidence
        )  # type: ignore


def do_ocr_single_class_mlp_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num: Sequence[int]
) -> Tuple[str, float]:
    """
    Classify a single character with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : str
                Result of classifying the character with the MLP.

    confidence : float
                 Confidence(s) of the class(es) of the character.

    See Also
    --------
    create_ocr_class_mlp, classify_class_mlp

    Alternatives
    ------------
    do_ocr_multi_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp, read_ocr_class_mlp
    """
    with HalconOperator(699) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1)   # confidence
        )  # type: ignore


def do_ocr_single_class_svm(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num: Sequence[int]
) -> Sequence[str]:
    """
    Classify a single character with an SVM-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the character with the SVM.

    See Also
    --------
    create_ocr_class_svm, classify_class_svm

    Alternatives
    ------------
    do_ocr_multi_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, read_ocr_class_svm
    """
    with HalconOperator(681) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_m(0)
        return class_val  # type: ignore


def do_ocr_single_class_svm_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    num: Sequence[int]
) -> str:
    """
    Classify a single character with an SVM-based OCR classifier.

    Parameters
    ----------

    character : HObject
                Character to be recognized.

    image : HObject
            Gray values of the character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    num : Sequence[int]
          Number of best classes to determine.
          Value Suggestion: 1

    Returns
    -------

    class_val : str
                Result of classifying the character with the SVM.

    See Also
    --------
    create_ocr_class_svm, classify_class_svm

    Alternatives
    ------------
    do_ocr_multi_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, read_ocr_class_svm
    """
    with HalconOperator(681) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, num)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_s(0)
        return class_val  # type: ignore


def do_ocr_word_cnn(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[Sequence[str], Sequence[float], str, float]:
    """
    Classify a related group of characters with an CNN-based OCR
    classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the CNN.

    confidence : Sequence[float]
                 Confidence of the class of the characters.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    Alternatives
    ------------
    do_ocr_multi_class_cnn

    Predecessors
    ------------
    read_ocr_class_cnn
    """
    with HalconOperator(2058) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1),  # confidence
            proc.get_output_tuple_s(2),  # word
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def do_ocr_word_cnn_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[str, float, str, float]:
    """
    Classify a related group of characters with an CNN-based OCR
    classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : str
                Result of classifying the characters with the CNN.

    confidence : float
                 Confidence of the class of the characters.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    Alternatives
    ------------
    do_ocr_multi_class_cnn

    Predecessors
    ------------
    read_ocr_class_cnn
    """
    with HalconOperator(2058) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1),  # confidence
            proc.get_output_tuple_s(2),  # word
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def do_ocr_word_knn(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[Sequence[str], Sequence[float], str, float]:
    """
    Classify a related group of characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the k-NN.

    confidence : Sequence[float]
                 Confidence of the class of the characters.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    See Also
    --------
    create_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    do_ocr_multi_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(647) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1),  # confidence
            proc.get_output_tuple_s(2),  # word
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def do_ocr_word_knn_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[str, float, str, float]:
    """
    Classify a related group of characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : str
                Result of classifying the characters with the k-NN.

    confidence : float
                 Confidence of the class of the characters.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    See Also
    --------
    create_ocr_class_knn, classify_class_knn

    Alternatives
    ------------
    do_ocr_multi_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(647) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1),  # confidence
            proc.get_output_tuple_s(2),  # word
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def do_ocr_word_mlp(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[Sequence[str], Sequence[float], str, float]:
    """
    Classify a related group of characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the MLP.

    confidence : Sequence[float]
                 Confidence of the class of the characters.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    See Also
    --------
    create_ocr_class_mlp, classify_class_mlp

    Alternatives
    ------------
    do_ocr_multi_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp, read_ocr_class_mlp
    """
    with HalconOperator(697) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_m(1),  # confidence
            proc.get_output_tuple_s(2),  # word
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def do_ocr_word_mlp_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[str, float, str, float]:
    """
    Classify a related group of characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : str
                Result of classifying the characters with the MLP.

    confidence : float
                 Confidence of the class of the characters.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    See Also
    --------
    create_ocr_class_mlp, classify_class_mlp

    Alternatives
    ------------
    do_ocr_multi_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp, read_ocr_class_mlp
    """
    with HalconOperator(697) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1),  # confidence
            proc.get_output_tuple_s(2),  # word
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def do_ocr_word_svm(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[Sequence[str], str, float]:
    """
    Classify a related group of characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : Sequence[str]
                Result of classifying the characters with the SVM.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    See Also
    --------
    create_ocr_class_svm, classify_class_svm

    Alternatives
    ------------
    do_ocr_multi_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, read_ocr_class_svm
    """
    with HalconOperator(679) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_val
            proc.get_output_tuple_s(1),  # word
            proc.get_output_tuple_s(2)   # score
        )  # type: ignore


def do_ocr_word_svm_s(
    character: HObject,
    image: HObject,
    ocrhandle: HHandle,
    expression: str,
    num_alternatives: int,
    num_corrections: int
) -> Tuple[str, str, float]:
    """
    Classify a related group of characters with an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be recognized.

    image : HObject
            Gray values of the characters.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    expression : str
                 Expression describing the allowed word structure.

    num_alternatives : int
                       Number of classes per character considered for the
                       internal word correction.
                       Value Suggestion: 3

    num_corrections : int
                      Maximum number of corrected characters.
                      Value Suggestion: 2

    Returns
    -------

    class_val : str
                Result of classifying the characters with the SVM.

    word : str
           Word text after classification and correction.

    score : float
            Measure of similarity between corrected word and uncorrected
            classification results.

    See Also
    --------
    create_ocr_class_svm, classify_class_svm

    Alternatives
    ------------
    do_ocr_multi_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, read_ocr_class_svm
    """
    with HalconOperator(679) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, num_alternatives)
        proc.set_input_tuple(3, num_corrections)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # class_val
            proc.get_output_tuple_s(1),  # word
            proc.get_output_tuple_s(2)   # score
        )  # type: ignore


def do_ocv_simple(
    pattern: HObject,
    ocvhandle: HHandle,
    pattern_name: MaybeSequence[str],
    adapt_pos: str,
    adapt_size: str,
    adapt_angle: str,
    adapt_gray: str,
    threshold: float
) -> Sequence[float]:
    """
    Verification of a pattern using an OCV tool.

    Parameters
    ----------

    pattern : HObject
              Characters to be verified.

    ocvhandle : HHandle
                Handle of the OCV tool.

    pattern_name : MaybeSequence[str]
                   Name of the character.
                   Value Suggestion: 'a'

    adapt_pos : str
                Adaption to vertical and horizontal translation.
                Value Suggestion: 'true'

    adapt_size : str
                 Adaption to vertical and horizontal scaling of the size.
                 Value Suggestion: true

    adapt_angle : str
                  Adaption to changes of the orientation (not implemented).
                  Value Suggestion: false

    adapt_gray : str
                 Adaption to additive and scaling gray value changes.
                 Value Suggestion: true

    threshold : float
                Minimum difference between objects.
                Value Suggestion: 10

    Returns
    -------

    quality : Sequence[float]
              Evaluation of the character.

    See Also
    --------
    create_ocv_proj

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box, read_ocv, threshold,
    connection, select_shape

    Successors
    ----------
    close_ocv
    """
    with HalconOperator(638) as proc:
        proc.set_input_object(1, pattern)
        proc.set_input_tuple(0, ocvhandle)
        proc.set_input_tuple(1, pattern_name)
        proc.set_input_tuple(2, adapt_pos)
        proc.set_input_tuple(3, adapt_size)
        proc.set_input_tuple(4, adapt_angle)
        proc.set_input_tuple(5, adapt_gray)
        proc.set_input_tuple(6, threshold)
        proc.init_oct(0)
        proc.execute()
        quality = proc.get_output_tuple_m(0)
        return quality  # type: ignore


def do_ocv_simple_s(
    pattern: HObject,
    ocvhandle: HHandle,
    pattern_name: MaybeSequence[str],
    adapt_pos: str,
    adapt_size: str,
    adapt_angle: str,
    adapt_gray: str,
    threshold: float
) -> float:
    """
    Verification of a pattern using an OCV tool.

    Parameters
    ----------

    pattern : HObject
              Characters to be verified.

    ocvhandle : HHandle
                Handle of the OCV tool.

    pattern_name : MaybeSequence[str]
                   Name of the character.
                   Value Suggestion: 'a'

    adapt_pos : str
                Adaption to vertical and horizontal translation.
                Value Suggestion: 'true'

    adapt_size : str
                 Adaption to vertical and horizontal scaling of the size.
                 Value Suggestion: true

    adapt_angle : str
                  Adaption to changes of the orientation (not implemented).
                  Value Suggestion: false

    adapt_gray : str
                 Adaption to additive and scaling gray value changes.
                 Value Suggestion: true

    threshold : float
                Minimum difference between objects.
                Value Suggestion: 10

    Returns
    -------

    quality : float
              Evaluation of the character.

    See Also
    --------
    create_ocv_proj

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box, read_ocv, threshold,
    connection, select_shape

    Successors
    ----------
    close_ocv
    """
    with HalconOperator(638) as proc:
        proc.set_input_object(1, pattern)
        proc.set_input_tuple(0, ocvhandle)
        proc.set_input_tuple(1, pattern_name)
        proc.set_input_tuple(2, adapt_pos)
        proc.set_input_tuple(3, adapt_size)
        proc.set_input_tuple(4, adapt_angle)
        proc.set_input_tuple(5, adapt_gray)
        proc.set_input_tuple(6, threshold)
        proc.init_oct(0)
        proc.execute()
        quality = proc.get_output_tuple_s(0)
        return quality  # type: ignore


def dots_image(
    image: HObject,
    diameter: int,
    filter_type: str,
    pixel_shift: int
) -> HObject:
    """
    Enhance circular dots in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    diameter : int
               Diameter of the dots to be enhanced.
               Value Suggestion: 5

    filter_type : str
                  Enhance dark, light, or all dots.
                  Value Suggestion: light

    pixel_shift : int
                  Shift of the filter response.
                  Value Suggestion: 0

    Returns
    -------

    dot_image : HObject
                Output image.

    Alternatives
    ------------
    laplace, laplace_of_gauss, diff_of_gauss, derivate_gauss, convol_image

    Successors
    ----------
    threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1430) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, diameter)
        proc.set_input_tuple(1, filter_type)
        proc.set_input_tuple(2, pixel_shift)
        proc.execute()
        dot_image = HObject(proc.get_output_object_key(1))
        return dot_image  # type: ignore


def drag_region1(
    source_region: HObject,
    window_handle: HHandle
) -> HObject:
    """
    Interactive moving of a region.

    Parameters
    ----------

    source_region : HObject
                    Regions to move.

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    destination_region : HObject
                         Moved Regions.

    See Also
    --------
    set_insert, set_draw, affine_trans_image

    Alternatives
    ------------
    get_mposition, move_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.

    Notes
    -----
    Gray values of regions are not moved. With moving the input region it
    is not sure whether the gray values of the output regions are filled
    reasonable. This may occur if the gray values of the input regions do
    not comprise the whole image.
    """
    with HalconOperator(1317) as proc:
        proc.set_input_object(1, source_region)
        proc.set_input_tuple(0, window_handle)
        proc.execute()
        destination_region = HObject(proc.get_output_object_key(1))
        return destination_region  # type: ignore


def drag_region2(
    source_region: HObject,
    window_handle: HHandle,
    row: int,
    column: int
) -> HObject:
    """
    Interactive movement of a region with fixpoint specification.

    Parameters
    ----------

    source_region : HObject
                    Regions to move.

    window_handle : HHandle
                    Window handle.

    row : int
          Row index of the reference point.
          Value Suggestion: 100

    column : int
             Column index of the reference point.
             Value Suggestion: 100

    Returns
    -------

    destination_region : HObject
                         Moved regions.

    See Also
    --------
    set_insert, set_draw, affine_trans_image

    Alternatives
    ------------
    get_mposition, move_region, drag_region1, drag_region3

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert, affine_trans_image

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.

    Notes
    -----
    Gray values of the regions are not moved. With moving the input region
    it is not sure whether the gray values of the output regions are
    filled reasonable. This may occur if the gray values of the input
    regions do not comprise the whole image.
    """
    with HalconOperator(1316) as proc:
        proc.set_input_object(1, source_region)
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()
        destination_region = HObject(proc.get_output_object_key(1))
        return destination_region  # type: ignore


def drag_region3(
    source_region: HObject,
    mask_region: HObject,
    window_handle: HHandle,
    row: int,
    column: int
) -> HObject:
    """
    Interactive movement of a region with restriction of positions.

    Parameters
    ----------

    source_region : HObject
                    Regions to move.

    mask_region : HObject
                  Points on which it is allowed for a region to move.

    window_handle : HHandle
                    Window handle.

    row : int
          Row index of the reference point.
          Value Suggestion: 100

    column : int
             Column index of the reference point.
             Value Suggestion: 100

    Returns
    -------

    destination_region : HObject
                         Moved regions.

    See Also
    --------
    set_insert, set_draw, affine_trans_image

    Alternatives
    ------------
    get_mposition, move_region, drag_region1, drag_region2

    Predecessors
    ------------
    open_window, get_mposition

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert, affine_trans_image

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.

    Notes
    -----
    The region's gray values are not moved. With moving the input region
    it is not sure whether the gray values of the output regions are
    filled reasonable. This may occur if the gray values of the input
    regions do not comprise the whole image.
    """
    with HalconOperator(1315) as proc:
        proc.set_input_object(1, source_region)
        proc.set_input_object(2, mask_region)
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()
        destination_region = HObject(proc.get_output_object_key(1))
        return destination_region  # type: ignore


def draw_circle(window_handle: HHandle) -> Tuple[float, float, float]:
    """
    Interactive drawing of a circle.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : float
          Barycenter's row index.

    column : float
             Barycenter's column index.

    radius : float
             Circle's radius.

    See Also
    --------
    gen_circle, draw_rectangle1, draw_rectangle2, draw_polygon, set_insert

    Alternatives
    ------------
    draw_circle_mod, draw_ellipse, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1335) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # radius
        )  # type: ignore


def draw_circle_mod(
    window_handle: HHandle,
    row_in: float,
    column_in: float,
    radius_in: float
) -> Tuple[float, float, float]:
    """
    Interactive drawing of a circle.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_in : float
             Row index of the center.

    column_in : float
                Column index of the center.

    radius_in : float
                Radius of the circle.

    Returns
    -------

    row : float
          Row index of the center.

    column : float
             Column index of the center.

    radius : float
             Circle's radius.

    See Also
    --------
    gen_circle, draw_rectangle1, draw_rectangle2, draw_polygon, set_insert

    Alternatives
    ------------
    draw_circle, draw_ellipse, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1334) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_in)
        proc.set_input_tuple(2, column_in)
        proc.set_input_tuple(3, radius_in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # radius
        )  # type: ignore


def draw_ellipse(
    window_handle: HHandle
) -> Tuple[float, float, float, float, float]:
    """
    Interactive drawing of an ellipse.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : float
          Row index of the center.

    column : float
             Column index of the center.

    phi : float
          Orientation of the first half axis in radians.

    radius_1 : float
               First half axis.

    radius_2 : float
               Second half axis.

    See Also
    --------
    gen_ellipse, draw_rectangle1, draw_rectangle2, draw_polygon, set_insert

    Alternatives
    ------------
    draw_ellipse_mod, draw_circle, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1333) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # radius_1
            proc.get_output_tuple_s(4)   # radius_2
        )  # type: ignore


def draw_ellipse_mod(
    window_handle: HHandle,
    row_in: float,
    column_in: float,
    phi_in: float,
    radius_1in: float,
    radius_2in: float
) -> Tuple[float, float, float, float, float]:
    """
    Interactive drawing of an ellipse.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_in : float
             Row index of the center.

    column_in : float
                Column index of the center.

    phi_in : float
             Orientation of the bigger half axis in radians.

    radius_1in : float
                 Bigger half axis.

    radius_2in : float
                 Smaller half axis.

    Returns
    -------

    row : float
          Row index of the center.

    column : float
             Column index of the center.

    phi : float
          Orientation of the first half axis in radians.

    radius_1 : float
               First half axis.

    radius_2 : float
               Second half axis.

    See Also
    --------
    gen_ellipse, draw_rectangle1, draw_rectangle2, draw_polygon, set_insert

    Alternatives
    ------------
    draw_ellipse, draw_circle, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1332) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_in)
        proc.set_input_tuple(2, column_in)
        proc.set_input_tuple(3, phi_in)
        proc.set_input_tuple(4, radius_1in)
        proc.set_input_tuple(5, radius_2in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # radius_1
            proc.get_output_tuple_s(4)   # radius_2
        )  # type: ignore


def draw_line(
    window_handle: HHandle
) -> Tuple[float, float, float, float]:
    """
    Draw a line.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row_1 : float
            Row index of the first point of the line.

    column_1 : float
               Column index of the first point of the line.

    row_2 : float
            Row index of the second point of the line.

    column_2 : float
               Column index of the second point of the line.

    See Also
    --------
    draw_line_mod, gen_rectangle1, draw_circle, draw_ellipse, set_insert

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_line, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1331) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def draw_line_mod(
    window_handle: HHandle,
    row_1in: float,
    column_1in: float,
    row_2in: float,
    column_2in: float
) -> Tuple[float, float, float, float]:
    """
    Draw a line.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1in : float
              Row index of the first point of the line.

    column_1in : float
                 Column index of the first point of the line.

    row_2in : float
              Row index of the second point of the line.

    column_2in : float
                 Column index of the second point of the line.

    Returns
    -------

    row_1 : float
            Row index of the first point of the line.

    column_1 : float
               Column index of the first point of the line.

    row_2 : float
            Row index of the second point of the line.

    column_2 : float
               Column index of the second point of the line.

    See Also
    --------
    gen_circle, draw_rectangle1, draw_rectangle2

    Alternatives
    ------------
    draw_line, draw_ellipse, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_line, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1330) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1in)
        proc.set_input_tuple(2, column_1in)
        proc.set_input_tuple(3, row_2in)
        proc.set_input_tuple(4, column_2in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def draw_nurbs(
    window_handle: HHandle,
    rotate: str,
    move: str,
    scale: str,
    keep_ratio: str,
    degree: int
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float]]:
    """
    Interactive drawing of a NURBS curve.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    rotate : str
             Enable rotation?
             Value Suggestion: true

    move : str
           Enable moving?
           Value Suggestion: true

    scale : str
            Enable scaling?
            Value Suggestion: true

    keep_ratio : str
                 Keep ratio while scaling?
                 Value Suggestion: true

    degree : int
             The degree $p$ of the NURBS curve. Reasonable values are 3 to
             25.
             Value Suggestion: 3
             Assertion: Degree >= 2

    Returns
    -------

    cont_out : HObject
               Contour approximating the NURBS curve.

    rows : Sequence[float]
           Row coordinates of the control polygon.

    cols : Sequence[float]
           Columns coordinates of the control polygon.

    weights : Sequence[float]
              Weight vector.

    See Also
    --------
    draw_nurbs_mod, draw_nurbs_interp, gen_contour_nurbs_xld

    Alternatives
    ------------
    draw_xld, draw_nurbs_interp

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_colored, set_line_width, set_draw, set_insert

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1321) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, rotate)
        proc.set_input_tuple(2, move)
        proc.set_input_tuple(3, scale)
        proc.set_input_tuple(4, keep_ratio)
        proc.set_input_tuple(5, degree)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # cont_out
            proc.get_output_tuple_m(0),  # rows
            proc.get_output_tuple_m(1),  # cols
            proc.get_output_tuple_m(2)   # weights
        )  # type: ignore


def draw_nurbs_interp(
    window_handle: HHandle,
    rotate: str,
    move: str,
    scale: str,
    keep_ratio: str,
    degree: int
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Interactive drawing of a NURBS curve using interpolation.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    rotate : str
             Enable rotation?
             Value Suggestion: true

    move : str
           Enable moving?
           Value Suggestion: true

    scale : str
            Enable scaling?
            Value Suggestion: true

    keep_ratio : str
                 Keep ratio while scaling?
                 Value Suggestion: true

    degree : int
             The degree $p$ of the NURBS curve. Reasonable values are 3 to
             5.
             Value Suggestion: 3
             Assertion: Degree >= 2 && Degree <= 9

    Returns
    -------

    cont_out : HObject
               Contour of the curve.

    control_rows : Sequence[float]
                   Row coordinates of the control polygon.

    control_cols : Sequence[float]
                   Column coordinates of the control polygon.

    knots : Sequence[float]
            Knot vector.

    rows : Sequence[float]
           Row coordinates of the points specified by the user.

    cols : Sequence[float]
           Column coordinates of the points specified by the user.

    tangents : Sequence[float]
               Tangents specified by the user.

    See Also
    --------
    draw_nurbs_interp_mod, draw_nurbs, gen_contour_nurbs_xld

    Alternatives
    ------------
    draw_xld, draw_nurbs

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_colored, set_line_width, set_draw, set_insert

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.

    Notes
    -----
    In contrast to draw_nurbs, each point specified by the user influences
    the whole curve. Thus, if one point is moved, the whole curve can and
    will change. To minimize this effects, it is recommended to use a
    small degree (3-5) and to place the points such that they are
    approximately equally spaced. In general, uneven degrees will perform
    slightly better than even degrees.
    """
    with HalconOperator(1319) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, rotate)
        proc.set_input_tuple(2, move)
        proc.set_input_tuple(3, scale)
        proc.set_input_tuple(4, keep_ratio)
        proc.set_input_tuple(5, degree)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # cont_out
            proc.get_output_tuple_m(0),  # control_rows
            proc.get_output_tuple_m(1),  # control_cols
            proc.get_output_tuple_m(2),  # knots
            proc.get_output_tuple_m(3),  # rows
            proc.get_output_tuple_m(4),  # cols
            proc.get_output_tuple_m(5)   # tangents
        )  # type: ignore


def draw_nurbs_interp_mod(
    window_handle: HHandle,
    rotate: str,
    move: str,
    scale: str,
    keep_ratio: str,
    edit: str,
    degree: int,
    rows_in: Sequence[float],
    cols_in: Sequence[float],
    tangents_in: Sequence[float]
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Interactive modification of a NURBS curve using interpolation.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    rotate : str
             Enable rotation?
             Value Suggestion: true

    move : str
           Enable moving?
           Value Suggestion: true

    scale : str
            Enable scaling?
            Value Suggestion: true

    keep_ratio : str
                 Keep ratio while scaling?
                 Value Suggestion: true

    edit : str
           Enable editing?
           Value Suggestion: true

    degree : int
             The degree $p$ of the NURBS curve. Reasonable values are 3 to
             5.
             Value Suggestion: 3
             Assertion: Degree >= 2 && Degree <= 9

    rows_in : Sequence[float]
              Row coordinates of the input interpolation points.

    cols_in : Sequence[float]
              Column coordinates of the input interpolation points.

    tangents_in : Sequence[float]
                  Input tangents.

    Returns
    -------

    cont_out : HObject
               Contour of the modified curve.

    control_rows : Sequence[float]
                   Row coordinates of the control polygon.

    control_cols : Sequence[float]
                   Column coordinates of the control polygon.

    knots : Sequence[float]
            Knot vector.

    rows : Sequence[float]
           Row coordinates of the points specified by the user.

    cols : Sequence[float]
           Column coordinates of the points specified by the user.

    tangents : Sequence[float]
               Tangents specified by the user.

    See Also
    --------
    draw_nurbs_interp, gen_contour_nurbs_xld

    Alternatives
    ------------
    draw_xld_mod, draw_nurbs_mod

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_colored, set_line_width, set_draw, set_insert

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.

    Notes
    -----
    In contrast to draw_nurbs, each point specified by the user influences
    the whole curve. Thus, if one point is moved, the whole curve can and
    will change. To minimize this effects, it is recommended to use a
    small degree (3-5) and to place the points such that they are
    approximately equally spaced. In general, uneven degrees will perform
    slightly better than even degrees.
    """
    with HalconOperator(1318) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, rotate)
        proc.set_input_tuple(2, move)
        proc.set_input_tuple(3, scale)
        proc.set_input_tuple(4, keep_ratio)
        proc.set_input_tuple(5, edit)
        proc.set_input_tuple(6, degree)
        proc.set_input_tuple(7, rows_in)
        proc.set_input_tuple(8, cols_in)
        proc.set_input_tuple(9, tangents_in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # cont_out
            proc.get_output_tuple_m(0),  # control_rows
            proc.get_output_tuple_m(1),  # control_cols
            proc.get_output_tuple_m(2),  # knots
            proc.get_output_tuple_m(3),  # rows
            proc.get_output_tuple_m(4),  # cols
            proc.get_output_tuple_m(5)   # tangents
        )  # type: ignore


def draw_nurbs_mod(
    window_handle: HHandle,
    rotate: str,
    move: str,
    scale: str,
    keep_ratio: str,
    edit: str,
    degree: int,
    rows_in: Sequence[float],
    cols_in: Sequence[float],
    weights_in: Sequence[float]
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float]]:
    """
    Interactive modification of a NURBS curve.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    rotate : str
             Enable rotation?
             Value Suggestion: true

    move : str
           Enable moving?
           Value Suggestion: true

    scale : str
            Enable scaling?
            Value Suggestion: true

    keep_ratio : str
                 Keep ratio while scaling?
                 Value Suggestion: true

    edit : str
           Enable editing?
           Value Suggestion: true

    degree : int
             The degree $p$ of the NURBS curve. Reasonable values are 3 to
             25.
             Value Suggestion: 3
             Assertion: Degree >= 2

    rows_in : Sequence[float]
              Row coordinates of the input control polygon.

    cols_in : Sequence[float]
              Column coordinates of the input control polygon.

    weights_in : Sequence[float]
                 Input weight vector.

    Returns
    -------

    cont_out : HObject
               Contour of the modified curve.

    rows : Sequence[float]
           Row coordinates of the control polygon.

    cols : Sequence[float]
           Columns coordinates of the control polygon.

    weights : Sequence[float]
              Weight vector.

    See Also
    --------
    draw_nurbs, draw_nurbs_interp, gen_contour_nurbs_xld

    Alternatives
    ------------
    draw_nurbs_interp_mod, draw_xld_mod

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_colored, set_line_width, set_draw, set_insert

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1320) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, rotate)
        proc.set_input_tuple(2, move)
        proc.set_input_tuple(3, scale)
        proc.set_input_tuple(4, keep_ratio)
        proc.set_input_tuple(5, edit)
        proc.set_input_tuple(6, degree)
        proc.set_input_tuple(7, rows_in)
        proc.set_input_tuple(8, cols_in)
        proc.set_input_tuple(9, weights_in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # cont_out
            proc.get_output_tuple_m(0),  # rows
            proc.get_output_tuple_m(1),  # cols
            proc.get_output_tuple_m(2)   # weights
        )  # type: ignore


def draw_point(window_handle: HHandle) -> Tuple[float, float]:
    """
    Draw a point.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : float
          Row index of the point.

    column : float
             Column index of the point.

    See Also
    --------
    draw_point_mod, draw_circle, draw_ellipse, set_insert

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_line, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1329) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def draw_point_mod(
    window_handle: HHandle,
    row_in: float,
    column_in: float
) -> Tuple[float, float]:
    """
    Draw a point.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_in : float
             Row index of the point.

    column_in : float
                Column index of the point.

    Returns
    -------

    row : float
          Row index of the point.

    column : float
             Column index of the point.

    See Also
    --------
    draw_point, draw_circle, draw_ellipse, set_insert

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_line, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1328) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_in)
        proc.set_input_tuple(2, column_in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def draw_polygon(window_handle: HHandle) -> HObject:
    """
    Interactive drawing of a polygon row.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    polygon_region : HObject
                     Region, which encompasses all painted points.

    See Also
    --------
    reduce_domain, fill_up, set_color

    Alternatives
    ------------
    draw_region, draw_circle, draw_rectangle1, draw_rectangle2, boundary

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw

    Notes
    -----
    The painted contour is not closed automatically, in particular it is
    not ``filled up'' either.
    Output object's gray values are not defined.
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1337) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()
        polygon_region = HObject(proc.get_output_object_key(1))
        return polygon_region  # type: ignore


def draw_rectangle1(
    window_handle: HHandle
) -> Tuple[float, float, float, float]:
    """
    Draw a rectangle parallel to the coordinate axis.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row_1 : float
            Row index of the left upper corner.

    column_1 : float
               Column index of the left upper corner.

    row_2 : float
            Row index of the right lower corner.

    column_2 : float
               Column index of the right lower corner.

    See Also
    --------
    gen_rectangle1, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle1_mod, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1327) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def draw_rectangle1_mod(
    window_handle: HHandle,
    row_1in: float,
    column_1in: float,
    row_2in: float,
    column_2in: float
) -> Tuple[float, float, float, float]:
    """
    Draw a rectangle parallel to the coordinate axis.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1in : float
              Row index of the left upper corner.

    column_1in : float
                 Column index of the left upper corner.

    row_2in : float
              Row index of the right lower corner.

    column_2in : float
                 Column index of the right lower corner.

    Returns
    -------

    row_1 : float
            Row index of the left upper corner.

    column_1 : float
               Column index of the left upper corner.

    row_2 : float
            Row index of the right lower corner.

    column_2 : float
               Column index of the right lower corner.

    See Also
    --------
    gen_rectangle1, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle1, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1326) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1in)
        proc.set_input_tuple(2, column_1in)
        proc.set_input_tuple(3, row_2in)
        proc.set_input_tuple(4, column_2in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def draw_rectangle2(
    window_handle: HHandle
) -> Tuple[float, float, float, float, float]:
    """
    Interactive drawing of any orientated rectangle.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : float
          Row index of the center.

    column : float
             Column index of the center.

    phi : float
          Orientation of the bigger half axis in radians.

    length_1 : float
               Bigger half axis.

    length_2 : float
               Smaller half axis.

    See Also
    --------
    gen_rectangle2, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle2_mod, draw_rectangle1, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1325) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # length_1
            proc.get_output_tuple_s(4)   # length_2
        )  # type: ignore


def draw_rectangle2_mod(
    window_handle: HHandle,
    row_in: float,
    column_in: float,
    phi_in: float,
    length_1in: float,
    length_2in: float
) -> Tuple[float, float, float, float, float]:
    """
    Interactive drawing of any orientated rectangle.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_in : float
             Row index of the center.

    column_in : float
                Column index of the center.

    phi_in : float
             Orientation of the bigger half axis in radians.

    length_1in : float
                 Bigger half axis.

    length_2in : float
                 Smaller half axis.

    Returns
    -------

    row : float
          Row index of the center.

    column : float
             Column index of the center.

    phi : float
          Orientation of the bigger half axis in radians.

    length_1 : float
               Bigger half axis.

    length_2 : float
               Smaller half axis.

    See Also
    --------
    gen_rectangle2, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle2, draw_rectangle1, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1324) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_in)
        proc.set_input_tuple(2, column_in)
        proc.set_input_tuple(3, phi_in)
        proc.set_input_tuple(4, length_1in)
        proc.set_input_tuple(5, length_2in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # length_1
            proc.get_output_tuple_s(4)   # length_2
        )  # type: ignore


def draw_region(window_handle: HHandle) -> HObject:
    """
    Interactive drawing of a closed region.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    region : HObject
             Interactive created region.

    See Also
    --------
    draw_polygon, reduce_domain, fill_up, set_color

    Alternatives
    ------------
    draw_circle, draw_ellipse, draw_rectangle1, draw_rectangle2

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw

    Notes
    -----
    The output object's gray values are not defined.
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1336) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def draw_xld(
    window_handle: HHandle,
    rotate: str,
    move: str,
    scale: str,
    keep_ratio: str
) -> HObject:
    """
    Interactive drawing of a contour.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    rotate : str
             Enable rotation?
             Value Suggestion: true

    move : str
           Enable moving?
           Value Suggestion: true

    scale : str
            Enable scaling?
            Value Suggestion: true

    keep_ratio : str
                 Keep ratio while scaling?
                 Value Suggestion: true

    Returns
    -------

    cont_out : HObject
               Modified contour.

    See Also
    --------
    gen_rectangle2, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle2, draw_rectangle1, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1323) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, rotate)
        proc.set_input_tuple(2, move)
        proc.set_input_tuple(3, scale)
        proc.set_input_tuple(4, keep_ratio)
        proc.execute()
        cont_out = HObject(proc.get_output_object_key(1))
        return cont_out  # type: ignore


def draw_xld_mod(
    cont_in: HObject,
    window_handle: HHandle,
    rotate: str,
    move: str,
    scale: str,
    keep_ratio: str,
    edit: str
) -> HObject:
    """
    Interactive modification of a contour.

    Parameters
    ----------

    cont_in : HObject
              Input contour.

    window_handle : HHandle
                    Window handle.

    rotate : str
             Enable rotation?
             Value Suggestion: true

    move : str
           Enable moving?
           Value Suggestion: true

    scale : str
            Enable scaling?
            Value Suggestion: true

    keep_ratio : str
                 Keep ratio while scaling?
                 Value Suggestion: true

    edit : str
           Enable editing?
           Value Suggestion: true

    Returns
    -------

    cont_out : HObject
               Modified contour.

    See Also
    --------
    gen_rectangle2, draw_circle, draw_ellipse, set_insert

    Alternatives
    ------------
    draw_rectangle2, draw_rectangle1, draw_rectangle2, draw_region

    Predecessors
    ------------
    open_window

    Successors
    ----------
    reduce_domain, disp_region, set_colored, set_line_width, set_draw,
    set_insert

    Notes
    -----
    If used in a buffer window, mouse events have to be supplied by the
    application, while the draw operator must be run in another thread.
    """
    with HalconOperator(1322) as proc:
        proc.set_input_object(1, cont_in)
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, rotate)
        proc.set_input_tuple(2, move)
        proc.set_input_tuple(3, scale)
        proc.set_input_tuple(4, keep_ratio)
        proc.set_input_tuple(5, edit)
        proc.execute()
        cont_out = HObject(proc.get_output_object_key(1))
        return cont_out  # type: ignore


def dual_quat_compose(
    dual_quaternion_left: Sequence[float],
    dual_quaternion_right: Sequence[float]
) -> Sequence[float]:
    """
    Multiply two dual quaternions.

    Parameters
    ----------

    dual_quaternion_left : Sequence[float]
                           Left dual quaternion.

    dual_quaternion_right : Sequence[float]
                            Right dual quaternion.

    Returns
    -------

    dual_quaternion_composed : Sequence[float]
                               Product of the dual quaternions.

    See Also
    --------
    dual_quat_interpolate, pose_to_dual_quat, dual_quat_normalize,
    dual_quat_conjugate, serialize_dual_quat, deserialize_dual_quat,
    dual_quat_trans_line_3d, quat_compose

    Alternatives
    ------------
    pose_compose, hom_mat3d_compose

    Predecessors
    ------------
    screw_to_dual_quat

    Successors
    ----------
    dual_quat_to_hom_mat3d, dual_quat_to_pose, dual_quat_to_screw
    """
    with HalconOperator(2059) as proc:
        proc.set_input_tuple(0, dual_quaternion_left)
        proc.set_input_tuple(1, dual_quaternion_right)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion_composed = proc.get_output_tuple_m(0)
        return dual_quaternion_composed  # type: ignore


def dual_quat_conjugate(
    dual_quaternion: Sequence[float]
) -> Sequence[float]:
    """
    Conjugate a dual quaternion.

    Parameters
    ----------

    dual_quaternion : Sequence[float]
                      Dual quaternion.

    Returns
    -------

    dual_quaternion_conjugate : Sequence[float]
                                Conjugate of the dual quaternion.

    See Also
    --------
    dual_quat_normalize, serialize_dual_quat, deserialize_dual_quat,
    dual_quat_trans_line_3d, quat_conjugate

    Alternatives
    ------------
    pose_invert, hom_mat3d_invert

    Predecessors
    ------------
    dual_quat_compose, pose_to_dual_quat, screw_to_dual_quat

    Successors
    ----------
    dual_quat_compose, dual_quat_to_hom_mat3d, dual_quat_to_screw,
    dual_quat_interpolate, dual_quat_to_pose
    """
    with HalconOperator(2060) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion_conjugate = proc.get_output_tuple_m(0)
        return dual_quaternion_conjugate  # type: ignore


def dual_quat_interpolate(
    dual_quaternion_start: Sequence[float],
    dual_quaternion_end: Sequence[float],
    interp_pos: MaybeSequence[float]
) -> Sequence[float]:
    """
    Interpolate two dual quaternions.

    Parameters
    ----------

    dual_quaternion_start : Sequence[float]
                            Dual quaternion as the start point of the
                            interpolation.

    dual_quaternion_end : Sequence[float]
                          Dual quaternion as the end point of the
                          interpolation.

    interp_pos : MaybeSequence[float]
                 Interpolation parameter.
                 Value Suggestion: 0.5

    Returns
    -------

    dual_quaternion_interpolated : Sequence[float]
                                   Interpolated dual quaternion.

    See Also
    --------
    dual_quat_compose, dual_quat_conjugate, serialize_dual_quat,
    deserialize_dual_quat, dual_quat_trans_line_3d, quat_interpolate

    Predecessors
    ------------
    pose_to_dual_quat, screw_to_dual_quat, dual_quat_normalize

    Successors
    ----------
    dual_quat_to_hom_mat3d, dual_quat_to_pose, dual_quat_to_screw
    """
    with HalconOperator(2061) as proc:
        proc.set_input_tuple(0, dual_quaternion_start)
        proc.set_input_tuple(1, dual_quaternion_end)
        proc.set_input_tuple(2, interp_pos)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion_interpolated = proc.get_output_tuple_m(0)
        return dual_quaternion_interpolated  # type: ignore


def dual_quat_normalize(
    dual_quaternion: Sequence[float]
) -> Sequence[float]:
    """
    Normalize a dual quaternion.

    Parameters
    ----------

    dual_quaternion : Sequence[float]
                      Unit dual quaternion.

    Returns
    -------

    dual_quaternion_normalized : Sequence[float]
                                 Normalized dual quaternion.

    See Also
    --------
    dual_quat_interpolate, pose_to_dual_quat, screw_to_dual_quat,
    dual_quat_to_screw, dual_quat_to_pose, dual_quat_conjugate,
    serialize_dual_quat, deserialize_dual_quat, dual_quat_trans_line_3d,
    quat_normalize

    Predecessors
    ------------
    dual_quat_compose

    Successors
    ----------
    dual_quat_to_hom_mat3d

    Notes
    -----
    If the norm of the real part of DualQuaternion is 0,
    dual_quat_normalize returns the error code 9310 (H_ERR_DQ_ZERO_NORM)
    because in this case no normalization is possible.
    """
    with HalconOperator(2062) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion_normalized = proc.get_output_tuple_m(0)
        return dual_quaternion_normalized  # type: ignore


def dual_quat_to_hom_mat3d(
    dual_quaternion: Sequence[float]
) -> Sequence[float]:
    """
    Convert a unit dual quaternion into a homogeneous transformation
    matrix.

    Parameters
    ----------

    dual_quaternion : Sequence[float]
                      Unit dual quaternion.

    Returns
    -------

    hom_mat_3d : Sequence[float]
                 Transformation matrix.

    See Also
    --------
    dual_quat_compose, pose_to_dual_quat, dual_quat_conjugate,
    serialize_dual_quat, deserialize_dual_quat, dual_quat_trans_line_3d,
    quat_to_hom_mat3d

    Alternatives
    ------------
    dual_quat_to_pose, dual_quat_to_screw

    Predecessors
    ------------
    screw_to_dual_quat, dual_quat_interpolate, dual_quat_compose,
    dual_quat_normalize

    Successors
    ----------
    affine_trans_point_3d

    Notes
    -----
    HomMat3D will only be a valid rigid transformation matrix if
    DualQuaternion is a unit dual quaternion.
    """
    with HalconOperator(2063) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3d = proc.get_output_tuple_m(0)
        return hom_mat_3d  # type: ignore


def dual_quat_to_pose(
    dual_quaternion: Sequence[float]
) -> Sequence[Union[float, int]]:
    """
    Convert a dual quaternion to a 3D pose.

    Parameters
    ----------

    dual_quaternion : Sequence[float]
                      Unit dual quaternion.

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose.

    See Also
    --------
    pose_to_dual_quat, dual_quat_normalize, serialize_dual_quat,
    deserialize_dual_quat, dual_quat_trans_line_3d, quat_to_pose

    Alternatives
    ------------
    dual_quat_to_screw, dual_quat_to_hom_mat3d

    Predecessors
    ------------
    dual_quat_compose, dual_quat_interpolate, screw_to_dual_quat,
    dual_quat_conjugate

    Successors
    ----------
    camera_calibration, hand_eye_calibration, write_pose, disp_caltab,
    sim_caltab

    Notes
    -----
    dual_quat_to_pose assumes that the input DualQuaternion is a unit dual
    quaternion, and hence represents a 3D rigid transformation. Otherwise
    the returned pose is not meaningful.
    """
    with HalconOperator(2064) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def dual_quat_to_screw(
    dual_quaternion: Sequence[float],
    screw_format: str
) -> Tuple[float, float, float, float, float, float, float, float]:
    """
    Convert a unit dual quaternion into a screw.

    Parameters
    ----------

    dual_quaternion : Sequence[float]
                      Unit dual quaternion.

    screw_format : str
                   Format of the screw parameters.
                   Value Suggestion: moment

    Returns
    -------

    axis_direction_x : float
                       X component of the direction vector of the screw
                       axis.

    axis_direction_y : float
                       Y component of the direction vector of the screw
                       axis.

    axis_direction_z : float
                       Z component of the direction vector of the screw
                       axis.

    axis_moment_or_point_x : float
                             X component of the moment vector or a point
                             on the screw axis.

    axis_moment_or_point_y : float
                             Y component of the moment vector or a point
                             on the screw axis.

    axis_moment_or_point_z : float
                             Z component of the moment vector or a point
                             on the screw axis.

    rotation : float
               Rotation angle in radians.

    translation : float
                  Translation.

    See Also
    --------
    pose_to_dual_quat, dual_quat_normalize, serialize_dual_quat,
    deserialize_dual_quat, dual_quat_trans_line_3d, screw_to_dual_quat

    Alternatives
    ------------
    dual_quat_to_pose, dual_quat_to_hom_mat3d

    Predecessors
    ------------
    dual_quat_compose, dual_quat_conjugate, dual_quat_interpolate

    Notes
    -----
    dual_quat_to_screw assumes that the input DualQuaternion is a unit
    dual quaternion, and hence represents a 3D rigid transformation.
    Otherwise the returned screw parameters are not meaningful. Further
    note that the screw axis for an identity transformation, i.e., no
    rotation and no translation, is undefined. In this case LL is
    arbitrarily set to (1,0,0)^T$(1,0,0)^T$.
    """
    with HalconOperator(2065) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.set_input_tuple(1, screw_format)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # axis_direction_x
            proc.get_output_tuple_s(1),  # axis_direction_y
            proc.get_output_tuple_s(2),  # axis_direction_z
            proc.get_output_tuple_s(3),  # axis_moment_or_point_x
            proc.get_output_tuple_s(4),  # axis_moment_or_point_y
            proc.get_output_tuple_s(5),  # axis_moment_or_point_z
            proc.get_output_tuple_s(6),  # rotation
            proc.get_output_tuple_s(7)   # translation
        )  # type: ignore


def dual_quat_trans_line_3d(
    dual_quaternion: Sequence[Union[float, int]],
    line_format: str,
    line_direction_x: MaybeSequence[Union[float, int]],
    line_direction_y: MaybeSequence[Union[float, int]],
    line_direction_z: MaybeSequence[Union[float, int]],
    line_moment_or_point_x: MaybeSequence[Union[float, int]],
    line_moment_or_point_y: MaybeSequence[Union[float, int]],
    line_moment_or_point_z: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]]]:
    """
    Transform a 3D line with a unit dual quaternion.

    Parameters
    ----------

    dual_quaternion : Sequence[Union[float, int]]
                      Unit dual quaternion representing the transformation.

    line_format : str
                  Format of the line parameters.
                  Value Suggestion: moment

    line_direction_x : MaybeSequence[Union[float, int]]
                       X component of the direction vector of the line.

    line_direction_y : MaybeSequence[Union[float, int]]
                       Y component of the direction vector of the line.

    line_direction_z : MaybeSequence[Union[float, int]]
                       Z component of the direction vector of the line.

    line_moment_or_point_x : MaybeSequence[Union[float, int]]
                             X component of the moment vector or a point
                             on the line.

    line_moment_or_point_y : MaybeSequence[Union[float, int]]
                             Y component of the moment vector or a point
                             on the line.

    line_moment_or_point_z : MaybeSequence[Union[float, int]]
                             Z component of the moment vector or a point
                             on the line.

    Returns
    -------

    trans_line_direction_x : Sequence[Union[float, int]]
                             X component of the direction vector of the
                             transformed line.

    trans_line_direction_y : Sequence[Union[float, int]]
                             Y component of the direction vector of the
                             transformed line.

    trans_line_direction_z : Sequence[Union[float, int]]
                             Z component of the direction vector of the
                             transformed line.

    trans_line_moment_or_point_x : Sequence[Union[float, int]]
                                   X component of the moment vector or a
                                   point on the transformed line.

    trans_line_moment_or_point_y : Sequence[Union[float, int]]
                                   Y component of the moment vector or a
                                   point on the transformed line.

    trans_line_moment_or_point_z : Sequence[Union[float, int]]
                                   Z component of the moment vector or a
                                   point on the transformed line.

    See Also
    --------
    dual_quat_to_hom_mat3d, dual_quat_to_screw, dual_quat_to_pose,
    dual_quat_normalize, serialize_dual_quat, deserialize_dual_quat,
    quat_rotate_point_3d

    Alternatives
    ------------
    affine_trans_point_3d

    Successors
    ----------
    dual_quat_compose, dual_quat_conjugate, pose_to_dual_quat

    Notes
    -----
    dual_quat_trans_line_3d returns meaningful results only if
    DualQuaternion is a unit dual quaternion and the length of  the line
    direction is 1.
    """
    with HalconOperator(2066) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.set_input_tuple(1, line_format)
        proc.set_input_tuple(2, line_direction_x)
        proc.set_input_tuple(3, line_direction_y)
        proc.set_input_tuple(4, line_direction_z)
        proc.set_input_tuple(5, line_moment_or_point_x)
        proc.set_input_tuple(6, line_moment_or_point_y)
        proc.set_input_tuple(7, line_moment_or_point_z)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # trans_line_direction_x
            proc.get_output_tuple_m(1),  # trans_line_direction_y
            proc.get_output_tuple_m(2),  # trans_line_direction_z
            proc.get_output_tuple_m(3),  # trans_line_moment_or_point_x
            proc.get_output_tuple_m(4),  # trans_line_moment_or_point_y
            proc.get_output_tuple_m(5)   # trans_line_moment_or_point_z
        )  # type: ignore


def dual_quat_trans_line_3d_s(
    dual_quaternion: Sequence[Union[float, int]],
    line_format: str,
    line_direction_x: MaybeSequence[Union[float, int]],
    line_direction_y: MaybeSequence[Union[float, int]],
    line_direction_z: MaybeSequence[Union[float, int]],
    line_moment_or_point_x: MaybeSequence[Union[float, int]],
    line_moment_or_point_y: MaybeSequence[Union[float, int]],
    line_moment_or_point_z: MaybeSequence[Union[float, int]]
) -> Tuple[Union[float, int], Union[float, int], Union[float, int], Union[float, int], Union[float, int], Union[float, int]]:
    """
    Transform a 3D line with a unit dual quaternion.

    Parameters
    ----------

    dual_quaternion : Sequence[Union[float, int]]
                      Unit dual quaternion representing the transformation.

    line_format : str
                  Format of the line parameters.
                  Value Suggestion: moment

    line_direction_x : MaybeSequence[Union[float, int]]
                       X component of the direction vector of the line.

    line_direction_y : MaybeSequence[Union[float, int]]
                       Y component of the direction vector of the line.

    line_direction_z : MaybeSequence[Union[float, int]]
                       Z component of the direction vector of the line.

    line_moment_or_point_x : MaybeSequence[Union[float, int]]
                             X component of the moment vector or a point
                             on the line.

    line_moment_or_point_y : MaybeSequence[Union[float, int]]
                             Y component of the moment vector or a point
                             on the line.

    line_moment_or_point_z : MaybeSequence[Union[float, int]]
                             Z component of the moment vector or a point
                             on the line.

    Returns
    -------

    trans_line_direction_x : Union[float, int]
                             X component of the direction vector of the
                             transformed line.

    trans_line_direction_y : Union[float, int]
                             Y component of the direction vector of the
                             transformed line.

    trans_line_direction_z : Union[float, int]
                             Z component of the direction vector of the
                             transformed line.

    trans_line_moment_or_point_x : Union[float, int]
                                   X component of the moment vector or a
                                   point on the transformed line.

    trans_line_moment_or_point_y : Union[float, int]
                                   Y component of the moment vector or a
                                   point on the transformed line.

    trans_line_moment_or_point_z : Union[float, int]
                                   Z component of the moment vector or a
                                   point on the transformed line.

    See Also
    --------
    dual_quat_to_hom_mat3d, dual_quat_to_screw, dual_quat_to_pose,
    dual_quat_normalize, serialize_dual_quat, deserialize_dual_quat,
    quat_rotate_point_3d

    Alternatives
    ------------
    affine_trans_point_3d

    Successors
    ----------
    dual_quat_compose, dual_quat_conjugate, pose_to_dual_quat

    Notes
    -----
    dual_quat_trans_line_3d returns meaningful results only if
    DualQuaternion is a unit dual quaternion and the length of  the line
    direction is 1.
    """
    with HalconOperator(2066) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.set_input_tuple(1, line_format)
        proc.set_input_tuple(2, line_direction_x)
        proc.set_input_tuple(3, line_direction_y)
        proc.set_input_tuple(4, line_direction_z)
        proc.set_input_tuple(5, line_moment_or_point_x)
        proc.set_input_tuple(6, line_moment_or_point_y)
        proc.set_input_tuple(7, line_moment_or_point_z)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # trans_line_direction_x
            proc.get_output_tuple_s(1),  # trans_line_direction_y
            proc.get_output_tuple_s(2),  # trans_line_direction_z
            proc.get_output_tuple_s(3),  # trans_line_moment_or_point_x
            proc.get_output_tuple_s(4),  # trans_line_moment_or_point_y
            proc.get_output_tuple_s(5)   # trans_line_moment_or_point_z
        )  # type: ignore


def dual_rank(
    image: HObject,
    mask_type: str,
    radius: int,
    mode_percent: int,
    margin: Union[int, float, str]
) -> HObject:
    """
    Opening, Median and Closing with circle or rectangle mask.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask_type : str
                Shape of the mask.
                Value Suggestion: circle

    radius : int
             Radius of the filter mask.
             Value Suggestion: 1

    mode_percent : int
                   Filter Mode: 0 corresponds to a gray value opening , 50
                   corresponds to a median and 100 to a gray values
                   closing.
                   Value Suggestion: 10

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_rank : HObject
                 Filtered Image.

    See Also
    --------
    gen_circle, gen_rectangle1, gray_erosion_rect, gray_dilation_rect,
    sigma_image

    Alternatives
    ------------
    rank_image, gray_closing, gray_opening, median_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, sub_image, regiongrowing

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1417) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_type)
        proc.set_input_tuple(1, radius)
        proc.set_input_tuple(2, mode_percent)
        proc.set_input_tuple(3, margin)
        proc.execute()
        image_rank = HObject(proc.get_output_object_key(1))
        return image_rank  # type: ignore


def dual_threshold(
    image: HObject,
    min_size: int,
    min_gray: float,
    threshold: float
) -> HObject:
    """
    Threshold operator for signed images.

    Parameters
    ----------

    image : HObject
            Input image.

    min_size : int
               Regions smaller than MinSize are suppressed.
               Value Suggestion: 20

    min_gray : float
               Regions whose maximum absolute gray value is smaller than
               MinGray are suppressed.
               Value Suggestion: 5.0
               Assertion: MinGray > 0

    threshold : float
                Regions that have a gray value smaller than Threshold (or
                larger than -Threshold) are suppressed.
                Value Suggestion: 2.0
                Assertion: Threshold >= 1 && Threshold <= MinGray

    Returns
    -------

    region_crossings : HObject
                       Positive and negative regions.

    See Also
    --------
    connection, select_shape, select_gray

    Alternatives
    ------------
    threshold, dyn_threshold, check_difference

    Predecessors
    ------------
    min_max_gray, sobel_amp, binomial_filter, gauss_filter, reduce_domain,
    diff_of_gauss, sub_image, derivate_gauss, laplace_of_gauss, laplace,
    expand_region

    Successors
    ----------
    connection, dilation1, erosion1, opening, closing, rank_region,
    shape_trans, skeleton
    """
    with HalconOperator(463) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, min_size)
        proc.set_input_tuple(1, min_gray)
        proc.set_input_tuple(2, threshold)
        proc.execute()
        region_crossings = HObject(proc.get_output_object_key(1))
        return region_crossings  # type: ignore


def dump_window(
    window_handle: HHandle,
    device: MaybeSequence[Union[str, int]],
    file_name: str
) -> None:
    """
    Write the window content to a file.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    device : MaybeSequence[Union[str, int]]
             Name of the target device or of the graphic format.
             Value Suggestion: postscript

    file_name : str
                File name (without extension).
                Value Suggestion: halcon_dump

    See Also
    --------
    open_window, set_system, dump_window_image

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    disp_region

    Successors
    ----------
    system_call

    Notes
    -----
    Under Unix-like systems, the graphics window must be completely
    visible on the root window, because otherwise the contents of the
    window cannot be read due to limitations in X Windows.  If larger
    graphical displays are to be written to a file, the window type
    'pixmap' can be used.
    """
    with HalconOperator(1185) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, device)
        proc.set_input_tuple(2, file_name)
        proc.execute()


def dump_window_image(window_handle: HHandle) -> HObject:
    """
    Write the window content in an image object.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    image : HObject
            Saved image.

    See Also
    --------
    open_window, set_system, dump_window

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width,
    disp_region

    Notes
    -----
    Under Unix-like systems, the graphics window must be completely
    visible on the root window, because otherwise the contents of the
    window cannot be read due to limitations in X Windows.
    """
    with HalconOperator(1184) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def dyn_threshold(
    orig_image: HObject,
    threshold_image: HObject,
    offset: Union[int, float],
    light_dark: str
) -> HObject:
    """
    Segment an image using a local threshold.

    Parameters
    ----------

    orig_image : HObject
                 Input image.

    threshold_image : HObject
                      Image containing the local thresholds.

    offset : Union[int, float]
             Offset applied to ThresholdImage.
             Value Suggestion: 5.0
             Assertion: -255 < Offset && Offset < 255

    light_dark : str
                 Extract light, dark or similar areas?
                 Value Suggestion: light

    Returns
    -------

    region_dyn_thresh : HObject
                        Segmented regions.

    See Also
    --------
    highpass_image, sub_image

    Alternatives
    ------------
    check_difference, threshold

    Predecessors
    ------------
    mean_image, smooth_image, binomial_filter, gauss_filter

    Successors
    ----------
    connection, select_shape, reduce_domain, select_gray, rank_region,
    dilation1, opening, erosion1

    Notes
    -----
    If Offset is chosen from  -1 to 1 $-1$ to $1$ usually a very noisy
    region is generated, requiring large storage. If Offset is chosen too
    large ($>$ 60, say) it may happen that no points fulfill the threshold
    condition (i.e., an empty region is returned).  If Offset is chosen
    too small ($<$ -60, say) it may happen that all points fulfill the
    threshold condition (i.e., a full region is returned).
    """
    with HalconOperator(452) as proc:
        proc.set_input_object(1, orig_image)
        proc.set_input_object(2, threshold_image)
        proc.set_input_tuple(0, offset)
        proc.set_input_tuple(1, light_dark)
        proc.execute()
        region_dyn_thresh = HObject(proc.get_output_object_key(1))
        return region_dyn_thresh  # type: ignore


def eccentricity(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Shape features derived from the ellipse parameters.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    anisometry : Sequence[float]
                 Shape feature (in case of a circle = 1.0).
                 Assertion: Anisometry >= 1.0

    bulkiness : Sequence[float]
                Calculated shape feature.

    structure_factor : Sequence[float]
                       Calculated shape feature.

    See Also
    --------
    elliptic_axis, moments_region_2nd, select_shape, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    It should be noted that, like for all region-moments-based operators,
    the region's pixels are regarded as mathematical, infinitely small
    points that are represented by the center of the pixels (see the
    documentation of elliptic_axis).  This can lead to non-empty regions
    that have Rb $=$ 0.  In these cases, the output features that require
    a division by Rb are set to 0.  In particular, regions that contain a
    single point or regions whose points lie exactly on a straight line
    (e.g., one pixel high horizontal regions or one pixel wide vertical
    regions) have an anisometry of 0.
    """
    with HalconOperator(1718) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # anisometry
            proc.get_output_tuple_m(1),  # bulkiness
            proc.get_output_tuple_m(2)   # structure_factor
        )  # type: ignore


def eccentricity_points_xld(xld: HObject) -> Sequence[float]:
    """
    Anisometry of contours or polygons treated as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    anisometry : Sequence[float]
                 Anisometry of the contours or polygons.
                 Assertion: Anisometry >= 1.0

    See Also
    --------
    elliptic_axis_points_xld, moments_region_2nd, select_shape_xld

    Alternatives
    ------------
    eccentricity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1670) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        anisometry = proc.get_output_tuple_m(0)
        return anisometry  # type: ignore


def eccentricity_points_xld_s(xld: HObject) -> float:
    """
    Anisometry of contours or polygons treated as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    anisometry : float
                 Anisometry of the contours or polygons.
                 Assertion: Anisometry >= 1.0

    See Also
    --------
    elliptic_axis_points_xld, moments_region_2nd, select_shape_xld

    Alternatives
    ------------
    eccentricity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1670) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        anisometry = proc.get_output_tuple_s(0)
        return anisometry  # type: ignore


def eccentricity_s(regions: HObject) -> Tuple[float, float, float]:
    """
    Shape features derived from the ellipse parameters.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    anisometry : float
                 Shape feature (in case of a circle = 1.0).
                 Assertion: Anisometry >= 1.0

    bulkiness : float
                Calculated shape feature.

    structure_factor : float
                       Calculated shape feature.

    See Also
    --------
    elliptic_axis, moments_region_2nd, select_shape, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    It should be noted that, like for all region-moments-based operators,
    the region's pixels are regarded as mathematical, infinitely small
    points that are represented by the center of the pixels (see the
    documentation of elliptic_axis).  This can lead to non-empty regions
    that have Rb $=$ 0.  In these cases, the output features that require
    a division by Rb are set to 0.  In particular, regions that contain a
    single point or regions whose points lie exactly on a straight line
    (e.g., one pixel high horizontal regions or one pixel wide vertical
    regions) have an anisometry of 0.
    """
    with HalconOperator(1718) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # anisometry
            proc.get_output_tuple_s(1),  # bulkiness
            proc.get_output_tuple_s(2)   # structure_factor
        )  # type: ignore


def eccentricity_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Shape features derived from the ellipse parameters of contours or
    polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    anisometry : Sequence[float]
                 Anisometry of the contours or polygons.
                 Assertion: Anisometry >= 1.0

    bulkiness : Sequence[float]
                Bulkiness of the contours or polygons.

    structure_factor : Sequence[float]
                       Structure factor of the contours or polygons.

    See Also
    --------
    elliptic_axis_xld, moments_region_2nd, select_shape_xld,
    area_center_xld

    Alternatives
    ------------
    eccentricity_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1680) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # anisometry
            proc.get_output_tuple_m(1),  # bulkiness
            proc.get_output_tuple_m(2)   # structure_factor
        )  # type: ignore


def eccentricity_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Shape features derived from the ellipse parameters of contours or
    polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    anisometry : float
                 Anisometry of the contours or polygons.
                 Assertion: Anisometry >= 1.0

    bulkiness : float
                Bulkiness of the contours or polygons.

    structure_factor : float
                       Structure factor of the contours or polygons.

    See Also
    --------
    elliptic_axis_xld, moments_region_2nd, select_shape_xld,
    area_center_xld

    Alternatives
    ------------
    eccentricity_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1680) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # anisometry
            proc.get_output_tuple_s(1),  # bulkiness
            proc.get_output_tuple_s(2)   # structure_factor
        )  # type: ignore


def edges_color(
    image: HObject,
    filter: str,
    alpha: float,
    nms: str,
    low: int,
    high: int
) -> Tuple[HObject, HObject]:
    """
    Extract color edges using Canny, Deriche, or Shen filters.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Edge operator to be applied.
             Value Suggestion: canny

    alpha : float
            Filter parameter: small values result in strong smoothing, and
            thus less detail (opposite for 'canny').
            Value Suggestion: 1.0
            Assertion: Alpha > 0.0

    nms : str
          Non-maximum suppression ('none', if not desired).
          Value Suggestion: nms

    low : int
          Lower threshold for the hysteresis threshold operation (negative
          if no thresholding is desired).
          Value Suggestion: 20
          Assertion: Low >= 1 || Low < 0

    high : int
           Upper threshold for the hysteresis threshold operation
           (negative if no thresholding is desired).
           Value Suggestion: 40
           Assertion: High >= 1 || High < 0 && High >= Low

    Returns
    -------

    ima_amp : HObject
              Edge amplitude (gradient magnitude) image.

    ima_dir : HObject
              Edge direction image.

    See Also
    --------
    edges_image, edges_sub_pix, info_edges, nonmax_suppression_amp,
    hysteresis_threshold

    Alternatives
    ------------
    edges_color_sub_pix

    Successors
    ----------
    threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1567) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, alpha)
        proc.set_input_tuple(2, nms)
        proc.set_input_tuple(3, low)
        proc.set_input_tuple(4, high)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # ima_amp
            HObject(proc.get_output_object_key(2))   # ima_dir
        )  # type: ignore


def edges_color_sub_pix(
    image: HObject,
    filter: str,
    alpha: float,
    low: Union[float, int],
    high: Union[float, int]
) -> HObject:
    """
    Extract subpixel precise color edges using Deriche, Shen, or Canny
    filters.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Edge operator to be applied.
             Value Suggestion: canny

    alpha : float
            Filter parameter: small values result in strong smoothing, and
            thus less detail (opposite for 'canny').
            Value Suggestion: 1.0
            Assertion: Alpha > 0.0

    low : Union[float, int]
          Lower threshold for the hysteresis threshold operation.
          Value Suggestion: 20
          Assertion: Low > 0

    high : Union[float, int]
           Upper threshold for the hysteresis threshold operation.
           Value Suggestion: 40
           Assertion: High > 0 && High >= Low

    Returns
    -------

    edges : HObject
            Extracted edges.

    See Also
    --------
    edges_image, edges_sub_pix, info_edges, hysteresis_threshold,
    lines_gauss, lines_facet

    Alternatives
    ------------
    edges_color

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1566) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, alpha)
        proc.set_input_tuple(2, low)
        proc.set_input_tuple(3, high)
        proc.execute()
        edges = HObject(proc.get_output_object_key(1))
        return edges  # type: ignore


def edges_image(
    image: HObject,
    filter: str,
    alpha: float,
    nms: str,
    low: Union[int, float],
    high: Union[int, float]
) -> Tuple[HObject, HObject]:
    """
    Extract edges using Deriche, Lanser, Shen, or Canny filters.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Edge operator to be applied.
             Value Suggestion: canny

    alpha : float
            Filter parameter: small values result in strong smoothing, and
            thus less detail (opposite for 'canny').
            Value Suggestion: 1.0
            Assertion: Alpha > 0.0

    nms : str
          Non-maximum suppression ('none', if not desired).
          Value Suggestion: nms

    low : Union[int, float]
          Lower threshold for the hysteresis threshold operation
          (negative, if no thresholding is desired).
          Value Suggestion: 20
          Assertion: Low > 1 || Low < 0

    high : Union[int, float]
           Upper threshold for the hysteresis threshold operation
           (negative, if no thresholding is desired).
           Value Suggestion: 40
           Assertion: High > 1 || High < 0 && High >= Low

    Returns
    -------

    ima_amp : HObject
              Edge amplitude (gradient magnitude) image.

    ima_dir : HObject
              Edge direction image.

    See Also
    --------
    info_edges, nonmax_suppression_amp, hysteresis_threshold,
    bandpass_image

    Alternatives
    ------------
    sobel_dir, frei_dir, kirsch_dir, prewitt_dir, robinson_dir

    Predecessors
    ------------
    info_edges

    Successors
    ----------
    threshold, hysteresis_threshold, close_edges_length

    Notes
    -----
    The OpenCL implementation of edges_image will generally compute
    results that differ somewhat from the CPU implementation.
    Since edges_image uses Gauss convolution internally for the 'canny'
    filter, the same limitations for OpenCL apply as for derivate_gauss:
    Alpha must be chosen small enough that the required filter mask is
    less than 129 pixels in size.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1569) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, alpha)
        proc.set_input_tuple(2, nms)
        proc.set_input_tuple(3, low)
        proc.set_input_tuple(4, high)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # ima_amp
            HObject(proc.get_output_object_key(2))   # ima_dir
        )  # type: ignore


def edges_object_model_3d(
    object_model_3d: HHandle,
    min_amplitude: Union[float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> HHandle:
    """
    Find edges in a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model whose edges should be
                      computed.

    min_amplitude : Union[float, int]
                    Edge threshold.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    object_model_3dedges : HHandle
                           3D object model containing the edges.

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    find_surface_model, find_surface_model_image,
    refine_surface_model_pose, refine_surface_model_pose_image
    """
    with HalconOperator(2067) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, min_amplitude)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dedges = proc.get_output_tuple_s(0)
        return object_model_3dedges  # type: ignore


def edges_sub_pix(
    image: HObject,
    filter: str,
    alpha: float,
    low: Union[int, float],
    high: Union[int, float]
) -> HObject:
    """
    Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny
    filters.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Edge operator to be applied.
             Value Suggestion: canny

    alpha : float
            Filter parameter: small values result in strong smoothing, and
            thus less detail (opposite for 'canny').
            Value Suggestion: 1.0
            Assertion: Alpha > 0.0

    low : Union[int, float]
          Lower threshold for the hysteresis threshold operation.
          Value Suggestion: 20
          Assertion: Low > 0

    high : Union[int, float]
           Upper threshold for the hysteresis threshold operation.
           Value Suggestion: 40
           Assertion: High > 0 && High >= Low

    Returns
    -------

    edges : HObject
            Extracted edges.

    See Also
    --------
    info_edges, hysteresis_threshold, bandpass_image, lines_gauss,
    lines_facet

    Alternatives
    ------------
    sobel_dir, frei_dir, kirsch_dir, prewitt_dir, robinson_dir, edges_image

    Successors
    ----------
    segment_contours_xld, gen_polygons_xld, select_shape_xld

    Notes
    -----
    Since edges_sub_pix uses Gauss convolution internally for the 'canny'
    filter, the same limitations for OpenCL apply as for derivate_gauss:
    Alpha must be chosen small enough that the required filter mask is
    less than 129 pixels in size. Also, edges_sub_pix is not available on
    OpenCL devices for HALCON XL, as double precision floating point
    arithmetic would be required, but OpenCL devices are optimized for
    single precision arithmetic.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1568) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, alpha)
        proc.set_input_tuple(2, low)
        proc.set_input_tuple(3, high)
        proc.execute()
        edges = HObject(proc.get_output_object_key(1))
        return edges  # type: ignore


def eigenvalues_general_matrix(
    matrix_id: HHandle,
    compute_eigenvectors: str
) -> Tuple[HHandle, HHandle, HHandle, HHandle]:
    """
    Compute the eigenvalues and optionally the eigenvectors of a general
    matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    compute_eigenvectors : str
                           Computation of the eigenvectors.
                           Value Suggestion: none

    Returns
    -------

    eigenvalues_real_id : HHandle
                          Matrix handle with the real parts of the
                          eigenvalues.

    eigenvalues_imag_id : HHandle
                          Matrix handle with the imaginary parts of the
                          eigenvalues.

    eigenvectors_real_id : HHandle
                           Matrix handle with the real parts of the
                           eigenvectors.

    eigenvectors_imag_id : HHandle
                           Matrix handle with the imaginary parts of the
                           eigenvectors.

    See Also
    --------
    eigenvalues_symmetric_matrix,
    generalized_eigenvalues_symmetric_matrix,
    generalized_eigenvalues_general_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix, get_diagonal_matrix
    """
    with HalconOperator(849) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, compute_eigenvectors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # eigenvalues_real_id
            proc.get_output_tuple_s(1),  # eigenvalues_imag_id
            proc.get_output_tuple_s(2),  # eigenvectors_real_id
            proc.get_output_tuple_s(3)   # eigenvectors_imag_id
        )  # type: ignore


def eigenvalues_symmetric_matrix(
    matrix_id: HHandle,
    compute_eigenvectors: str
) -> Tuple[HHandle, HHandle]:
    """
    Compute the eigenvalues and optionally eigenvectors of a symmetric
    matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    compute_eigenvectors : str
                           Computation of the eigenvectors.
                           Value Suggestion: false

    Returns
    -------

    eigenvalues_id : HHandle
                     Matrix handle with the eigenvalues.

    eigenvectors_id : HHandle
                      Matrix handle with the eigenvectors.

    See Also
    --------
    generalized_eigenvalues_symmetric_matrix,
    generalized_eigenvalues_general_matrix

    Alternatives
    ------------
    eigenvalues_general_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    The upper triangular part of the input Matrix must contain the
    relevant information of the matrix.  The strictly lower triangular
    part of the matrix is not referenced.  If the referenced part of the
    input Matrix is not of the specified type, an exception is raised.
    """
    with HalconOperator(850) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, compute_eigenvectors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # eigenvalues_id
            proc.get_output_tuple_s(1)   # eigenvectors_id
        )  # type: ignore


def eliminate_min_max(
    image: HObject,
    mask_width: int,
    mask_height: int,
    gap: float,
    mode: int
) -> HObject:
    """
    Smooth an image in the spatial domain to suppress noise.

    Parameters
    ----------

    image : HObject
            Image to smooth.

    mask_width : int
                 Width of filter mask.
                 Value Suggestion: 3
                 Assertion: odd(MaskWidth)

    mask_height : int
                  Height of filter mask.
                  Value Suggestion: 3
                  Assertion: odd(MaskWidth)

    gap : float
          Gap between local maximum/minimum and all other gray values of
          the neighborhood.
          Value Suggestion: 1.0

    mode : int
           Replacement rule (1 = next minimum/maximum, 2 = average, 3
           =median).
           Value Suggestion: 3

    Returns
    -------

    filtered_image : HObject
                     Smoothed image.

    See Also
    --------
    mean_sp, mean_image, median_image, median_weighted, binomial_filter,
    gauss_filter, smooth_image

    Successors
    ----------
    wiener_filter, wiener_filter_ni

    Notes
    -----
    eliminate_min_max only can work on byte images (HALCON image type
    BYTE_IMAGE). If MaskWidth or MaskHeight is an even number, it is
    replaced by the next higher odd number (this allows the unique
    extraction of the center of the filter mask). Width/height of the mask
    may not exceed the image width/height. Note that filter operators may
    return unexpected results if  an image with a reduced domain is used
    as input. Please refer to the  chapter Filters.
    """
    with HalconOperator(1423) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, gap)
        proc.set_input_tuple(3, mode)
        proc.execute()
        filtered_image = HObject(proc.get_output_object_key(1))
        return filtered_image  # type: ignore


def eliminate_runs(
    region: HObject,
    elim_shorter: int,
    elim_longer: int
) -> HObject:
    """
    Eliminate runs of a given length.

    Parameters
    ----------

    region : HObject
             Region to be clipped.

    elim_shorter : int
                   All runs which are shorter are eliminated.
                   Value Suggestion: 3

    elim_longer : int
                  All runs which are longer are eliminated.
                  Value Suggestion: 1000

    Returns
    -------

    region_clipped : HObject
                     Clipped regions.

    Alternatives
    ------------
    shape_trans

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    erosion1, dilation1, disp_region
    """
    with HalconOperator(514) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, elim_shorter)
        proc.set_input_tuple(1, elim_longer)
        proc.execute()
        region_clipped = HObject(proc.get_output_object_key(1))
        return region_clipped  # type: ignore


def eliminate_sp(
    image: HObject,
    mask_width: int,
    mask_height: int,
    min_thresh: int,
    max_thresh: int
) -> HObject:
    """
    Replace values outside of thresholds with average value.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_width : int
                 Width of filter mask.
                 Value Suggestion: 3
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    mask_height : int
                  Height of filter mask.
                  Value Suggestion: 3
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    min_thresh : int
                 Minimum gray value.
                 Value Suggestion: 1

    max_thresh : int
                 Maximum gray value.
                 Value Suggestion: 254
                 Assertion: MinThresh <= MaxThresh

    Returns
    -------

    image_fill_sp : HObject
                    Smoothed image.

    See Also
    --------
    binomial_filter, gauss_filter, smooth_image, anisotropic_diffusion,
    sigma_image, eliminate_min_max

    Alternatives
    ------------
    mean_sp, mean_image, median_image, eliminate_min_max

    Successors
    ----------
    disp_image

    Notes
    -----
    If even values instead of odd values are given for MaskHeight or
    MaskWidth, the routine uses the next larger odd values instead (this
    way the center of the filter mask is always explicitly determined).
    This operator may return unexpected results if an image with a
    reduced domain is used as input. Please refer to the chapter  Filters.
    """
    with HalconOperator(1427) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, min_thresh)
        proc.set_input_tuple(3, max_thresh)
        proc.execute()
        image_fill_sp = HObject(proc.get_output_object_key(1))
        return image_fill_sp  # type: ignore


def elliptic_axis(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the parameters of the equivalent ellipse.

    Parameters
    ----------

    regions : HObject
              Input regions.

    Returns
    -------

    ra : Sequence[float]
         Main radius (normalized to the area).
         Assertion: Ra >= 0.0

    rb : Sequence[float]
         Secondary radius (normalized to the area).
         Assertion: Rb >= 0.0 && Rb <= Ra

    phi : Sequence[float]
          Angle between main radius and x-axis in radians.
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    See Also
    --------
    moments_region_2nd, select_shape, set_shape

    Alternatives
    ------------
    smallest_rectangle2, orientation_region

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    gen_ellipse

    Notes
    -----
    It should be noted that, like for all region-moments-based operators,
    the region's pixels are regarded as mathematical, infinitely small
    points that are represented by the center of the pixels.  This means
    that Ra and Rb can assume the value 0.  In particular, for an empty
    region and a region containing a single point Ra $=$ Rb $=$ 0 is
    returned.  Furthermore, for regions whose points lie exactly on a
    straight line (e.g., one pixel high horizontal regions or one pixel
    wide vertical regions), Rb $=$ 0 is returned.
    """
    with HalconOperator(1721) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ra
            proc.get_output_tuple_m(1),  # rb
            proc.get_output_tuple_m(2)   # phi
        )  # type: ignore


def elliptic_axis_gray(
    regions: HObject,
    image: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the orientation and major axes of a region in a gray value
    image.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    image : HObject
            Gray value image.

    Returns
    -------

    ra : Sequence[float]
         Major axis of the region.

    rb : Sequence[float]
         Minor axis of the region.

    phi : Sequence[float]
          Angle enclosed by the major axis and the x-axis.

    See Also
    --------
    area_center_gray

    Alternatives
    ------------
    elliptic_axis

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    gen_ellipse

    Notes
    -----
    Note that the operator elliptic_axis_gray only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1763) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ra
            proc.get_output_tuple_m(1),  # rb
            proc.get_output_tuple_m(2)   # phi
        )  # type: ignore


def elliptic_axis_gray_s(
    regions: HObject,
    image: HObject
) -> Tuple[float, float, float]:
    """
    Compute the orientation and major axes of a region in a gray value
    image.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    image : HObject
            Gray value image.

    Returns
    -------

    ra : float
         Major axis of the region.

    rb : float
         Minor axis of the region.

    phi : float
          Angle enclosed by the major axis and the x-axis.

    See Also
    --------
    area_center_gray

    Alternatives
    ------------
    elliptic_axis

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    gen_ellipse

    Notes
    -----
    Note that the operator elliptic_axis_gray only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1763) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ra
            proc.get_output_tuple_s(1),  # rb
            proc.get_output_tuple_s(2)   # phi
        )  # type: ignore


def elliptic_axis_points_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Parameters of the equivalent ellipse of contours or polygons treated
    as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    ra : Sequence[float]
         Major radius.
         Assertion: Ra >= 0.0

    rb : Sequence[float]
         Minor radius.
         Assertion: Rb >= 0.0 && Rb <= Ra

    phi : Sequence[float]
          Angle between the major axis and the column axis (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    See Also
    --------
    moments_xld, smallest_circle_xld, smallest_rectangle1_xld,
    smallest_rectangle2_xld, shape_trans_xld

    Alternatives
    ------------
    elliptic_axis_xld, smallest_rectangle2

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Successors
    ----------
    area_center_points_xld, gen_ellipse_contour_xld
    """
    with HalconOperator(1671) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ra
            proc.get_output_tuple_m(1),  # rb
            proc.get_output_tuple_m(2)   # phi
        )  # type: ignore


def elliptic_axis_points_xld_s(
    xld: HObject
) -> Tuple[float, float, float]:
    """
    Parameters of the equivalent ellipse of contours or polygons treated
    as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    ra : float
         Major radius.
         Assertion: Ra >= 0.0

    rb : float
         Minor radius.
         Assertion: Rb >= 0.0 && Rb <= Ra

    phi : float
          Angle between the major axis and the column axis (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    See Also
    --------
    moments_xld, smallest_circle_xld, smallest_rectangle1_xld,
    smallest_rectangle2_xld, shape_trans_xld

    Alternatives
    ------------
    elliptic_axis_xld, smallest_rectangle2

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Successors
    ----------
    area_center_points_xld, gen_ellipse_contour_xld
    """
    with HalconOperator(1671) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ra
            proc.get_output_tuple_s(1),  # rb
            proc.get_output_tuple_s(2)   # phi
        )  # type: ignore


def elliptic_axis_s(regions: HObject) -> Tuple[float, float, float]:
    """
    Calculate the parameters of the equivalent ellipse.

    Parameters
    ----------

    regions : HObject
              Input regions.

    Returns
    -------

    ra : float
         Main radius (normalized to the area).
         Assertion: Ra >= 0.0

    rb : float
         Secondary radius (normalized to the area).
         Assertion: Rb >= 0.0 && Rb <= Ra

    phi : float
          Angle between main radius and x-axis in radians.
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    See Also
    --------
    moments_region_2nd, select_shape, set_shape

    Alternatives
    ------------
    smallest_rectangle2, orientation_region

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    gen_ellipse

    Notes
    -----
    It should be noted that, like for all region-moments-based operators,
    the region's pixels are regarded as mathematical, infinitely small
    points that are represented by the center of the pixels.  This means
    that Ra and Rb can assume the value 0.  In particular, for an empty
    region and a region containing a single point Ra $=$ Rb $=$ 0 is
    returned.  Furthermore, for regions whose points lie exactly on a
    straight line (e.g., one pixel high horizontal regions or one pixel
    wide vertical regions), Rb $=$ 0 is returned.
    """
    with HalconOperator(1721) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ra
            proc.get_output_tuple_s(1),  # rb
            proc.get_output_tuple_s(2)   # phi
        )  # type: ignore


def elliptic_axis_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Parameters of the equivalent ellipse of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    ra : Sequence[float]
         Major radius.
         Assertion: Ra >= 0.0

    rb : Sequence[float]
         Minor radius.
         Assertion: Rb >= 0.0 && Rb <= Ra

    phi : Sequence[float]
          Angle between the major axis and the x axis (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    See Also
    --------
    moments_xld, smallest_circle_xld, smallest_rectangle1_xld,
    smallest_rectangle2_xld, shape_trans_xld

    Alternatives
    ------------
    elliptic_axis_points_xld, smallest_rectangle2

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Successors
    ----------
    area_center_xld, gen_ellipse_contour_xld
    """
    with HalconOperator(1685) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ra
            proc.get_output_tuple_m(1),  # rb
            proc.get_output_tuple_m(2)   # phi
        )  # type: ignore


def elliptic_axis_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Parameters of the equivalent ellipse of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    ra : float
         Major radius.
         Assertion: Ra >= 0.0

    rb : float
         Minor radius.
         Assertion: Rb >= 0.0 && Rb <= Ra

    phi : float
          Angle between the major axis and the x axis (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    See Also
    --------
    moments_xld, smallest_circle_xld, smallest_rectangle1_xld,
    smallest_rectangle2_xld, shape_trans_xld

    Alternatives
    ------------
    elliptic_axis_points_xld, smallest_rectangle2

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Successors
    ----------
    area_center_xld, gen_ellipse_contour_xld
    """
    with HalconOperator(1685) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ra
            proc.get_output_tuple_s(1),  # rb
            proc.get_output_tuple_s(2)   # phi
        )  # type: ignore


def emphasize(
    image: HObject,
    mask_width: int,
    mask_height: int,
    factor: float
) -> HObject:
    """
    Enhance contrast of the image.

    Parameters
    ----------

    image : HObject
            Image to be enhanced.

    mask_width : int
                 Width of low pass mask.
                 Value Suggestion: 7

    mask_height : int
                  Height of the low pass mask.
                  Value Suggestion: 7

    factor : float
             Intensity of contrast emphasis.
             Value Suggestion: 1.0
             Assertion: 0 < Factor && Factor < 20

    Returns
    -------

    image_emphasize : HObject
                      contrast enhanced image.

    See Also
    --------
    mean_image, highpass_image

    Alternatives
    ------------
    mean_image, sub_image, laplace, add_image

    Successors
    ----------
    disp_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1550) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, factor)
        proc.execute()
        image_emphasize = HObject(proc.get_output_object_key(1))
        return image_emphasize  # type: ignore


def energy_gabor(
    image_gabor: HObject,
    image_hilbert: HObject
) -> HObject:
    """
    Calculate the energy of a two-channel image.

    Parameters
    ----------

    image_gabor : HObject
                  1st channel of input image (usually: Gabor image).

    image_hilbert : HObject
                    2nd channel of input image (usually: Hilbert image).

    Returns
    -------

    energy : HObject
             Image containing the local energy.

    Predecessors
    ------------
    gen_gabor, convol_gabor, fft_image_inv
    """
    with HalconOperator(1529) as proc:
        proc.set_input_object(1, image_gabor)
        proc.set_input_object(2, image_hilbert)
        proc.execute()
        energy = HObject(proc.get_output_object_key(1))
        return energy  # type: ignore


def enqueue_message(
    queue_handle: HHandle,
    message_handle: MaybeSequence[HHandle],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> None:
    """
    Enqueue one or more messages to the message queue.

    Parameters
    ----------

    queue_handle : HHandle
                   Message queue handle.
                   Assertion: QueueHandle != 0

    message_handle : MaybeSequence[HHandle]
                     Handle(s) of message(s) to be enqueued.
                     Assertion: MessageHandle != 0

    gen_param_name : Sequence[str]
                     Names of optional generic parameters.

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of optional generic parameters.

    See Also
    --------
    create_message_queue, clear_message_queue, dequeue_message,
    set_message_queue_param, get_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Predecessors
    ------------
    set_message_tuple, set_message_obj
    """
    with HalconOperator(531) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.set_input_tuple(1, message_handle)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def enquire_class_box(
    classif_handle: HHandle,
    feature_list: Sequence[Union[int, float, str]]
) -> int:
    """
    Classify a tuple of attributes.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    feature_list : Sequence[Union[int, float, str]]
                   Array of attributes which has to be classified.
                   Value Suggestion: 1.0

    Returns
    -------

    class_val : int
                Number of the class to which the array of attributes had
                been assigned.

    See Also
    --------
    test_sampset_box, learn_class_box, learn_sampset_box

    Alternatives
    ------------
    enquire_reject_class_box

    Predecessors
    ------------
    create_class_box, learn_class_box, set_class_box_param

    Successors
    ----------
    learn_class_box, write_class_box, close_class_box

    Warnings
    --------
    enquire_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1899) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, feature_list)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_s(0)
        return class_val  # type: ignore


def enquire_reject_class_box(
    classif_handle: HHandle,
    feature_list: Sequence[Union[int, float, str]]
) -> int:
    """
    Classify a tuple of attributes with rejection class.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    feature_list : Sequence[Union[int, float, str]]
                   Array of attributes which has to be classified.
                   Value Suggestion: 1.0

    Returns
    -------

    class_val : int
                Number of the class, to which the array of attributes had
                been assigned or -1 for the rejection class.

    See Also
    --------
    test_sampset_box, learn_class_box, learn_sampset_box

    Alternatives
    ------------
    enquire_class_box

    Predecessors
    ------------
    create_class_box, learn_class_box, set_class_box_param

    Successors
    ----------
    learn_class_box, write_class_box, close_class_box

    Warnings
    --------
    enquire_reject_class_box is obsolete and is only provided for reasons
    of backward compatibility. New applications should use the  MLP, SVM,
    KNN or GMM operators instead.
    """
    with HalconOperator(1898) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, feature_list)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_s(0)
        return class_val  # type: ignore


def entropy_gray(
    regions: HObject,
    image: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Determine the entropy and anisotropy of images.

    Parameters
    ----------

    regions : HObject
              Regions where the features are to be determined.

    image : HObject
            Gray value image.

    Returns
    -------

    entropy : Sequence[float]
              Information content (entropy) of the gray values.
              Assertion: 0 <= Entropy && Entropy <= 8

    anisotropy : Sequence[float]
                 Measure of the symmetry of gray value distribution.

    See Also
    --------
    entropy_image, gray_histo, gray_histo_abs, fuzzy_entropy,
    fuzzy_perimeter

    Alternatives
    ------------
    select_gray

    Notes
    -----
    Note that the operator entropy_gray only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1757) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # entropy
            proc.get_output_tuple_m(1)   # anisotropy
        )  # type: ignore


def entropy_gray_s(
    regions: HObject,
    image: HObject
) -> Tuple[float, float]:
    """
    Determine the entropy and anisotropy of images.

    Parameters
    ----------

    regions : HObject
              Regions where the features are to be determined.

    image : HObject
            Gray value image.

    Returns
    -------

    entropy : float
              Information content (entropy) of the gray values.
              Assertion: 0 <= Entropy && Entropy <= 8

    anisotropy : float
                 Measure of the symmetry of gray value distribution.

    See Also
    --------
    entropy_image, gray_histo, gray_histo_abs, fuzzy_entropy,
    fuzzy_perimeter

    Alternatives
    ------------
    select_gray

    Notes
    -----
    Note that the operator entropy_gray only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1757) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # entropy
            proc.get_output_tuple_s(1)   # anisotropy
        )  # type: ignore


def entropy_image(image: HObject, width: int, height: int) -> HObject:
    """
    Calculate the entropy of gray values within a rectangular window.

    Parameters
    ----------

    image : HObject
            Image for which the entropy is to be calculated.

    width : int
            Width of the mask in which the entropy is calculated.
            Value Suggestion: 9
            Assertion: 3 <= Width && odd(Width)

    height : int
             Height of the mask in which the entropy is calculated.
             Value Suggestion: 9
             Assertion: 3 <= Height && odd(Height)

    Returns
    -------

    image_entropy : HObject
                    Entropy image.

    See Also
    --------
    energy_gabor, entropy_gray

    Alternatives
    ------------
    entropy_gray

    Successors
    ----------
    disp_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1404) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        image_entropy = HObject(proc.get_output_object_key(1))
        return image_entropy  # type: ignore


def equ_histo_image(image: HObject) -> HObject:
    """
    Histogram linearization of images

    Parameters
    ----------

    image : HObject
            Image to be enhanced.

    Returns
    -------

    image_equ_histo : HObject
                      Image with linearized gray values.

    See Also
    --------
    scale_image

    Alternatives
    ------------
    scale_image, scale_image_max, illuminate

    Successors
    ----------
    disp_image

    Notes
    -----
    The operator equ_histo_image primarily serves for optical processing
    of images for a human viewer. For example, the (local) contrast
    spreading can lead to a detection of fictitious edges.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1548) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_equ_histo = HObject(proc.get_output_object_key(1))
        return image_equ_histo  # type: ignore


def erosion1(
    region: HObject,
    struct_element: HObject,
    iterations: int
) -> HObject:
    """
    Erode a region.

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    struct_element : HObject
                     Structuring element.

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_erosion : HObject
                     Eroded regions.

    See Also
    --------
    transpose_region

    Alternatives
    ------------
    minkowski_sub1, minkowski_sub2, erosion2

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm, gen_circle,
    gen_ellipse, gen_rectangle1, gen_rectangle2, draw_region,
    gen_region_points, gen_region_polygon_filled

    Successors
    ----------
    connection, reduce_domain, select_shape, area_center
    """
    with HalconOperator(773) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, iterations)
        proc.execute()
        region_erosion = HObject(proc.get_output_object_key(1))
        return region_erosion  # type: ignore


def erosion2(
    region: HObject,
    struct_element: HObject,
    row: int,
    column: int,
    iterations: int
) -> HObject:
    """
    Erode a region (using a reference point).

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    struct_element : HObject
                     Structuring element.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 0

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_erosion : HObject
                     Eroded regions.

    See Also
    --------
    transpose_region, gen_circle, gen_rectangle2, gen_region_polygon

    Alternatives
    ------------
    minkowski_sub2, minkowski_sub1, erosion1

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm, gen_circle,
    gen_ellipse, gen_rectangle1, gen_rectangle2, draw_region,
    gen_region_points, gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(772) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        region_erosion = HObject(proc.get_output_object_key(1))
        return region_erosion  # type: ignore


def erosion_circle(
    region: HObject,
    radius: Union[float, int]
) -> HObject:
    """
    Erode a region with a circular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    radius : Union[float, int]
             Radius of the circular structuring element.
             Value Suggestion: 3.5

    Returns
    -------

    region_erosion : HObject
                     Eroded regions.

    See Also
    --------
    gen_circle, dilation_circle, closing_circle, opening_circle

    Alternatives
    ------------
    minkowski_sub1

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm

    Successors
    ----------
    connection, reduce_domain, select_shape, area_center
    """
    with HalconOperator(771) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, radius)
        proc.execute()
        region_erosion = HObject(proc.get_output_object_key(1))
        return region_erosion  # type: ignore


def erosion_golay(
    region: HObject,
    golay_element: str,
    iterations: int,
    rotation: int
) -> HObject:
    """
    Erode a region with an element from the Golay alphabet.

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_erosion : HObject
                     Eroded regions.

    See Also
    --------
    dilation_golay, opening_golay, closing_golay, hit_or_miss_golay,
    thinning_golay, thickening_golay, golay_elements

    Alternatives
    ------------
    erosion_seq, erosion1, erosion2

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    erosion_golay is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.  For some
    of the values of Rotation, the resulting regions are identical to the
    input regions.
    """
    with HalconOperator(769) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, rotation)
        proc.execute()
        region_erosion = HObject(proc.get_output_object_key(1))
        return region_erosion  # type: ignore


def erosion_rectangle1(
    region: HObject,
    width: int,
    height: int
) -> HObject:
    """
    Erode a region with a rectangular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    width : int
            Width of the structuring rectangle.
            Value Suggestion: 11

    height : int
             Height of the structuring rectangle.
             Value Suggestion: 11

    Returns
    -------

    region_erosion : HObject
                     Eroded regions.

    See Also
    --------
    gen_rectangle1

    Alternatives
    ------------
    erosion1, minkowski_sub1

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    To reduce a region by the same amount in all directions, Width and
    Height must be odd.  If this is not the case, the region is eroded by
    a larger amount at the right or at the bottom, respectively, than at
    the left or at the top.
    """
    with HalconOperator(770) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        region_erosion = HObject(proc.get_output_object_key(1))
        return region_erosion  # type: ignore


def erosion_seq(
    region: HObject,
    golay_element: str,
    iterations: int
) -> HObject:
    """
    Erode a region sequentially.

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_erosion : HObject
                     Eroded regions.

    See Also
    --------
    dilation_seq, hit_or_miss_seq, thinning_seq

    Alternatives
    ------------
    erosion_golay, erosion1, erosion2

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm

    Successors
    ----------
    connection, reduce_domain, select_shape, area_center

    Warnings
    --------
    erosion_seq is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(768) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, iterations)
        proc.execute()
        region_erosion = HObject(proc.get_output_object_key(1))
        return region_erosion  # type: ignore


def essential_to_fundamental_matrix(
    ematrix: Sequence[Union[float, int]],
    cov_emat: Sequence[Union[float, int]],
    cam_mat_1: Sequence[Union[float, int]],
    cam_mat_2: Sequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the fundamental matrix from an essential matrix.

    Parameters
    ----------

    ematrix : Sequence[Union[float, int]]
              Essential matrix.

    cov_emat : Sequence[Union[float, int]]
               $9- covariance matrix of the essential matrix.
               Value Suggestion: []

    cam_mat_1 : Sequence[Union[float, int]]
                Camera matrix of the 1. camera.

    cam_mat_2 : Sequence[Union[float, int]]
                Camera matrix of the 2. camera.

    Returns
    -------

    fmatrix : Sequence[float]
              Computed fundamental matrix.

    cov_fmat : Sequence[float]
               $9- covariance matrix of the fundamental matrix.

    Alternatives
    ------------
    rel_pose_to_fundamental_matrix

    Predecessors
    ------------
    vector_to_essential_matrix
    """
    with HalconOperator(354) as proc:
        proc.set_input_tuple(0, ematrix)
        proc.set_input_tuple(1, cov_emat)
        proc.set_input_tuple(2, cam_mat_1)
        proc.set_input_tuple(3, cam_mat_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # fmatrix
            proc.get_output_tuple_m(1)   # cov_fmat
        )  # type: ignore


def estimate_al_am(
    image: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Estimate the albedo of a surface and the amount of ambient light.

    Parameters
    ----------

    image : HObject
            Image for which albedo and ambient are to be estimated.

    Returns
    -------

    albedo : Sequence[float]
             Amount of light reflected by the surface.

    ambient : Sequence[float]
              Amount of ambient light.

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field

    Notes
    -----
    It is assumed that the image contains at least one point for which the
    reflection function assumes its minimum, e.g., points in shadows.
    Furthermore, it is assumed that the image contains at least one point
    for which the reflection function assumes its maximum.  If this is not
    the case, wrong values will be estimated.
    """
    with HalconOperator(393) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # albedo
            proc.get_output_tuple_m(1)   # ambient
        )  # type: ignore


def estimate_al_am_s(image: HObject) -> Tuple[float, float]:
    """
    Estimate the albedo of a surface and the amount of ambient light.

    Parameters
    ----------

    image : HObject
            Image for which albedo and ambient are to be estimated.

    Returns
    -------

    albedo : float
             Amount of light reflected by the surface.

    ambient : float
              Amount of ambient light.

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field

    Notes
    -----
    It is assumed that the image contains at least one point for which the
    reflection function assumes its minimum, e.g., points in shadows.
    Furthermore, it is assumed that the image contains at least one point
    for which the reflection function assumes its maximum.  If this is not
    the case, wrong values will be estimated.
    """
    with HalconOperator(393) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # albedo
            proc.get_output_tuple_s(1)   # ambient
        )  # type: ignore


def estimate_noise(
    image: HObject,
    method: str,
    percent: Union[int, float]
) -> Sequence[float]:
    """
    Estimate the image noise from a single image.

    Parameters
    ----------

    image : HObject
            Input image.

    method : str
             Method to estimate the image noise.
             Value Suggestion: foerstner

    percent : Union[int, float]
              Percentage of used image points.
              Value Suggestion: 20
              Assertion: 0 < Percent && Percent <= 50.

    Returns
    -------

    sigma : Sequence[float]
            Standard deviation of the image noise.
            Assertion: Sigma >= 0

    See Also
    --------
    gauss_distribution, add_noise_distribution

    Alternatives
    ------------
    noise_distribution_mean, intensity, min_max_gray

    Predecessors
    ------------
    grab_image, grab_image_async, read_image, reduce_domain

    Successors
    ----------
    binomial_filter, gauss_filter, mean_image, smooth_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1439) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, percent)
        proc.init_oct(0)
        proc.execute()
        sigma = proc.get_output_tuple_m(0)
        return sigma  # type: ignore


def estimate_noise_s(
    image: HObject,
    method: str,
    percent: Union[int, float]
) -> float:
    """
    Estimate the image noise from a single image.

    Parameters
    ----------

    image : HObject
            Input image.

    method : str
             Method to estimate the image noise.
             Value Suggestion: foerstner

    percent : Union[int, float]
              Percentage of used image points.
              Value Suggestion: 20
              Assertion: 0 < Percent && Percent <= 50.

    Returns
    -------

    sigma : float
            Standard deviation of the image noise.
            Assertion: Sigma >= 0

    See Also
    --------
    gauss_distribution, add_noise_distribution

    Alternatives
    ------------
    noise_distribution_mean, intensity, min_max_gray

    Predecessors
    ------------
    grab_image, grab_image_async, read_image, reduce_domain

    Successors
    ----------
    binomial_filter, gauss_filter, mean_image, smooth_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1439) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, percent)
        proc.init_oct(0)
        proc.execute()
        sigma = proc.get_output_tuple_s(0)
        return sigma  # type: ignore


def estimate_sl_al_lr(
    image: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Estimate the slant of a light source and the albedo of a surface.

    Parameters
    ----------

    image : HObject
            Image for which slant and albedo are to be estimated.

    Returns
    -------

    slant : Sequence[float]
            Angle between the light sources and the positive z-axis (in
            degrees).

    albedo : Sequence[float]
             Amount of light reflected by the surface.

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field

    Notes
    -----
    The Albedo is assumed constant for the entire surface depicted in the
    image.
    """
    with HalconOperator(395) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # slant
            proc.get_output_tuple_m(1)   # albedo
        )  # type: ignore


def estimate_sl_al_lr_s(image: HObject) -> Tuple[float, float]:
    """
    Estimate the slant of a light source and the albedo of a surface.

    Parameters
    ----------

    image : HObject
            Image for which slant and albedo are to be estimated.

    Returns
    -------

    slant : float
            Angle between the light sources and the positive z-axis (in
            degrees).

    albedo : float
             Amount of light reflected by the surface.

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field

    Notes
    -----
    The Albedo is assumed constant for the entire surface depicted in the
    image.
    """
    with HalconOperator(395) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # slant
            proc.get_output_tuple_s(1)   # albedo
        )  # type: ignore


def estimate_sl_al_zc(
    image: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Estimate the slant of a light source and the albedo of a surface.

    Parameters
    ----------

    image : HObject
            Image for which slant and albedo are to be estimated.

    Returns
    -------

    slant : Sequence[float]
            Angle of the light sources and the positive z-axis (in
            degrees).

    albedo : Sequence[float]
             Amount of light reflected by the surface.

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field

    Notes
    -----
    The Albedo is assumed constant for the entire surface depicted in the
    image.
    """
    with HalconOperator(394) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # slant
            proc.get_output_tuple_m(1)   # albedo
        )  # type: ignore


def estimate_sl_al_zc_s(image: HObject) -> Tuple[float, float]:
    """
    Estimate the slant of a light source and the albedo of a surface.

    Parameters
    ----------

    image : HObject
            Image for which slant and albedo are to be estimated.

    Returns
    -------

    slant : float
            Angle of the light sources and the positive z-axis (in
            degrees).

    albedo : float
             Amount of light reflected by the surface.

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field

    Notes
    -----
    The Albedo is assumed constant for the entire surface depicted in the
    image.
    """
    with HalconOperator(394) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # slant
            proc.get_output_tuple_s(1)   # albedo
        )  # type: ignore


def estimate_tilt_lr(image: HObject) -> Sequence[float]:
    """
    Estimate the tilt of a light source.

    Parameters
    ----------

    image : HObject
            Image for which the tilt is to be estimated.

    Returns
    -------

    tilt : Sequence[float]
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field
    """
    with HalconOperator(397) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        tilt = proc.get_output_tuple_m(0)
        return tilt  # type: ignore


def estimate_tilt_lr_s(image: HObject) -> float:
    """
    Estimate the tilt of a light source.

    Parameters
    ----------

    image : HObject
            Image for which the tilt is to be estimated.

    Returns
    -------

    tilt : float
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field
    """
    with HalconOperator(397) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        tilt = proc.get_output_tuple_s(0)
        return tilt  # type: ignore


def estimate_tilt_zc(image: HObject) -> Sequence[float]:
    """
    Estimate the tilt of a light source.

    Parameters
    ----------

    image : HObject
            Image for which the tilt is to be estimated.

    Returns
    -------

    tilt : Sequence[float]
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field
    """
    with HalconOperator(396) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        tilt = proc.get_output_tuple_m(0)
        return tilt  # type: ignore


def estimate_tilt_zc_s(image: HObject) -> float:
    """
    Estimate the tilt of a light source.

    Parameters
    ----------

    image : HObject
            Image for which the tilt is to be estimated.

    Returns
    -------

    tilt : float
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).

    Successors
    ----------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo,
    shade_height_field
    """
    with HalconOperator(396) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        tilt = proc.get_output_tuple_s(0)
        return tilt  # type: ignore


def euler_number(regions: HObject) -> Sequence[int]:
    """
    Calculate the Euler number.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    euler_number : Sequence[int]
                   Calculated Euler number.

    Alternatives
    ------------
    connect_and_holes

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1719) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        euler_number = proc.get_output_tuple_m(0)
        return euler_number  # type: ignore


def euler_number_s(regions: HObject) -> int:
    """
    Calculate the Euler number.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    euler_number : int
                   Calculated Euler number.

    Alternatives
    ------------
    connect_and_holes

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1719) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        euler_number = proc.get_output_tuple_s(0)
        return euler_number  # type: ignore


def evaluate_class_gmm(
    gmmhandle: HHandle,
    features: Sequence[float]
) -> Tuple[Sequence[float], float, float]:
    """
    Evaluate a feature vector by a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    features : Sequence[float]
               Feature vector.

    Returns
    -------

    class_prob : Sequence[float]
                 A-posteriori probability of the classes.

    density : float
              Probability density of the feature vector.

    ksigma_prob : float
                  Normalized k-sigma-probability for the feature vector.

    See Also
    --------
    create_class_gmm

    Alternatives
    ------------
    classify_class_gmm

    Predecessors
    ------------
    train_class_gmm, read_class_gmm
    """
    with HalconOperator(1833) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, features)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # class_prob
            proc.get_output_tuple_s(1),  # density
            proc.get_output_tuple_s(2)   # ksigma_prob
        )  # type: ignore


def evaluate_class_mlp(
    mlphandle: HHandle,
    features: Sequence[float]
) -> Sequence[float]:
    """
    Calculate the evaluation of a feature vector by a multilayer
    perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    features : Sequence[float]
               Feature vector.

    Returns
    -------

    result : Sequence[float]
             Result of evaluating the feature vector with the MLP.

    See Also
    --------
    create_class_mlp

    Alternatives
    ------------
    classify_class_mlp

    Predecessors
    ------------
    train_class_mlp, read_class_mlp
    """
    with HalconOperator(1872) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, features)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def evaluate_class_svm(
    svmhandle: HHandle,
    features: Sequence[float]
) -> Sequence[float]:
    """
    Evaluate a feature vector by a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    features : Sequence[float]
               Feature vector.

    Returns
    -------

    result : Sequence[float]
             Result of evaluating the feature vector with the SVM.

    See Also
    --------
    create_class_svm

    Predecessors
    ------------
    train_class_svm, read_class_svm
    """
    with HalconOperator(1850) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, features)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def evaluate_class_svm_s(
    svmhandle: HHandle,
    features: Sequence[float]
) -> float:
    """
    Evaluate a feature vector by a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    features : Sequence[float]
               Feature vector.

    Returns
    -------

    result : float
             Result of evaluating the feature vector with the SVM.

    See Also
    --------
    create_class_svm

    Predecessors
    ------------
    train_class_svm, read_class_svm
    """
    with HalconOperator(1850) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, features)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_s(0)
        return result  # type: ignore


def exhaustive_match(
    image: HObject,
    region_of_interest: HObject,
    image_template: HObject,
    mode: str
) -> HObject:
    """
    Matching of a template and an image.

    Parameters
    ----------

    image : HObject
            Input image.

    region_of_interest : HObject
                         Area to be searched in the input image.

    image_template : HObject
                     This area  will be ``matched'' by Image within the
                     RegionOfInterest.

    mode : str
           Desired matching criterion.
           Value Suggestion: dfd

    Returns
    -------

    image_match : HObject
                  Result image: values of the matching criterion.

    Alternatives
    ------------
    exhaustive_match_mg

    Predecessors
    ------------
    draw_region, draw_rectangle1

    Successors
    ----------
    local_max, threshold
    """
    with HalconOperator(1506) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region_of_interest)
        proc.set_input_object(3, image_template)
        proc.set_input_tuple(0, mode)
        proc.execute()
        image_match = HObject(proc.get_output_object_key(1))
        return image_match  # type: ignore


def exhaustive_match_mg(
    image: HObject,
    image_template: HObject,
    mode: str,
    level: int,
    threshold: int
) -> HObject:
    """
    Matching a template and an image in a resolution pyramid.

    Parameters
    ----------

    image : HObject
            Input image.

    image_template : HObject
                     The domain of this image will be matched with Image.

    mode : str
           Desired matching criterion.
           Value Suggestion: dfd

    level : int
            Startlevel in the resolution pyramid (highest resolution:
            Level 0).
            Value Suggestion: 1
            Assertion: Level <= ld(width(Image)) && Level <= ld(height(Image)) && Level <= ld(width(ImageTemplate)) && Level <= ld(height(ImageTemplate))

    threshold : int
                Threshold to determine the ``region of interest''.
                Value Suggestion: 30

    Returns
    -------

    image_match : HObject
                  Result image and result region: values of the matching
                  criterion within the determined ``region of interest''.

    See Also
    --------
    gen_gauss_pyramid

    Alternatives
    ------------
    exhaustive_match

    Predecessors
    ------------
    draw_region, draw_rectangle1

    Successors
    ----------
    threshold, local_max
    """
    with HalconOperator(1487) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, image_template)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, level)
        proc.set_input_tuple(2, threshold)
        proc.execute()
        image_match = HObject(proc.get_output_object_key(1))
        return image_match  # type: ignore


def exp_image(image: HObject, base: Union[int, float, str]) -> HObject:
    """
    Calculate the exponentiation of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    base : Union[int, float, str]
           Base of the exponentiation.
           Value Suggestion: e

    Returns
    -------

    exp_image : HObject
                Output image.

    See Also
    --------
    pow_image, log_image

    Notes
    -----
    exp_image can be executed on an OpenCL device for byte, int1, int2,
    uint2, int4, and real images. Note that the results of the OpenCL code
    may vary from the results produced by the CPU.
    """
    with HalconOperator(1595) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, base)
        proc.execute()
        exp_image = HObject(proc.get_output_object_key(1))
        return exp_image  # type: ignore


def expand_domain_gray(
    input_image: HObject,
    expansion_range: int
) -> HObject:
    """
    Expand the domain of an image and set the gray values in the expanded
    domain.

    Parameters
    ----------

    input_image : HObject
                  Input image with domain to be expanded.

    expansion_range : int
                      Radius of the gray value expansion, measured in
                      pixels.
                      Value Suggestion: 2
                      Assertion: ExpansionRange >= 1

    Returns
    -------

    expanded_image : HObject
                     Output image with new gray values in the expanded
                     domain.

    See Also
    --------
    reduce_domain, mean_image

    Predecessors
    ------------
    reduce_domain

    Successors
    ----------
    reduce_domain, mean_image, dyn_threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1452) as proc:
        proc.set_input_object(1, input_image)
        proc.set_input_tuple(0, expansion_range)
        proc.execute()
        expanded_image = HObject(proc.get_output_object_key(1))
        return expanded_image  # type: ignore


def expand_gray(
    regions: HObject,
    image: HObject,
    forbidden_area: HObject,
    iterations: Union[int, str],
    mode: str,
    threshold: MaybeSequence[int]
) -> HObject:
    """
    Fill gaps between regions (depending on gray value or color) or split
    overlapping regions.

    Parameters
    ----------

    regions : HObject
              Regions for which the gaps are to be closed, or which are to
              be separated.

    image : HObject
            Image (possibly multi-channel) for gray value or color
            comparison.

    forbidden_area : HObject
                     Regions in which no expansion takes place.

    iterations : Union[int, str]
                 Number of iterations.
                 Value Suggestion: maximal

    mode : str
           Expansion mode.
           Value Suggestion: image

    threshold : MaybeSequence[int]
                Maximum difference between the gray value or color at the
                region's border and a candidate for expansion.
                Value Suggestion: 32

    Returns
    -------

    region_expand : HObject
                    Expanded or separated regions.

    See Also
    --------
    expand_gray_ref, expand_region

    Predecessors
    ------------
    connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape

    Notes
    -----
    Because regions are only expanded into areas having a matching gray
    value or color, usually gaps will remain between the output regions,
    i.e., the segmentation is not complete.
    """
    with HalconOperator(509) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_object(3, forbidden_area)
        proc.set_input_tuple(0, iterations)
        proc.set_input_tuple(1, mode)
        proc.set_input_tuple(2, threshold)
        proc.execute()
        region_expand = HObject(proc.get_output_object_key(1))
        return region_expand  # type: ignore


def expand_gray_ref(
    regions: HObject,
    image: HObject,
    forbidden_area: HObject,
    iterations: Union[int, str],
    mode: str,
    ref_gray: MaybeSequence[int],
    threshold: MaybeSequence[int]
) -> HObject:
    """
    Fill gaps between regions (depending on gray value or color) or split
    overlapping regions.

    Parameters
    ----------

    regions : HObject
              Regions for which the gaps are to be closed, or which are to
              be separated.

    image : HObject
            Image (possibly multi-channel) for gray value or color
            comparison.

    forbidden_area : HObject
                     Regions in which no expansion takes place.

    iterations : Union[int, str]
                 Number of iterations.
                 Value Suggestion: maximal

    mode : str
           Expansion mode.
           Value Suggestion: image

    ref_gray : MaybeSequence[int]
               Reference gray value or color for comparison.
               Value Suggestion: 128

    threshold : MaybeSequence[int]
                Maximum difference between the reference gray value or
                color and a candidate for expansion.
                Value Suggestion: 32

    Returns
    -------

    region_expand : HObject
                    Expanded or separated regions.

    See Also
    --------
    expand_gray, expand_region

    Predecessors
    ------------
    connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape

    Notes
    -----
    Because regions are only expanded into areas having a matching gray
    value or color, usually gaps will remain between the output regions,
    i.e., the segmentation is not complete.
    """
    with HalconOperator(510) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_object(3, forbidden_area)
        proc.set_input_tuple(0, iterations)
        proc.set_input_tuple(1, mode)
        proc.set_input_tuple(2, ref_gray)
        proc.set_input_tuple(3, threshold)
        proc.execute()
        region_expand = HObject(proc.get_output_object_key(1))
        return region_expand  # type: ignore


def expand_line(
    image: HObject,
    coordinate: int,
    expand_type: str,
    row_column: str,
    threshold: Union[int, float]
) -> HObject:
    """
    Expand a region starting at a given line.

    Parameters
    ----------

    image : HObject
            Input image.

    coordinate : int
                 Row or column coordinate.
                 Value Suggestion: 256
                 Assertion: Coordinate >= 0

    expand_type : str
                  Stopping criterion.
                  Value Suggestion: gradient

    row_column : str
                 Segmentation mode (row or column).
                 Value Suggestion: row

    threshold : Union[int, float]
                Threshold for the expansion.
                Value Suggestion: 3.0
                Assertion: Threshold >= 0.0 && Threshold <= 255.0

    Returns
    -------

    region_expand : HObject
                    Extracted segments.

    Alternatives
    ------------
    regiongrowing_mean, expand_gray, expand_gray_ref

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image, anisotropic_diffusion,
    median_image, affine_trans_image, rotate_image

    Successors
    ----------
    intersection, opening, closing

    Warnings
    --------
    expand_line is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(464) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, coordinate)
        proc.set_input_tuple(1, expand_type)
        proc.set_input_tuple(2, row_column)
        proc.set_input_tuple(3, threshold)
        proc.execute()
        region_expand = HObject(proc.get_output_object_key(1))
        return region_expand  # type: ignore


def expand_region(
    regions: HObject,
    forbidden_area: HObject,
    iterations: Union[int, str],
    mode: str
) -> HObject:
    """
    Fill gaps between regions or split overlapping regions.

    Parameters
    ----------

    regions : HObject
              Regions for which the gaps are to be closed, or which are to
              be separated.

    forbidden_area : HObject
                     Regions in which no expansion takes place.

    iterations : Union[int, str]
                 Number of iterations.
                 Value Suggestion: maximal

    mode : str
           Expansion mode.
           Value Suggestion: image

    Returns
    -------

    region_expanded : HObject
                      Expanded or separated regions.

    See Also
    --------
    expand_gray, interjacent, skeleton

    Alternatives
    ------------
    dilation1

    Predecessors
    ------------
    pouring, threshold, dyn_threshold, regiongrowing
    """
    with HalconOperator(497) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, forbidden_area)
        proc.set_input_tuple(0, iterations)
        proc.set_input_tuple(1, mode)
        proc.execute()
        region_expanded = HObject(proc.get_output_object_key(1))
        return region_expanded  # type: ignore


def fast_match(
    image: HObject,
    template_id: HHandle,
    max_error: float
) -> HObject:
    """
    Searching all good matches of a template and an image.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    max_error : float
                Maximal average difference of the gray values.
                Value Suggestion: 20.0

    Returns
    -------

    matches : HObject
              All points whose error lies below a certain threshold.

    Alternatives
    ------------
    best_match, best_match_mg, fast_match_mg, exhaustive_match,
    exhaustive_match_mg

    Predecessors
    ------------
    create_template, read_template, adapt_template, draw_region,
    draw_rectangle1, reduce_domain

    Successors
    ----------
    connection, best_match

    Warnings
    --------
    fast_match is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  shape-based or
    NCC-based operators instead.
    """
    with HalconOperator(1502) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, max_error)
        proc.execute()
        matches = HObject(proc.get_output_object_key(1))
        return matches  # type: ignore


def fast_match_mg(
    image: HObject,
    template_id: HHandle,
    max_error: float,
    num_level: MaybeSequence[int]
) -> HObject:
    """
    Searching all good gray value matches in a pyramid.

    Parameters
    ----------

    image : HObject
            Input image inside of which the pattern has to be found.

    template_id : HHandle
                  Template number.

    max_error : float
                Maximal average difference of the gray values.
                Value Suggestion: 30.0

    num_level : MaybeSequence[int]
                Number of levels in the pyramid.
                Value Suggestion: 3

    Returns
    -------

    matches : HObject
              All points which have an error below a certain threshold.

    Alternatives
    ------------
    best_match, best_match_mg, fast_match, exhaustive_match,
    exhaustive_match_mg

    Predecessors
    ------------
    create_template, read_template, adapt_template, draw_region,
    draw_rectangle1, reduce_domain

    Warnings
    --------
    fast_match_mg is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  shape-based or
    NCC-based operators instead.
    """
    with HalconOperator(1499) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, max_error)
        proc.set_input_tuple(2, num_level)
        proc.execute()
        matches = HObject(proc.get_output_object_key(1))
        return matches  # type: ignore


def fast_threshold(
    image: HObject,
    min_gray: Union[int, float],
    max_gray: Union[int, float],
    min_size: int
) -> HObject:
    """
    Fast thresholding of images using global thresholds.

    Parameters
    ----------

    image : HObject
            Input image.

    min_gray : Union[int, float]
               Lower threshold for the gray values.
               Value Suggestion: 128

    max_gray : Union[int, float]
               Upper threshold for the gray values.
               Value Suggestion: 255.0

    min_size : int
               Minimum size of objects to be extracted.
               Value Suggestion: 20

    Returns
    -------

    region : HObject
             Segmented regions.

    See Also
    --------
    class_2dim_sup, hysteresis_threshold

    Alternatives
    ------------
    threshold, gen_grid_region, dilation_rectangle1, dyn_threshold

    Predecessors
    ------------
    histo_to_thresh, min_max_gray, sobel_amp, binomial_filter,
    gauss_filter, reduce_domain, fill_interlace

    Successors
    ----------
    connection, dilation1, erosion1, opening, closing, rank_region,
    shape_trans, skeleton

    Notes
    -----
    On multi-core computers supporting the SSE2 instruction set, threshold
    is most likely faster than fast_threshold. fast_threshold may only be
    preferred to threshold if those features are not available, e.g. on
    embedded platforms.
    """
    with HalconOperator(474) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, min_gray)
        proc.set_input_tuple(1, max_gray)
        proc.set_input_tuple(2, min_size)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def fft_generic(
    image: HObject,
    direction: str,
    exponent: int,
    norm: str,
    mode: str,
    result_type: str
) -> HObject:
    """
    Compute the fast Fourier transform of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    direction : str
                Calculate forward or reverse transform.
                Value Suggestion: to_freq

    exponent : int
               Sign of the exponent.
               Value Suggestion: -1

    norm : str
           Normalizing factor of the transform.
           Value Suggestion: sqrt

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    result_type : str
                  Image type of the output image.
                  Value Suggestion: complex

    Returns
    -------

    image_fft : HObject
                Fourier-transformed image.

    Alternatives
    ------------
    fft_image, fft_image_inv, rft_generic

    Predecessors
    ------------
    optimize_fft_speed, read_fft_optimization_data

    Successors
    ----------
    convol_fft, correlation_fft, phase_correlation_fft, convol_gabor,
    convert_image_type, power_byte, power_real, power_ln, phase_deg,
    phase_rad, energy_gabor

    Notes
    -----
    The transformation is always performed for the entire image, i.e., the
    domain of the image is ignored.
    """
    with HalconOperator(1544) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, direction)
        proc.set_input_tuple(1, exponent)
        proc.set_input_tuple(2, norm)
        proc.set_input_tuple(3, mode)
        proc.set_input_tuple(4, result_type)
        proc.execute()
        image_fft = HObject(proc.get_output_object_key(1))
        return image_fft  # type: ignore


def fft_image(image: HObject) -> HObject:
    """
    Compute the fast Fourier transform of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_fft : HObject
                Fourier-transformed image.

    See Also
    --------
    fft_image_inv

    Alternatives
    ------------
    fft_generic, rft_generic

    Predecessors
    ------------
    optimize_fft_speed, read_fft_optimization_data

    Successors
    ----------
    convol_fft, convol_gabor, convert_image_type, power_byte, power_real,
    power_ln, phase_deg, phase_rad

    Notes
    -----
    The transformation is always performed for the entire image, i.e., the
    domain of the image is ignored.
    """
    with HalconOperator(1543) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_fft = HObject(proc.get_output_object_key(1))
        return image_fft  # type: ignore


def fft_image_inv(image: HObject) -> HObject:
    """
    Compute the inverse fast Fourier transform of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_fftinv : HObject
                   Inverse-Fourier-transformed image.

    See Also
    --------
    fft_image, fft_generic, energy_gabor

    Alternatives
    ------------
    fft_generic, rft_generic

    Predecessors
    ------------
    convol_fft, convol_gabor, fft_image, optimize_fft_speed,
    read_fft_optimization_data

    Successors
    ----------
    convert_image_type, energy_gabor

    Notes
    -----
    The transformation is always performed for the entire image, i.e., the
    domain of the image is ignored.
    """
    with HalconOperator(1542) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_fftinv = HObject(proc.get_output_object_key(1))
        return image_fftinv  # type: ignore


def file_exists(file_name: str) -> int:
    """
    Check whether file exists.

    Parameters
    ----------

    file_name : str
                Name of file to be checked.
                Value Suggestion: /bin/cc

    Returns
    -------

    file_exists : int
                  Boolean number.

    Alternatives
    ------------
    open_file

    Successors
    ----------
    open_file
    """
    with HalconOperator(1645) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        file_exists = proc.get_output_tuple_s(0)
        return file_exists  # type: ignore


def fill_interlace(image_camera: HObject, mode: str) -> HObject:
    """
    Interpolate 2 video half images.

    Parameters
    ----------

    image_camera : HObject
                   Gray image consisting of two half images.

    mode : str
           Instruction whether even or odd lines should be
           replaced/removed.
           Value Suggestion: odd

    Returns
    -------

    image_filled : HObject
                   Full image with interpolated/removed lines.

    See Also
    --------
    median_image, binomial_filter, gauss_filter, crop_part

    Predecessors
    ------------
    read_image, grab_image

    Successors
    ----------
    sobel_amp, edges_image, regiongrowing, diff_of_gauss, threshold,
    dyn_threshold, auto_threshold, mean_image, binomial_filter,
    gauss_filter, anisotropic_diffusion, sigma_image, median_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1424) as proc:
        proc.set_input_object(1, image_camera)
        proc.set_input_tuple(0, mode)
        proc.execute()
        image_filled = HObject(proc.get_output_object_key(1))
        return image_filled  # type: ignore


def fill_up(region: HObject) -> HObject:
    """
    Fill up holes in regions.

    Parameters
    ----------

    region : HObject
             Input regions containing holes.

    Returns
    -------

    region_fill_up : HObject
                     Regions without holes.

    See Also
    --------
    boundary

    Alternatives
    ------------
    fill_up_shape

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(495) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        region_fill_up = HObject(proc.get_output_object_key(1))
        return region_fill_up  # type: ignore


def fill_up_shape(
    region: HObject,
    feature: str,
    min: Union[int, float],
    max: Union[int, float]
) -> HObject:
    """
    Fill up holes in regions having given shape features.

    Parameters
    ----------

    region : HObject
             Input region(s).

    feature : str
              Shape feature used.
              Value Suggestion: area

    min : Union[int, float]
          Minimum value for Feature.
          Value Suggestion: 1.0

    max : Union[int, float]
          Maximum value for Feature.
          Value Suggestion: 100.0

    Returns
    -------

    region_fill_up : HObject
                     Output region(s) with filled holes.

    See Also
    --------
    select_shape, connection, area_center

    Alternatives
    ------------
    fill_up

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(496) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, feature)
        proc.set_input_tuple(1, min)
        proc.set_input_tuple(2, max)
        proc.execute()
        region_fill_up = HObject(proc.get_output_object_key(1))
        return region_fill_up  # type: ignore


def filter_kalman(
    dimension: Sequence[int],
    model: Sequence[float],
    measurement: Sequence[float],
    prediction_in: Sequence[float]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Estimate the current state of a system with the help of the Kalman
    filtering.

    Parameters
    ----------

    dimension : Sequence[int]
                The dimensions of the state vector, the measurement and
                the controller vector.
                Value Suggestion: [3,1,0]

    model : Sequence[float]
            The lined up matrices A,C,Q$A,C,Q$, possibly G$G$ and u$u$,
            and if necessary L$L$ which have been stored in row-major
            order.
            Value Suggestion: [1.0,1.0,0.5,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,54.3,37.9,48.0,37.9,34.3,42.5,48.0,42.5,43.7]

    measurement : Sequence[float]
                  The matrix R$R$ stored in row-major order and the
                  measurement vector y$y$ lined up.
                  Value Suggestion: [1.2,1.0]

    prediction_in : Sequence[float]
                    The matrix P*$P$ (the extrapolation-error covariances)
                    stored in row-major order and the extrapolation vector
                    x*$x$ lined up.
                    Value Suggestion: [0.0,0.0,0.0,0.0,180.5,0.0,0.0,0.0,100.0,0.0,100.0,0.0]

    Returns
    -------

    prediction_out : Sequence[float]
                     The matrix P*P$- (the extrapolation-error
                     covariances)stored in row-major order and the
                     extrapolation vector x*$x$ lined up.

    estimate : Sequence[float]
               The matrix P~$P$ (the estimation-error covariances) stored
               in row-major order and the estimated state x~$x$ lined up.

    See Also
    --------
    read_kalman, update_kalman

    Predecessors
    ------------
    read_kalman

    Successors
    ----------
    update_kalman

    Warnings
    --------
    filter_kalman is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1107) as proc:
        proc.set_input_tuple(0, dimension)
        proc.set_input_tuple(1, model)
        proc.set_input_tuple(2, measurement)
        proc.set_input_tuple(3, prediction_in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # prediction_out
            proc.get_output_tuple_m(1)   # estimate
        )  # type: ignore


def find_aniso_shape_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    scale_rmin: float,
    scale_rmax: float,
    scale_cmin: float,
    scale_cmax: float,
    min_score: MaybeSequence[float],
    num_matches: int,
    max_overlap: float,
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int],
    greediness: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Find the best matches of an anisotropically scaled shape model in an
    image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    scale_rmin : float
                 Minimum scale of the model in the row direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleRMin > 0

    scale_rmax : float
                 Maximum scale of the model in the row direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleRMax >= ScaleRMin

    scale_cmin : float
                 Minimum scale of the model in the column direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleCMin > 0

    scale_cmax : float
                 Maximum scale of the model in the column direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleCMax >= ScaleCMin

    min_score : MaybeSequence[float]
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.5

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: least_squares

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the model.

    column : Sequence[float]
             Column coordinate of the found instances of the model.

    angle : Sequence[float]
            Rotation angle of the found instances of the model.

    scale_r : Sequence[float]
              Scale of the found instances of the model in the row
              direction.

    scale_c : Sequence[float]
              Scale of the found instances of the model in the column
              direction.

    score : Sequence[float]
            Score of the found instances of the model.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    find_shape_model, find_scaled_shape_model, find_shape_models,
    find_scaled_shape_models, find_aniso_shape_models, find_ncc_model,
    find_ncc_models

    Predecessors
    ------------
    create_aniso_shape_model, read_shape_model, set_shape_model_origin,
    set_shape_model_clutter

    Successors
    ----------
    clear_shape_model
    """
    with HalconOperator(930) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_rmin)
        proc.set_input_tuple(4, scale_rmax)
        proc.set_input_tuple(5, scale_cmin)
        proc.set_input_tuple(6, scale_cmax)
        proc.set_input_tuple(7, min_score)
        proc.set_input_tuple(8, num_matches)
        proc.set_input_tuple(9, max_overlap)
        proc.set_input_tuple(10, sub_pixel)
        proc.set_input_tuple(11, num_levels)
        proc.set_input_tuple(12, greediness)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3),  # scale_r
            proc.get_output_tuple_m(4),  # scale_c
            proc.get_output_tuple_m(5)   # score
        )  # type: ignore


def find_aniso_shape_models(
    image: HObject,
    model_ids: MaybeSequence[HHandle],
    angle_start: MaybeSequence[float],
    angle_extent: MaybeSequence[float],
    scale_rmin: MaybeSequence[float],
    scale_rmax: MaybeSequence[float],
    scale_cmin: MaybeSequence[float],
    scale_cmax: MaybeSequence[float],
    min_score: MaybeSequence[float],
    num_matches: MaybeSequence[int],
    max_overlap: MaybeSequence[float],
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int],
    greediness: MaybeSequence[float]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Find the best matches of multiple anisotropically scaled shape models.

    Parameters
    ----------

    image : HObject
            Input image in which the models should be found.

    model_ids : MaybeSequence[HHandle]
                Handle of the models.

    angle_start : MaybeSequence[float]
                  Smallest rotation of the models.
                  Value Suggestion: -0.39

    angle_extent : MaybeSequence[float]
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    scale_rmin : MaybeSequence[float]
                 Minimum scale of the models in the row direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleRMin > 0

    scale_rmax : MaybeSequence[float]
                 Maximum scale of the models in the row direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleRMax >= ScaleRMin

    scale_cmin : MaybeSequence[float]
                 Minimum scale of the models in the column direction.
                 Value Suggestion: 0.9
                 Assertion: ScaleCMin > 0

    scale_cmax : MaybeSequence[float]
                 Maximum scale of the models in the column direction.
                 Value Suggestion: 1.1
                 Assertion: ScaleCMax >= ScaleCMin

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.5

    num_matches : MaybeSequence[int]
                  Number of instances of the models to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : MaybeSequence[float]
                  Maximum overlap of the instances of the models to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: least_squares

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : MaybeSequence[float]
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the models.

    column : Sequence[float]
             Column coordinate of the found instances of the models.

    angle : Sequence[float]
            Rotation angle of the found instances of the models.

    scale_r : Sequence[float]
              Scale of the found instances of the models in the row
              direction.

    scale_c : Sequence[float]
              Scale of the found instances of the models in the column
              direction.

    score : Sequence[float]
            Score of the found instances of the models.

    model : Sequence[int]
            Index of the found instances of the models.

    See Also
    --------
    set_system, get_system, set_shape_model_param

    Alternatives
    ------------
    find_shape_models, find_scaled_shape_models, find_shape_model,
    find_scaled_shape_model, find_aniso_shape_model, find_ncc_model,
    find_ncc_models

    Predecessors
    ------------
    add_channels, create_aniso_shape_model, read_shape_model,
    set_shape_model_origin, set_shape_model_clutter

    Successors
    ----------
    clear_shape_model
    """
    with HalconOperator(927) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_ids)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_rmin)
        proc.set_input_tuple(4, scale_rmax)
        proc.set_input_tuple(5, scale_cmin)
        proc.set_input_tuple(6, scale_cmax)
        proc.set_input_tuple(7, min_score)
        proc.set_input_tuple(8, num_matches)
        proc.set_input_tuple(9, max_overlap)
        proc.set_input_tuple(10, sub_pixel)
        proc.set_input_tuple(11, num_levels)
        proc.set_input_tuple(12, greediness)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3),  # scale_r
            proc.get_output_tuple_m(4),  # scale_c
            proc.get_output_tuple_m(5),  # score
            proc.get_output_tuple_m(6)   # model
        )  # type: ignore


def find_bar_code(
    image: HObject,
    bar_code_handle: HHandle,
    code_type: MaybeSequence[str]
) -> Tuple[HObject, Sequence[str]]:
    """
    Detect and read bar code symbols in an image.

    Parameters
    ----------

    image : HObject
            Input image. If the image has a reduced domain, the bar code
            search is reduced to that domain. This usually reduces the
            runtime of the operator. However, if the bar code is not fully
            inside the domain, the bar code cannot be decoded correctly.

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_type : MaybeSequence[str]
                Type of the searched bar code.
                Value Suggestion: 'auto'

    Returns
    -------

    symbol_regions : HObject
                     Regions of the successfully decoded bar code symbols.

    decoded_data_strings : Sequence[str]
                           Data strings of all successfully decoded bar
                           codes.

    Alternatives
    ------------
    decode_bar_code_rectangle2

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param

    Successors
    ----------
    get_bar_code_result, get_bar_code_object, clear_bar_code_model
    """
    with HalconOperator(1993) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_type)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # symbol_regions
            proc.get_output_tuple_m(0)   # decoded_data_strings
        )  # type: ignore


def find_bar_code_s(
    image: HObject,
    bar_code_handle: HHandle,
    code_type: MaybeSequence[str]
) -> Tuple[HObject, str]:
    """
    Detect and read bar code symbols in an image.

    Parameters
    ----------

    image : HObject
            Input image. If the image has a reduced domain, the bar code
            search is reduced to that domain. This usually reduces the
            runtime of the operator. However, if the bar code is not fully
            inside the domain, the bar code cannot be decoded correctly.

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_type : MaybeSequence[str]
                Type of the searched bar code.
                Value Suggestion: 'auto'

    Returns
    -------

    symbol_regions : HObject
                     Regions of the successfully decoded bar code symbols.

    decoded_data_strings : str
                           Data strings of all successfully decoded bar
                           codes.

    Alternatives
    ------------
    decode_bar_code_rectangle2

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param

    Successors
    ----------
    get_bar_code_result, get_bar_code_object, clear_bar_code_model
    """
    with HalconOperator(1993) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_type)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # symbol_regions
            proc.get_output_tuple_s(0)   # decoded_data_strings
        )  # type: ignore


def find_box_3d(
    object_model_3dscene: HHandle,
    side_len_1: Sequence[float],
    side_len_2: Sequence[float],
    side_len_3: Sequence[float],
    min_score: Union[float, int],
    gen_param: HHandle
) -> Tuple[Sequence[Union[float, int]], Sequence[float], Sequence[HHandle], HHandle]:
    """
    Find boxes in 3D data.

    Parameters
    ----------

    object_model_3dscene : HHandle
                           Handle of 3D object model where to search the
                           box.

    side_len_1 : Sequence[float]
                 Length of the first box side.

    side_len_2 : Sequence[float]
                 Length of the second box side.

    side_len_3 : Sequence[float]
                 Length of the third box side.
                 Value Suggestion: -1

    min_score : Union[float, int]
                Minimum score of the returned boxes.
                Value Suggestion: 0.6
                Assertion: 0 <= MinScore <= 1

    gen_param : HHandle
                Dictionary for generic parameters.
                Value Suggestion: []

    Returns
    -------

    gripping_pose : Sequence[Union[float, int]]
                    Gripping poses of the detected boxes.

    score : Sequence[float]
            Scores of the detected boxes.

    object_model_3dbox : Sequence[HHandle]
                         Detected boxes as triangulated 3D object models.

    box_information : HHandle
                      Additional debug information as dictionary.

    Alternatives
    ------------
    find_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    gen_box_object_model_3d, get_dict_tuple
    """
    with HalconOperator(2181) as proc:
        proc.set_input_tuple(0, object_model_3dscene)
        proc.set_input_tuple(1, side_len_1)
        proc.set_input_tuple(2, side_len_2)
        proc.set_input_tuple(3, side_len_3)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, gen_param)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # gripping_pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_m(2),  # object_model_3dbox
            proc.get_output_tuple_s(3)   # box_information
        )  # type: ignore


def find_calib_descriptor_model(
    image: HObject,
    model_id: HHandle,
    detector_param_name: Sequence[str],
    detector_param_value: Sequence[Union[int, float, str]],
    descriptor_param_name: Sequence[str],
    descriptor_param_value: Sequence[Union[int, float, str]],
    min_score: MaybeSequence[float],
    num_matches: int,
    cam_param: Sequence[Union[float, int, str]],
    score_type: MaybeSequence[str]
) -> Tuple[Sequence[Union[float, int]], Sequence[Union[float, int]]]:
    """
    Find the best matches of a calibrated descriptor model in an image and
    return their 3D pose.

    Parameters
    ----------

    image : HObject
            Input image where the model should be found.

    model_id : HHandle
               The handle to the descriptor model.

    detector_param_name : Sequence[str]
                          The detector's parameter names.
                          Value Suggestion: []

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detector's parameters.
                           Value Suggestion: []

    descriptor_param_name : Sequence[str]
                            The descriptor's parameter names.
                            Value Suggestion: []

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptor's parameters.
                             Value Suggestion: []

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.2

    num_matches : int
                  Maximal number of found instances.
                  Value Suggestion: 1
                  Assertion: NumMatches >= 1

    cam_param : Sequence[Union[float, int, str]]
                Camera parameter (inner orientation) obtained from camera
                calibration.

    score_type : MaybeSequence[str]
                 Score type to be evaluated in Score.
                 Value Suggestion: num_points

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the object.

    score : Sequence[Union[float, int]]
            Score of the found instances according to the ScoreType input.

    See Also
    --------
    vector_to_pose, points_lepetit, create_calib_descriptor_model

    Predecessors
    ------------
    create_calib_descriptor_model, read_descriptor_model

    Notes
    -----
    Note that the domain of the search image should contain the whole
    object to be searched for because interest points are only extracted
    inside the domain of the search image. This means that if the domain
    does not contain the full object to be searched for, the resulting
    Score will decrease. Note also that matches may be found even if the
    reference point (origin) of the model lies outside of the domain of
    the search image. Both is in contrast to shape-based matching, where
    the domain of the search image defines the search space for the
    reference point of the model.
    """
    with HalconOperator(948) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, detector_param_name)
        proc.set_input_tuple(2, detector_param_value)
        proc.set_input_tuple(3, descriptor_param_name)
        proc.set_input_tuple(4, descriptor_param_value)
        proc.set_input_tuple(5, min_score)
        proc.set_input_tuple(6, num_matches)
        proc.set_input_tuple(7, cam_param)
        proc.set_input_tuple(8, score_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1)   # score
        )  # type: ignore


def find_calib_descriptor_model_s(
    image: HObject,
    model_id: HHandle,
    detector_param_name: Sequence[str],
    detector_param_value: Sequence[Union[int, float, str]],
    descriptor_param_name: Sequence[str],
    descriptor_param_value: Sequence[Union[int, float, str]],
    min_score: MaybeSequence[float],
    num_matches: int,
    cam_param: Sequence[Union[float, int, str]],
    score_type: MaybeSequence[str]
) -> Tuple[Sequence[Union[float, int]], Union[float, int]]:
    """
    Find the best matches of a calibrated descriptor model in an image and
    return their 3D pose.

    Parameters
    ----------

    image : HObject
            Input image where the model should be found.

    model_id : HHandle
               The handle to the descriptor model.

    detector_param_name : Sequence[str]
                          The detector's parameter names.
                          Value Suggestion: []

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detector's parameters.
                           Value Suggestion: []

    descriptor_param_name : Sequence[str]
                            The descriptor's parameter names.
                            Value Suggestion: []

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptor's parameters.
                             Value Suggestion: []

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.2

    num_matches : int
                  Maximal number of found instances.
                  Value Suggestion: 1
                  Assertion: NumMatches >= 1

    cam_param : Sequence[Union[float, int, str]]
                Camera parameter (inner orientation) obtained from camera
                calibration.

    score_type : MaybeSequence[str]
                 Score type to be evaluated in Score.
                 Value Suggestion: num_points

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the object.

    score : Union[float, int]
            Score of the found instances according to the ScoreType input.

    See Also
    --------
    vector_to_pose, points_lepetit, create_calib_descriptor_model

    Predecessors
    ------------
    create_calib_descriptor_model, read_descriptor_model

    Notes
    -----
    Note that the domain of the search image should contain the whole
    object to be searched for because interest points are only extracted
    inside the domain of the search image. This means that if the domain
    does not contain the full object to be searched for, the resulting
    Score will decrease. Note also that matches may be found even if the
    reference point (origin) of the model lies outside of the domain of
    the search image. Both is in contrast to shape-based matching, where
    the domain of the search image defines the search space for the
    reference point of the model.
    """
    with HalconOperator(948) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, detector_param_name)
        proc.set_input_tuple(2, detector_param_value)
        proc.set_input_tuple(3, descriptor_param_name)
        proc.set_input_tuple(4, descriptor_param_value)
        proc.set_input_tuple(5, min_score)
        proc.set_input_tuple(6, num_matches)
        proc.set_input_tuple(7, cam_param)
        proc.set_input_tuple(8, score_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_s(1)   # score
        )  # type: ignore


def find_calib_object(
    image: HObject,
    calib_data_id: HHandle,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> None:
    """
    Find the HALCON calibration plate and set the extracted points and
    contours in a calibration data model.

    Parameters
    ----------

    image : HObject
            Input image.

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the calibration object.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object.
                         Value Suggestion: 0
                         Assertion: CalibObjPoseIdx >= 0

    gen_param_name : Sequence[str]
                     Names of the generic parameters to be set.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters to be set.
                      Value Suggestion: []

    Alternatives
    ------------
    find_caltab, find_marks_and_pose, set_calib_data_observ_points

    Predecessors
    ------------
    read_image, find_marks_and_pose, set_calib_data_cam_param,
    set_calib_data_calib_object

    Successors
    ----------
    set_calib_data, calibrate_cameras
    """
    with HalconOperator(1969) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, calib_obj_idx)
        proc.set_input_tuple(3, calib_obj_pose_idx)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.execute()


def find_caltab(
    image: HObject,
    cal_plate_descr: str,
    size_gauss: MaybeSequence[Union[int, str]],
    mark_thresh: MaybeSequence[Union[int, float]],
    min_diam_marks: int
) -> HObject:
    """
    Segment the region of a standard calibration plate with rectangularly
    arranged marks in the image.

    Parameters
    ----------

    image : HObject
            Input image.

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: caltab_100.descr

    size_gauss : MaybeSequence[Union[int, str]]
                 Filter size of the Gaussian.
                 Value Suggestion: 3

    mark_thresh : MaybeSequence[Union[int, float]]
                  Threshold value for mark extraction.
                  Value Suggestion: 112

    min_diam_marks : int
                     Expected minimal diameter of the marks on the
                     calibration plate.
                     Value Suggestion: 5

    Returns
    -------

    cal_plate : HObject
                Output region.

    See Also
    --------
    find_marks_and_pose, camera_calibration, disp_caltab, sim_caltab,
    caltab_points, gen_caltab

    Predecessors
    ------------
    read_image

    Successors
    ----------
    find_marks_and_pose
    """
    with HalconOperator(1948) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, cal_plate_descr)
        proc.set_input_tuple(1, size_gauss)
        proc.set_input_tuple(2, mark_thresh)
        proc.set_input_tuple(3, min_diam_marks)
        proc.execute()
        cal_plate = HObject(proc.get_output_object_key(1))
        return cal_plate  # type: ignore


def find_component_model(
    image: HObject,
    component_model_id: HHandle,
    root_component: MaybeSequence[int],
    angle_start_root: MaybeSequence[float],
    angle_extent_root: MaybeSequence[float],
    min_score: float,
    num_matches: int,
    max_overlap: float,
    if_root_not_found: str,
    if_component_not_found: str,
    pose_prediction: str,
    min_score_comp: MaybeSequence[float],
    sub_pixel_comp: MaybeSequence[str],
    num_levels_comp: MaybeSequence[int],
    greediness_comp: MaybeSequence[float]
) -> Tuple[Sequence[int], Sequence[int], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Find the best matches of a component model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the component model should be found.

    component_model_id : HHandle
                         Handle of the component model.

    root_component : MaybeSequence[int]
                     Index of the root component.

    angle_start_root : MaybeSequence[float]
                       Smallest rotation of the root component
                       Value Suggestion: -0.39

    angle_extent_root : MaybeSequence[float]
                        Extent of the rotation of the root component.
                        Value Suggestion: 0.79
                        Assertion: AngleExtentRoot >= 0

    min_score : float
                Minimum score of the instances of the component model to
                be found.
                Value Suggestion: 0.5
                Assertion: 0 <= MinScore && MinScore <= 1

    num_matches : int
                  Number of instances of the component model to be found
                  (or 0 for all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the component models
                  to be found.
                  Value Suggestion: 0.5
                  Assertion: 0 <= MaxOverlap && MaxOverlap <= 1

    if_root_not_found : str
                        Behavior if the root component is missing.
                        Value Suggestion: stop_search

    if_component_not_found : str
                             Behavior if a component is missing.
                             Value Suggestion: prune_branch

    pose_prediction : str
                      Pose prediction of components that are not found.
                      Value Suggestion: none

    min_score_comp : MaybeSequence[float]
                     Minimum score of the instances of the components to
                     be found.
                     Value Suggestion: 0.5
                     Assertion: 0 <= MinScoreComp && MinScoreComp <= 1

    sub_pixel_comp : MaybeSequence[str]
                     Subpixel accuracy of the component poses if not equal
                     to 'none'.
                     Value Suggestion: least_squares

    num_levels_comp : MaybeSequence[int]
                      Number of pyramid levels for the components used in
                      the matching (and lowest pyramid level to use if
                      $|NumLevelsComp| = 2n$).
                      Value Suggestion: 0

    greediness_comp : MaybeSequence[float]
                      ``Greediness'' of the search heuristic for the
                      components (0: safe but slow; 1: fast but matches
                      may be missed).
                      Value Suggestion: 0.9
                      Assertion: 0 <= GreedinessComp && GreedinessComp <= 1

    Returns
    -------

    model_start : Sequence[int]
                  Start index of each found instance of the component
                  model in the tuples describing the component matches.

    model_end : Sequence[int]
                End index of each found instance of the component model in
                the tuples describing the component matches.

    score : Sequence[float]
            Score of the found instances of the component model.

    row_comp : Sequence[float]
               Row coordinate of the found component matches.

    column_comp : Sequence[float]
                  Column coordinate of the found component matches.

    angle_comp : Sequence[float]
                 Rotation angle of the found component matches.

    score_comp : Sequence[float]
                 Score of the found component matches.

    model_comp : Sequence[int]
                 Index of the found components.

    See Also
    --------
    find_shape_model, find_shape_models, get_shape_model_params,
    get_component_model_params, train_model_components,
    set_shape_model_origin, smallest_rectangle2

    Alternatives
    ------------
    find_shape_models

    Predecessors
    ------------
    create_trained_component_model, create_component_model,
    read_component_model

    Successors
    ----------
    get_found_component_model
    """
    with HalconOperator(995) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, root_component)
        proc.set_input_tuple(2, angle_start_root)
        proc.set_input_tuple(3, angle_extent_root)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, num_matches)
        proc.set_input_tuple(6, max_overlap)
        proc.set_input_tuple(7, if_root_not_found)
        proc.set_input_tuple(8, if_component_not_found)
        proc.set_input_tuple(9, pose_prediction)
        proc.set_input_tuple(10, min_score_comp)
        proc.set_input_tuple(11, sub_pixel_comp)
        proc.set_input_tuple(12, num_levels_comp)
        proc.set_input_tuple(13, greediness_comp)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # model_start
            proc.get_output_tuple_m(1),  # model_end
            proc.get_output_tuple_m(2),  # score
            proc.get_output_tuple_m(3),  # row_comp
            proc.get_output_tuple_m(4),  # column_comp
            proc.get_output_tuple_m(5),  # angle_comp
            proc.get_output_tuple_m(6),  # score_comp
            proc.get_output_tuple_m(7)   # model_comp
        )  # type: ignore


def find_component_model_s(
    image: HObject,
    component_model_id: HHandle,
    root_component: MaybeSequence[int],
    angle_start_root: MaybeSequence[float],
    angle_extent_root: MaybeSequence[float],
    min_score: float,
    num_matches: int,
    max_overlap: float,
    if_root_not_found: str,
    if_component_not_found: str,
    pose_prediction: str,
    min_score_comp: MaybeSequence[float],
    sub_pixel_comp: MaybeSequence[str],
    num_levels_comp: MaybeSequence[int],
    greediness_comp: MaybeSequence[float]
) -> Tuple[int, int, float, float, float, float, float, int]:
    """
    Find the best matches of a component model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the component model should be found.

    component_model_id : HHandle
                         Handle of the component model.

    root_component : MaybeSequence[int]
                     Index of the root component.

    angle_start_root : MaybeSequence[float]
                       Smallest rotation of the root component
                       Value Suggestion: -0.39

    angle_extent_root : MaybeSequence[float]
                        Extent of the rotation of the root component.
                        Value Suggestion: 0.79
                        Assertion: AngleExtentRoot >= 0

    min_score : float
                Minimum score of the instances of the component model to
                be found.
                Value Suggestion: 0.5
                Assertion: 0 <= MinScore && MinScore <= 1

    num_matches : int
                  Number of instances of the component model to be found
                  (or 0 for all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the component models
                  to be found.
                  Value Suggestion: 0.5
                  Assertion: 0 <= MaxOverlap && MaxOverlap <= 1

    if_root_not_found : str
                        Behavior if the root component is missing.
                        Value Suggestion: stop_search

    if_component_not_found : str
                             Behavior if a component is missing.
                             Value Suggestion: prune_branch

    pose_prediction : str
                      Pose prediction of components that are not found.
                      Value Suggestion: none

    min_score_comp : MaybeSequence[float]
                     Minimum score of the instances of the components to
                     be found.
                     Value Suggestion: 0.5
                     Assertion: 0 <= MinScoreComp && MinScoreComp <= 1

    sub_pixel_comp : MaybeSequence[str]
                     Subpixel accuracy of the component poses if not equal
                     to 'none'.
                     Value Suggestion: least_squares

    num_levels_comp : MaybeSequence[int]
                      Number of pyramid levels for the components used in
                      the matching (and lowest pyramid level to use if
                      $|NumLevelsComp| = 2n$).
                      Value Suggestion: 0

    greediness_comp : MaybeSequence[float]
                      ``Greediness'' of the search heuristic for the
                      components (0: safe but slow; 1: fast but matches
                      may be missed).
                      Value Suggestion: 0.9
                      Assertion: 0 <= GreedinessComp && GreedinessComp <= 1

    Returns
    -------

    model_start : int
                  Start index of each found instance of the component
                  model in the tuples describing the component matches.

    model_end : int
                End index of each found instance of the component model in
                the tuples describing the component matches.

    score : float
            Score of the found instances of the component model.

    row_comp : float
               Row coordinate of the found component matches.

    column_comp : float
                  Column coordinate of the found component matches.

    angle_comp : float
                 Rotation angle of the found component matches.

    score_comp : float
                 Score of the found component matches.

    model_comp : int
                 Index of the found components.

    See Also
    --------
    find_shape_model, find_shape_models, get_shape_model_params,
    get_component_model_params, train_model_components,
    set_shape_model_origin, smallest_rectangle2

    Alternatives
    ------------
    find_shape_models

    Predecessors
    ------------
    create_trained_component_model, create_component_model,
    read_component_model

    Successors
    ----------
    get_found_component_model
    """
    with HalconOperator(995) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, root_component)
        proc.set_input_tuple(2, angle_start_root)
        proc.set_input_tuple(3, angle_extent_root)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, num_matches)
        proc.set_input_tuple(6, max_overlap)
        proc.set_input_tuple(7, if_root_not_found)
        proc.set_input_tuple(8, if_component_not_found)
        proc.set_input_tuple(9, pose_prediction)
        proc.set_input_tuple(10, min_score_comp)
        proc.set_input_tuple(11, sub_pixel_comp)
        proc.set_input_tuple(12, num_levels_comp)
        proc.set_input_tuple(13, greediness_comp)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # model_start
            proc.get_output_tuple_s(1),  # model_end
            proc.get_output_tuple_s(2),  # score
            proc.get_output_tuple_s(3),  # row_comp
            proc.get_output_tuple_s(4),  # column_comp
            proc.get_output_tuple_s(5),  # angle_comp
            proc.get_output_tuple_s(6),  # score_comp
            proc.get_output_tuple_s(7)   # model_comp
        )  # type: ignore


def find_data_code_2d(
    image: HObject,
    data_code_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> Tuple[HObject, Sequence[int], Sequence[str]]:
    """
    Detect and read 2D data code symbols in an image or train the 2D data
    code model.

    Parameters
    ----------

    image : HObject
            Input image. If the image has a reduced domain, the data code
            search is reduced to that domain. This usually reduces the
            runtime of the operator. However, if the datacode is not fully
            inside the domain, the datacode might not be found correctly.
            In rare cases, data codes may be found outside the domain. If
            these results  are undesirable, they have to be subsequently
            eliminated.

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    gen_param_name : MaybeSequence[str]
                     Names of (optional) parameters for controlling the
                     behavior of the operator.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the optional generic parameters.
                      Value Suggestion: []

    Returns
    -------

    symbol_xlds : HObject
                  XLD contours that surround the successfully decoded data
                  code symbols. The order of the contour points reflects
                  the orientation of the detected symbols. The contours
                  begin in the top left corner (see 'orientation' at
                  get_data_code_2d_results) and continue clockwise.
                  Alignment{left}
                  Figure[1][1][60]{get_data_code_2d_results-xld_qrcode}
                  Order of points of SymbolXLDs Figure Alignment $

    result_handles : Sequence[int]
                     Handles of all successfully decoded 2D data code
                     symbols.

    decoded_data_strings : Sequence[str]
                           Decoded data strings of all detected 2D data
                           code symbols in the image.

    See Also
    --------
    create_data_code_2d_model, set_data_code_2d_param,
    get_data_code_2d_results, get_data_code_2d_objects

    Predecessors
    ------------
    create_data_code_2d_model, read_data_code_2d_model,
    set_data_code_2d_param

    Successors
    ----------
    get_data_code_2d_results, get_data_code_2d_objects,
    write_data_code_2d_model
    """
    with HalconOperator(1768) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # symbol_xlds
            proc.get_output_tuple_m(0),  # result_handles
            proc.get_output_tuple_m(1)   # decoded_data_strings
        )  # type: ignore


def find_data_code_2d_s(
    image: HObject,
    data_code_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> Tuple[HObject, int, str]:
    """
    Detect and read 2D data code symbols in an image or train the 2D data
    code model.

    Parameters
    ----------

    image : HObject
            Input image. If the image has a reduced domain, the data code
            search is reduced to that domain. This usually reduces the
            runtime of the operator. However, if the datacode is not fully
            inside the domain, the datacode might not be found correctly.
            In rare cases, data codes may be found outside the domain. If
            these results  are undesirable, they have to be subsequently
            eliminated.

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    gen_param_name : MaybeSequence[str]
                     Names of (optional) parameters for controlling the
                     behavior of the operator.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the optional generic parameters.
                      Value Suggestion: []

    Returns
    -------

    symbol_xlds : HObject
                  XLD contours that surround the successfully decoded data
                  code symbols. The order of the contour points reflects
                  the orientation of the detected symbols. The contours
                  begin in the top left corner (see 'orientation' at
                  get_data_code_2d_results) and continue clockwise.
                  Alignment{left}
                  Figure[1][1][60]{get_data_code_2d_results-xld_qrcode}
                  Order of points of SymbolXLDs Figure Alignment $

    result_handles : int
                     Handles of all successfully decoded 2D data code
                     symbols.

    decoded_data_strings : str
                           Decoded data strings of all detected 2D data
                           code symbols in the image.

    See Also
    --------
    create_data_code_2d_model, set_data_code_2d_param,
    get_data_code_2d_results, get_data_code_2d_objects

    Predecessors
    ------------
    create_data_code_2d_model, read_data_code_2d_model,
    set_data_code_2d_param

    Successors
    ----------
    get_data_code_2d_results, get_data_code_2d_objects,
    write_data_code_2d_model
    """
    with HalconOperator(1768) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # symbol_xlds
            proc.get_output_tuple_s(0),  # result_handles
            proc.get_output_tuple_s(1)   # decoded_data_strings
        )  # type: ignore


def find_deformable_surface_model(
    deformable_surface_model: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    min_score: Union[float, int],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[float], Sequence[HHandle]]:
    """
    Find the best match of a deformable surface model in a 3D scene.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Scene sampling distance relative to the
                            diameter of the surface model.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    min_score : Union[float, int]
                Minimum score of the returned match.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    score : Sequence[float]
            Score of the found instances of the surface model.

    deformable_surface_matching_result : Sequence[HHandle]
                                         Handle of the matching result.

    See Also
    --------
    refine_deformable_surface_model

    Alternatives
    ------------
    refine_deformable_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_deformable_surface_model,
    create_deformable_surface_model, get_deformable_surface_model_param,
    add_deformable_surface_model_reference_point,
    add_deformable_surface_model_sample

    Successors
    ----------
    refine_deformable_surface_model,
    get_deformable_surface_matching_result,
    clear_deformable_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(1027) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # score
            proc.get_output_tuple_m(1)   # deformable_surface_matching_result
        )  # type: ignore


def find_deformable_surface_model_s(
    deformable_surface_model: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    min_score: Union[float, int],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[float, HHandle]:
    """
    Find the best match of a deformable surface model in a 3D scene.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Scene sampling distance relative to the
                            diameter of the surface model.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    min_score : Union[float, int]
                Minimum score of the returned match.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    score : float
            Score of the found instances of the surface model.

    deformable_surface_matching_result : HHandle
                                         Handle of the matching result.

    See Also
    --------
    refine_deformable_surface_model

    Alternatives
    ------------
    refine_deformable_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_deformable_surface_model,
    create_deformable_surface_model, get_deformable_surface_model_param,
    add_deformable_surface_model_reference_point,
    add_deformable_surface_model_sample

    Successors
    ----------
    refine_deformable_surface_model,
    get_deformable_surface_matching_result,
    clear_deformable_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(1027) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # score
            proc.get_output_tuple_s(1)   # deformable_surface_matching_result
        )  # type: ignore


def find_local_deformable_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    scale_rmin: float,
    scale_rmax: float,
    scale_cmin: float,
    scale_cmax: float,
    min_score: float,
    num_matches: int,
    max_overlap: float,
    num_levels: int,
    greediness: float,
    result_type: Sequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> Tuple[HObject, HObject, HObject, Sequence[float], Sequence[float], Sequence[float]]:
    """
    Find the best matches of a local deformable model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    scale_rmin : float
                 Minimum scale of the model in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : float
                 Maximum scale of the model in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMax >= ScaleRMin

    scale_cmin : float
                 Minimum scale of the model in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : float
                 Maximum scale of the model in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMax >= ScaleCMin

    min_score : float
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.5

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 1.0

    num_levels : int
                 Number of pyramid levels used in the matching.
                 Value Suggestion: 0

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    result_type : Sequence[str]
                  Switch for requested iconic result.
                  Value Suggestion: []

    gen_param_name : Sequence[str]
                     The general parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the general parameters.
                      Value Suggestion: []

    Returns
    -------

    image_rectified : HObject
                      Rectified image of the found model.

    vector_field : HObject
                   Vector field of the rectification transformation.

    deformed_contours : HObject
                        Contours of the found instances of the model.

    score : Sequence[float]
            Scores of the found instances of the model.

    row : Sequence[float]
          Row coordinates of the found instances of the model.

    column : Sequence[float]
             Column coordinates of the found instances of the model.

    Predecessors
    ------------
    create_local_deformable_model, create_local_deformable_model_xld,
    read_deformable_model
    """
    with HalconOperator(969) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_rmin)
        proc.set_input_tuple(4, scale_rmax)
        proc.set_input_tuple(5, scale_cmin)
        proc.set_input_tuple(6, scale_cmax)
        proc.set_input_tuple(7, min_score)
        proc.set_input_tuple(8, num_matches)
        proc.set_input_tuple(9, max_overlap)
        proc.set_input_tuple(10, num_levels)
        proc.set_input_tuple(11, greediness)
        proc.set_input_tuple(12, result_type)
        proc.set_input_tuple(13, gen_param_name)
        proc.set_input_tuple(14, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_rectified
            HObject(proc.get_output_object_key(2)),  # vector_field
            HObject(proc.get_output_object_key(3)),  # deformed_contours
            proc.get_output_tuple_m(0),  # score
            proc.get_output_tuple_m(1),  # row
            proc.get_output_tuple_m(2)   # column
        )  # type: ignore


def find_marks_and_pose(
    image: HObject,
    cal_plate_region: HObject,
    cal_plate_descr: str,
    start_cam_param: Sequence[Union[int, float, str]],
    start_thresh: int,
    delta_thresh: int,
    min_thresh: int,
    alpha: float,
    min_cont_length: float,
    max_diam_marks: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[Union[float, int]]]:
    """
    Extract rectangularly arranged 2D calibration marks from the image and
    calculate initial values for the external camera parameters.

    Parameters
    ----------

    image : HObject
            Input image.

    cal_plate_region : HObject
                       Region of the calibration plate.

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: caltab_100.descr

    start_cam_param : Sequence[Union[int, float, str]]
                      Initial values for the internal camera parameters.

    start_thresh : int
                   Initial threshold value for contour detection.
                   Value Suggestion: 128
                   Assertion: StartThresh > 0

    delta_thresh : int
                   Loop value for successive reduction of StartThresh.
                   Value Suggestion: 10
                   Assertion: DeltaThresh > 0

    min_thresh : int
                 Minimum threshold for contour detection.
                 Value Suggestion: 18
                 Assertion: MinThresh > 0

    alpha : float
            Filter parameter for contour detection, see edges_image.
            Value Suggestion: 0.9
            Assertion: Alpha > 0.0

    min_cont_length : float
                      Minimum length of the contours of the marks.
                      Value Suggestion: 15.0
                      Assertion: MinContLength > 0.0

    max_diam_marks : float
                     Maximum expected diameter of the marks.
                     Value Suggestion: 100.0
                     Assertion: MaxDiamMarks > 0.0

    Returns
    -------

    rcoord : Sequence[float]
             Tuple with row coordinates of the detected marks.

    ccoord : Sequence[float]
             Tuple with column coordinates of the detected marks.

    start_pose : Sequence[Union[float, int]]
                 Estimation for the external camera parameters.

    See Also
    --------
    find_caltab, camera_calibration, disp_caltab, sim_caltab,
    read_cam_par, read_pose, create_pose, pose_to_hom_mat3d,
    caltab_points, gen_caltab, edges_sub_pix, edges_image

    Predecessors
    ------------
    find_caltab

    Successors
    ----------
    camera_calibration
    """
    with HalconOperator(1947) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, cal_plate_region)
        proc.set_input_tuple(0, cal_plate_descr)
        proc.set_input_tuple(1, start_cam_param)
        proc.set_input_tuple(2, start_thresh)
        proc.set_input_tuple(3, delta_thresh)
        proc.set_input_tuple(4, min_thresh)
        proc.set_input_tuple(5, alpha)
        proc.set_input_tuple(6, min_cont_length)
        proc.set_input_tuple(7, max_diam_marks)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rcoord
            proc.get_output_tuple_m(1),  # ccoord
            proc.get_output_tuple_m(2)   # start_pose
        )  # type: ignore


def find_ncc_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    min_score: float,
    num_matches: int,
    max_overlap: float,
    sub_pixel: str,
    num_levels: MaybeSequence[int]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Find the best matches of an NCC model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    min_score : float
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.8

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : str
                Subpixel accuracy.
                Value Suggestion: true

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the model.

    column : Sequence[float]
             Column coordinate of the found instances of the model.

    angle : Sequence[float]
            Rotation angle of the found instances of the model.

    score : Sequence[float]
            Score of the found instances of the model.

    Alternatives
    ------------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models

    Predecessors
    ------------
    create_ncc_model, read_ncc_model, set_ncc_model_origin

    Successors
    ----------
    clear_ncc_model

    Notes
    -----
    find_ncc_model can be partially executed on OpenCL devices that
    support the cl_khr_global_int32_base_atomics OpenCL extension. Only
    the initial search for the model in the topmost pyramid level is done
    on the OpenCL device, while the tracking of matches is done on the
    host CPU. If the domain of the image to search in is substantially
    smaller than the size of the image, use crop_domain to reduce the
    amount of data that needs to be copied from the OpenCL device to the
    host CPU. Note that find_ncc_model using OpenCL may run either
    substantially faster or slower depending on a wide number of factors,
    so the only way to tell if using OpenCL is beneficial is by testing
    with images from the actual application.
    Furthermore, note that the internally used memory increases with the
    number of used threads.
    """
    with HalconOperator(991) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, num_matches)
        proc.set_input_tuple(5, max_overlap)
        proc.set_input_tuple(6, sub_pixel)
        proc.set_input_tuple(7, num_levels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3)   # score
        )  # type: ignore


def find_ncc_models(
    image: HObject,
    model_ids: MaybeSequence[HHandle],
    angle_start: MaybeSequence[float],
    angle_extent: MaybeSequence[float],
    min_score: MaybeSequence[float],
    num_matches: MaybeSequence[int],
    max_overlap: MaybeSequence[float],
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Find the best matches of multiple NCC models.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_ids : MaybeSequence[HHandle]
                Handle of the models.

    angle_start : MaybeSequence[float]
                  Smallest rotation of the models.
                  Value Suggestion: -0.39

    angle_extent : MaybeSequence[float]
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.8

    num_matches : MaybeSequence[int]
                  Number of instances of the models to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : MaybeSequence[float]
                  Maximum overlap of the instances of the models to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: true

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the models.

    column : Sequence[float]
             Column coordinate of the found instances of the models.

    angle : Sequence[float]
            Rotation angle of the found instances of the models.

    score : Sequence[float]
            Score of the found instances of the models.

    model : Sequence[int]
            Index of the found instances of the models.

    Alternatives
    ------------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models

    Predecessors
    ------------
    create_ncc_model, read_ncc_model, set_ncc_model_origin

    Successors
    ----------
    clear_ncc_model

    Notes
    -----
    Note that the internally used memory increases with the number of used
    threads.
    """
    with HalconOperator(2068) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_ids)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, num_matches)
        proc.set_input_tuple(5, max_overlap)
        proc.set_input_tuple(6, sub_pixel)
        proc.set_input_tuple(7, num_levels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3),  # score
            proc.get_output_tuple_m(4)   # model
        )  # type: ignore


def find_neighbors(
    regions_1: HObject,
    regions_2: HObject,
    max_distance: int
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Search direct neighbors.

    Parameters
    ----------

    regions_1 : HObject
                Starting regions.

    regions_2 : HObject
                Comparative regions.

    max_distance : int
                   Maximal distance of regions.
                   Value Suggestion: 1

    Returns
    -------

    region_index_1 : Sequence[int]
                     Indices of the found regions from Regions1.

    region_index_2 : Sequence[int]
                     Indices of the found regions from Regions2.

    See Also
    --------
    spatial_relation, select_region_spatial, expand_region,
    distance_transform, interjacent, boundary

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    Covered regions are not found!
    """
    with HalconOperator(1705) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.set_input_tuple(0, max_distance)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # region_index_1
            proc.get_output_tuple_m(1)   # region_index_2
        )  # type: ignore


def find_planar_calib_deformable_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    scale_rmin: float,
    scale_rmax: float,
    scale_cmin: float,
    scale_cmax: float,
    min_score: float,
    num_matches: int,
    max_overlap: float,
    num_levels: MaybeSequence[int],
    greediness: float,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], Sequence[float]]:
    """
    Find the best matches of a calibrated deformable model in an image and
    return their 3D pose.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.78
                   Assertion: AngleExtent >= 0

    scale_rmin : float
                 Minimum scale of the model in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : float
                 Maximum scale of the model in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMax >= ScaleRMin

    scale_cmin : float
                 Minimum scale of the model in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : float
                 Maximum scale of the model in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMax >= ScaleCMin

    min_score : float
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.5

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 1.0

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    gen_param_name : Sequence[str]
                     The general parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the general parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           Pose of the object.

    cov_pose : Sequence[float]
               6 standard deviations or 36 covariances of the pose
               parameters.

    score : Sequence[float]
            Score of the found instances of the model.

    Predecessors
    ------------
    create_planar_calib_deformable_model, read_deformable_model
    """
    with HalconOperator(970) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_rmin)
        proc.set_input_tuple(4, scale_rmax)
        proc.set_input_tuple(5, scale_cmin)
        proc.set_input_tuple(6, scale_cmax)
        proc.set_input_tuple(7, min_score)
        proc.set_input_tuple(8, num_matches)
        proc.set_input_tuple(9, max_overlap)
        proc.set_input_tuple(10, num_levels)
        proc.set_input_tuple(11, greediness)
        proc.set_input_tuple(12, gen_param_name)
        proc.set_input_tuple(13, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # cov_pose
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def find_planar_uncalib_deformable_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    scale_rmin: float,
    scale_rmax: float,
    scale_cmin: float,
    scale_cmax: float,
    min_score: float,
    num_matches: int,
    max_overlap: float,
    num_levels: MaybeSequence[int],
    greediness: float,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Find the best matches of a planar projective invariant deformable
    model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.78
                   Assertion: AngleExtent >= 0

    scale_rmin : float
                 Minimum scale of the model in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMin > 0

    scale_rmax : float
                 Maximum scale of the model in row direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleRMax >= ScaleRMin

    scale_cmin : float
                 Minimum scale of the model in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMin > 0

    scale_cmax : float
                 Maximum scale of the model in column direction.
                 Value Suggestion: 1.0
                 Assertion: ScaleCMax >= ScaleCMin

    min_score : float
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.5

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 1.0

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    gen_param_name : Sequence[str]
                     The general parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the general parameters.
                      Value Suggestion: []

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homographies between model and found instances.

    score : Sequence[float]
            Score of the found instances of the model.

    Alternatives
    ------------
    find_planar_calib_deformable_model

    Predecessors
    ------------
    create_planar_uncalib_deformable_model, read_deformable_model
    """
    with HalconOperator(971) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_rmin)
        proc.set_input_tuple(4, scale_rmax)
        proc.set_input_tuple(5, scale_cmin)
        proc.set_input_tuple(6, scale_cmax)
        proc.set_input_tuple(7, min_score)
        proc.set_input_tuple(8, num_matches)
        proc.set_input_tuple(9, max_overlap)
        proc.set_input_tuple(10, num_levels)
        proc.set_input_tuple(11, greediness)
        proc.set_input_tuple(12, gen_param_name)
        proc.set_input_tuple(13, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_m(1)   # score
        )  # type: ignore


def find_rectification_grid(
    image: HObject,
    min_contrast: Union[int, float],
    radius: Union[float, int]
) -> HObject:
    """
    Segment the rectification grid region in the image.

    Parameters
    ----------

    image : HObject
            Input image.

    min_contrast : Union[int, float]
                   Minimum contrast.
                   Value Suggestion: 8.0
                   Assertion: MinContrast >= 0

    radius : Union[float, int]
             Radius of the circular structuring element.
             Value Suggestion: 7.5
             Assertion: Radius >= 0.5

    Returns
    -------

    grid_region : HObject
                  Output region containing the rectification grid.

    Successors
    ----------
    dilation_circle, reduce_domain
    """
    with HalconOperator(1156) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, min_contrast)
        proc.set_input_tuple(1, radius)
        proc.execute()
        grid_region = HObject(proc.get_output_object_key(1))
        return grid_region  # type: ignore


def find_scaled_shape_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    scale_min: float,
    scale_max: float,
    min_score: MaybeSequence[float],
    num_matches: int,
    max_overlap: float,
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int],
    greediness: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Find the best matches of an isotropically scaled shape model in an
    image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.78
                   Assertion: AngleExtent >= 0

    scale_min : float
                Minimum scale of the model.
                Value Suggestion: 0.9
                Assertion: ScaleMin > 0

    scale_max : float
                Maximum scale of the model.
                Value Suggestion: 1.1
                Assertion: ScaleMax >= ScaleMin

    min_score : MaybeSequence[float]
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.5

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: least_squares

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the model.

    column : Sequence[float]
             Column coordinate of the found instances of the model.

    angle : Sequence[float]
            Rotation angle of the found instances of the model.

    scale : Sequence[float]
            Scale of the found instances of the model.

    score : Sequence[float]
            Score of the found instances of the model.

    See Also
    --------
    set_system, get_system, set_shape_model_param

    Alternatives
    ------------
    find_shape_model, find_aniso_shape_model, find_shape_models,
    find_scaled_shape_models, find_aniso_shape_models, find_ncc_model,
    find_ncc_models

    Predecessors
    ------------
    create_scaled_shape_model, read_shape_model, set_shape_model_origin,
    set_shape_model_clutter

    Successors
    ----------
    clear_shape_model
    """
    with HalconOperator(931) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_min)
        proc.set_input_tuple(4, scale_max)
        proc.set_input_tuple(5, min_score)
        proc.set_input_tuple(6, num_matches)
        proc.set_input_tuple(7, max_overlap)
        proc.set_input_tuple(8, sub_pixel)
        proc.set_input_tuple(9, num_levels)
        proc.set_input_tuple(10, greediness)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3),  # scale
            proc.get_output_tuple_m(4)   # score
        )  # type: ignore


def find_scaled_shape_models(
    image: HObject,
    model_ids: MaybeSequence[HHandle],
    angle_start: MaybeSequence[float],
    angle_extent: MaybeSequence[float],
    scale_min: MaybeSequence[float],
    scale_max: MaybeSequence[float],
    min_score: MaybeSequence[float],
    num_matches: MaybeSequence[int],
    max_overlap: MaybeSequence[float],
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int],
    greediness: MaybeSequence[float]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Find the best matches of multiple isotropically scaled shape models.

    Parameters
    ----------

    image : HObject
            Input image in which the models should be found.

    model_ids : MaybeSequence[HHandle]
                Handle of the models.

    angle_start : MaybeSequence[float]
                  Smallest rotation of the models.
                  Value Suggestion: -0.39

    angle_extent : MaybeSequence[float]
                   Extent of the rotation angles.
                   Value Suggestion: 0.78
                   Assertion: AngleExtent >= 0

    scale_min : MaybeSequence[float]
                Minimum scale of the models.
                Value Suggestion: 0.9
                Assertion: ScaleMin > 0

    scale_max : MaybeSequence[float]
                Maximum scale of the models.
                Value Suggestion: 1.1
                Assertion: ScaleMax >= ScaleMin

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.5

    num_matches : MaybeSequence[int]
                  Number of instances of the models to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : MaybeSequence[float]
                  Maximum overlap of the instances of the models to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: least_squares

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : MaybeSequence[float]
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the models.

    column : Sequence[float]
             Column coordinate of the found instances of the models.

    angle : Sequence[float]
            Rotation angle of the found instances of the models.

    scale : Sequence[float]
            Scale of the found instances of the models.

    score : Sequence[float]
            Score of the found instances of the models.

    model : Sequence[int]
            Index of the found instances of the models.

    See Also
    --------
    set_system, get_system, set_shape_model_param

    Alternatives
    ------------
    find_shape_models, find_aniso_shape_models, find_shape_model,
    find_scaled_shape_model, find_aniso_shape_model, find_ncc_model,
    find_ncc_models

    Predecessors
    ------------
    add_channels, create_scaled_shape_model, read_shape_model,
    set_shape_model_origin, set_shape_model_clutter

    Successors
    ----------
    clear_shape_model
    """
    with HalconOperator(928) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_ids)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, scale_min)
        proc.set_input_tuple(4, scale_max)
        proc.set_input_tuple(5, min_score)
        proc.set_input_tuple(6, num_matches)
        proc.set_input_tuple(7, max_overlap)
        proc.set_input_tuple(8, sub_pixel)
        proc.set_input_tuple(9, num_levels)
        proc.set_input_tuple(10, greediness)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3),  # scale
            proc.get_output_tuple_m(4),  # score
            proc.get_output_tuple_m(5)   # model
        )  # type: ignore


def find_shape_model(
    image: HObject,
    model_id: HHandle,
    angle_start: float,
    angle_extent: float,
    min_score: MaybeSequence[float],
    num_matches: int,
    max_overlap: float,
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int],
    greediness: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Find the best matches of a shape model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    model_id : HHandle
               Handle of the model.

    angle_start : float
                  Smallest rotation of the model.
                  Value Suggestion: -0.39

    angle_extent : float
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    min_score : MaybeSequence[float]
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.5

    num_matches : int
                  Number of instances of the model to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : float
                  Maximum overlap of the instances of the model to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: least_squares

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the model.

    column : Sequence[float]
             Column coordinate of the found instances of the model.

    angle : Sequence[float]
            Rotation angle of the found instances of the model.

    score : Sequence[float]
            Score of the found instances of the model.

    See Also
    --------
    set_system, get_system, set_shape_model_param

    Alternatives
    ------------
    find_scaled_shape_model, find_aniso_shape_model,
    find_scaled_shape_models, find_shape_models, find_aniso_shape_models,
    find_ncc_model, find_ncc_models

    Predecessors
    ------------
    create_shape_model, read_shape_model, set_shape_model_origin,
    set_shape_model_clutter

    Successors
    ----------
    clear_shape_model
    """
    with HalconOperator(932) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, num_matches)
        proc.set_input_tuple(5, max_overlap)
        proc.set_input_tuple(6, sub_pixel)
        proc.set_input_tuple(7, num_levels)
        proc.set_input_tuple(8, greediness)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3)   # score
        )  # type: ignore


def find_shape_model_3d(
    image: HObject,
    shape_model_3did: HHandle,
    min_score: float,
    greediness: float,
    num_levels: Sequence[int],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[Union[int, float]], Sequence[float], Sequence[float]]:
    """
    Find the best matches of a 3D shape model in an image.

    Parameters
    ----------

    image : HObject
            Input image in which the model should be found.

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    min_score : float
                Minimum score of the instances of the model to be found.
                Value Suggestion: 0.7

    greediness : float
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    num_levels : Sequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    gen_param_name : Sequence[str]
                     Names of (optional) parameters for controlling the
                     behavior of the operator.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the optional generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[int, float]]
           3D pose of the 3D shape model.

    cov_pose : Sequence[float]
               6 standard deviations or 36 covariances of the pose
               parameters.

    score : Sequence[float]
            Score of the found instances of the 3D shape model.

    See Also
    --------
    convert_point_3d_cart_to_spher, convert_point_3d_spher_to_cart,
    create_cam_pose_look_at_point, trans_pose_shape_model_3d

    Predecessors
    ------------
    create_shape_model_3d, read_shape_model_3d

    Successors
    ----------
    project_shape_model_3d
    """
    with HalconOperator(1058) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, min_score)
        proc.set_input_tuple(2, greediness)
        proc.set_input_tuple(3, num_levels)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # cov_pose
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def find_shape_models(
    image: HObject,
    model_ids: MaybeSequence[HHandle],
    angle_start: MaybeSequence[float],
    angle_extent: MaybeSequence[float],
    min_score: MaybeSequence[float],
    num_matches: MaybeSequence[int],
    max_overlap: MaybeSequence[float],
    sub_pixel: MaybeSequence[str],
    num_levels: MaybeSequence[int],
    greediness: MaybeSequence[float]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Find the best matches of multiple shape models.

    Parameters
    ----------

    image : HObject
            Input image in which the models should be found.

    model_ids : MaybeSequence[HHandle]
                Handle of the models.

    angle_start : MaybeSequence[float]
                  Smallest rotation of the models.
                  Value Suggestion: -0.39

    angle_extent : MaybeSequence[float]
                   Extent of the rotation angles.
                   Value Suggestion: 0.79
                   Assertion: AngleExtent >= 0

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.5

    num_matches : MaybeSequence[int]
                  Number of instances of the models to be found (or 0 for
                  all matches).
                  Value Suggestion: 1

    max_overlap : MaybeSequence[float]
                  Maximum overlap of the instances of the models to be
                  found.
                  Value Suggestion: 0.5

    sub_pixel : MaybeSequence[str]
                Subpixel accuracy if not equal to 'none'.
                Value Suggestion: least_squares

    num_levels : MaybeSequence[int]
                 Number of pyramid levels used in the matching (and lowest
                 pyramid level to use if $|NumLevels| = 2$).
                 Value Suggestion: 0

    greediness : MaybeSequence[float]
                 ``Greediness'' of the search heuristic (0: safe but slow;
                 1: fast but matches may be missed).
                 Value Suggestion: 0.9

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the found instances of the models.

    column : Sequence[float]
             Column coordinate of the found instances of the models.

    angle : Sequence[float]
            Rotation angle of the found instances of the models.

    score : Sequence[float]
            Score of the found instances of the models.

    model : Sequence[int]
            Index of the found instances of the models.

    See Also
    --------
    set_system, get_system

    Alternatives
    ------------
    find_scaled_shape_models, find_aniso_shape_models, find_shape_model,
    find_scaled_shape_model, find_aniso_shape_model, find_ncc_model,
    find_ncc_models

    Predecessors
    ------------
    add_channels, create_shape_model, read_shape_model,
    set_shape_model_origin, set_shape_model_param, set_shape_model_clutter

    Successors
    ----------
    clear_shape_model
    """
    with HalconOperator(929) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_ids)
        proc.set_input_tuple(1, angle_start)
        proc.set_input_tuple(2, angle_extent)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, num_matches)
        proc.set_input_tuple(5, max_overlap)
        proc.set_input_tuple(6, sub_pixel)
        proc.set_input_tuple(7, num_levels)
        proc.set_input_tuple(8, greediness)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3),  # score
            proc.get_output_tuple_m(4)   # model
        )  # type: ignore


def find_surface_model(
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    key_point_fraction: float,
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], Sequence[HHandle]]:
    """
    Find the best matches of a surface model in a 3D scene.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Scene sampling distance relative to the
                            diameter of the surface model.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    key_point_fraction : float
                         Fraction of sampled scene points used as key
                         points.
                         Value Suggestion: 0.2
                         Assertion: 0 < KeyPointFraction <= 1

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the surface model.

    surface_matching_result_id : Sequence[HHandle]
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    refine_surface_model_pose, find_surface_model_image

    Alternatives
    ------------
    refine_surface_model_pose, find_surface_model_image,
    refine_surface_model_pose_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, edges_object_model_3d

    Successors
    ----------
    refine_surface_model_pose, get_surface_matching_result,
    clear_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(1042) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, key_point_fraction)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, return_result_handle)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_m(2)   # surface_matching_result_id
        )  # type: ignore


def find_surface_model_image(
    image: HObject,
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    key_point_fraction: float,
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], Sequence[HHandle]]:
    """
    Find the best matches of a surface model in a 3D scene and images.

    Parameters
    ----------

    image : HObject
            Images of the scene.

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Scene sampling distance relative to the
                            diameter of the surface model.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    key_point_fraction : float
                         Fraction of sampled scene points used as key
                         points.
                         Value Suggestion: 0.2
                         Assertion: 0 < KeyPointFraction <= 1

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the surface model.

    surface_matching_result_id : Sequence[HHandle]
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    refine_surface_model_pose, find_surface_model

    Alternatives
    ------------
    refine_surface_model_pose, find_surface_model,
    refine_surface_model_pose_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, edges_object_model_3d

    Successors
    ----------
    refine_surface_model_pose, get_surface_matching_result,
    clear_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(2069) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, key_point_fraction)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, return_result_handle)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_m(2)   # surface_matching_result_id
        )  # type: ignore


def find_surface_model_image_s(
    image: HObject,
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    key_point_fraction: float,
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], HHandle]:
    """
    Find the best matches of a surface model in a 3D scene and images.

    Parameters
    ----------

    image : HObject
            Images of the scene.

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Scene sampling distance relative to the
                            diameter of the surface model.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    key_point_fraction : float
                         Fraction of sampled scene points used as key
                         points.
                         Value Suggestion: 0.2
                         Assertion: 0 < KeyPointFraction <= 1

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the surface model.

    surface_matching_result_id : HHandle
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    refine_surface_model_pose, find_surface_model

    Alternatives
    ------------
    refine_surface_model_pose, find_surface_model,
    refine_surface_model_pose_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, edges_object_model_3d

    Successors
    ----------
    refine_surface_model_pose, get_surface_matching_result,
    clear_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(2069) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, key_point_fraction)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, return_result_handle)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_s(2)   # surface_matching_result_id
        )  # type: ignore


def find_surface_model_s(
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    key_point_fraction: float,
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], HHandle]:
    """
    Find the best matches of a surface model in a 3D scene.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Scene sampling distance relative to the
                            diameter of the surface model.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    key_point_fraction : float
                         Fraction of sampled scene points used as key
                         points.
                         Value Suggestion: 0.2
                         Assertion: 0 < KeyPointFraction <= 1

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the surface model.

    surface_matching_result_id : HHandle
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    refine_surface_model_pose, find_surface_model_image

    Alternatives
    ------------
    refine_surface_model_pose, find_surface_model_image,
    refine_surface_model_pose_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, edges_object_model_3d

    Successors
    ----------
    refine_surface_model_pose, get_surface_matching_result,
    clear_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(1042) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, key_point_fraction)
        proc.set_input_tuple(4, min_score)
        proc.set_input_tuple(5, return_result_handle)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_s(2)   # surface_matching_result_id
        )  # type: ignore


def find_text(image: HObject, text_model: HHandle) -> HHandle:
    """
    Find text in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    text_model : HHandle
                 Text model specifying the text to be segmented.

    Returns
    -------

    text_result_id : HHandle
                     Result of the segmentation.

    Predecessors
    ------------
    create_text_model_reader, set_text_model_param, text_line_orientation,
    text_line_slant

    Successors
    ----------
    get_text_result, get_text_object
    """
    with HalconOperator(417) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, text_model)
        proc.init_oct(0)
        proc.execute()
        text_result_id = proc.get_output_tuple_s(0)
        return text_result_id  # type: ignore


def find_uncalib_descriptor_model(
    image: HObject,
    model_id: HHandle,
    detector_param_name: Sequence[str],
    detector_param_value: Sequence[Union[int, float, str]],
    descriptor_param_name: Sequence[str],
    descriptor_param_value: Sequence[Union[int, float, str]],
    min_score: MaybeSequence[float],
    num_matches: int,
    score_type: MaybeSequence[str]
) -> Tuple[Sequence[float], Sequence[Union[float, int]]]:
    """
    Find the best matches of a descriptor model in an image.

    Parameters
    ----------

    image : HObject
            Input image where the model should be found.

    model_id : HHandle
               The handle to the descriptor model.

    detector_param_name : Sequence[str]
                          The detector's parameter names.
                          Value Suggestion: []

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detector's parameters.
                           Value Suggestion: []

    descriptor_param_name : Sequence[str]
                            The descriptor's parameter names.
                            Value Suggestion: []

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptor's parameters.
                             Value Suggestion: []

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.2

    num_matches : int
                  Maximal number of found instances.
                  Value Suggestion: 1
                  Assertion: NumMatches >= 1

    score_type : MaybeSequence[str]
                 Score type to be evaluated in Score.
                 Value Suggestion: num_points

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homography between model and found instance.

    score : Sequence[Union[float, int]]
            Score of the found instances according to the ScoreType input.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    find_calib_descriptor_model, get_descriptor_model_points

    Predecessors
    ------------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    read_descriptor_model

    Notes
    -----
    Note that the domain of the search image should contain the whole
    object to be searched for because interest points are only extracted
    inside the domain of the search image. This means that if the domain
    does not contain the full object to be searched for, the resulting
    Score will decrease. Note also that matches may be found even if the
    reference point (origin) of the model lies outside of the domain of
    the search image. Both is in contrast to shape-based matching, where
    the domain of the search image defines the search space for the
    reference point of the model.
    """
    with HalconOperator(949) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, detector_param_name)
        proc.set_input_tuple(2, detector_param_value)
        proc.set_input_tuple(3, descriptor_param_name)
        proc.set_input_tuple(4, descriptor_param_value)
        proc.set_input_tuple(5, min_score)
        proc.set_input_tuple(6, num_matches)
        proc.set_input_tuple(7, score_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_m(1)   # score
        )  # type: ignore


def find_uncalib_descriptor_model_s(
    image: HObject,
    model_id: HHandle,
    detector_param_name: Sequence[str],
    detector_param_value: Sequence[Union[int, float, str]],
    descriptor_param_name: Sequence[str],
    descriptor_param_value: Sequence[Union[int, float, str]],
    min_score: MaybeSequence[float],
    num_matches: int,
    score_type: MaybeSequence[str]
) -> Tuple[Sequence[float], Union[float, int]]:
    """
    Find the best matches of a descriptor model in an image.

    Parameters
    ----------

    image : HObject
            Input image where the model should be found.

    model_id : HHandle
               The handle to the descriptor model.

    detector_param_name : Sequence[str]
                          The detector's parameter names.
                          Value Suggestion: []

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detector's parameters.
                           Value Suggestion: []

    descriptor_param_name : Sequence[str]
                            The descriptor's parameter names.
                            Value Suggestion: []

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptor's parameters.
                             Value Suggestion: []

    min_score : MaybeSequence[float]
                Minimum score of the instances of the models to be found.
                Value Suggestion: 0.2

    num_matches : int
                  Maximal number of found instances.
                  Value Suggestion: 1
                  Assertion: NumMatches >= 1

    score_type : MaybeSequence[str]
                 Score type to be evaluated in Score.
                 Value Suggestion: num_points

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homography between model and found instance.

    score : Union[float, int]
            Score of the found instances according to the ScoreType input.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    find_calib_descriptor_model, get_descriptor_model_points

    Predecessors
    ------------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    read_descriptor_model

    Notes
    -----
    Note that the domain of the search image should contain the whole
    object to be searched for because interest points are only extracted
    inside the domain of the search image. This means that if the domain
    does not contain the full object to be searched for, the resulting
    Score will decrease. Note also that matches may be found even if the
    reference point (origin) of the model lies outside of the domain of
    the search image. Both is in contrast to shape-based matching, where
    the domain of the search image defines the search space for the
    reference point of the model.
    """
    with HalconOperator(949) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, detector_param_name)
        proc.set_input_tuple(2, detector_param_value)
        proc.set_input_tuple(3, descriptor_param_name)
        proc.set_input_tuple(4, descriptor_param_value)
        proc.set_input_tuple(5, min_score)
        proc.set_input_tuple(6, num_matches)
        proc.set_input_tuple(7, score_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_s(1)   # score
        )  # type: ignore


def fit_circle_contour_xld(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    max_closure_dist: float,
    clipping_end_points: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[str]]:
    """
    Approximate XLD contours by circles.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for the fitting of circles.
                Value Suggestion: algebraic

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 3

    max_closure_dist : float
                       Maximum distance between the end points of a
                       contour to be considered as 'closed'.
                       Value Suggestion: 0.0
                       Assertion: MaxClosureDist >= 0.0

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    iterations : int
                 Maximum number of iterations for the robust weighted
                 fitting.
                 Value Suggestion: 3
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical: 1.0 for Huber and 2.0 for Tukey).
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the center of the circle.

    column : Sequence[float]
             Column coordinate of the center of the circle.

    radius : Sequence[float]
             Radius of circle.

    start_phi : Sequence[float]
                Angle of the start point [rad].

    end_phi : Sequence[float]
              Angle of the end point [rad].

    point_order : Sequence[str]
                  Point order along the boundary.

    See Also
    --------
    fit_ellipse_contour_xld, fit_line_contour_xld,
    fit_rectangle2_contour_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld

    Successors
    ----------
    gen_ellipse_contour_xld, disp_circle, get_points_ellipse
    """
    with HalconOperator(29) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, max_closure_dist)
        proc.set_input_tuple(3, clipping_end_points)
        proc.set_input_tuple(4, iterations)
        proc.set_input_tuple(5, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # radius
            proc.get_output_tuple_m(3),  # start_phi
            proc.get_output_tuple_m(4),  # end_phi
            proc.get_output_tuple_m(5)   # point_order
        )  # type: ignore


def fit_circle_contour_xld_s(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    max_closure_dist: float,
    clipping_end_points: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[float, float, float, float, float, str]:
    """
    Approximate XLD contours by circles.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for the fitting of circles.
                Value Suggestion: algebraic

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 3

    max_closure_dist : float
                       Maximum distance between the end points of a
                       contour to be considered as 'closed'.
                       Value Suggestion: 0.0
                       Assertion: MaxClosureDist >= 0.0

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    iterations : int
                 Maximum number of iterations for the robust weighted
                 fitting.
                 Value Suggestion: 3
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical: 1.0 for Huber and 2.0 for Tukey).
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row : float
          Row coordinate of the center of the circle.

    column : float
             Column coordinate of the center of the circle.

    radius : float
             Radius of circle.

    start_phi : float
                Angle of the start point [rad].

    end_phi : float
              Angle of the end point [rad].

    point_order : str
                  Point order along the boundary.

    See Also
    --------
    fit_ellipse_contour_xld, fit_line_contour_xld,
    fit_rectangle2_contour_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld

    Successors
    ----------
    gen_ellipse_contour_xld, disp_circle, get_points_ellipse
    """
    with HalconOperator(29) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, max_closure_dist)
        proc.set_input_tuple(3, clipping_end_points)
        proc.set_input_tuple(4, iterations)
        proc.set_input_tuple(5, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # radius
            proc.get_output_tuple_s(3),  # start_phi
            proc.get_output_tuple_s(4),  # end_phi
            proc.get_output_tuple_s(5)   # point_order
        )  # type: ignore


def fit_ellipse_contour_xld(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    max_closure_dist: float,
    clipping_end_points: int,
    voss_tab_size: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[str]]:
    """
    Approximate XLD contours by ellipses or elliptic arcs.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for the fitting of ellipses.
                Value Suggestion: fitzgibbon

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 5

    max_closure_dist : float
                       Maximum distance between the end points of a
                       contour to be considered as 'closed'.
                       Value Suggestion: 0.0
                       Assertion: MaxClosureDist >= 0.0

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    voss_tab_size : int
                    Number of circular segments used for the Voss approach.
                    Value Suggestion: 200
                    Assertion: VossTabSize >= 25 && VossTabSize <= 5000

    iterations : int
                 Maximum number of iterations for the robust weighted
                 fitting.
                 Value Suggestion: 3
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical: 1.0 for '*huber' and 2.0 for '*tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the center of the ellipse.

    column : Sequence[float]
             Column coordinate of the center of the ellipse.

    phi : Sequence[float]
          Orientation of the main axis [rad].

    radius_1 : Sequence[float]
               Length of the larger half axis.

    radius_2 : Sequence[float]
               Length of the smaller half axis.

    start_phi : Sequence[float]
                Angle of the start point [rad].

    end_phi : Sequence[float]
              Angle of the end point [rad].

    point_order : Sequence[str]
                  point order along the boundary.

    See Also
    --------
    fit_line_contour_xld, fit_circle_contour_xld,
    fit_rectangle2_contour_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld

    Successors
    ----------
    gen_ellipse_contour_xld, disp_ellipse, get_points_ellipse
    """
    with HalconOperator(33) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, max_closure_dist)
        proc.set_input_tuple(3, clipping_end_points)
        proc.set_input_tuple(4, voss_tab_size)
        proc.set_input_tuple(5, iterations)
        proc.set_input_tuple(6, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # phi
            proc.get_output_tuple_m(3),  # radius_1
            proc.get_output_tuple_m(4),  # radius_2
            proc.get_output_tuple_m(5),  # start_phi
            proc.get_output_tuple_m(6),  # end_phi
            proc.get_output_tuple_m(7)   # point_order
        )  # type: ignore


def fit_ellipse_contour_xld_s(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    max_closure_dist: float,
    clipping_end_points: int,
    voss_tab_size: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[float, float, float, float, float, float, float, str]:
    """
    Approximate XLD contours by ellipses or elliptic arcs.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for the fitting of ellipses.
                Value Suggestion: fitzgibbon

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 5

    max_closure_dist : float
                       Maximum distance between the end points of a
                       contour to be considered as 'closed'.
                       Value Suggestion: 0.0
                       Assertion: MaxClosureDist >= 0.0

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    voss_tab_size : int
                    Number of circular segments used for the Voss approach.
                    Value Suggestion: 200
                    Assertion: VossTabSize >= 25 && VossTabSize <= 5000

    iterations : int
                 Maximum number of iterations for the robust weighted
                 fitting.
                 Value Suggestion: 3
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical: 1.0 for '*huber' and 2.0 for '*tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row : float
          Row coordinate of the center of the ellipse.

    column : float
             Column coordinate of the center of the ellipse.

    phi : float
          Orientation of the main axis [rad].

    radius_1 : float
               Length of the larger half axis.

    radius_2 : float
               Length of the smaller half axis.

    start_phi : float
                Angle of the start point [rad].

    end_phi : float
              Angle of the end point [rad].

    point_order : str
                  point order along the boundary.

    See Also
    --------
    fit_line_contour_xld, fit_circle_contour_xld,
    fit_rectangle2_contour_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld

    Successors
    ----------
    gen_ellipse_contour_xld, disp_ellipse, get_points_ellipse
    """
    with HalconOperator(33) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, max_closure_dist)
        proc.set_input_tuple(3, clipping_end_points)
        proc.set_input_tuple(4, voss_tab_size)
        proc.set_input_tuple(5, iterations)
        proc.set_input_tuple(6, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # radius_1
            proc.get_output_tuple_s(4),  # radius_2
            proc.get_output_tuple_s(5),  # start_phi
            proc.get_output_tuple_s(6),  # end_phi
            proc.get_output_tuple_s(7)   # point_order
        )  # type: ignore


def fit_line_contour_xld(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    clipping_end_points: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Approximate XLD contours by line segments.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for the fitting of lines.
                Value Suggestion: tukey

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 2

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    iterations : int
                 Maximum number of iterations (unused for 'regression').
                 Value Suggestion: 5
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical values: 1.0 for 'huber' and 'drop' and 2.0
                      for 'tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row_begin : Sequence[float]
                Row coordinates of the starting points of the line
                segments.

    col_begin : Sequence[float]
                Column coordinates of the starting points of the line
                segments.

    row_end : Sequence[float]
              Row coordinates of the end points of the line segments.

    col_end : Sequence[float]
              Column coordinates of the end points of the line segments.

    nr : Sequence[float]
         Line parameter: Row coordinate of the normal vector

    nc : Sequence[float]
         Line parameter: Column coordinate of the normal vector

    dist : Sequence[float]
           Line parameter: Distance of the line from the origin

    See Also
    --------
    regress_contours_xld, get_regress_params_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld

    Successors
    ----------
    disp_line, line_orientation
    """
    with HalconOperator(30) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, clipping_end_points)
        proc.set_input_tuple(3, iterations)
        proc.set_input_tuple(4, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_begin
            proc.get_output_tuple_m(1),  # col_begin
            proc.get_output_tuple_m(2),  # row_end
            proc.get_output_tuple_m(3),  # col_end
            proc.get_output_tuple_m(4),  # nr
            proc.get_output_tuple_m(5),  # nc
            proc.get_output_tuple_m(6)   # dist
        )  # type: ignore


def fit_line_contour_xld_s(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    clipping_end_points: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[float, float, float, float, float, float, float]:
    """
    Approximate XLD contours by line segments.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for the fitting of lines.
                Value Suggestion: tukey

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints >= 2

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    iterations : int
                 Maximum number of iterations (unused for 'regression').
                 Value Suggestion: 5
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical values: 1.0 for 'huber' and 'drop' and 2.0
                      for 'tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row_begin : float
                Row coordinates of the starting points of the line
                segments.

    col_begin : float
                Column coordinates of the starting points of the line
                segments.

    row_end : float
              Row coordinates of the end points of the line segments.

    col_end : float
              Column coordinates of the end points of the line segments.

    nr : float
         Line parameter: Row coordinate of the normal vector

    nc : float
         Line parameter: Column coordinate of the normal vector

    dist : float
           Line parameter: Distance of the line from the origin

    See Also
    --------
    regress_contours_xld, get_regress_params_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld

    Successors
    ----------
    disp_line, line_orientation
    """
    with HalconOperator(30) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, clipping_end_points)
        proc.set_input_tuple(3, iterations)
        proc.set_input_tuple(4, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_begin
            proc.get_output_tuple_s(1),  # col_begin
            proc.get_output_tuple_s(2),  # row_end
            proc.get_output_tuple_s(3),  # col_end
            proc.get_output_tuple_s(4),  # nr
            proc.get_output_tuple_s(5),  # nc
            proc.get_output_tuple_s(6)   # dist
        )  # type: ignore


def fit_primitives_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Sequence[HHandle]:
    """
    Fit 3D primitives into a set of 3D points.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the input 3D object model.

    gen_param_name : Sequence[str]
                     Names of the generic parameters.

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.

    Returns
    -------

    object_model_3dout : Sequence[HHandle]
                         Handle of the output 3D object model.

    Alternatives
    ------------
    segment_object_model_3d

    Predecessors
    ------------
    xyz_to_object_model_3d, read_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, object_model_3d_to_xyz,
    write_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(411) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dout = proc.get_output_tuple_m(0)
        return object_model_3dout  # type: ignore


def fit_primitives_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> HHandle:
    """
    Fit 3D primitives into a set of 3D points.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the input 3D object model.

    gen_param_name : Sequence[str]
                     Names of the generic parameters.

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.

    Returns
    -------

    object_model_3dout : HHandle
                         Handle of the output 3D object model.

    Alternatives
    ------------
    segment_object_model_3d

    Predecessors
    ------------
    xyz_to_object_model_3d, read_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, object_model_3d_to_xyz,
    write_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(411) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dout = proc.get_output_tuple_s(0)
        return object_model_3dout  # type: ignore


def fit_rectangle2_contour_xld(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    max_closure_dist: float,
    clipping_end_points: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[str]]:
    """
    Fit rectangles to XLD contours.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for fitting the rectangles.
                Value Suggestion: regression

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints == -1 || MaxNumPoints >= 8

    max_closure_dist : float
                       Maximum distance between the end points of a
                       contour to be considered as closed.
                       Value Suggestion: 0.0
                       Assertion: MaxClosureDist >= 0.0

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    iterations : int
                 Maximum number of iterations (not used for 'regression').
                 Value Suggestion: 3
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical values: 1.0 for 'huber' and 2.0 for
                      'tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the center of the rectangle.

    column : Sequence[float]
             Column coordinate of the center of the rectangle.

    phi : Sequence[float]
          Orientation of the main axis of the rectangle [rad].

    length_1 : Sequence[float]
               First radius (half length) of the rectangle.

    length_2 : Sequence[float]
               Second radius (half width) of the rectangle.

    point_order : Sequence[str]
                  Point order of the contour.

    See Also
    --------
    fit_line_contour_xld, fit_circle_contour_xld, fit_ellipse_contour_xld

    Alternatives
    ------------
    smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld, union_collinear_contours_xld,
    union_collinear_contours_ext_xld, union_adjacent_contours_xld

    Successors
    ----------
    dist_rectangle2_contour_points_xld, gen_rectangle2_contour_xld
    """
    with HalconOperator(26) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, max_closure_dist)
        proc.set_input_tuple(3, clipping_end_points)
        proc.set_input_tuple(4, iterations)
        proc.set_input_tuple(5, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # phi
            proc.get_output_tuple_m(3),  # length_1
            proc.get_output_tuple_m(4),  # length_2
            proc.get_output_tuple_m(5)   # point_order
        )  # type: ignore


def fit_rectangle2_contour_xld_s(
    contours: HObject,
    algorithm: str,
    max_num_points: int,
    max_closure_dist: float,
    clipping_end_points: int,
    iterations: int,
    clipping_factor: float
) -> Tuple[float, float, float, float, float, str]:
    """
    Fit rectangles to XLD contours.

    Parameters
    ----------

    contours : HObject
               Input contours.

    algorithm : str
                Algorithm for fitting the rectangles.
                Value Suggestion: regression

    max_num_points : int
                     Maximum number of contour points used for the
                     computation (-1 for all points).
                     Value Suggestion: -1
                     Assertion: MaxNumPoints == -1 || MaxNumPoints >= 8

    max_closure_dist : float
                       Maximum distance between the end points of a
                       contour to be considered as closed.
                       Value Suggestion: 0.0
                       Assertion: MaxClosureDist >= 0.0

    clipping_end_points : int
                          Number of points at the beginning and at the end
                          of the contours to be ignored for the fitting.
                          Value Suggestion: 0
                          Assertion: ClippingEndPoints >= 0

    iterations : int
                 Maximum number of iterations (not used for 'regression').
                 Value Suggestion: 3
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical values: 1.0 for 'huber' and 2.0 for
                      'tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    row : float
          Row coordinate of the center of the rectangle.

    column : float
             Column coordinate of the center of the rectangle.

    phi : float
          Orientation of the main axis of the rectangle [rad].

    length_1 : float
               First radius (half length) of the rectangle.

    length_2 : float
               Second radius (half width) of the rectangle.

    point_order : str
                  Point order of the contour.

    See Also
    --------
    fit_line_contour_xld, fit_circle_contour_xld, fit_ellipse_contour_xld

    Alternatives
    ------------
    smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    smooth_contours_xld, union_collinear_contours_xld,
    union_collinear_contours_ext_xld, union_adjacent_contours_xld

    Successors
    ----------
    dist_rectangle2_contour_points_xld, gen_rectangle2_contour_xld
    """
    with HalconOperator(26) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, max_num_points)
        proc.set_input_tuple(2, max_closure_dist)
        proc.set_input_tuple(3, clipping_end_points)
        proc.set_input_tuple(4, iterations)
        proc.set_input_tuple(5, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # length_1
            proc.get_output_tuple_s(4),  # length_2
            proc.get_output_tuple_s(5)   # point_order
        )  # type: ignore


def fit_surface_first_order(
    regions: HObject,
    image: HObject,
    algorithm: str,
    iterations: int,
    clipping_factor: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate gray value moments and approximation by a first order
    surface (plane).

    Parameters
    ----------

    regions : HObject
              Regions to be checked.

    image : HObject
            Corresponding gray values.

    algorithm : str
                Algorithm for the fitting.
                Value Suggestion: regression

    iterations : int
                 Maximum number of iterations (unused for 'regression').
                 Value Suggestion: 5
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers.
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    alpha : Sequence[float]
            Parameter Alpha of the approximating surface.

    beta : Sequence[float]
           Parameter Beta of the approximating surface.

    gamma : Sequence[float]
            Parameter Gamma of the approximating surface.

    See Also
    --------
    moments_gray_plane, fit_surface_second_order

    Successors
    ----------
    gen_image_surface_first_order

    Notes
    -----
    Note that the operator fit_surface_first_order only considers  the
    given Regions and ignores any previously set domain of the input image
    Image.
    """
    with HalconOperator(1743) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # alpha
            proc.get_output_tuple_m(1),  # beta
            proc.get_output_tuple_m(2)   # gamma
        )  # type: ignore


def fit_surface_first_order_s(
    regions: HObject,
    image: HObject,
    algorithm: str,
    iterations: int,
    clipping_factor: float
) -> Tuple[float, float, float]:
    """
    Calculate gray value moments and approximation by a first order
    surface (plane).

    Parameters
    ----------

    regions : HObject
              Regions to be checked.

    image : HObject
            Corresponding gray values.

    algorithm : str
                Algorithm for the fitting.
                Value Suggestion: regression

    iterations : int
                 Maximum number of iterations (unused for 'regression').
                 Value Suggestion: 5
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers.
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    alpha : float
            Parameter Alpha of the approximating surface.

    beta : float
           Parameter Beta of the approximating surface.

    gamma : float
            Parameter Gamma of the approximating surface.

    See Also
    --------
    moments_gray_plane, fit_surface_second_order

    Successors
    ----------
    gen_image_surface_first_order

    Notes
    -----
    Note that the operator fit_surface_first_order only considers  the
    given Regions and ignores any previously set domain of the input image
    Image.
    """
    with HalconOperator(1743) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # alpha
            proc.get_output_tuple_s(1),  # beta
            proc.get_output_tuple_s(2)   # gamma
        )  # type: ignore


def fit_surface_second_order(
    regions: HObject,
    image: HObject,
    algorithm: str,
    iterations: int,
    clipping_factor: float
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate gray value moments and approximation by a second order
    surface.

    Parameters
    ----------

    regions : HObject
              Regions to be checked.

    image : HObject
            Corresponding gray values.

    algorithm : str
                Algorithm for the fitting.
                Value Suggestion: regression

    iterations : int
                 Maximum number of iterations (unused for 'regression').
                 Value Suggestion: 5
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers.
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    alpha : Sequence[float]
            Parameter Alpha of the approximating surface.

    beta : Sequence[float]
           Parameter Beta of the approximating surface.

    gamma : Sequence[float]
            Parameter Gamma of the approximating surface.

    delta : Sequence[float]
            Parameter Delta of the approximating surface.

    epsilon : Sequence[float]
              Parameter Epsilon of the approximating surface.

    zeta : Sequence[float]
           Parameter Zeta of the approximating surface.

    See Also
    --------
    moments_gray_plane, fit_surface_first_order

    Successors
    ----------
    gen_image_surface_second_order

    Notes
    -----
    Note that the operator fit_surface_second_order only considers  the
    given Regions and ignores any previously set domain of the input image
    Image.
    """
    with HalconOperator(1744) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # alpha
            proc.get_output_tuple_m(1),  # beta
            proc.get_output_tuple_m(2),  # gamma
            proc.get_output_tuple_m(3),  # delta
            proc.get_output_tuple_m(4),  # epsilon
            proc.get_output_tuple_m(5)   # zeta
        )  # type: ignore


def fit_surface_second_order_s(
    regions: HObject,
    image: HObject,
    algorithm: str,
    iterations: int,
    clipping_factor: float
) -> Tuple[float, float, float, float, float, float]:
    """
    Calculate gray value moments and approximation by a second order
    surface.

    Parameters
    ----------

    regions : HObject
              Regions to be checked.

    image : HObject
            Corresponding gray values.

    algorithm : str
                Algorithm for the fitting.
                Value Suggestion: regression

    iterations : int
                 Maximum number of iterations (unused for 'regression').
                 Value Suggestion: 5
                 Assertion: Iterations >= 0

    clipping_factor : float
                      Clipping factor for the elimination of outliers.
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    alpha : float
            Parameter Alpha of the approximating surface.

    beta : float
           Parameter Beta of the approximating surface.

    gamma : float
            Parameter Gamma of the approximating surface.

    delta : float
            Parameter Delta of the approximating surface.

    epsilon : float
              Parameter Epsilon of the approximating surface.

    zeta : float
           Parameter Zeta of the approximating surface.

    See Also
    --------
    moments_gray_plane, fit_surface_first_order

    Successors
    ----------
    gen_image_surface_second_order

    Notes
    -----
    Note that the operator fit_surface_second_order only considers  the
    given Regions and ignores any previously set domain of the input image
    Image.
    """
    with HalconOperator(1744) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # alpha
            proc.get_output_tuple_s(1),  # beta
            proc.get_output_tuple_s(2),  # gamma
            proc.get_output_tuple_s(3),  # delta
            proc.get_output_tuple_s(4),  # epsilon
            proc.get_output_tuple_s(5)   # zeta
        )  # type: ignore


def fitting(region: HObject, struct_elements: HObject) -> HObject:
    """
    Perform a closing after an opening with multiple structuring elements.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_elements : HObject
                      Structuring elements.

    Returns
    -------

    region_fitted : HObject
                    Fitted regions.

    Alternatives
    ------------
    opening, closing, connection, select_shape

    Predecessors
    ------------
    gen_struct_elements, gen_region_points

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    fitting is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(737) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_elements)
        proc.execute()
        region_fitted = HObject(proc.get_output_object_key(1))
        return region_fitted  # type: ignore


def flush_buffer(window_handle: HHandle) -> None:
    """
    Flush the contents of a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    set_window_param

    Predecessors
    ------------
    disp_obj

    Successors
    ----------
    dump_window_image

    Notes
    -----
    flush_buffer depends on the library libcanvas, which might not be
    available on embedded systems.
    """
    with HalconOperator(2070) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def fnew_line(file_handle: HHandle) -> None:
    """
    Write a line break and clear the output buffer.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    See Also
    --------
    fwrite_string

    Predecessors
    ------------
    fwrite_string
    """
    with HalconOperator(1664) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.execute()


def fread_bytes(
    file_handle: HHandle,
    number_of_bytes: int
) -> Tuple[Sequence[int], int]:
    """
    Read bytes from a binary file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    number_of_bytes : int
                      Number of bytes to be read.

    Returns
    -------

    read_data : Sequence[int]
                Bytes read from the input binary file.

    is_eof : int
             Indicates if end of file is reached while reading  the file.

    See Also
    --------
    open_file, close_file, fwrite_bytes

    Alternatives
    ------------
    fread_char

    Predecessors
    ------------
    open_file

    Successors
    ----------
    close_file
    """
    with HalconOperator(2182) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.set_input_tuple(1, number_of_bytes)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # read_data
            proc.get_output_tuple_s(1)   # is_eof
        )  # type: ignore


def fread_char(file_handle: HHandle) -> str:
    """
    Read one character from a text file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    Returns
    -------

    char : str
           Read character, which can be multi-byte or the control string
           'eof'.

    See Also
    --------
    open_file, close_file, fread_string, fread_line

    Alternatives
    ------------
    fread_string, read_string, fread_line

    Predecessors
    ------------
    open_file

    Successors
    ----------
    close_file
    """
    with HalconOperator(1663) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.init_oct(0)
        proc.execute()
        char = proc.get_output_tuple_s(0)
        return char  # type: ignore


def fread_line(file_handle: HHandle) -> Tuple[str, int]:
    """
    Read a character line from a text file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    Returns
    -------

    out_line : str
               Read line.

    is_eof : int
             Reached end of file before any character was read.

    See Also
    --------
    open_file, close_file, fread_char, fread_string

    Alternatives
    ------------
    fread_char, fread_string

    Predecessors
    ------------
    open_file

    Successors
    ----------
    close_file
    """
    with HalconOperator(1661) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # out_line
            proc.get_output_tuple_s(1)   # is_eof
        )  # type: ignore


def fread_serialized_item(file_handle: HHandle) -> HHandle:
    """
    Read a serialized item from a file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    open_file, fwrite_serialized_item

    Successors
    ----------
    close_file, get_serialized_item_ptr, deserialize_shape_model,
    deserialize_ncc_model
    """
    with HalconOperator(406) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def fread_string(file_handle: HHandle) -> Tuple[str, int]:
    """
    Read a string from a text file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    Returns
    -------

    out_string : str
                 Read character sequence.

    is_eof : int
             Reached end of file before any character was added to the
             output string.

    See Also
    --------
    open_file, close_file, fread_char, fread_line

    Alternatives
    ------------
    fread_char, read_string, fread_line

    Predecessors
    ------------
    open_file

    Successors
    ----------
    close_file
    """
    with HalconOperator(1662) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # out_string
            proc.get_output_tuple_s(1)   # is_eof
        )  # type: ignore


def frei_amp(image: HObject) -> HObject:
    """
    Detect edges (amplitude) using the Frei-Chen operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    sobel_amp, kirsch_amp, prewitt_amp, robinson_amp, roberts

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1557) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_edge_amp = HObject(proc.get_output_object_key(1))
        return image_edge_amp  # type: ignore


def frei_dir(image: HObject) -> Tuple[HObject, HObject]:
    """
    Detect edges (amplitude and direction) using the Frei-Chen operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    image_edge_dir : HObject
                     Edge direction image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    edges_image, sobel_dir, robinson_dir, prewitt_dir, kirsch_dir

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Successors
    ----------
    hysteresis_threshold, threshold, gray_skeleton,
    nonmax_suppression_dir, close_edges, close_edges_length

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1556) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_edge_amp
            HObject(proc.get_output_object_key(2))   # image_edge_dir
        )  # type: ignore


def full_domain(image: HObject) -> HObject:
    """
    Expand the domain of an image to maximum.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_full : HObject
                 Image with maximum definition domain.

    See Also
    --------
    get_domain, gen_rectangle1

    Alternatives
    ------------
    change_domain, reduce_domain

    Predecessors
    ------------
    get_domain
    """
    with HalconOperator(1147) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_full = HObject(proc.get_output_object_key(1))
        return image_full  # type: ignore


def funct_1d_to_pairs(
    function: Sequence[Union[float, int]]
) -> Tuple[Sequence[Union[int, float]], Sequence[Union[int, float]]]:
    """
    Access to the x/y values of a function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    xvalues : Sequence[Union[int, float]]
              X values of the function.

    yvalues : Sequence[Union[int, float]]
              Y values of the function.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1390) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # xvalues
            proc.get_output_tuple_m(1)   # yvalues
        )  # type: ignore


def fuse_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    bounding_box: Sequence[Union[int, float]],
    resolution: Union[int, float],
    surface_tolerance: Union[int, float],
    min_thickness: Union[int, float],
    smoothing: Union[int, float],
    normal_direction: MaybeSequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> HHandle:
    """
    Fuse 3D object models into a surface.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    bounding_box : Sequence[Union[int, float]]
                   The two opposite bound box corners.

    resolution : Union[int, float]
                 Used resolution within the bounding box.
                 Value Suggestion: 1.0

    surface_tolerance : Union[int, float]
                        Distance of expected noise to surface.
                        Value Suggestion: 1.0

    min_thickness : Union[int, float]
                    Minimum thickness of the object in direction of the
                    surface normal.
                    Value Suggestion: 1.0

    smoothing : Union[int, float]
                Weight factor for data fidelity.
                Value Suggestion: 1.0

    normal_direction : MaybeSequence[str]
                       Direction of normals of the input models.
                       Value Suggestion: inwards

    gen_param_name : Sequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    object_model_3dfusion : HHandle
                            Handle of the fused 3D object model.

    See Also
    --------
    reconstruct_surface_stereo

    Predecessors
    ------------
    read_object_model_3d, register_object_model_3d_pair,
    register_object_model_3d_global, surface_normals_object_model_3d,
    triangulate_object_model_3d, simplify_object_model_3d,
    get_object_model_3d_params

    Successors
    ----------
    write_object_model_3d, create_surface_model
    """
    with HalconOperator(2112) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, bounding_box)
        proc.set_input_tuple(2, resolution)
        proc.set_input_tuple(3, surface_tolerance)
        proc.set_input_tuple(4, min_thickness)
        proc.set_input_tuple(5, smoothing)
        proc.set_input_tuple(6, normal_direction)
        proc.set_input_tuple(7, gen_param_name)
        proc.set_input_tuple(8, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dfusion = proc.get_output_tuple_s(0)
        return object_model_3dfusion  # type: ignore


def fuzzy_entropy(
    regions: HObject,
    image: HObject,
    apar: int,
    cpar: int
) -> Sequence[float]:
    """
    Determine the fuzzy entropy of regions.

    Parameters
    ----------

    regions : HObject
              Regions for which the fuzzy entropy is to be calculated.

    image : HObject
            Input image containing the fuzzy membership values.

    apar : int
           Start of the fuzzy function.
           Value Suggestion: 0

    cpar : int
           End of the fuzzy function.
           Value Suggestion: 255
           Assertion: Apar <= Cpar

    Returns
    -------

    entropy : Sequence[float]
              Fuzzy entropy of a region.

    See Also
    --------
    fuzzy_perimeter

    Notes
    -----
    Note that for fuzzy_entropy, the Regions must lie  completely within
    the previously defined domain. Otherwise an exception is raised.
    """
    with HalconOperator(1457) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, apar)
        proc.set_input_tuple(1, cpar)
        proc.init_oct(0)
        proc.execute()
        entropy = proc.get_output_tuple_m(0)
        return entropy  # type: ignore


def fuzzy_entropy_s(
    regions: HObject,
    image: HObject,
    apar: int,
    cpar: int
) -> float:
    """
    Determine the fuzzy entropy of regions.

    Parameters
    ----------

    regions : HObject
              Regions for which the fuzzy entropy is to be calculated.

    image : HObject
            Input image containing the fuzzy membership values.

    apar : int
           Start of the fuzzy function.
           Value Suggestion: 0

    cpar : int
           End of the fuzzy function.
           Value Suggestion: 255
           Assertion: Apar <= Cpar

    Returns
    -------

    entropy : float
              Fuzzy entropy of a region.

    See Also
    --------
    fuzzy_perimeter

    Notes
    -----
    Note that for fuzzy_entropy, the Regions must lie  completely within
    the previously defined domain. Otherwise an exception is raised.
    """
    with HalconOperator(1457) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, apar)
        proc.set_input_tuple(1, cpar)
        proc.init_oct(0)
        proc.execute()
        entropy = proc.get_output_tuple_s(0)
        return entropy  # type: ignore


def fuzzy_measure_pairing(
    image: HObject,
    measure_handle: HHandle,
    sigma: float,
    amp_thresh: float,
    fuzzy_thresh: float,
    transition: str,
    pairing: str,
    num_pairs: int
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Extract straight edge pairs perpendicular to a rectangle or an annular
    arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    sigma : float
            Sigma of Gaussian smoothing.
            Value Suggestion: 1.0
            Assertion: Sigma >= 0.4

    amp_thresh : float
                 Minimum edge amplitude.
                 Value Suggestion: 30.0

    fuzzy_thresh : float
                   Minimum fuzzy value.
                   Value Suggestion: 0.5

    transition : str
                 Select the first gray value transition of the edge pairs.
                 Value Suggestion: all

    pairing : str
              Constraint of pairing.
              Value Suggestion: no_restriction

    num_pairs : int
                Number of edge pairs.
                Value Suggestion: 10

    Returns
    -------

    row_edge_first : Sequence[float]
                     Row coordinate of the first edge.

    column_edge_first : Sequence[float]
                        Column coordinate of the first edge.

    amplitude_first : Sequence[float]
                      Edge amplitude of the first edge (with sign).

    row_edge_second : Sequence[float]
                      Row coordinate of the second edge.

    column_edge_second : Sequence[float]
                         Column coordinate of the second edge.

    amplitude_second : Sequence[float]
                       Edge amplitude of the second edge (with sign).

    row_pair_center : Sequence[float]
                      Row coordinate of the center of the edge pair.

    column_pair_center : Sequence[float]
                         Column coordinate of the center of the edge pair.

    fuzzy_score : Sequence[float]
                  Fuzzy evaluation of the edge pair.

    intra_distance : Sequence[float]
                     Distance between the edges of the edge pair.

    See Also
    --------
    fuzzy_measure_pos, measure_pos

    Alternatives
    ------------
    edges_sub_pix, fuzzy_measure_pairs, measure_pairs

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc, set_fuzzy_measure

    Successors
    ----------
    close_measure

    Notes
    -----
    fuzzy_measure_pairing only returns meaningful results if the
    assumptions that the edges are straight and perpendicular to the major
    axis of the rectangle or annular arc are fulfilled.  Thus, it should
    not be used to extract edges from curved objects, for example.
    Furthermore, the user should ensure that the rectangle or annular arc
    is as close to perpendicular as possible to the edges in the image.
    Additionally, Sigma must not become larger than approx. 0.5 * Length1
    (for Length1 see gen_measure_rectangle2).
    It should be kept in mind that fuzzy_measure_pairing ignores the
    domain of Image for efficiency reasons.  If certain regions in the
    image should be excluded from the measurement a new measure object
    with appropriately modified parameters should be generated.
    """
    with HalconOperator(832) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, amp_thresh)
        proc.set_input_tuple(3, fuzzy_thresh)
        proc.set_input_tuple(4, transition)
        proc.set_input_tuple(5, pairing)
        proc.set_input_tuple(6, num_pairs)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_edge_first
            proc.get_output_tuple_m(1),  # column_edge_first
            proc.get_output_tuple_m(2),  # amplitude_first
            proc.get_output_tuple_m(3),  # row_edge_second
            proc.get_output_tuple_m(4),  # column_edge_second
            proc.get_output_tuple_m(5),  # amplitude_second
            proc.get_output_tuple_m(6),  # row_pair_center
            proc.get_output_tuple_m(7),  # column_pair_center
            proc.get_output_tuple_m(8),  # fuzzy_score
            proc.get_output_tuple_m(9)   # intra_distance
        )  # type: ignore


def fuzzy_measure_pairs(
    image: HObject,
    measure_handle: HHandle,
    sigma: float,
    amp_thresh: float,
    fuzzy_thresh: float,
    transition: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Extract straight edge pairs perpendicular to a rectangle or an annular
    arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    sigma : float
            Sigma of Gaussian smoothing.
            Value Suggestion: 1.0
            Assertion: Sigma >= 0.4

    amp_thresh : float
                 Minimum edge amplitude.
                 Value Suggestion: 30.0

    fuzzy_thresh : float
                   Minimum fuzzy value.
                   Value Suggestion: 0.5

    transition : str
                 Select the first gray value transition of the edge pairs.
                 Value Suggestion: all

    Returns
    -------

    row_edge_first : Sequence[float]
                     Row coordinate of the first edge point.

    column_edge_first : Sequence[float]
                        Column coordinate of the first edge point.

    amplitude_first : Sequence[float]
                      Edge amplitude of the first edge (with sign).

    row_edge_second : Sequence[float]
                      Row coordinate of the second edge point.

    column_edge_second : Sequence[float]
                         Column coordinate of the second edge point.

    amplitude_second : Sequence[float]
                       Edge amplitude of the second edge (with sign).

    row_edge_center : Sequence[float]
                      Row coordinate of the center of the edge pair.

    column_edge_center : Sequence[float]
                         Column coordinate of the center of the edge pair.

    fuzzy_score : Sequence[float]
                  Fuzzy evaluation of the edge pair.

    intra_distance : Sequence[float]
                     Distance between edges of an edge pair.

    inter_distance : Sequence[float]
                     Distance between consecutive edge pairs.

    See Also
    --------
    fuzzy_measure_pos, measure_pos

    Alternatives
    ------------
    edges_sub_pix, fuzzy_measure_pairing, measure_pairs

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc, set_fuzzy_measure

    Successors
    ----------
    close_measure

    Notes
    -----
    fuzzy_measure_pairs only returns meaningful results if the assumptions
    that the edges are straight and perpendicular to the major axis of the
    rectangle or annular arc are fulfilled.  Thus, it should not be used
    to extract edges from curved objects, for example.  Furthermore, the
    user should ensure that the rectangle or a annular arc is as close to
    perpendicular as possible to the edges in the image. Additionally,
    Sigma must not become larger than approx. 0.5 * Length1 (for Length1
    see gen_measure_rectangle2).
    It should be kept in mind that fuzzy_measure_pairs ignores the domain
    of Image for efficiency reasons.  If certain regions in the image
    should be excluded from the measurement a new measure object with
    appropriately modified parameters should be generated.
    """
    with HalconOperator(833) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, amp_thresh)
        proc.set_input_tuple(3, fuzzy_thresh)
        proc.set_input_tuple(4, transition)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.init_oct(10)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_edge_first
            proc.get_output_tuple_m(1),  # column_edge_first
            proc.get_output_tuple_m(2),  # amplitude_first
            proc.get_output_tuple_m(3),  # row_edge_second
            proc.get_output_tuple_m(4),  # column_edge_second
            proc.get_output_tuple_m(5),  # amplitude_second
            proc.get_output_tuple_m(6),  # row_edge_center
            proc.get_output_tuple_m(7),  # column_edge_center
            proc.get_output_tuple_m(8),  # fuzzy_score
            proc.get_output_tuple_m(9),  # intra_distance
            proc.get_output_tuple_m(10)   # inter_distance
        )  # type: ignore


def fuzzy_measure_pos(
    image: HObject,
    measure_handle: HHandle,
    sigma: float,
    amp_thresh: float,
    fuzzy_thresh: float,
    transition: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Extract straight edges perpendicular to a rectangle or an annular arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    sigma : float
            Sigma of Gaussian smoothing.
            Value Suggestion: 1.0
            Assertion: Sigma >= 0.4

    amp_thresh : float
                 Minimum edge amplitude.
                 Value Suggestion: 30.0

    fuzzy_thresh : float
                   Minimum fuzzy value.
                   Value Suggestion: 0.5

    transition : str
                 Select light/dark or dark/light edges.
                 Value Suggestion: all

    Returns
    -------

    row_edge : Sequence[float]
               Row coordinate of the edge point.

    column_edge : Sequence[float]
                  Column coordinate of the edge point.

    amplitude : Sequence[float]
                Edge amplitude of the edge (with sign).

    fuzzy_score : Sequence[float]
                  Fuzzy evaluation of the edges.

    distance : Sequence[float]
               Distance between consecutive edges.

    See Also
    --------
    fuzzy_measure_pairing, fuzzy_measure_pairs, measure_pairs

    Alternatives
    ------------
    edges_sub_pix, measure_pos

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc, set_fuzzy_measure

    Successors
    ----------
    close_measure

    Notes
    -----
    fuzzy_measure_pos only returns meaningful results if the assumptions
    that the edges are straight and perpendicular to the major axis of the
    rectangle are fulfilled.  Thus, it should not be used to extract edges
    from curved objects, for example. Furthermore, the user should ensure
    that the rectangle is as close to perpendicular as possible to the
    edges in the image. Additionally, Sigma must not become larger than
    approx. 0.5 * Length1 (for Length1 see gen_measure_rectangle2).
    It should be kept in mind that fuzzy_measure_pos ignores the domain of
    Image for efficiency reasons.  If certain regions in the image should
    be excluded from the measurement a new measure object with
    appropriately modified parameters should be generated.
    """
    with HalconOperator(834) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, amp_thresh)
        proc.set_input_tuple(3, fuzzy_thresh)
        proc.set_input_tuple(4, transition)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_edge
            proc.get_output_tuple_m(1),  # column_edge
            proc.get_output_tuple_m(2),  # amplitude
            proc.get_output_tuple_m(3),  # fuzzy_score
            proc.get_output_tuple_m(4)   # distance
        )  # type: ignore


def fuzzy_perimeter(
    regions: HObject,
    image: HObject,
    apar: int,
    cpar: int
) -> Sequence[float]:
    """
    Calculate the fuzzy perimeter of a region.

    Parameters
    ----------

    regions : HObject
              Regions for which the fuzzy perimeter is to be calculated.

    image : HObject
            Input image containing the fuzzy membership values.

    apar : int
           Start of the fuzzy function.
           Value Suggestion: 0

    cpar : int
           End of the fuzzy function.
           Value Suggestion: 255
           Assertion: Apar <= Cpar

    Returns
    -------

    perimeter : Sequence[float]
                Fuzzy perimeter of a region.

    See Also
    --------
    fuzzy_entropy

    Notes
    -----
    Note that for fuzzy_perimeter, the Regions must lie  completely within
    the previously defined domain. Otherwise an exception is raised.
    """
    with HalconOperator(1458) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, apar)
        proc.set_input_tuple(1, cpar)
        proc.init_oct(0)
        proc.execute()
        perimeter = proc.get_output_tuple_m(0)
        return perimeter  # type: ignore


def fuzzy_perimeter_s(
    regions: HObject,
    image: HObject,
    apar: int,
    cpar: int
) -> float:
    """
    Calculate the fuzzy perimeter of a region.

    Parameters
    ----------

    regions : HObject
              Regions for which the fuzzy perimeter is to be calculated.

    image : HObject
            Input image containing the fuzzy membership values.

    apar : int
           Start of the fuzzy function.
           Value Suggestion: 0

    cpar : int
           End of the fuzzy function.
           Value Suggestion: 255
           Assertion: Apar <= Cpar

    Returns
    -------

    perimeter : float
                Fuzzy perimeter of a region.

    See Also
    --------
    fuzzy_entropy

    Notes
    -----
    Note that for fuzzy_perimeter, the Regions must lie  completely within
    the previously defined domain. Otherwise an exception is raised.
    """
    with HalconOperator(1458) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, apar)
        proc.set_input_tuple(1, cpar)
        proc.init_oct(0)
        proc.execute()
        perimeter = proc.get_output_tuple_s(0)
        return perimeter  # type: ignore


def fwrite_bytes(
    file_handle: HHandle,
    data_to_write: Sequence[int]
) -> int:
    """
    Write bytes to a binary file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    data_to_write : Sequence[int]
                    Data to be written to the file.

    Returns
    -------

    number_of_bytes_written : int
                              Number of bytes written to the output
                              binary file.

    See Also
    --------
    open_file, close_file, fread_bytes

    Alternatives
    ------------
    fwrite_string

    Predecessors
    ------------
    open_file

    Successors
    ----------
    close_file
    """
    with HalconOperator(2183) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.set_input_tuple(1, data_to_write)
        proc.init_oct(0)
        proc.execute()
        number_of_bytes_written = proc.get_output_tuple_s(0)
        return number_of_bytes_written  # type: ignore


def fwrite_serialized_item(
    file_handle: HHandle,
    serialized_item_handle: HHandle
) -> None:
    """
    Write a serialized item to a file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    open_file, serialize_shape_model, serialize_ncc_model

    Successors
    ----------
    close_file, fread_serialized_item
    """
    with HalconOperator(405) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.set_input_tuple(1, serialized_item_handle)
        proc.execute()


def fwrite_string(
    file_handle: HHandle,
    string: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Write strings and numbers into a text file.

    Parameters
    ----------

    file_handle : HHandle
                  File handle.

    string : MaybeSequence[Union[int, float, str]]
             Values to be written into the file.
             Value Suggestion: hallo

    See Also
    --------
    open_file, close_file, set_system

    Alternatives
    ------------
    write_string

    Predecessors
    ------------
    open_file

    Successors
    ----------
    close_file
    """
    with HalconOperator(1660) as proc:
        proc.set_input_tuple(0, file_handle)
        proc.set_input_tuple(1, string)
        proc.execute()


def gamma_image(
    image: HObject,
    gamma: float,
    offset: float,
    threshold: float,
    max_gray: Union[float, int],
    encode: str
) -> HObject:
    """
    Perform a gamma encoding or decoding of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    gamma : float
            Gamma coefficient of the exponential part of the
            transformation.
            Value Suggestion: 0.416666666667

    offset : float
             Offset of the exponential part of the transformation.
             Value Suggestion: 0.055

    threshold : float
                Gray value for which the transformation switches from
                linear to exponential.
                Value Suggestion: 0.0031308

    max_gray : Union[float, int]
               Maximum gray value of the input image type.
               Value Suggestion: 255.0

    encode : str
             If 'true', perform a gamma encoding, otherwise a gamma
             decoding.
             Value Suggestion: true

    Returns
    -------

    gamma_image : HObject
                  Output image.

    See Also
    --------
    sqrt_image, exp_image, log_image

    Alternatives
    ------------
    pow_image

    Notes
    -----
    gamma_image can be executed on an OpenCL device for byte, uint2 and
    real images. As the operation is performed in single precision
    floating point instead of double precision as on the CPU, the result
    of the OpenCL implementation can vary slightly from that of the CPU
    implementation.
    """
    with HalconOperator(1593) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, gamma)
        proc.set_input_tuple(1, offset)
        proc.set_input_tuple(2, threshold)
        proc.set_input_tuple(3, max_gray)
        proc.set_input_tuple(4, encode)
        proc.execute()
        gamma_image = HObject(proc.get_output_object_key(1))
        return gamma_image  # type: ignore


def gauss_distribution(sigma: float) -> Sequence[float]:
    """
    Generate a Gaussian noise distribution.

    Parameters
    ----------

    sigma : float
            Standard deviation of the Gaussian noise distribution.
            Value Suggestion: 2.0

    Returns
    -------

    distribution : Sequence[float]
                   Resulting Gaussian noise distribution.

    See Also
    --------
    sp_distribution, add_noise_white, noise_distribution_mean

    Alternatives
    ------------
    sp_distribution, noise_distribution_mean

    Successors
    ----------
    add_noise_distribution
    """
    with HalconOperator(1443) as proc:
        proc.set_input_tuple(0, sigma)
        proc.init_oct(0)
        proc.execute()
        distribution = proc.get_output_tuple_m(0)
        return distribution  # type: ignore


def gauss_filter(image: HObject, size: int) -> HObject:
    """
    Smooth using discrete Gauss functions.

    Parameters
    ----------

    image : HObject
            Image to be smoothed.

    size : int
           Required filter size.
           Value Suggestion: 5

    Returns
    -------

    image_gauss : HObject
                  Filtered image.

    See Also
    --------
    mean_image, anisotropic_diffusion, sigma_image, gen_lowpass

    Alternatives
    ------------
    binomial_filter, smooth_image, derivate_gauss, isotropic_diffusion

    Predecessors
    ------------
    read_image, grab_image

    Successors
    ----------
    regiongrowing, threshold, sub_image, dyn_threshold, auto_threshold

    Notes
    -----
    In order to be able to process gauss_filter on on OpenCL device, Image
    must be at least 64 pixels in both width and height.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1422) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, size)
        proc.execute()
        image_gauss = HObject(proc.get_output_object_key(1))
        return image_gauss  # type: ignore


def gauss_image(image: HObject, size: int) -> HObject:
    """
    Smooth an image using discrete Gaussian functions.

    Parameters
    ----------

    image : HObject
            Image to be smoothed.

    size : int
           Required filter size.
           Value Suggestion: 5

    Returns
    -------

    image_gauss : HObject
                  Filtered image.

    Warnings
    --------
    gauss_image is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the  operator gauss_filter
    instead.

    Notes
    -----
    In order to be able to process gauss_image on on OpenCL device, Image
    must be at least 64 pixels in both width and height.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1421) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, size)
        proc.execute()
        image_gauss = HObject(proc.get_output_object_key(1))
        return image_gauss  # type: ignore


def gen_arbitrary_distortion_map(
    grid_spacing: int,
    row: Sequence[float],
    column: Sequence[float],
    grid_width: int,
    image_width: int,
    image_height: int,
    map_type: str
) -> HObject:
    """
    Generate a projection map that describes the mapping between an
    arbitrarily distorted image and the rectified image.

    Parameters
    ----------

    grid_spacing : int
                   Distance of the grid points in the rectified image.
                   Assertion: GridSpacing > 0

    row : Sequence[float]
          Row coordinates of the grid points in the distorted image.

    column : Sequence[float]
             Column coordinates of the grid points in the distorted image.
             Assertion: number(Row) == number(Column)

    grid_width : int
                 Width of the point grid (number of grid points).

    image_width : int
                  Width of the images to be rectified.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images to be rectified.
                   Assertion: ImageHeight > 0

    map_type : str
               Type of mapping.
               Value Suggestion: bilinear

    Returns
    -------

    map : HObject
          Image containing the mapping data.

    See Also
    --------
    create_rectification_grid, find_rectification_grid,
    connect_grid_points, gen_grid_rectification_map

    Successors
    ----------
    map_image
    """
    with HalconOperator(1160) as proc:
        proc.set_input_tuple(0, grid_spacing)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, grid_width)
        proc.set_input_tuple(4, image_width)
        proc.set_input_tuple(5, image_height)
        proc.set_input_tuple(6, map_type)
        proc.execute()
        map = HObject(proc.get_output_object_key(1))
        return map  # type: ignore


def gen_bandfilter(
    min_frequency: float,
    max_frequency: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate an ideal band filter.

    Parameters
    ----------

    min_frequency : float
                    Minimum frequency.
                    Value Suggestion: 0.1
                    Assertion: MinFrequency >= 0

    max_frequency : float
                    Maximum frequency.
                    Value Suggestion: 0.2
                    Assertion: MaxFrequency >= 0 && MaxFrequency >= MinFrequency

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_filter : HObject
                   Band filter in the frequency domain.

    See Also
    --------
    gen_highpass, gen_lowpass, gen_bandpass, gen_gauss_filter,
    gen_mean_filter, gen_derivative_filter

    Alternatives
    ------------
    gen_circle, paint_region

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1520) as proc:
        proc.set_input_tuple(0, min_frequency)
        proc.set_input_tuple(1, max_frequency)
        proc.set_input_tuple(2, norm)
        proc.set_input_tuple(3, mode)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, height)
        proc.execute()
        image_filter = HObject(proc.get_output_object_key(1))
        return image_filter  # type: ignore


def gen_bandpass(
    min_frequency: float,
    max_frequency: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate an ideal bandpass filter.

    Parameters
    ----------

    min_frequency : float
                    Minimum frequency.
                    Value Suggestion: 0.1
                    Assertion: MinFrequency >= 0

    max_frequency : float
                    Maximum frequency.
                    Value Suggestion: 0.2
                    Assertion: MaxFrequency >= 0 && MaxFrequency >= MinFrequency

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_bandpass : HObject
                     Bandpass filter in the frequency domain.

    See Also
    --------
    gen_highpass, gen_lowpass, gen_bandfilter, gen_gauss_filter,
    gen_mean_filter, gen_derivative_filter

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1521) as proc:
        proc.set_input_tuple(0, min_frequency)
        proc.set_input_tuple(1, max_frequency)
        proc.set_input_tuple(2, norm)
        proc.set_input_tuple(3, mode)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, height)
        proc.execute()
        image_bandpass = HObject(proc.get_output_object_key(1))
        return image_bandpass  # type: ignore


def gen_binocular_proj_rectification(
    fmatrix: Sequence[Union[float, int]],
    cov_fmat: Sequence[Union[float, int]],
    width_1: int,
    height_1: int,
    width_2: int,
    height_2: int,
    sub_sampling: Union[int, float],
    mapping: str
) -> Tuple[HObject, HObject, Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the projective rectification of weakly calibrated binocular
    stereo images.

    Parameters
    ----------

    fmatrix : Sequence[Union[float, int]]
              Fundamental matrix.

    cov_fmat : Sequence[Union[float, int]]
               $9- covariance matrix of the fundamental matrix.
               Value Suggestion: []

    width_1 : int
              Width of the 1. image.
              Value Suggestion: 512
              Assertion: Width1 > 0

    height_1 : int
               Height of the 1. image.
               Value Suggestion: 512
               Assertion: Height1 > 0

    width_2 : int
              Width of the 2. image.
              Value Suggestion: 512
              Assertion: Width2 > 0

    height_2 : int
               Height of the 2. image.
               Value Suggestion: 512
               Assertion: Height2 > 0

    sub_sampling : Union[int, float]
                   Subsampling factor.
                   Value Suggestion: 1

    mapping : str
              Type of mapping.
              Value Suggestion: no_map

    Returns
    -------

    map_1 : HObject
            Image coding the rectification of the 1. image.

    map_2 : HObject
            Image coding the rectification of the 2. image.

    cov_fmat_rect : Sequence[float]
                    $9- covariance matrix of the rectified fundamental
                    matrix.

    h1 : Sequence[float]
         Projective transformation of the 1. image.

    h2 : Sequence[float]
         Projective transformation of the 2. image.

    Alternatives
    ------------
    gen_binocular_rectification_map

    Predecessors
    ------------
    match_fundamental_matrix_ransac, vector_to_fundamental_matrix

    Successors
    ----------
    map_image, projective_trans_image, binocular_disparity
    """
    with HalconOperator(351) as proc:
        proc.set_input_tuple(0, fmatrix)
        proc.set_input_tuple(1, cov_fmat)
        proc.set_input_tuple(2, width_1)
        proc.set_input_tuple(3, height_1)
        proc.set_input_tuple(4, width_2)
        proc.set_input_tuple(5, height_2)
        proc.set_input_tuple(6, sub_sampling)
        proc.set_input_tuple(7, mapping)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # map_1
            HObject(proc.get_output_object_key(2)),  # map_2
            proc.get_output_tuple_m(0),  # cov_fmat_rect
            proc.get_output_tuple_m(1),  # h1
            proc.get_output_tuple_m(2)   # h2
        )  # type: ignore


def gen_binocular_rectification_map(
    cam_param_1: Sequence[Union[int, float, str]],
    cam_param_2: Sequence[Union[int, float, str]],
    rel_pose: Sequence[Union[int, float]],
    sub_sampling: float,
    method: str,
    map_type: str
) -> Tuple[HObject, HObject, Sequence[Union[int, float, str]], Sequence[Union[int, float, str]], Sequence[Union[int, float]], Sequence[Union[int, float]], Sequence[Union[int, float]]]:
    """
    Generate transformation maps that describe the mapping of the images
    of a binocular camera pair to a common rectified image plane.

    Parameters
    ----------

    cam_param_1 : Sequence[Union[int, float, str]]
                  Internal parameters of camera 1.

    cam_param_2 : Sequence[Union[int, float, str]]
                  Internal parameters of camera 2.

    rel_pose : Sequence[Union[int, float]]
               Point transformation from camera 2 to camera 1.

    sub_sampling : float
                   Subsampling factor.
                   Value Suggestion: 1.0

    method : str
             Type of rectification.
             Value Suggestion: viewing_direction

    map_type : str
               Type of mapping.
               Value Suggestion: bilinear

    Returns
    -------

    map_1 : HObject
            Image containing the mapping data of camera 1.

    map_2 : HObject
            Image containing the mapping data of camera 2.

    cam_param_rect_1 : Sequence[Union[int, float, str]]
                       Rectified internal parameters of camera 1.

    cam_param_rect_2 : Sequence[Union[int, float, str]]
                       Rectified internal parameters of camera 2.

    cam_pose_rect_1 : Sequence[Union[int, float]]
                      Point transformation from the rectified camera 1 to
                      the original camera 1.

    cam_pose_rect_2 : Sequence[Union[int, float]]
                      Point transformation from the rectified camera 1 to
                      the original camera 1.

    rel_pose_rect : Sequence[Union[int, float]]
                    Point transformation from the rectified camera 2 to
                    the rectified camera 1.

    See Also
    --------
    map_image, binocular_disparity, binocular_distance,
    binocular_disparity_mg, binocular_distance_mg, binocular_disparity_ms,
    binocular_distance_ms, gen_image_to_world_plane_map,
    contour_to_world_plane_xld, image_points_to_world_plane

    Alternatives
    ------------
    gen_image_to_world_plane_map

    Predecessors
    ------------
    binocular_calibration

    Successors
    ----------
    map_image

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.
    """
    with HalconOperator(369) as proc:
        proc.set_input_tuple(0, cam_param_1)
        proc.set_input_tuple(1, cam_param_2)
        proc.set_input_tuple(2, rel_pose)
        proc.set_input_tuple(3, sub_sampling)
        proc.set_input_tuple(4, method)
        proc.set_input_tuple(5, map_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # map_1
            HObject(proc.get_output_object_key(2)),  # map_2
            proc.get_output_tuple_m(0),  # cam_param_rect_1
            proc.get_output_tuple_m(1),  # cam_param_rect_2
            proc.get_output_tuple_m(2),  # cam_pose_rect_1
            proc.get_output_tuple_m(3),  # cam_pose_rect_2
            proc.get_output_tuple_m(4)   # rel_pose_rect
        )  # type: ignore


def gen_box_object_model_3d(
    pose: Sequence[Union[int, float]],
    length_x: MaybeSequence[float],
    length_y: MaybeSequence[float],
    length_z: MaybeSequence[float]
) -> Sequence[HHandle]:
    """
    Create a 3D object model that represents a box.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The pose that describes the position and orientation of the
           box.  The pose has its origin in the center of the box.

    length_x : MaybeSequence[float]
               The length of the box along the x-axis.

    length_y : MaybeSequence[float]
               The length of the box along the y-axis.

    length_z : MaybeSequence[float]
               The length of the box along the z-axis.

    Returns
    -------

    object_model_3d : Sequence[HHandle]
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_sphere_object_model_3d,
    gen_sphere_object_model_3d_center, gen_plane_object_model_3d

    Predecessors
    ------------
    smallest_bounding_box_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1070) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, length_x)
        proc.set_input_tuple(2, length_y)
        proc.set_input_tuple(3, length_z)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_m(0)
        return object_model_3d  # type: ignore


def gen_box_object_model_3d_s(
    pose: Sequence[Union[int, float]],
    length_x: MaybeSequence[float],
    length_y: MaybeSequence[float],
    length_z: MaybeSequence[float]
) -> HHandle:
    """
    Create a 3D object model that represents a box.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The pose that describes the position and orientation of the
           box.  The pose has its origin in the center of the box.

    length_x : MaybeSequence[float]
               The length of the box along the x-axis.

    length_y : MaybeSequence[float]
               The length of the box along the y-axis.

    length_z : MaybeSequence[float]
               The length of the box along the z-axis.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_sphere_object_model_3d,
    gen_sphere_object_model_3d_center, gen_plane_object_model_3d

    Predecessors
    ------------
    smallest_bounding_box_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1070) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, length_x)
        proc.set_input_tuple(2, length_y)
        proc.set_input_tuple(3, length_z)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def gen_bundle_adjusted_mosaic(
    images: HObject,
    hom_matrices_2d: Sequence[float],
    stacking_order: MaybeSequence[Union[str, int]],
    transform_domain: str
) -> Tuple[HObject, Sequence[float]]:
    """
    Combine multiple images into a mosaic image.

    Parameters
    ----------

    images : HObject
             Input images.

    hom_matrices_2d : Sequence[float]
                      Array of $3- projective transformation matrices.

    stacking_order : MaybeSequence[Union[str, int]]
                     Stacking order of the images in the mosaic.
                     Value Suggestion: default

    transform_domain : str
                       Should the domains of the input images also be
                       transformed?
                       Value Suggestion: false

    Returns
    -------

    mosaic_image : HObject
                   Output image.

    trans_mat_2d : Sequence[float]
                   $3- projective transformation matrix that describes the
                   translation that was necessary to transform all images
                   completely into the output image.

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d, projective_trans_pixel

    Alternatives
    ------------
    gen_projective_mosaic

    Predecessors
    ------------
    bundle_adjust_mosaic
    """
    with HalconOperator(1618) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, hom_matrices_2d)
        proc.set_input_tuple(1, stacking_order)
        proc.set_input_tuple(2, transform_domain)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # mosaic_image
            proc.get_output_tuple_m(0)   # trans_mat_2d
        )  # type: ignore


def gen_caltab(
    xnum: int,
    ynum: int,
    mark_dist: float,
    diameter_ratio: float,
    cal_plate_descr: str,
    cal_plate_psfile: str
) -> None:
    """
    Generate a calibration plate description file and a corresponding
    PostScript file for a calibration plate with rectangularly arranged
    marks.

    Parameters
    ----------

    xnum : int
           Number of marks in x direction.
           Value Suggestion: 7
           Assertion: XNum > 1

    ynum : int
           Number of marks in y direction.
           Value Suggestion: 7
           Assertion: YNum > 1

    mark_dist : float
                Distance of the marks in meters.
                Value Suggestion: 0.0125
                Assertion: 0.0 < MarkDist

    diameter_ratio : float
                     Ratio of the mark diameter to the mark distance.
                     Value Suggestion: 0.5
                     Assertion: 0.0 < DiameterRatio < 1.0

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: caltab.descr

    cal_plate_psfile : str
                       File name of the PostScript file.
                       Value Suggestion: caltab.ps

    See Also
    --------
    find_caltab, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab

    Alternatives
    ------------
    create_caltab

    Successors
    ----------
    read_cam_par, caltab_points

    Notes
    -----
    Depending on the accuracy of the used output device (e.g., laser
    printer), the printed calibration plate may not match the values in
    the calibration plate description file CalPlateDescr exactly. Thus,
    the coordinates of the calibration marks in the calibration plate
    description file may have to be corrected!
    """
    with HalconOperator(1926) as proc:
        proc.set_input_tuple(0, xnum)
        proc.set_input_tuple(1, ynum)
        proc.set_input_tuple(2, mark_dist)
        proc.set_input_tuple(3, diameter_ratio)
        proc.set_input_tuple(4, cal_plate_descr)
        proc.set_input_tuple(5, cal_plate_psfile)
        proc.execute()


def gen_checker_region(
    width_region: int,
    height_region: int,
    width_pattern: int,
    height_pattern: int
) -> HObject:
    """
    Create a checkered region.

    Parameters
    ----------

    width_region : int
                   Largest occurring $x$ value of the region.
                   Value Suggestion: 511
                   Assertion: WidthRegion >= 1

    height_region : int
                    Largest occurring $y$ value of the region.
                    Value Suggestion: 511
                    Assertion: HeightRegion >= 1

    width_pattern : int
                    Width of a field of the checkerboard.
                    Value Suggestion: 64
                    Assertion: WidthPattern > 0 && WidthPattern < WidthRegion

    height_pattern : int
                     Height of a field of the checkerboard.
                     Value Suggestion: 64
                     Assertion: HeightPattern > 0 && HeightPattern < HeightRegion

    Returns
    -------

    region_checker : HObject
                     Created checkerboard region.

    See Also
    --------
    reduce_domain

    Alternatives
    ------------
    gen_grid_region, gen_region_polygon_filled, gen_region_points,
    gen_region_runs, gen_rectangle1, concat_obj, gen_random_region,
    gen_random_regions

    Successors
    ----------
    paint_region

    Notes
    -----
    If a very small pattern is chosen (WidthPattern $<$ 4) the created
    region requires much storage.
    """
    with HalconOperator(612) as proc:
        proc.set_input_tuple(0, width_region)
        proc.set_input_tuple(1, height_region)
        proc.set_input_tuple(2, width_pattern)
        proc.set_input_tuple(3, height_pattern)
        proc.execute()
        region_checker = HObject(proc.get_output_object_key(1))
        return region_checker  # type: ignore


def gen_circle(
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    radius: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Create a circle.

    Parameters
    ----------

    row : MaybeSequence[Union[int, float]]
          Line index of center.
          Value Suggestion: 200.0

    column : MaybeSequence[Union[int, float]]
             Column index of center.
             Value Suggestion: 200.0

    radius : MaybeSequence[Union[int, float]]
             Radius of circle.
             Value Suggestion: 100.5
             Assertion: Radius > 0.0

    Returns
    -------

    circle : HObject
             Generated circle.

    See Also
    --------
    disp_circle, set_shape, smallest_circle, reduce_domain

    Alternatives
    ------------
    gen_ellipse, gen_region_polygon_filled, gen_region_points,
    gen_region_runs, draw_circle

    Successors
    ----------
    paint_region, reduce_domain

    Notes
    -----
    For speed reasons, the resulting region may contain additional pixels
    at the border and some individual pixels at the border may be missing.
    This may lead to an inconsistency between the operators
    smallest_circle and gen_circle.
    """
    with HalconOperator(611) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, radius)
        proc.execute()
        circle = HObject(proc.get_output_object_key(1))
        return circle  # type: ignore


def gen_circle_contour_xld(
    row: MaybeSequence[float],
    column: MaybeSequence[float],
    radius: MaybeSequence[float],
    start_phi: MaybeSequence[float],
    end_phi: MaybeSequence[float],
    point_order: MaybeSequence[str],
    resolution: float
) -> HObject:
    """
    Create XLD contours corresponding to circles or circular arcs.

    Parameters
    ----------

    row : MaybeSequence[float]
          Row coordinate of the center of the circles or circular arcs.
          Value Suggestion: 200.0

    column : MaybeSequence[float]
             Column coordinate of the center of the circles or circular
             arcs.
             Value Suggestion: 200.0

    radius : MaybeSequence[float]
             Radius of the circles or circular arcs.
             Value Suggestion: 100.0
             Assertion: Radius > 0

    start_phi : MaybeSequence[float]
                Angle of the start points of the circles or circular arcs
                [rad].
                Value Suggestion: 0.0

    end_phi : MaybeSequence[float]
              Angle of the end points of the circles or circular arcs
              [rad].
              Value Suggestion: 6.28318

    point_order : MaybeSequence[str]
                  Point order along the circles or circular arcs.
                  Value Suggestion: positive

    resolution : float
                 Distance between neighboring contour points.
                 Value Suggestion: 1.0
                 Assertion: Resolution >= 0.00001

    Returns
    -------

    cont_circle : HObject
                  Resulting contours.

    Alternatives
    ------------
    gen_ellipse_contour_xld

    Predecessors
    ------------
    draw_circle

    Successors
    ----------
    disp_xld
    """
    with HalconOperator(34) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, start_phi)
        proc.set_input_tuple(4, end_phi)
        proc.set_input_tuple(5, point_order)
        proc.set_input_tuple(6, resolution)
        proc.execute()
        cont_circle = HObject(proc.get_output_object_key(1))
        return cont_circle  # type: ignore


def gen_circle_sector(
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    radius: MaybeSequence[Union[int, float]],
    start_angle: MaybeSequence[Union[int, float]],
    end_angle: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Create a circle sector.

    Parameters
    ----------

    row : MaybeSequence[Union[int, float]]
          Line index of center.
          Value Suggestion: 200.0

    column : MaybeSequence[Union[int, float]]
             Column index of center.
             Value Suggestion: 200.0

    radius : MaybeSequence[Union[int, float]]
             Radius of circle.
             Value Suggestion: 100.5
             Assertion: Radius > 0.0

    start_angle : MaybeSequence[Union[int, float]]
                  Start angle of the circle sector.
                  Value Suggestion: 0.0
                  Assertion: 0 <= StartAngle && StartAngle <= 2 * pi

    end_angle : MaybeSequence[Union[int, float]]
                End angle of the circle sector.
                Value Suggestion: 3.14159
                Assertion: 0 <= EndAngle && EndAngle <= 2 * pi

    Returns
    -------

    circle_sector : HObject
                    Generated circle sector.

    See Also
    --------
    disp_circle, disp_region, set_shape, smallest_circle, reduce_domain

    Alternatives
    ------------
    gen_ellipse, gen_ellipse_sector, gen_region_polygon_filled,
    gen_region_points, gen_region_runs, draw_circle

    Successors
    ----------
    paint_region, reduce_domain
    """
    with HalconOperator(610) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, start_angle)
        proc.set_input_tuple(4, end_angle)
        proc.execute()
        circle_sector = HObject(proc.get_output_object_key(1))
        return circle_sector  # type: ignore


def gen_contour_nurbs_xld(
    rows: Sequence[float],
    cols: Sequence[float],
    knots: MaybeSequence[Union[str, float]],
    weights: MaybeSequence[Union[str, float]],
    degree: int,
    max_error: Union[float, str],
    max_distance: Union[float, str]
) -> HObject:
    """
    Transform a NURBS curve into an XLD contour.

    Parameters
    ----------

    rows : Sequence[float]
           Row coordinates of the control polygon.

    cols : Sequence[float]
           Column coordinates of the control polygon.

    knots : MaybeSequence[Union[str, float]]
            The knot vector $u$.
            Value Suggestion: auto

    weights : MaybeSequence[Union[str, float]]
              The weight vector $w$.
              Value Suggestion: auto
              Assertion: Weights > 0.0

    degree : int
             The degree $p$ of the NURBS curve.
             Value Suggestion: 3
             Assertion: Degree >= 2

    max_error : Union[float, str]
                Maximum distance between the NURBS curve and its
                approximation.
                Value Suggestion: 1.0
                Assertion: MaxError > 0.0

    max_distance : Union[float, str]
                   Maximum distance between two subsequent Contour points.
                   Value Suggestion: 5.0
                   Assertion: MaxDistance > 0.0

    Returns
    -------

    contour : HObject
              The contour that approximates the NURBS curve.

    Predecessors
    ------------
    gen_nurbs_interp

    Successors
    ----------
    gen_polygons_xld
    """
    with HalconOperator(4) as proc:
        proc.set_input_tuple(0, rows)
        proc.set_input_tuple(1, cols)
        proc.set_input_tuple(2, knots)
        proc.set_input_tuple(3, weights)
        proc.set_input_tuple(4, degree)
        proc.set_input_tuple(5, max_error)
        proc.set_input_tuple(6, max_distance)
        proc.execute()
        contour = HObject(proc.get_output_object_key(1))
        return contour  # type: ignore


def gen_contour_polygon_rounded_xld(
    row: Sequence[Union[float, int]],
    col: Sequence[Union[float, int]],
    radius: Sequence[Union[float, int]],
    sampling_interval: Union[float, int]
) -> HObject:
    """
    Generate an XLD contour with rounded corners from a polygon (given as
    tuples).

    Parameters
    ----------

    row : Sequence[Union[float, int]]
          Row coordinates of the polygon.
          Value Suggestion: [20,80,80,20,20]

    col : Sequence[Union[float, int]]
          Column coordinates of the polygon.
          Value Suggestion: [20,20,80,80,20]

    radius : Sequence[Union[float, int]]
             Radii of the rounded corners.
             Value Suggestion: [20,20,20,20,20]

    sampling_interval : Union[float, int]
                        Distance of the samples.
                        Value Suggestion: 1.0

    Returns
    -------

    contour : HObject
              Resulting contour.

    See Also
    --------
    gen_contour_polygon_xld, gen_contours_skeleton_xld

    Predecessors
    ------------
    get_region_contour

    Successors
    ----------
    smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(71) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, col)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, sampling_interval)
        proc.execute()
        contour = HObject(proc.get_output_object_key(1))
        return contour  # type: ignore


def gen_contour_polygon_xld(
    row: Sequence[Union[float, int]],
    col: Sequence[Union[float, int]]
) -> HObject:
    """
    Generate an XLD contour from a polygon (given as tuples).

    Parameters
    ----------

    row : Sequence[Union[float, int]]
          Row coordinates of the polygon.
          Value Suggestion: [0,1,2,2,2]

    col : Sequence[Union[float, int]]
          Column coordinates of the polygon.
          Value Suggestion: [0,0,0,1,2]

    Returns
    -------

    contour : HObject
              Resulting contour.

    See Also
    --------
    gen_contours_skeleton_xld, get_contour_xld

    Predecessors
    ------------
    get_region_contour

    Successors
    ----------
    smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(72) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, col)
        proc.execute()
        contour = HObject(proc.get_output_object_key(1))
        return contour  # type: ignore


def gen_contour_region_xld(regions: HObject, mode: str) -> HObject:
    """
    Generate XLD contours from regions.

    Parameters
    ----------

    regions : HObject
              Input regions.

    mode : str
           Mode of contour generation.
           Value Suggestion: border

    Returns
    -------

    contours : HObject
               Resulting contours.

    See Also
    --------
    gen_contours_skeleton_xld

    Alternatives
    ------------
    gen_contour_polygon_xld, get_region_contour

    Successors
    ----------
    smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(70) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, mode)
        proc.execute()
        contours = HObject(proc.get_output_object_key(1))
        return contours  # type: ignore


def gen_contours_skeleton_xld(
    skeleton: HObject,
    length: int,
    mode: str
) -> HObject:
    """
    Convert a skeleton into XLD contours.

    Parameters
    ----------

    skeleton : HObject
               Skeleton of which the contours are to be determined.

    length : int
             Minimum number of points a contour has to have.
             Value Suggestion: 1

    mode : str
           Contour filter mode.
           Value Suggestion: filter

    Returns
    -------

    contours : HObject
               Resulting contours.

    See Also
    --------
    edges_image, threshold, get_region_contour

    Predecessors
    ------------
    skeleton

    Successors
    ----------
    smooth_contours_xld, get_contour_xld, gen_polygons_xld
    """
    with HalconOperator(73) as proc:
        proc.set_input_object(1, skeleton)
        proc.set_input_tuple(0, length)
        proc.set_input_tuple(1, mode)
        proc.execute()
        contours = HObject(proc.get_output_object_key(1))
        return contours  # type: ignore


def gen_cooc_matrix(
    regions: HObject,
    image: HObject,
    ld_gray: int,
    direction: int
) -> HObject:
    """
    Calculate the co-occurrence matrix of a region in an image.

    Parameters
    ----------

    regions : HObject
              Region to be checked.

    image : HObject
            Image providing the gray values.

    ld_gray : int
              Number of gray values to be distinguished
              (2^LdGray$2^{LdGray}$).
              Value Suggestion: 6

    direction : int
                Direction of neighbor relation.
                Value Suggestion: 0

    Returns
    -------

    matrix : HObject
             Co-occurrence matrix (matrices).

    See Also
    --------
    cooc_feature_matrix

    Alternatives
    ------------
    cooc_feature_image

    Predecessors
    ------------
    draw_region, gen_circle, gen_ellipse, gen_rectangle1, gen_rectangle2,
    threshold, erosion_circle, binomial_filter, gauss_filter,
    smooth_image, sub_image

    Notes
    -----
    Note that the operator gen_cooc_matrix only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1760) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ld_gray)
        proc.set_input_tuple(1, direction)
        proc.execute()
        matrix = HObject(proc.get_output_object_key(1))
        return matrix  # type: ignore


def gen_cross_contour_xld(
    row: MaybeSequence[Union[float, int]],
    col: MaybeSequence[Union[float, int]],
    size: Union[float, int],
    angle: float
) -> HObject:
    """
    Generate one XLD contour in the shape of a cross for each input point.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinates of the input points.

    col : MaybeSequence[Union[float, int]]
          Column coordinates of the input points.
          Assertion: number(Col) == number(Row)

    size : Union[float, int]
           Length of the cross bars.
           Value Suggestion: 6.0
           Assertion: 0.0 <= Size

    angle : float
            Orientation of the crosses.
            Value Suggestion: 0.785398

    Returns
    -------

    cross : HObject
            Generated XLD contours.

    Alternatives
    ------------
    disp_cross

    Predecessors
    ------------
    points_foerstner, points_harris, critical_points_sub_pix,
    local_max_sub_pix, local_min_sub_pix, saddle_points_sub_pix
    """
    with HalconOperator(15) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, col)
        proc.set_input_tuple(2, size)
        proc.set_input_tuple(3, angle)
        proc.execute()
        cross = HObject(proc.get_output_object_key(1))
        return cross  # type: ignore


def gen_cube_map_mosaic(
    images: HObject,
    camera_matrices: Sequence[float],
    rotation_matrices: Sequence[float],
    cube_map_dimension: int,
    stacking_order: MaybeSequence[Union[str, int]],
    interpolation: str
) -> Tuple[HObject, HObject, HObject, HObject, HObject, HObject]:
    """
    Create 6 cube map images of a spherical mosaic.

    Parameters
    ----------

    images : HObject
             Input images.

    camera_matrices : Sequence[float]
                      (Array of) $3- projective camera matrices that
                      determine the internal camera parameters.

    rotation_matrices : Sequence[float]
                        Array of $3-                     transformation
                        matrices that determine rotation of the camera in
                        the respective image.

    cube_map_dimension : int
                         Width and height of the resulting cube maps.
                         Value Suggestion: 1000
                         Assertion: CubeMapDimension >= 0

    stacking_order : MaybeSequence[Union[str, int]]
                     Mode of adding the images to the mosaic image.
                     Value Suggestion: voronoi

    interpolation : str
                    Mode of image interpolation.
                    Value Suggestion: bilinear

    Returns
    -------

    front : HObject
            Front cube map.

    rear : HObject
           Rear cube map.

    left : HObject
           Left cube map.

    right : HObject
            Right cube map.

    top : HObject
          Top cube map.

    bottom : HObject
             Bottom cube map.

    Alternatives
    ------------
    gen_spherical_mosaic, gen_projective_mosaic

    Predecessors
    ------------
    stationary_camera_self_calibration
    """
    with HalconOperator(1616) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, camera_matrices)
        proc.set_input_tuple(1, rotation_matrices)
        proc.set_input_tuple(2, cube_map_dimension)
        proc.set_input_tuple(3, stacking_order)
        proc.set_input_tuple(4, interpolation)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # front
            HObject(proc.get_output_object_key(2)),  # rear
            HObject(proc.get_output_object_key(3)),  # left
            HObject(proc.get_output_object_key(4)),  # right
            HObject(proc.get_output_object_key(5)),  # top
            HObject(proc.get_output_object_key(6))   # bottom
        )  # type: ignore


def gen_cylinder_object_model_3d(
    pose: Sequence[Union[int, float]],
    radius: MaybeSequence[float],
    min_extent: MaybeSequence[float],
    max_extent: MaybeSequence[float]
) -> Sequence[HHandle]:
    """
    Create a 3D object model that represents a cylinder.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The pose that describes the position and orientation of the
           cylinder.

    radius : MaybeSequence[float]
             The radius of the cylinder.

    min_extent : MaybeSequence[float]
                 Lowest z-coordinate of the cylinder in the direction of
                 the rotation axis.

    max_extent : MaybeSequence[float]
                 Highest z-coordinate of the cylinder in the direction of
                 the rotation axis.
                 Assertion: MinExtent < MaxExtent

    Returns
    -------

    object_model_3d : Sequence[HHandle]
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_sphere_object_model_3d, gen_sphere_object_model_3d_center,
    gen_plane_object_model_3d, gen_box_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1074) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, radius)
        proc.set_input_tuple(2, min_extent)
        proc.set_input_tuple(3, max_extent)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_m(0)
        return object_model_3d  # type: ignore


def gen_cylinder_object_model_3d_s(
    pose: Sequence[Union[int, float]],
    radius: MaybeSequence[float],
    min_extent: MaybeSequence[float],
    max_extent: MaybeSequence[float]
) -> HHandle:
    """
    Create a 3D object model that represents a cylinder.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The pose that describes the position and orientation of the
           cylinder.

    radius : MaybeSequence[float]
             The radius of the cylinder.

    min_extent : MaybeSequence[float]
                 Lowest z-coordinate of the cylinder in the direction of
                 the rotation axis.

    max_extent : MaybeSequence[float]
                 Highest z-coordinate of the cylinder in the direction of
                 the rotation axis.
                 Assertion: MinExtent < MaxExtent

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_sphere_object_model_3d, gen_sphere_object_model_3d_center,
    gen_plane_object_model_3d, gen_box_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1074) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, radius)
        proc.set_input_tuple(2, min_extent)
        proc.set_input_tuple(3, max_extent)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def gen_derivative_filter(
    derivative: str,
    exponent: int,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate a derivative filter in the frequency domain.

    Parameters
    ----------

    derivative : str
                 Derivative to be computed.
                 Value Suggestion: x

    exponent : int
               Exponent used in the reverse transform.
               Value Suggestion: 1

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_derivative : HObject
                       Derivative filter as image in the frequency domain.

    See Also
    --------
    fft_image_inv, gen_gauss_filter, gen_mean_filter, gen_lowpass,
    gen_bandpass, gen_bandfilter, gen_highpass

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1517) as proc:
        proc.set_input_tuple(0, derivative)
        proc.set_input_tuple(1, exponent)
        proc.set_input_tuple(2, norm)
        proc.set_input_tuple(3, mode)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, height)
        proc.execute()
        image_derivative = HObject(proc.get_output_object_key(1))
        return image_derivative  # type: ignore


def gen_disc_se(
    type: str,
    width: int,
    height: int,
    smax: Union[int, float]
) -> HObject:
    """
    Generate ellipsoidal structuring elements for gray morphology.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    width : int
            Width of the structuring element.
            Value Suggestion: 5

    height : int
             Height of the structuring element.
             Value Suggestion: 5

    smax : Union[int, float]
           Maximum gray value of the structuring element.
           Value Suggestion: 0

    Returns
    -------

    se : HObject
         Generated structuring element.

    See Also
    --------
    paint_region, paint_gray, crop_part

    Alternatives
    ------------
    read_gray_se, read_image

    Successors
    ----------
    gray_erosion, gray_dilation, gray_opening, gray_closing, gray_tophat,
    gray_bothat, write_image
    """
    with HalconOperator(787) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, smax)
        proc.execute()
        se = HObject(proc.get_output_object_key(1))
        return se  # type: ignore


def gen_dl_model_heatmap(
    dlmodel_handle: HHandle,
    dlsample: Sequence[HHandle],
    heatmap_method: str,
    target_classes: MaybeSequence[int],
    gen_param: HHandle
) -> Sequence[HHandle]:
    """
    Infer the sample and generate a heatmap.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of a Deep learning model.

    dlsample : Sequence[HHandle]
               Dictionaries with the sample input data.

    heatmap_method : str
                     Method to be used for the heatmap calculation.
                     Value Suggestion: 'grad_cam'

    target_classes : MaybeSequence[int]
                     ID of the target class.
                     Value Suggestion: []

    gen_param : HHandle
                Dictionary for generic parameters.
                Value Suggestion: []

    Returns
    -------

    dlresult : Sequence[HHandle]
               Dictionaries with the result data.

    Predecessors
    ------------
    apply_dl_model

    Notes
    -----
    System requirements:  To run this operator on GPU by setting 'runtime'
    to 'gpu' (see get_dl_model_param), cuDNN and cuBLAS are required. For
    further details, please refer to the ``Installation Guide'', paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    Alternatively, this operator can also be run on CPU by setting
    'runtime' to 'cpu'.
    The heatmap should be used as a tool for visualizing and better
    understanding classification results. It is not intended as a
    segmentation tool. Moreover, gen_dl_model_heatmap currently only
    supports models with 'type'='classification'.
    """
    with HalconOperator(2184) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, dlsample)
        proc.set_input_tuple(2, heatmap_method)
        proc.set_input_tuple(3, target_classes)
        proc.set_input_tuple(4, gen_param)
        proc.init_oct(0)
        proc.execute()
        dlresult = proc.get_output_tuple_m(0)
        return dlresult  # type: ignore


def gen_dl_model_heatmap_s(
    dlmodel_handle: HHandle,
    dlsample: Sequence[HHandle],
    heatmap_method: str,
    target_classes: MaybeSequence[int],
    gen_param: HHandle
) -> HHandle:
    """
    Infer the sample and generate a heatmap.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of a Deep learning model.

    dlsample : Sequence[HHandle]
               Dictionaries with the sample input data.

    heatmap_method : str
                     Method to be used for the heatmap calculation.
                     Value Suggestion: 'grad_cam'

    target_classes : MaybeSequence[int]
                     ID of the target class.
                     Value Suggestion: []

    gen_param : HHandle
                Dictionary for generic parameters.
                Value Suggestion: []

    Returns
    -------

    dlresult : HHandle
               Dictionaries with the result data.

    Predecessors
    ------------
    apply_dl_model

    Notes
    -----
    System requirements:  To run this operator on GPU by setting 'runtime'
    to 'gpu' (see get_dl_model_param), cuDNN and cuBLAS are required. For
    further details, please refer to the ``Installation Guide'', paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    Alternatively, this operator can also be run on CPU by setting
    'runtime' to 'cpu'.
    The heatmap should be used as a tool for visualizing and better
    understanding classification results. It is not intended as a
    segmentation tool. Moreover, gen_dl_model_heatmap currently only
    supports models with 'type'='classification'.
    """
    with HalconOperator(2184) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, dlsample)
        proc.set_input_tuple(2, heatmap_method)
        proc.set_input_tuple(3, target_classes)
        proc.set_input_tuple(4, gen_param)
        proc.init_oct(0)
        proc.execute()
        dlresult = proc.get_output_tuple_s(0)
        return dlresult  # type: ignore


def gen_dl_pruned_model(
    dlmodel_handle_to_prune: HHandle,
    dlpruning_handle: HHandle
) -> HHandle:
    """
    Prune a deep learning model.

    Parameters
    ----------

    dlmodel_handle_to_prune : HHandle
                              Input model.

    dlpruning_handle : HHandle
                       Pruning data handle.

    Returns
    -------

    dlmodel_handle_pruned : HHandle
                            Pruned model.

    Predecessors
    ------------
    add_dl_pruning_batch, set_dl_pruning_param
    """
    with HalconOperator(2210) as proc:
        proc.set_input_tuple(0, dlmodel_handle_to_prune)
        proc.set_input_tuple(1, dlpruning_handle)
        proc.init_oct(0)
        proc.execute()
        dlmodel_handle_pruned = proc.get_output_tuple_s(0)
        return dlmodel_handle_pruned  # type: ignore


def gen_ellipse(
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    radius_1: MaybeSequence[Union[int, float]],
    radius_2: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Create an ellipse.

    Parameters
    ----------

    row : MaybeSequence[Union[int, float]]
          Line index of center.
          Value Suggestion: 200.0

    column : MaybeSequence[Union[int, float]]
             Column index of center.
             Value Suggestion: 200.0

    phi : MaybeSequence[Union[int, float]]
          Orientation of the longer radius (Radius1).
          Value Suggestion: 0.0

    radius_1 : MaybeSequence[Union[int, float]]
               Longer radius.
               Value Suggestion: 100.0
               Assertion: Radius1 > 0

    radius_2 : MaybeSequence[Union[int, float]]
               Shorter radius.
               Value Suggestion: 60.0
               Assertion: Radius2 > 0 && Radius2 <= Radius1

    Returns
    -------

    ellipse : HObject
              Created ellipse(s).

    See Also
    --------
    disp_ellipse, set_shape, smallest_circle, reduce_domain

    Alternatives
    ------------
    gen_circle, gen_region_polygon_filled, draw_ellipse

    Successors
    ----------
    paint_region, reduce_domain
    """
    with HalconOperator(609) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, radius_1)
        proc.set_input_tuple(4, radius_2)
        proc.execute()
        ellipse = HObject(proc.get_output_object_key(1))
        return ellipse  # type: ignore


def gen_ellipse_contour_xld(
    row: MaybeSequence[float],
    column: MaybeSequence[float],
    phi: MaybeSequence[float],
    radius_1: MaybeSequence[float],
    radius_2: MaybeSequence[float],
    start_phi: MaybeSequence[float],
    end_phi: MaybeSequence[float],
    point_order: MaybeSequence[str],
    resolution: float
) -> HObject:
    """
    Create an XLD contour that corresponds to an elliptic arc.

    Parameters
    ----------

    row : MaybeSequence[float]
          Row coordinate of the center of the ellipse.
          Value Suggestion: 200.0

    column : MaybeSequence[float]
             Column coordinate of the center of the ellipse.
             Value Suggestion: 200.0

    phi : MaybeSequence[float]
          Orientation of the main axis [rad].
          Value Suggestion: 0.0

    radius_1 : MaybeSequence[float]
               Length of the larger half axis.
               Value Suggestion: 100.0
               Assertion: Radius1 > 0

    radius_2 : MaybeSequence[float]
               Length of the smaller half axis.
               Value Suggestion: 50.0
               Assertion: Radius2 >= 0 && Radius2 <= Radius1

    start_phi : MaybeSequence[float]
                Angle of the start point on the smallest surrounding
                circle  [rad].
                Value Suggestion: 0.0

    end_phi : MaybeSequence[float]
              Angle of the end point on the smallest surrounding circle
              [rad].
              Value Suggestion: 6.28318

    point_order : MaybeSequence[str]
                  point order along the boundary.
                  Value Suggestion: positive

    resolution : float
                 Resolution: Maximum distance between neighboring contour
                 points.
                 Value Suggestion: 1.5
                 Assertion: Resolution >= 1.192e-7

    Returns
    -------

    cont_ellipse : HObject
                   Resulting contour.

    Alternatives
    ------------
    gen_circle_contour_xld

    Predecessors
    ------------
    draw_ellipse

    Successors
    ----------
    disp_xld, get_points_ellipse
    """
    with HalconOperator(35) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, radius_1)
        proc.set_input_tuple(4, radius_2)
        proc.set_input_tuple(5, start_phi)
        proc.set_input_tuple(6, end_phi)
        proc.set_input_tuple(7, point_order)
        proc.set_input_tuple(8, resolution)
        proc.execute()
        cont_ellipse = HObject(proc.get_output_object_key(1))
        return cont_ellipse  # type: ignore


def gen_ellipse_sector(
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    radius_1: MaybeSequence[Union[int, float]],
    radius_2: MaybeSequence[Union[int, float]],
    start_angle: MaybeSequence[Union[int, float]],
    end_angle: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Create an ellipse sector.

    Parameters
    ----------

    row : MaybeSequence[Union[int, float]]
          Line index of center.
          Value Suggestion: 200.0

    column : MaybeSequence[Union[int, float]]
             Column index of center.
             Value Suggestion: 200.0

    phi : MaybeSequence[Union[int, float]]
          Orientation of the longer radius (Radius1).
          Value Suggestion: 0.0
          Assertion: - pi / 2 <= Phi <= pi / 2

    radius_1 : MaybeSequence[Union[int, float]]
               Longer radius.
               Value Suggestion: 100.0
               Assertion: Radius1 > 0

    radius_2 : MaybeSequence[Union[int, float]]
               Shorter radius.
               Value Suggestion: 60.0
               Assertion: Radius2 > 0 && Radius2 <= Radius1

    start_angle : MaybeSequence[Union[int, float]]
                  Start angle of the sector.
                  Value Suggestion: 0.0
                  Assertion: 0 <= StartAngle && StartAngle <= 2 * pi

    end_angle : MaybeSequence[Union[int, float]]
                End angle of the sector.
                Value Suggestion: 3.14159
                Assertion: 0 <= EndAngle && EndAngle <= 2 * pi

    Returns
    -------

    ellipse_sector : HObject
                     Created ellipse(s).

    See Also
    --------
    disp_ellipse, set_shape, smallest_circle, reduce_domain

    Alternatives
    ------------
    gen_circle, gen_circle_sector, gen_region_polygon_filled,
    draw_ellipse, gen_ellipse

    Successors
    ----------
    paint_region, reduce_domain
    """
    with HalconOperator(608) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, radius_1)
        proc.set_input_tuple(4, radius_2)
        proc.set_input_tuple(5, start_angle)
        proc.set_input_tuple(6, end_angle)
        proc.execute()
        ellipse_sector = HObject(proc.get_output_object_key(1))
        return ellipse_sector  # type: ignore


def gen_empty_obj() -> HObject:
    """
    Create an empty object tuple.

    Returns
    -------

    empty_object : HObject
                   No objects.
    """
    with HalconOperator(617) as proc:
        proc.execute()
        empty_object = HObject(proc.get_output_object_key(1))
        return empty_object  # type: ignore


def gen_empty_object_model_3d() -> HHandle:
    """
    Create an empty 3D object model.

    Returns
    -------

    empty_object_model_3d : HHandle
                            Handle of the new 3D object model.

    See Also
    --------
    gen_box_object_model_3d, gen_cylinder_object_model_3d,
    gen_sphere_object_model_3d, gen_sphere_object_model_3d_center,
    gen_plane_object_model_3d

    Successors
    ----------
    set_object_model_3d_attrib, set_object_model_3d_attrib_mod
    """
    with HalconOperator(1065) as proc:
        proc.init_oct(0)
        proc.execute()
        empty_object_model_3d = proc.get_output_tuple_s(0)
        return empty_object_model_3d  # type: ignore


def gen_empty_region() -> HObject:
    """
    Create an empty region.

    Returns
    -------

    empty_region : HObject
                   Empty region (no pixels).
    """
    with HalconOperator(618) as proc:
        proc.execute()
        empty_region = HObject(proc.get_output_object_key(1))
        return empty_region  # type: ignore


def gen_filter_mask(
    filter_mask: MaybeSequence[Union[int, str]],
    scale: float,
    width: int,
    height: int
) -> HObject:
    """
    Store a filter mask in the spatial domain as a real-image.

    Parameters
    ----------

    filter_mask : MaybeSequence[Union[int, str]]
                  Filter mask as file name or tuple.
                  Value Suggestion: gauss

    scale : float
            Scaling factor.
            Value Suggestion: 1.0
            Assertion: Scale > 0.0

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_filter : HObject
                   Filter in the spatial domain.

    See Also
    --------
    convol_image

    Successors
    ----------
    fft_image, fft_generic
    """
    with HalconOperator(1514) as proc:
        proc.set_input_tuple(0, filter_mask)
        proc.set_input_tuple(1, scale)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.execute()
        image_filter = HObject(proc.get_output_object_key(1))
        return image_filter  # type: ignore


def gen_gabor(
    angle: float,
    frequency: float,
    bandwidth: float,
    orientation: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate a Gabor filter.

    Parameters
    ----------

    angle : float
            Angle range, inversely proportional to the range of
            orientations.
            Value Suggestion: 1.4

    frequency : float
                Distance of the center of the filter to the DC term.
                Value Suggestion: 0.4

    bandwidth : float
                Bandwidth range, inversely proportional to the range of
                frequencies being passed.
                Value Suggestion: 1.0

    orientation : float
                  Angle of the principal orientation.
                  Value Suggestion: 1.5

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_filter : HObject
                   Gabor and Hilbert filter.

    See Also
    --------
    fft_image_inv, energy_gabor

    Alternatives
    ------------
    gen_bandpass, gen_bandfilter, gen_highpass, gen_lowpass

    Predecessors
    ------------
    fft_image, fft_generic

    Successors
    ----------
    convol_gabor
    """
    with HalconOperator(1531) as proc:
        proc.set_input_tuple(0, angle)
        proc.set_input_tuple(1, frequency)
        proc.set_input_tuple(2, bandwidth)
        proc.set_input_tuple(3, orientation)
        proc.set_input_tuple(4, norm)
        proc.set_input_tuple(5, mode)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.execute()
        image_filter = HObject(proc.get_output_object_key(1))
        return image_filter  # type: ignore


def gen_gauss_filter(
    sigma_1: float,
    sigma_2: float,
    phi: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate a Gaussian filter in the frequency domain.

    Parameters
    ----------

    sigma_1 : float
              Standard deviation of the Gaussian in the principal
              direction of the filter in the spatial domain.
              Value Suggestion: 1.0
              Assertion: Sigma1 >= 0

    sigma_2 : float
              Standard deviation of the Gaussian perpendicular to the
              principal direction of the filter in the spatial domain.
              Value Suggestion: 1.0
              Assertion: Sigma2 >= 0

    phi : float
          Principal direction of the filter in the spatial domain.
          Value Suggestion: 0.0

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_gauss : HObject
                  Gaussian filter as image in the frequency domain.

    See Also
    --------
    fft_image_inv, gen_mean_filter, gen_derivative_filter, gen_lowpass,
    gen_bandpass, gen_bandfilter, gen_highpass

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1516) as proc:
        proc.set_input_tuple(0, sigma_1)
        proc.set_input_tuple(1, sigma_2)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, norm)
        proc.set_input_tuple(4, mode)
        proc.set_input_tuple(5, width)
        proc.set_input_tuple(6, height)
        proc.execute()
        image_gauss = HObject(proc.get_output_object_key(1))
        return image_gauss  # type: ignore


def gen_gauss_pyramid(
    image: HObject,
    mode: str,
    scale: float
) -> HObject:
    """
    Calculating a Gauss pyramid.

    Parameters
    ----------

    image : HObject
            Input image.

    mode : str
           Kind of filtermask.
           Value Suggestion: weighted

    scale : float
            Factor for scaling down.
            Value Suggestion: 0.5
            Assertion: 0.1 < Scale && Scale < 0.9

    Returns
    -------

    image_pyramid : HObject
                    Output images.

    See Also
    --------
    affine_trans_image

    Alternatives
    ------------
    zoom_image_size, zoom_image_factor

    Successors
    ----------
    image_to_channels, count_obj, select_obj, copy_obj
    """
    with HalconOperator(1508) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, scale)
        proc.execute()
        image_pyramid = HObject(proc.get_output_object_key(1))
        return image_pyramid  # type: ignore


def gen_grid_rectification_map(
    image: HObject,
    connecting_lines: HObject,
    grid_spacing: int,
    rotation: Union[str, int],
    row: Sequence[float],
    column: Sequence[float],
    map_type: str
) -> Tuple[HObject, HObject]:
    """
    Compute the mapping between the distorted image and the rectified
    image based upon the points of a regular grid.

    Parameters
    ----------

    image : HObject
            Input image.

    connecting_lines : HObject
                       Input contours.

    grid_spacing : int
                   Distance of the grid points in the rectified image.
                   Assertion: GridSpacing > 0

    rotation : Union[str, int]
               Rotation to be applied to the point grid.
               Value Suggestion: 'auto'

    row : Sequence[float]
          Row coordinates of the grid points.

    column : Sequence[float]
             Column coordinates of the grid points.
             Assertion: number(Column) == number(Row)

    map_type : str
               Type of mapping.
               Value Suggestion: bilinear

    Returns
    -------

    map : HObject
          Image containing the mapping data.

    meshes : HObject
             Output contours.

    See Also
    --------
    gen_arbitrary_distortion_map

    Predecessors
    ------------
    connect_grid_points

    Successors
    ----------
    map_image

    Notes
    -----
    Each input XLD contour ConnectingLines must own the global attribute
    'bright_dark', as it is described with connect_grid_points!
    """
    with HalconOperator(1159) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, connecting_lines)
        proc.set_input_tuple(0, grid_spacing)
        proc.set_input_tuple(1, rotation)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, map_type)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # map
            HObject(proc.get_output_object_key(2))   # meshes
        )  # type: ignore


def gen_grid_region(
    row_steps: Union[float, int],
    column_steps: Union[float, int],
    type: str,
    width: int,
    height: int
) -> HObject:
    """
    Create a region from lines or pixels.

    Parameters
    ----------

    row_steps : Union[float, int]
                Step width in line direction or zero.
                Value Suggestion: 10
                Assertion: RowSteps > 1 || RowSteps == 0

    column_steps : Union[float, int]
                   Step width in column direction or zero.
                   Value Suggestion: 10
                   Assertion: ColumnSteps > 1 || ColumnSteps == 0

    type : str
           Type of created pattern.
           Value Suggestion: lines

    width : int
            Maximum width of pattern.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Maximum height of pattern.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    region_grid : HObject
                  Created lines/pixel region.

    See Also
    --------
    gen_checker_region, reduce_domain

    Alternatives
    ------------
    gen_region_line, gen_region_polygon, gen_region_points, gen_region_runs

    Successors
    ----------
    reduce_domain, paint_region

    Notes
    -----
    If a very small pattern is chosen (RowSteps $<$ 4 or ColumnSteps $<$
    4) the created region requires much storage.
    In the 'points' mode RowSteps and ColumnSteps must not be set to zero.
    """
    with HalconOperator(613) as proc:
        proc.set_input_tuple(0, row_steps)
        proc.set_input_tuple(1, column_steps)
        proc.set_input_tuple(2, type)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.execute()
        region_grid = HObject(proc.get_output_object_key(1))
        return region_grid  # type: ignore


def gen_highpass(
    frequency: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate an ideal highpass filter.

    Parameters
    ----------

    frequency : float
                Cutoff frequency.
                Value Suggestion: 0.1
                Assertion: Frequency >= 0

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_highpass : HObject
                     Highpass filter in the frequency domain.

    See Also
    --------
    convol_fft, gen_lowpass, gen_bandpass, gen_bandfilter,
    gen_gauss_filter, gen_mean_filter, gen_derivative_filter

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1523) as proc:
        proc.set_input_tuple(0, frequency)
        proc.set_input_tuple(1, norm)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.execute()
        image_highpass = HObject(proc.get_output_object_key(1))
        return image_highpass  # type: ignore


def gen_image1(
    type: str,
    width: int,
    height: int,
    pixel_pointer: int
) -> HObject:
    """
    Create an image from a pointer to the pixels.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    pixel_pointer : int
                    Pointer to first gray value.

    Returns
    -------

    image : HObject
            Created image with new image matrix.

    See Also
    --------
    reduce_domain, paint_gray, paint_region, set_grayval

    Alternatives
    ------------
    gen_image3, gen_image1_extern, gen_image_const, get_image_pointer1

    Predecessors
    ------------
    gen_image_const, get_image_pointer1

    Notes
    -----
    gen_image1 does not check whether the PixelPointer is valid or not.
    Thus, it must be ensured by the user that it is valid. Otherwise, the
    program may crash!
    """
    with HalconOperator(606) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, pixel_pointer)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def gen_image1_extern(
    type: str,
    width: int,
    height: int,
    pixel_pointer: int,
    clear_proc: int
) -> HObject:
    """
    Create an image from a pointer on the pixels with storage management.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    pixel_pointer : int
                    Pointer to the first gray value.

    clear_proc : int
                 Pointer to the procedure re-releasing the memory of the
                 image when deleting the object.
                 Value Suggestion: 0

    Returns
    -------

    image : HObject
            Created HALCON image.

    See Also
    --------
    reduce_domain, paint_gray, paint_region, set_grayval

    Alternatives
    ------------
    gen_image1, gen_image_const, get_image_pointer1, gen_image3_extern

    Notes
    -----
    gen_image1_extern does not check if enough memory for an image of
    Width *$- Height is allocated in PixelPointer.
    Also, gen_image1_extern does not check whether the PixelPointer is
    valid or not. Thus, it must be ensured by the user that it is valid.
    Otherwise, the program may crash!
    """
    with HalconOperator(621) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, pixel_pointer)
        proc.set_input_tuple(4, clear_proc)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def gen_image1_rect(
    pixel_pointer: int,
    width: int,
    height: int,
    vertical_pitch: int,
    horizontal_bit_pitch: int,
    bits_per_pixel: int,
    do_copy: str,
    clear_proc: int
) -> HObject:
    """
    Create an image with a rectangular domain from a pointer on the pixels
    (with storage management).

    Parameters
    ----------

    pixel_pointer : int
                    Pointer to the first pixel.

    width : int
            Width of the image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of the image.
             Value Suggestion: 512
             Assertion: Height >= 1

    vertical_pitch : int
                     Distance (in bytes) between pixel m in row n and
                     pixel m in row n+1 of the 'input image'.
                     Assertion: VerticalPitch >= Width * HorizontalBitPitch / 8

    horizontal_bit_pitch : int
                           Distance between two neighboring pixels in bits
                           .
                           Value Suggestion: 8

    bits_per_pixel : int
                     Number of used bits per pixel.
                     Value Suggestion: 8
                     Assertion: BitsPerPixel <= HorizontalBitPitch

    do_copy : str
              Copy image data.
              Value Suggestion: false

    clear_proc : int
                 Pointer to the procedure releasing the memory of the
                 image when deleting the object.
                 Value Suggestion: 0

    Returns
    -------

    image : HObject
            Created HALCON image.

    See Also
    --------
    get_image_pointer1_rect

    Alternatives
    ------------
    gen_image1, gen_image1_extern, gen_image_const

    Successors
    ----------
    get_image_pointer1_rect

    Notes
    -----
    gen_image1_rect does not check whether the PixelPointer is valid or
    not. Thus, it must be ensured by the user that it is valid. Otherwise,
    the program may crash!
    """
    with HalconOperator(622) as proc:
        proc.set_input_tuple(0, pixel_pointer)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, vertical_pitch)
        proc.set_input_tuple(4, horizontal_bit_pitch)
        proc.set_input_tuple(5, bits_per_pixel)
        proc.set_input_tuple(6, do_copy)
        proc.set_input_tuple(7, clear_proc)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def gen_image3(
    type: str,
    width: int,
    height: int,
    pixel_pointer_red: int,
    pixel_pointer_green: int,
    pixel_pointer_blue: int
) -> HObject:
    """
    Create an image from three pointers to the pixels (red/green/blue).

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    width : int
            Width of image.
            Value Suggestion: 512

    height : int
             Height of image.
             Value Suggestion: 512

    pixel_pointer_red : int
                        Pointer to first red value (channel 1).

    pixel_pointer_green : int
                          Pointer to first green value (channel 2).

    pixel_pointer_blue : int
                         Pointer to first blue value (channel 3).

    Returns
    -------

    image_rgb : HObject
                Created image with new image matrix.

    See Also
    --------
    reduce_domain, paint_gray, paint_region, set_grayval,
    get_image_pointer1, decompose3

    Alternatives
    ------------
    gen_image1, compose3, gen_image_const

    Predecessors
    ------------
    gen_image_const, get_image_pointer1

    Successors
    ----------
    disp_color

    Notes
    -----
    gen_image3 does not check whether the pixels in
    PixelPointerRed,PixelPointerGreen, and PixelPointerBlue are valid or
    not. Thus, it must be ensured by the user that they are valid.
    Otherwise, the program may crash!
    """
    with HalconOperator(605) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, pixel_pointer_red)
        proc.set_input_tuple(4, pixel_pointer_green)
        proc.set_input_tuple(5, pixel_pointer_blue)
        proc.execute()
        image_rgb = HObject(proc.get_output_object_key(1))
        return image_rgb  # type: ignore


def gen_image3_extern(
    type: str,
    width: int,
    height: int,
    pointer_red: int,
    pointer_green: int,
    pointer_blue: int,
    clear_proc: int
) -> HObject:
    """
    Create a three-channel image from three pointers on the pixels with
    storage management.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    pointer_red : int
                  Pointer to the first gray value of the first channel.

    pointer_green : int
                    Pointer to the first gray value of the second channel.

    pointer_blue : int
                   Pointer to the first gray value of the third channel.

    clear_proc : int
                 Pointer to the procedure re-releasing the memory of the
                 image when deleting the object.
                 Value Suggestion: 0

    Returns
    -------

    image : HObject
            Created HALCON image.

    See Also
    --------
    reduce_domain, paint_gray, paint_region, set_grayval

    Alternatives
    ------------
    gen_image3, gen_image_const, get_image_pointer3, gen_image1_extern

    Notes
    -----
    gen_image3_extern does not check if enough memory for an image of
    Width *$- Height is allocated in PointerRed, PointerGreen, and
    PointerBlue.
    Also, gen_image3_extern does not check whether the pixels in
    PointerRed, PointerGreen, and PointerBlue are valid or not. Thus, it
    must be ensured by the user that they are valid. Otherwise, the
    program may crash!
    """
    with HalconOperator(620) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, pointer_red)
        proc.set_input_tuple(4, pointer_green)
        proc.set_input_tuple(5, pointer_blue)
        proc.set_input_tuple(6, clear_proc)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def gen_image_const(type: str, width: int, height: int) -> HObject:
    """
    Create an image with constant gray value.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    image : HObject
            Created image with new image matrix.

    See Also
    --------
    reduce_domain, paint_gray, paint_region, set_grayval,
    get_image_pointer1

    Alternatives
    ------------
    gen_image1, gen_image3

    Successors
    ----------
    paint_region, reduce_domain, get_image_pointer1, copy_obj
    """
    with HalconOperator(607) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def gen_image_gray_ramp(
    alpha: float,
    beta: float,
    mean: float,
    row: int,
    column: int,
    width: int,
    height: int
) -> HObject:
    """
    Create a gray value ramp.

    Parameters
    ----------

    alpha : float
            Gradient in line direction.
            Value Suggestion: 1.0

    beta : float
           Gradient in column direction.
           Value Suggestion: 1.0

    mean : float
           Mean gray value.
           Value Suggestion: 128

    row : int
          Line index of reference point.
          Value Suggestion: 256

    column : int
             Column index of reference point.
             Value Suggestion: 256

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    image_gray_ramp : HObject
                      Created image with new image matrix.

    See Also
    --------
    reduce_domain, paint_gray, gen_image_const

    Alternatives
    ------------
    gen_image1

    Predecessors
    ------------
    moments_gray_plane

    Successors
    ----------
    paint_region, reduce_domain, get_image_pointer1, copy_obj
    """
    with HalconOperator(619) as proc:
        proc.set_input_tuple(0, alpha)
        proc.set_input_tuple(1, beta)
        proc.set_input_tuple(2, mean)
        proc.set_input_tuple(3, row)
        proc.set_input_tuple(4, column)
        proc.set_input_tuple(5, width)
        proc.set_input_tuple(6, height)
        proc.execute()
        image_gray_ramp = HObject(proc.get_output_object_key(1))
        return image_gray_ramp  # type: ignore


def gen_image_interleaved(
    pixel_pointer: int,
    color_format: str,
    original_width: int,
    original_height: int,
    alignment: int,
    type: str,
    image_width: int,
    image_height: int,
    start_row: int,
    start_column: int,
    bits_per_channel: int,
    bit_shift: int
) -> HObject:
    """
    Create a three-channel image from a pointer to the interleaved pixels.

    Parameters
    ----------

    pixel_pointer : int
                    Pointer to interleaved pixels.

    color_format : str
                   Format of the input pixels.
                   Value Suggestion: rgb

    original_width : int
                     Width of input image.
                     Value Suggestion: 512

    original_height : int
                      Height of input image.
                      Value Suggestion: 512

    alignment : int
                Reserved.

    type : str
           Pixel type of output image.
           Value Suggestion: byte

    image_width : int
                  Width of output image.
                  Value Suggestion: 0

    image_height : int
                   Height of output image.
                   Value Suggestion: 0

    start_row : int
                Line number of upper left corner of desired image part.
                Value Suggestion: 0

    start_column : int
                   Column number of upper left corner of desired image
                   part.
                   Value Suggestion: 0

    bits_per_channel : int
                       Number of used bits per pixel and channel of the
                       output image (-1: All bits are used).
                       Value Suggestion: -1

    bit_shift : int
                Number of bits that the color values of the input pixels
                are shifted to the right (only uint2 images).
                Value Suggestion: 0

    Returns
    -------

    image_rgb : HObject
                Created image with new image matrix.

    See Also
    --------
    reduce_domain, paint_gray, paint_region, set_grayval, gen_image_const

    Successors
    ----------
    disp_color

    Notes
    -----
    gen_image_interleaved does not check whether the PixelPointer is valid
    or not. Thus, it must be ensured by the user that it is valid.
    Otherwise, the program may crash!
    """
    with HalconOperator(595) as proc:
        proc.set_input_tuple(0, pixel_pointer)
        proc.set_input_tuple(1, color_format)
        proc.set_input_tuple(2, original_width)
        proc.set_input_tuple(3, original_height)
        proc.set_input_tuple(4, alignment)
        proc.set_input_tuple(5, type)
        proc.set_input_tuple(6, image_width)
        proc.set_input_tuple(7, image_height)
        proc.set_input_tuple(8, start_row)
        proc.set_input_tuple(9, start_column)
        proc.set_input_tuple(10, bits_per_channel)
        proc.set_input_tuple(11, bit_shift)
        proc.execute()
        image_rgb = HObject(proc.get_output_object_key(1))
        return image_rgb  # type: ignore


def gen_image_proto(
    image: HObject,
    grayval: Union[int, float]
) -> HObject:
    """
    Create an image with a specified constant gray value.

    Parameters
    ----------

    image : HObject
            Input image.

    grayval : Union[int, float]
              Gray value to be used for the output image.
              Value Suggestion: 0

    Returns
    -------

    image_cleared : HObject
                    Image with constant gray value.

    See Also
    --------
    get_image_pointer1

    Alternatives
    ------------
    set_grayval, paint_gray, gen_image_const, copy_image
    """
    with HalconOperator(578) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, grayval)
        proc.execute()
        image_cleared = HObject(proc.get_output_object_key(1))
        return image_cleared  # type: ignore


def gen_image_surface_first_order(
    type: str,
    alpha: float,
    beta: float,
    gamma: float,
    row: float,
    column: float,
    width: int,
    height: int
) -> HObject:
    """
    Create a tilted gray surface with first order polynomial.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    alpha : float
            First order coefficient in vertical direction.
            Value Suggestion: 1.0

    beta : float
           First order coefficient in horizontal direction.
           Value Suggestion: 1.0

    gamma : float
            Zero order coefficient.
            Value Suggestion: 1.0

    row : float
          Row coordinate of the reference point of the surface.
          Value Suggestion: 256.0

    column : float
             Column coordinate of the reference point of the surface.
             Value Suggestion: 256.0

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    image_surface : HObject
                    Created image with new image matrix.

    See Also
    --------
    gen_image_gray_ramp, gen_image_surface_second_order, gen_image_const

    Predecessors
    ------------
    fit_surface_first_order

    Successors
    ----------
    sub_image
    """
    with HalconOperator(1746) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, alpha)
        proc.set_input_tuple(2, beta)
        proc.set_input_tuple(3, gamma)
        proc.set_input_tuple(4, row)
        proc.set_input_tuple(5, column)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.execute()
        image_surface = HObject(proc.get_output_object_key(1))
        return image_surface  # type: ignore


def gen_image_surface_second_order(
    type: str,
    alpha: float,
    beta: float,
    gamma: float,
    delta: float,
    epsilon: float,
    zeta: float,
    row: float,
    column: float,
    width: int,
    height: int
) -> HObject:
    """
    Create a curved gray surface with second order polynomial.

    Parameters
    ----------

    type : str
           Pixel type.
           Value Suggestion: byte

    alpha : float
            Second order coefficient in vertical direction.
            Value Suggestion: 1.0

    beta : float
           Second order coefficient in horizontal direction.
           Value Suggestion: 1.0

    gamma : float
            Mixed second order coefficient.
            Value Suggestion: 1.0

    delta : float
            First order coefficient in vertical direction.
            Value Suggestion: 1.0

    epsilon : float
              First order coefficient in horizontal direction.
              Value Suggestion: 1.0

    zeta : float
           Zero order coefficient.
           Value Suggestion: 1.0

    row : float
          Row coordinate of the reference point of the surface.
          Value Suggestion: 256.0

    column : float
             Column coordinate of the reference point of the surface.
             Value Suggestion: 256.0

    width : int
            Width of image.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of image.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    image_surface : HObject
                    Created image with new image matrix.

    See Also
    --------
    gen_image_gray_ramp, gen_image_surface_first_order, gen_image_const

    Predecessors
    ------------
    fit_surface_second_order

    Successors
    ----------
    sub_image
    """
    with HalconOperator(1745) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, alpha)
        proc.set_input_tuple(2, beta)
        proc.set_input_tuple(3, gamma)
        proc.set_input_tuple(4, delta)
        proc.set_input_tuple(5, epsilon)
        proc.set_input_tuple(6, zeta)
        proc.set_input_tuple(7, row)
        proc.set_input_tuple(8, column)
        proc.set_input_tuple(9, width)
        proc.set_input_tuple(10, height)
        proc.execute()
        image_surface = HObject(proc.get_output_object_key(1))
        return image_surface  # type: ignore


def gen_image_to_world_plane_map(
    camera_param: Sequence[Union[int, float, str]],
    world_pose: Sequence[Union[int, float]],
    width_in: int,
    height_in: int,
    width_mapped: int,
    height_mapped: int,
    scale: Union[int, float, str],
    map_type: str
) -> HObject:
    """
    Generate a projection map that describes the mapping between the image
    plane and the plane z=0 of a world coordinate system.

    Parameters
    ----------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    world_pose : Sequence[Union[int, float]]
                 3D pose of the world coordinate system in camera
                 coordinates.

    width_in : int
               Width of the images to be transformed.
               Assertion: WidthIn >= 1

    height_in : int
                Height of the images to be transformed.
                Assertion: HeightIn >= 1

    width_mapped : int
                   Width of the resulting mapped images in pixels.
                   Assertion: WidthMapped >= 1

    height_mapped : int
                    Height of the resulting mapped images in pixels.
                    Assertion: HeightMapped >= 1

    scale : Union[int, float, str]
            Scale or unit.
            Value Suggestion: m
            Assertion: Scale > 0

    map_type : str
               Type of the mapping.
               Value Suggestion: bilinear

    Returns
    -------

    map : HObject
          Image containing the mapping data.

    See Also
    --------
    map_image, contour_to_world_plane_xld, image_points_to_world_plane

    Alternatives
    ------------
    image_to_world_plane

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration, set_origin_pose

    Successors
    ----------
    map_image
    """
    with HalconOperator(1913) as proc:
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, world_pose)
        proc.set_input_tuple(2, width_in)
        proc.set_input_tuple(3, height_in)
        proc.set_input_tuple(4, width_mapped)
        proc.set_input_tuple(5, height_mapped)
        proc.set_input_tuple(6, scale)
        proc.set_input_tuple(7, map_type)
        proc.execute()
        map = HObject(proc.get_output_object_key(1))
        return map  # type: ignore


def gen_initial_components(
    model_image: HObject,
    contrast_low: MaybeSequence[Union[int, str]],
    contrast_high: MaybeSequence[Union[int, str]],
    min_size: MaybeSequence[Union[int, str]],
    mode: str,
    generic_name: MaybeSequence[str],
    generic_value: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Extract the initial components of a component model.

    Parameters
    ----------

    model_image : HObject
                  Input image from which the initial components should be
                  extracted.

    contrast_low : MaybeSequence[Union[int, str]]
                   Lower hysteresis threshold for the contrast of the
                   initial components in the image.
                   Value Suggestion: auto
                   Assertion: ContrastLow > 0

    contrast_high : MaybeSequence[Union[int, str]]
                    Upper hysteresis threshold for the contrast of the
                    initial components in the image.
                    Value Suggestion: auto
                    Assertion: ContrastHigh > 0 && ContrastHigh >= ContrastLow

    min_size : MaybeSequence[Union[int, str]]
               Minimum size of the initial components.
               Value Suggestion: auto
               Assertion: MinSize >= 0

    mode : str
           Type of automatic segmentation.
           Value Suggestion: connection

    generic_name : MaybeSequence[str]
                   Names of optional control parameters.
                   Value Suggestion: []

    generic_value : MaybeSequence[Union[int, float]]
                    Values of optional control parameters.
                    Value Suggestion: []

    Returns
    -------

    initial_components : HObject
                         Contour regions of initial components.

    Alternatives
    ------------
    inspect_shape_model

    Predecessors
    ------------
    draw_region, add_channels, reduce_domain

    Successors
    ----------
    train_model_components
    """
    with HalconOperator(1018) as proc:
        proc.set_input_object(1, model_image)
        proc.set_input_tuple(0, contrast_low)
        proc.set_input_tuple(1, contrast_high)
        proc.set_input_tuple(2, min_size)
        proc.set_input_tuple(3, mode)
        proc.set_input_tuple(4, generic_name)
        proc.set_input_tuple(5, generic_value)
        proc.execute()
        initial_components = HObject(proc.get_output_object_key(1))
        return initial_components  # type: ignore


def gen_lowpass(
    frequency: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate an ideal lowpass filter.

    Parameters
    ----------

    frequency : float
                Cutoff frequency.
                Value Suggestion: 0.1
                Assertion: Frequency >= 0

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_lowpass : HObject
                    Lowpass filter in the frequency domain.

    See Also
    --------
    gen_highpass, gen_bandpass, gen_bandfilter, gen_gauss_filter,
    gen_mean_filter, gen_derivative_filter

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1522) as proc:
        proc.set_input_tuple(0, frequency)
        proc.set_input_tuple(1, norm)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.execute()
        image_lowpass = HObject(proc.get_output_object_key(1))
        return image_lowpass  # type: ignore


def gen_mean_filter(
    mask_shape: str,
    diameter_1: float,
    diameter_2: float,
    phi: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate a mean filter in the frequency domain.

    Parameters
    ----------

    mask_shape : str
                 Shape of the filter mask in the spatial domain.
                 Value Suggestion: ellipse

    diameter_1 : float
                 Diameter of the mean filter in the principal direction of
                 the filter in the spatial domain.
                 Value Suggestion: 11.0
                 Assertion: Diameter1 > 0

    diameter_2 : float
                 Diameter of the mean filter perpendicular to the
                 principal direction of the filter in the spatial domain.
                 Value Suggestion: 11.0
                 Assertion: Diameter2 > 0

    phi : float
          Principal direction of the filter in the spatial domain.
          Value Suggestion: 0.0

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_mean : HObject
                 Mean filter as image in the frequency domain.

    See Also
    --------
    fft_image_inv, gen_gauss_filter, gen_derivative_filter, gen_lowpass,
    gen_bandpass, gen_bandfilter, gen_highpass

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1515) as proc:
        proc.set_input_tuple(0, mask_shape)
        proc.set_input_tuple(1, diameter_1)
        proc.set_input_tuple(2, diameter_2)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, norm)
        proc.set_input_tuple(5, mode)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.execute()
        image_mean = HObject(proc.get_output_object_key(1))
        return image_mean  # type: ignore


def gen_measure_arc(
    center_row: Union[int, float],
    center_col: Union[int, float],
    radius: Union[int, float],
    angle_start: Union[int, float],
    angle_extent: Union[int, float],
    annulus_radius: Union[int, float],
    width: int,
    height: int,
    interpolation: str
) -> HHandle:
    """
    Prepare the extraction of straight edges perpendicular to an annular
    arc.

    Parameters
    ----------

    center_row : Union[int, float]
                 Row coordinate of the center of the arc.
                 Value Suggestion: 100.0

    center_col : Union[int, float]
                 Column coordinate of the center of the arc.
                 Value Suggestion: 100.0

    radius : Union[int, float]
             Radius of the arc.
             Value Suggestion: 50.0

    angle_start : Union[int, float]
                  Start angle of the arc in radians.
                  Value Suggestion: 0.0

    angle_extent : Union[int, float]
                   Angular extent of the arc in radians.
                   Value Suggestion: 6.28318
                   Assertion: AngleExtent != 0.0

    annulus_radius : Union[int, float]
                     Radius (half width) of the annulus.
                     Value Suggestion: 10.0
                     Assertion: AnnulusRadius <= Radius

    width : int
            Width of the image to be processed subsequently.
            Value Suggestion: 512

    height : int
             Height of the image to be processed subsequently.
             Value Suggestion: 512

    interpolation : str
                    Type of interpolation to be used.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    measure_handle : HHandle
                     Measure object handle.

    See Also
    --------
    gen_measure_rectangle2

    Alternatives
    ------------
    edges_sub_pix

    Predecessors
    ------------
    draw_circle

    Successors
    ----------
    measure_pos, measure_pairs, fuzzy_measure_pos, fuzzy_measure_pairs,
    fuzzy_measure_pairing

    Notes
    -----
    Note that when using bilinear or bicubic interpolation, not only the
    measurement rectangle but additionally the margin around the rectangle
    must fit into the image.  The width of the margin (in all four
    directions) must be at least one pixel for bilinear interpolation and
    two pixels for bicubic interpolation.  For projection lines that do
    not fulfill this condition, no gray value is computed.  Thus, no edge
    can be extracted at these positions.
    Please also note that the center coordinates of the arc are rounded
    internally, so that the center lies on the pixel grid.  This is done
    to ensure consistency.
    """
    with HalconOperator(838) as proc:
        proc.set_input_tuple(0, center_row)
        proc.set_input_tuple(1, center_col)
        proc.set_input_tuple(2, radius)
        proc.set_input_tuple(3, angle_start)
        proc.set_input_tuple(4, angle_extent)
        proc.set_input_tuple(5, annulus_radius)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.set_input_tuple(8, interpolation)
        proc.init_oct(0)
        proc.execute()
        measure_handle = proc.get_output_tuple_s(0)
        return measure_handle  # type: ignore


def gen_measure_rectangle2(
    row: Union[int, float],
    column: Union[int, float],
    phi: Union[int, float],
    length_1: Union[int, float],
    length_2: Union[int, float],
    width: int,
    height: int,
    interpolation: str
) -> HHandle:
    """
    Prepare the extraction of straight edges perpendicular to a rectangle.

    Parameters
    ----------

    row : Union[int, float]
          Row coordinate of the center of the rectangle.
          Value Suggestion: 300.0

    column : Union[int, float]
             Column coordinate of the center of the rectangle.
             Value Suggestion: 200.0

    phi : Union[int, float]
          Angle of longitudinal axis of the rectangle to horizontal
          (radians).
          Value Suggestion: 0.0
          Assertion: - pi < Phi && Phi <= pi

    length_1 : Union[int, float]
               Half width of the rectangle.
               Value Suggestion: 100.0
               Assertion: Length1 >= 1.0

    length_2 : Union[int, float]
               Half height of the rectangle.
               Value Suggestion: 20.0
               Assertion: Length2 >= 0.0

    width : int
            Width of the image to be processed subsequently.
            Value Suggestion: 512

    height : int
             Height of the image to be processed subsequently.
             Value Suggestion: 512

    interpolation : str
                    Type of interpolation to be used.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    measure_handle : HHandle
                     Measure object handle.

    See Also
    --------
    gen_measure_arc

    Alternatives
    ------------
    edges_sub_pix

    Predecessors
    ------------
    draw_rectangle2

    Successors
    ----------
    measure_pos, measure_pairs, fuzzy_measure_pos, fuzzy_measure_pairs,
    fuzzy_measure_pairing, measure_thresh

    Notes
    -----
    Note that when using bilinear or bicubic interpolation, not only the
    measurement rectangle but additionally the margin around the rectangle
    must fit into the image.  The width of the margin (in all four
    directions) must be at least one pixel for bilinear interpolation and
    two pixels for bicubic interpolation.  For projection lines that do
    not fulfill this condition, no gray value is computed.  Thus, no edge
    can be extracted at these positions.
    Please also note that the center coordinates of the rectangle are
    rounded  internally, so that the center lies on the pixel grid.  This
    is done to ensure consistency.
    """
    with HalconOperator(839) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, length_1)
        proc.set_input_tuple(4, length_2)
        proc.set_input_tuple(5, width)
        proc.set_input_tuple(6, height)
        proc.set_input_tuple(7, interpolation)
        proc.init_oct(0)
        proc.execute()
        measure_handle = proc.get_output_tuple_s(0)
        return measure_handle  # type: ignore


def gen_nurbs_interp(
    rows: Sequence[float],
    cols: Sequence[float],
    tangents: Sequence[float],
    degree: int
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Create control data of a NURBS curve that interpolates given points.

    Parameters
    ----------

    rows : Sequence[float]
           Row coordinates of input point list.

    cols : Sequence[float]
           Column coordinates of input point list.

    tangents : Sequence[float]
               Tangents at first and last point.
               Value Suggestion: []

    degree : int
             Order of the output curve.
             Value Suggestion: 3
             Assertion: Degree >= 2

    Returns
    -------

    ctrl_rows : Sequence[float]
                Row coordinates of the control polygon.

    ctrl_cols : Sequence[float]
                Column coordinates of the control polygon.

    knots : Sequence[float]
            The knot vector of the output curve.

    See Also
    --------
    draw_nurbs_interp, draw_nurbs_interp_mod

    Successors
    ----------
    gen_contour_nurbs_xld
    """
    with HalconOperator(3) as proc:
        proc.set_input_tuple(0, rows)
        proc.set_input_tuple(1, cols)
        proc.set_input_tuple(2, tangents)
        proc.set_input_tuple(3, degree)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ctrl_rows
            proc.get_output_tuple_m(1),  # ctrl_cols
            proc.get_output_tuple_m(2)   # knots
        )  # type: ignore


def gen_object_model_3d_from_points(
    x: MaybeSequence[float],
    y: MaybeSequence[float],
    z: MaybeSequence[float]
) -> HHandle:
    """
    Create a 3D object model that represents a point cloud from a set of
    3D points.

    Parameters
    ----------

    x : MaybeSequence[float]
        The x-coordinates of the points in the 3D point cloud.

    y : MaybeSequence[float]
        The y-coordinates of the points in the 3D point cloud.

    z : MaybeSequence[float]
        The z-coordinates of the points in the 3D point cloud.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_box_object_model_3d, gen_sphere_object_model_3d,
    gen_cylinder_object_model_3d

    Alternatives
    ------------
    xyz_to_object_model_3d

    Predecessors
    ------------
    get_object_model_3d_params

    Successors
    ----------
    connection_object_model_3d, convex_hull_object_model_3d
    """
    with HalconOperator(1069) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def gen_parallel_contour_xld(
    contours: HObject,
    mode: str,
    distance: Union[float, int]
) -> HObject:
    """
    Compute the parallel contour of an XLD contour.

    Parameters
    ----------

    contours : HObject
               Contours to be transformed.

    mode : str
           Mode, with which the direction information is computed.
           Value Suggestion: regression_normal

    distance : Union[float, int]
               Distance of the parallel contour.
               Value Suggestion: 1

    Returns
    -------

    parallel_contours : HObject
                        Parallel contours.

    See Also
    --------
    get_contour_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    threshold_sub_pix

    Successors
    ----------
    gen_polygons_xld
    """
    with HalconOperator(23) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, distance)
        proc.execute()
        parallel_contours = HObject(proc.get_output_object_key(1))
        return parallel_contours  # type: ignore


def gen_parallels_xld(
    polygons: HObject,
    len: Union[float, int],
    dist: Union[float, int],
    alpha: Union[float, int],
    merge: str
) -> HObject:
    """
    Extract parallel XLD polygons.

    Parameters
    ----------

    polygons : HObject
               Input polygons.

    len : Union[float, int]
          Minimum length of the individual polygon segments.
          Value Suggestion: 10.0
          Assertion: Len > 0.0

    dist : Union[float, int]
           Maximum distance between the polygon segments.
           Value Suggestion: 30.0
           Assertion: Dist > 0.0

    alpha : Union[float, int]
            Maximum angle difference of the polygon segments.
            Value Suggestion: 0.15
            Assertion: 0 <= Alpha && Alpha <= pi / 2

    merge : str
            Should adjacent parallel relations be merged?
            Value Suggestion: true

    Returns
    -------

    parallels : HObject
                Parallel polygons.

    Predecessors
    ------------
    gen_polygons_xld

    Successors
    ----------
    mod_parallels_xld, get_parallels_xld, info_parallels_xld
    """
    with HalconOperator(42) as proc:
        proc.set_input_object(1, polygons)
        proc.set_input_tuple(0, len)
        proc.set_input_tuple(1, dist)
        proc.set_input_tuple(2, alpha)
        proc.set_input_tuple(3, merge)
        proc.execute()
        parallels = HObject(proc.get_output_object_key(1))
        return parallels  # type: ignore


def gen_plane_object_model_3d(
    pose: Sequence[Union[int, float]],
    xextent: MaybeSequence[Union[float, int]],
    yextent: MaybeSequence[Union[float, int]]
) -> HHandle:
    """
    Create a 3D object model that represents a plane.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The center and the rotation of the plane.

    xextent : MaybeSequence[Union[float, int]]
              x coordinates specifying the extent of the plane.

    yextent : MaybeSequence[Union[float, int]]
              y coordinates specifying the extent of the plane.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_sphere_object_model_3d,
    gen_sphere_object_model_3d_center, gen_box_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1071) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, xextent)
        proc.set_input_tuple(2, yextent)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def gen_polygons_xld(
    contours: HObject,
    type: str,
    alpha: Union[float, int]
) -> HObject:
    """
    Approximate XLD contours by polygons.

    Parameters
    ----------

    contours : HObject
               Contours to be approximated.

    type : str
           Type of approximation.
           Value Suggestion: ramer

    alpha : Union[float, int]
            Threshold for the approximation.
            Value Suggestion: 2.0
            Assertion: Alpha > 0.0

    Returns
    -------

    polygons : HObject
               Approximating polygons.

    See Also
    --------
    get_region_polygon

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    gen_parallels_xld, split_contours_xld
    """
    with HalconOperator(45) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, alpha)
        proc.execute()
        polygons = HObject(proc.get_output_object_key(1))
        return polygons  # type: ignore


def gen_principal_comp_trans(
    multichannel_image: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the transformation matrix of the principal component analysis
    of multichannel images.

    Parameters
    ----------

    multichannel_image : HObject
                         Multichannel input image.

    Returns
    -------

    trans : Sequence[float]
            Transformation matrix for the computation of the PCA.

    trans_inv : Sequence[float]
                Transformation matrix for the computation of the inverse
                PCA.

    mean : Sequence[float]
           Mean gray value of the channels.

    cov : Sequence[float]
          Covariance matrix of the channels.

    info_per_comp : Sequence[float]
                    Information content of the transformed channels.

    Alternatives
    ------------
    principal_comp

    Successors
    ----------
    linear_trans_color

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1455) as proc:
        proc.set_input_object(1, multichannel_image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # trans
            proc.get_output_tuple_m(1),  # trans_inv
            proc.get_output_tuple_m(2),  # mean
            proc.get_output_tuple_m(3),  # cov
            proc.get_output_tuple_m(4)   # info_per_comp
        )  # type: ignore


def gen_projective_mosaic(
    images: HObject,
    start_image: int,
    mapping_source: Sequence[int],
    mapping_dest: Sequence[int],
    hom_matrices_2d: Sequence[float],
    stacking_order: MaybeSequence[Union[str, int]],
    transform_domain: str
) -> Tuple[HObject, Sequence[float]]:
    """
    Combine multiple images into a mosaic image.

    Parameters
    ----------

    images : HObject
             Input images.

    start_image : int
                  Index of the central input image.

    mapping_source : Sequence[int]
                     Indices of the source images of the transformations.

    mapping_dest : Sequence[int]
                   Indices of the target images of the transformations.

    hom_matrices_2d : Sequence[float]
                      Array of $3- projective transformation matrices.

    stacking_order : MaybeSequence[Union[str, int]]
                     Stacking order of the images in the mosaic.
                     Value Suggestion: default

    transform_domain : str
                       Should the domains of the input images also be
                       transformed?
                       Value Suggestion: false

    Returns
    -------

    mosaic_image : HObject
                   Output image.

    mosaic_matrices_2d : Sequence[float]
                         Array of $3- projective transformation matrices
                         that determine the position of the images in the
                         mosaic.

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d, projective_trans_pixel

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided,
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d
    """
    with HalconOperator(1619) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, start_image)
        proc.set_input_tuple(1, mapping_source)
        proc.set_input_tuple(2, mapping_dest)
        proc.set_input_tuple(3, hom_matrices_2d)
        proc.set_input_tuple(4, stacking_order)
        proc.set_input_tuple(5, transform_domain)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # mosaic_image
            proc.get_output_tuple_m(0)   # mosaic_matrices_2d
        )  # type: ignore


def gen_psf_defocus(
    psfwidth: int,
    psfheight: int,
    blurring: float
) -> HObject:
    """
    Generate an impulse response of an uniform out-of-focus blurring.

    Parameters
    ----------

    psfwidth : int
               Width of result image.
               Value Suggestion: 256

    psfheight : int
                Height of result image.
                Value Suggestion: 256

    blurring : float
               Degree of Blurring.
               Value Suggestion: 5.0

    Returns
    -------

    psf : HObject
          Impulse response of uniform out-of-focus blurring.

    See Also
    --------
    simulate_defocus, gen_psf_motion, simulate_motion, wiener_filter,
    wiener_filter_ni

    Predecessors
    ------------
    simulate_motion, gen_psf_motion

    Successors
    ----------
    simulate_defocus, wiener_filter, wiener_filter_ni
    """
    with HalconOperator(79) as proc:
        proc.set_input_tuple(0, psfwidth)
        proc.set_input_tuple(1, psfheight)
        proc.set_input_tuple(2, blurring)
        proc.execute()
        psf = HObject(proc.get_output_object_key(1))
        return psf  # type: ignore


def gen_psf_motion(
    psfwidth: int,
    psfheight: int,
    blurring: float,
    angle: int,
    type: int
) -> HObject:
    """
    Generate an impulse response of a (linearly) motion blurring.

    Parameters
    ----------

    psfwidth : int
               Width of impulse response image.
               Value Suggestion: 256

    psfheight : int
                Height of impulse response image.
                Value Suggestion: 256

    blurring : float
               Degree of motion-blur.
               Value Suggestion: 20.0

    angle : int
            Angle between direction of motion and x-axis (anticlockwise).
            Value Suggestion: 0

    type : int
           PSF prototype resp. type of motion.
           Value Suggestion: 3

    Returns
    -------

    psf : HObject
          Impulse response of motion-blur.

    See Also
    --------
    simulate_motion, simulate_defocus, gen_psf_defocus, wiener_filter,
    wiener_filter_ni

    Predecessors
    ------------
    simulate_defocus, gen_psf_defocus

    Successors
    ----------
    simulate_motion, wiener_filter, wiener_filter_ni
    """
    with HalconOperator(77) as proc:
        proc.set_input_tuple(0, psfwidth)
        proc.set_input_tuple(1, psfheight)
        proc.set_input_tuple(2, blurring)
        proc.set_input_tuple(3, angle)
        proc.set_input_tuple(4, type)
        proc.execute()
        psf = HObject(proc.get_output_object_key(1))
        return psf  # type: ignore


def gen_radial_distortion_map(
    cam_param_in: Sequence[Union[int, float, str]],
    cam_param_out: Sequence[Union[int, float, str]],
    map_type: str
) -> HObject:
    """
    Generate a projection map that describes the mapping of images
    corresponding to a changing radial distortion.

    Parameters
    ----------

    cam_param_in : Sequence[Union[int, float, str]]
                   Old camera parameters.

    cam_param_out : Sequence[Union[int, float, str]]
                    New camera parameters.

    map_type : str
               Type of the mapping.
               Value Suggestion: bilinear

    Returns
    -------

    map : HObject
          Image containing the mapping data.

    See Also
    --------
    change_radial_distortion_contours_xld

    Alternatives
    ------------
    change_radial_distortion_image

    Predecessors
    ------------
    change_radial_distortion_cam_par, camera_calibration,
    hand_eye_calibration

    Successors
    ----------
    map_image
    """
    with HalconOperator(1912) as proc:
        proc.set_input_tuple(0, cam_param_in)
        proc.set_input_tuple(1, cam_param_out)
        proc.set_input_tuple(2, map_type)
        proc.execute()
        map = HObject(proc.get_output_object_key(1))
        return map  # type: ignore


def gen_random_region(width: int, height: int) -> HObject:
    """
    Create a random region.

    Parameters
    ----------

    width : int
            Maximum horizontal expansion of random region.
            Value Suggestion: 128
            Assertion: Width > 0

    height : int
             Maximum vertical expansion of random region.
             Value Suggestion: 128
             Assertion: Height > 0

    Returns
    -------

    region_random : HObject
                    Created random region with expansion Width x Height.

    See Also
    --------
    gen_checker_region, add_noise_distribution, add_noise_white,
    reduce_domain

    Successors
    ----------
    paint_region, reduce_domain

    Notes
    -----
    If Width and Height are chosen large ($>$ 100) the created region may
    require much storage space due to the internally used runlength
    coding. The gray values of the output region are undefined.
    """
    with HalconOperator(604) as proc:
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        region_random = HObject(proc.get_output_object_key(1))
        return region_random  # type: ignore


def gen_random_regions(
    type: str,
    width_min: Union[float, int],
    width_max: Union[float, int],
    height_min: Union[float, int],
    height_max: Union[float, int],
    phi_min: Union[float, int],
    phi_max: Union[float, int],
    num_regions: int,
    width: int,
    height: int
) -> HObject:
    """
    Create random regions like circles, rectangles and ellipses.

    Parameters
    ----------

    type : str
           Type of regions to be created.
           Value Suggestion: circle

    width_min : Union[float, int]
                Minimum width of the region.
                Value Suggestion: 10.0
                Assertion: WidthMin > 0

    width_max : Union[float, int]
                Maximum width of the region.
                Value Suggestion: 20.0
                Assertion: WidthMax > 0

    height_min : Union[float, int]
                 Minimum height of the region.
                 Value Suggestion: 10.0
                 Assertion: HeightMin > 0

    height_max : Union[float, int]
                 Maximum height of the region.
                 Value Suggestion: 30.0
                 Assertion: HeightMax > 0

    phi_min : Union[float, int]
              Minimum rotation angle of the region.
              Value Suggestion: -0.7854
              Assertion: PhiMin > 0

    phi_max : Union[float, int]
              Maximum rotation angle of the region.
              Value Suggestion: 0.7854
              Assertion: PhiMax > 0

    num_regions : int
                  Number of regions.
                  Value Suggestion: 100
                  Assertion: NumRegions > 0

    width : int
            Maximum horizontal expansion.
            Value Suggestion: 512
            Assertion: Width > 0

    height : int
             Maximum vertical expansion.
             Value Suggestion: 512
             Assertion: Height > 0

    Returns
    -------

    regions : HObject
              Created regions.

    Successors
    ----------
    paint_region
    """
    with HalconOperator(614) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width_min)
        proc.set_input_tuple(2, width_max)
        proc.set_input_tuple(3, height_min)
        proc.set_input_tuple(4, height_max)
        proc.set_input_tuple(5, phi_min)
        proc.set_input_tuple(6, phi_max)
        proc.set_input_tuple(7, num_regions)
        proc.set_input_tuple(8, width)
        proc.set_input_tuple(9, height)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def gen_rectangle1(
    row_1: MaybeSequence[Union[int, float]],
    column_1: MaybeSequence[Union[int, float]],
    row_2: MaybeSequence[Union[int, float]],
    column_2: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Create a rectangle parallel to the coordinate axes.

    Parameters
    ----------

    row_1 : MaybeSequence[Union[int, float]]
            Line of upper left corner point.
            Value Suggestion: 30.0

    column_1 : MaybeSequence[Union[int, float]]
               Column of upper left corner point.
               Value Suggestion: 20.0

    row_2 : MaybeSequence[Union[int, float]]
            Line of lower right corner point.
            Value Suggestion: 100.0
            Assertion: Row2 >= Row1

    column_2 : MaybeSequence[Union[int, float]]
               Column of lower right corner point.
               Value Suggestion: 200.0
               Assertion: Column2 >= Column1

    Returns
    -------

    rectangle : HObject
                Created rectangle.

    See Also
    --------
    draw_rectangle1, reduce_domain, smallest_rectangle1

    Alternatives
    ------------
    gen_rectangle2, gen_region_polygon, fill_up, gen_region_runs,
    gen_region_points, gen_region_line

    Successors
    ----------
    paint_region, reduce_domain
    """
    with HalconOperator(603) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.execute()
        rectangle = HObject(proc.get_output_object_key(1))
        return rectangle  # type: ignore


def gen_rectangle2(
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    length_1: MaybeSequence[Union[int, float]],
    length_2: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Create a rectangle of any orientation.

    Parameters
    ----------

    row : MaybeSequence[Union[int, float]]
          Line index of the center.
          Value Suggestion: 300.0

    column : MaybeSequence[Union[int, float]]
             Column index of the center.
             Value Suggestion: 200.0

    phi : MaybeSequence[Union[int, float]]
          Angle of the first edge to the horizontal (in radians).
          Value Suggestion: 0.0
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : MaybeSequence[Union[int, float]]
               Half width.
               Value Suggestion: 100.0

    length_2 : MaybeSequence[Union[int, float]]
               Half height.
               Value Suggestion: 20.0

    Returns
    -------

    rectangle : HObject
                Created rectangle.

    See Also
    --------
    draw_rectangle2, reduce_domain, smallest_rectangle2, gen_ellipse

    Alternatives
    ------------
    gen_rectangle1, gen_region_polygon_filled, gen_region_polygon,
    gen_region_points, fill_up

    Successors
    ----------
    paint_region, reduce_domain

    Notes
    -----
    The gray values of the output objects are undefined.  For speed
    reasons, the resulting region may contain additional pixels at the
    border and some individual pixels at the border may be missing. This
    may lead to an inconsistency between the operators smallest_rectangle2
    and gen_rectangle2.
    """
    with HalconOperator(602) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, length_1)
        proc.set_input_tuple(4, length_2)
        proc.execute()
        rectangle = HObject(proc.get_output_object_key(1))
        return rectangle  # type: ignore


def gen_rectangle2_contour_xld(
    row: MaybeSequence[float],
    column: MaybeSequence[float],
    phi: MaybeSequence[float],
    length_1: MaybeSequence[float],
    length_2: MaybeSequence[float]
) -> HObject:
    """
    Create an XLD contour in the shape of a rectangle.

    Parameters
    ----------

    row : MaybeSequence[float]
          Row coordinate of the center of the rectangle.
          Value Suggestion: 300.0

    column : MaybeSequence[float]
             Column coordinate of the center of the rectangle.
             Value Suggestion: 200.0

    phi : MaybeSequence[float]
          Orientation of the main axis of the rectangle [rad].
          Value Suggestion: 0.0
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : MaybeSequence[float]
               First radius (half length) of the rectangle.
               Value Suggestion: 100.5

    length_2 : MaybeSequence[float]
               Second radius (half width) of the rectangle.
               Value Suggestion: 20.5

    Returns
    -------

    rectangle : HObject
                Rectangle contour.

    See Also
    --------
    gen_contour_polygon_xld

    Alternatives
    ------------
    gen_rectangle2

    Predecessors
    ------------
    fit_rectangle2_contour_xld
    """
    with HalconOperator(24) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, phi)
        proc.set_input_tuple(3, length_1)
        proc.set_input_tuple(4, length_2)
        proc.execute()
        rectangle = HObject(proc.get_output_object_key(1))
        return rectangle  # type: ignore


def gen_region_contour_xld(contour: HObject, mode: str) -> HObject:
    """
    Create a region from an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input contour(s).

    mode : str
           Fill mode of the region(s).
           Value Suggestion: filled

    Returns
    -------

    region : HObject
             Created region(s).

    See Also
    --------
    set_system

    Alternatives
    ------------
    gen_region_polygon, gen_region_polygon_xld

    Predecessors
    ------------
    gen_contour_polygon_xld, gen_contour_polygon_rounded_xld
    """
    with HalconOperator(597) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, mode)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_region_histo(
    histogram: Sequence[int],
    row: int,
    column: int,
    scale: int
) -> HObject:
    """
    Convert a histogram into a region.

    Parameters
    ----------

    histogram : Sequence[int]
                Input histogram.

    row : int
          Row coordinate of the center of the histogram.
          Value Suggestion: 255

    column : int
             Column coordinate of the center of the histogram.
             Value Suggestion: 255

    scale : int
            Scale factor for the histogram.
            Value Suggestion: 1

    Returns
    -------

    region : HObject
             Region containing the histogram.

    See Also
    --------
    disp_channel

    Predecessors
    ------------
    gray_histo, gray_histo_range, tuple_histo_range
    """
    with HalconOperator(513) as proc:
        proc.set_input_tuple(0, histogram)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, scale)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_region_hline(
    orientation: MaybeSequence[Union[int, float]],
    distance: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Store input lines described in Hesse normal form as regions.

    Parameters
    ----------

    orientation : MaybeSequence[Union[int, float]]
                  Orientation of the normal vector in radians.
                  Value Suggestion: 0.0

    distance : MaybeSequence[Union[int, float]]
               Distance from the line to the coordinate origin (0.0).
               Value Suggestion: 200

    Returns
    -------

    regions : HObject
              Created regions (one for every line), clipped to maximum
              image format.

    See Also
    --------
    hough_lines

    Alternatives
    ------------
    gen_region_line

    Notes
    -----
    The lines are clipped to the current maximum image format.
    """
    with HalconOperator(615) as proc:
        proc.set_input_tuple(0, orientation)
        proc.set_input_tuple(1, distance)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def gen_region_line(
    begin_row: MaybeSequence[Union[int, float]],
    begin_col: MaybeSequence[Union[int, float]],
    end_row: MaybeSequence[Union[int, float]],
    end_col: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Store input lines as regions.

    Parameters
    ----------

    begin_row : MaybeSequence[Union[int, float]]
                Line coordinates of the starting points of the input lines.
                Value Suggestion: 100

    begin_col : MaybeSequence[Union[int, float]]
                Column coordinates of the starting points of the input
                lines.
                Value Suggestion: 50

    end_row : MaybeSequence[Union[int, float]]
              Line coordinates of the ending points of the input lines.
              Value Suggestion: 150

    end_col : MaybeSequence[Union[int, float]]
              Column coordinates of the ending points of the input lines.
              Value Suggestion: 250

    Returns
    -------

    region_lines : HObject
                   Created regions.

    Alternatives
    ------------
    gen_region_hline

    Predecessors
    ------------
    split_skeleton_lines
    """
    with HalconOperator(616) as proc:
        proc.set_input_tuple(0, begin_row)
        proc.set_input_tuple(1, begin_col)
        proc.set_input_tuple(2, end_row)
        proc.set_input_tuple(3, end_col)
        proc.execute()
        region_lines = HObject(proc.get_output_object_key(1))
        return region_lines  # type: ignore


def gen_region_points(
    rows: MaybeSequence[Union[int, float]],
    columns: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Store individual pixels as image region.

    Parameters
    ----------

    rows : MaybeSequence[Union[int, float]]
           Lines of the pixels in the region.
           Value Suggestion: 100

    columns : MaybeSequence[Union[int, float]]
              Columns of the pixels in the region.
              Value Suggestion: 100

    Returns
    -------

    region : HObject
             Created region.

    See Also
    --------
    reduce_domain

    Alternatives
    ------------
    gen_region_polygon, gen_region_runs, gen_region_line

    Predecessors
    ------------
    get_region_points

    Successors
    ----------
    paint_region, reduce_domain
    """
    with HalconOperator(600) as proc:
        proc.set_input_tuple(0, rows)
        proc.set_input_tuple(1, columns)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_region_polygon(
    rows: Sequence[int],
    columns: Sequence[int]
) -> HObject:
    """
    Store a polygon as a region.

    Parameters
    ----------

    rows : Sequence[int]
           Line indices of the base points of the region contour.
           Value Suggestion: 100

    columns : Sequence[int]
              Column indices of the base points of the region contour.
              Value Suggestion: 100

    Returns
    -------

    region : HObject
             Created region.

    See Also
    --------
    fill_up, reduce_domain, get_region_polygon, draw_polygon

    Alternatives
    ------------
    gen_region_polygon_filled, gen_region_points, gen_region_runs

    Predecessors
    ------------
    get_region_polygon, draw_polygon

    Notes
    -----
    The region is not automatically closed and not filled.
    """
    with HalconOperator(599) as proc:
        proc.set_input_tuple(0, rows)
        proc.set_input_tuple(1, columns)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_region_polygon_filled(
    rows: Sequence[Union[int, float]],
    columns: Sequence[Union[int, float]]
) -> HObject:
    """
    Store a polygon as a ``filled'' region.

    Parameters
    ----------

    rows : Sequence[Union[int, float]]
           Line indices of the base points of the region contour.
           Value Suggestion: 100

    columns : Sequence[Union[int, float]]
              Column indices of the base points of the region contour.
              Value Suggestion: 100

    Returns
    -------

    region : HObject
             Created region.

    See Also
    --------
    gen_region_polygon, reduce_domain, get_region_polygon, gen_region_runs

    Alternatives
    ------------
    gen_region_polygon, gen_region_points, draw_polygon

    Predecessors
    ------------
    get_region_polygon, draw_polygon
    """
    with HalconOperator(598) as proc:
        proc.set_input_tuple(0, rows)
        proc.set_input_tuple(1, columns)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_region_polygon_xld(polygon: HObject, mode: str) -> HObject:
    """
    Create a region from an XLD polygon.

    Parameters
    ----------

    polygon : HObject
              Input polygon(s).

    mode : str
           Fill mode of the region(s).
           Value Suggestion: filled

    Returns
    -------

    region : HObject
             Created region(s).

    See Also
    --------
    set_system

    Alternatives
    ------------
    gen_region_polygon, gen_region_contour_xld

    Predecessors
    ------------
    gen_polygons_xld
    """
    with HalconOperator(596) as proc:
        proc.set_input_object(1, polygon)
        proc.set_input_tuple(0, mode)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_region_runs(
    row: MaybeSequence[int],
    column_begin: MaybeSequence[int],
    column_end: MaybeSequence[int]
) -> HObject:
    """
    Create a region from a runlength coding.

    Parameters
    ----------

    row : MaybeSequence[int]
          Lines of the runs.
          Value Suggestion: 100

    column_begin : MaybeSequence[int]
                   Columns of the starting points of the runs.
                   Value Suggestion: 50

    column_end : MaybeSequence[int]
                 Columns of the ending points of the runs.
                 Value Suggestion: 200
                 Assertion: ColumnEnd >= ColumnBegin

    Returns
    -------

    region : HObject
             Created region.

    See Also
    --------
    reduce_domain

    Alternatives
    ------------
    gen_region_points, gen_region_polygon, gen_region_line,
    gen_region_polygon_filled

    Predecessors
    ------------
    get_region_runs

    Notes
    -----
    For runtime reasons, it is not checked whether the restriction
    $ColumnEnd >= ColumnBegin$ is fulfilled. Note that if this restriction
    is violated, subsequent operations will likely lead to errors or
    unexpected behavior.
    """
    with HalconOperator(601) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column_begin)
        proc.set_input_tuple(2, column_end)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def gen_sin_bandpass(
    frequency: float,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate a bandpass filter with sinusoidal shape.

    Parameters
    ----------

    frequency : float
                Distance of the filter's maximum from the DC term.
                Value Suggestion: 0.1
                Assertion: Frequency >= 0

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_filter : HObject
                   Bandpass filter as image in the frequency domain.

    See Also
    --------
    fft_image_inv, gen_gauss_filter, gen_mean_filter,
    gen_derivative_filter, gen_bandpass, gen_bandfilter, gen_highpass,
    gen_lowpass

    Alternatives
    ------------
    gen_std_bandpass

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1519) as proc:
        proc.set_input_tuple(0, frequency)
        proc.set_input_tuple(1, norm)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.execute()
        image_filter = HObject(proc.get_output_object_key(1))
        return image_filter  # type: ignore


def gen_sphere_object_model_3d(
    pose: Sequence[Union[int, float]],
    radius: MaybeSequence[float]
) -> Sequence[HHandle]:
    """
    Create a 3D object model that represents a sphere.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The pose that describes the position of the sphere.

    radius : MaybeSequence[float]
             The radius of the sphere.

    Returns
    -------

    object_model_3d : Sequence[HHandle]
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_plane_object_model_3d,
    gen_box_object_model_3d

    Alternatives
    ------------
    gen_sphere_object_model_3d_center

    Predecessors
    ------------
    smallest_sphere_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1073) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, radius)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_m(0)
        return object_model_3d  # type: ignore


def gen_sphere_object_model_3d_center(
    x: MaybeSequence[Union[int, float]],
    y: MaybeSequence[Union[int, float]],
    z: MaybeSequence[Union[int, float]],
    radius: MaybeSequence[float]
) -> Sequence[HHandle]:
    """
    Create a 3D object model that represents a sphere from x,y,z
    coordinates.

    Parameters
    ----------

    x : MaybeSequence[Union[int, float]]
        The x-coordinate of the center point of the sphere.

    y : MaybeSequence[Union[int, float]]
        The y-coordinate of the center point of the sphere.

    z : MaybeSequence[Union[int, float]]
        The z-coordinate of the center point of the sphere.

    radius : MaybeSequence[float]
             The radius of the sphere.

    Returns
    -------

    object_model_3d : Sequence[HHandle]
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_plane_object_model_3d,
    gen_box_object_model_3d

    Alternatives
    ------------
    gen_sphere_object_model_3d

    Predecessors
    ------------
    smallest_sphere_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1072) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, radius)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_m(0)
        return object_model_3d  # type: ignore


def gen_sphere_object_model_3d_center_s(
    x: MaybeSequence[Union[int, float]],
    y: MaybeSequence[Union[int, float]],
    z: MaybeSequence[Union[int, float]],
    radius: MaybeSequence[float]
) -> HHandle:
    """
    Create a 3D object model that represents a sphere from x,y,z
    coordinates.

    Parameters
    ----------

    x : MaybeSequence[Union[int, float]]
        The x-coordinate of the center point of the sphere.

    y : MaybeSequence[Union[int, float]]
        The y-coordinate of the center point of the sphere.

    z : MaybeSequence[Union[int, float]]
        The z-coordinate of the center point of the sphere.

    radius : MaybeSequence[float]
             The radius of the sphere.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_plane_object_model_3d,
    gen_box_object_model_3d

    Alternatives
    ------------
    gen_sphere_object_model_3d

    Predecessors
    ------------
    smallest_sphere_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1072) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, radius)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def gen_sphere_object_model_3d_s(
    pose: Sequence[Union[int, float]],
    radius: MaybeSequence[float]
) -> HHandle:
    """
    Create a 3D object model that represents a sphere.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           The pose that describes the position of the sphere.

    radius : MaybeSequence[float]
             The radius of the sphere.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    See Also
    --------
    gen_cylinder_object_model_3d, gen_plane_object_model_3d,
    gen_box_object_model_3d

    Alternatives
    ------------
    gen_sphere_object_model_3d_center

    Predecessors
    ------------
    smallest_sphere_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, sample_object_model_3d,
    clear_object_model_3d
    """
    with HalconOperator(1073) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, radius)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def gen_spherical_mosaic(
    images: HObject,
    camera_matrices: Sequence[float],
    rotation_matrices: Sequence[float],
    lat_min: Union[float, int],
    lat_max: Union[float, int],
    long_min: Union[float, int],
    long_max: Union[float, int],
    lat_long_step: Union[float, int],
    stacking_order: MaybeSequence[Union[str, int]],
    interpolation: Union[str, int]
) -> HObject:
    """
    Create a spherical mosaic image.

    Parameters
    ----------

    images : HObject
             Input images.

    camera_matrices : Sequence[float]
                      (Array of) $3- projective camera matrices that
                      determine the internal camera parameters.

    rotation_matrices : Sequence[float]
                        Array of $3-                     transformation
                        matrices that determine rotation of the camera in
                        the respective image.

    lat_min : Union[float, int]
              Minimum latitude of points in the spherical mosaic image.
              Value Suggestion: -90
              Assertion: LatMin <= 90

    lat_max : Union[float, int]
              Maximum latitude of points in the spherical mosaic image.
              Value Suggestion: 90
              Assertion: LatMax >= -90 && LatMax > LatMin

    long_min : Union[float, int]
               Minimum longitude of points in the spherical mosaic image.
               Value Suggestion: -180
               Assertion: LongMin <= 180

    long_max : Union[float, int]
               Maximum longitude of points in the spherical mosaic image.
               Value Suggestion: 180
               Assertion: LongMax >= -90 && LongMax > LongMin

    lat_long_step : Union[float, int]
                    Latitude and longitude angle step width.
                    Value Suggestion: 0.1
                    Assertion: LatLongStep >= 0

    stacking_order : MaybeSequence[Union[str, int]]
                     Mode of adding the images to the mosaic image.
                     Value Suggestion: voronoi

    interpolation : Union[str, int]
                    Mode of interpolation when creating the mosaic image.
                    Value Suggestion: bilinear

    Returns
    -------

    mosaic_image : HObject
                   Output image.

    Alternatives
    ------------
    gen_cube_map_mosaic, gen_projective_mosaic

    Predecessors
    ------------
    stationary_camera_self_calibration
    """
    with HalconOperator(1617) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, camera_matrices)
        proc.set_input_tuple(1, rotation_matrices)
        proc.set_input_tuple(2, lat_min)
        proc.set_input_tuple(3, lat_max)
        proc.set_input_tuple(4, long_min)
        proc.set_input_tuple(5, long_max)
        proc.set_input_tuple(6, lat_long_step)
        proc.set_input_tuple(7, stacking_order)
        proc.set_input_tuple(8, interpolation)
        proc.execute()
        mosaic_image = HObject(proc.get_output_object_key(1))
        return mosaic_image  # type: ignore


def gen_std_bandpass(
    frequency: float,
    sigma: float,
    type: str,
    norm: str,
    mode: str,
    width: int,
    height: int
) -> HObject:
    """
    Generate a bandpass filter with Gaussian or sinusoidal shape.

    Parameters
    ----------

    frequency : float
                Distance of the filter's maximum from the DC term.
                Value Suggestion: 0.1
                Assertion: Frequency >= 0

    sigma : float
            Bandwidth of the filter (standard deviation).
            Value Suggestion: 0.01
            Assertion: Sigma >= 0

    type : str
           Filter type.
           Value Suggestion: sin

    norm : str
           Normalizing factor of the filter.
           Value Suggestion: none

    mode : str
           Location of the DC term in the frequency domain.
           Value Suggestion: dc_center

    width : int
            Width of the image (filter).
            Value Suggestion: 512

    height : int
             Height of the image (filter).
             Value Suggestion: 512

    Returns
    -------

    image_filter : HObject
                   Bandpass filter as image in the frequency domain.

    See Also
    --------
    fft_image_inv, gen_gauss_filter, gen_mean_filter,
    gen_derivative_filter, gen_bandpass, gen_bandfilter, gen_highpass,
    gen_lowpass

    Alternatives
    ------------
    gen_sin_bandpass

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    convol_fft
    """
    with HalconOperator(1518) as proc:
        proc.set_input_tuple(0, frequency)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, type)
        proc.set_input_tuple(3, norm)
        proc.set_input_tuple(4, mode)
        proc.set_input_tuple(5, width)
        proc.set_input_tuple(6, height)
        proc.execute()
        image_filter = HObject(proc.get_output_object_key(1))
        return image_filter  # type: ignore


def gen_struct_elements(type: str, row: int, column: int) -> HObject:
    """
    Generate standard structuring elements.

    Parameters
    ----------

    type : str
           Type of structuring element to generate.
           Value Suggestion: noise

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 1

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 1

    Returns
    -------

    struct_elements : HObject
                      Generated structuring elements.

    See Also
    --------
    golay_elements

    Successors
    ----------
    fitting, hit_or_miss, opening, closing, erosion2, dilation2

    Warnings
    --------
    gen_struct_elements is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(738) as proc:
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()
        struct_elements = HObject(proc.get_output_object_key(1))
        return struct_elements  # type: ignore


def gen_structured_light_pattern(
    structured_light_model: HHandle
) -> HObject:
    """
    Generate the pattern images to be displayed in a structured light
    setup.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    Returns
    -------

    pattern_images : HObject
                     Generated pattern images.

    See Also
    --------
    create_structured_light_model, get_structured_light_model_param,
    get_structured_light_object

    Predecessors
    ------------
    set_structured_light_model_param

    Successors
    ----------
    decode_structured_light_pattern
    """
    with HalconOperator(2113) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.execute()
        pattern_images = HObject(proc.get_output_object_key(1))
        return pattern_images  # type: ignore


def generalized_eigenvalues_general_matrix(
    matrix_aid: HHandle,
    matrix_bid: HHandle,
    compute_eigenvectors: str
) -> Tuple[HHandle, HHandle, HHandle, HHandle]:
    """
    Compute the generalized eigenvalues and optionally the generalized
    eigenvectors of general matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    compute_eigenvectors : str
                           Computation of the eigenvectors.
                           Value Suggestion: none

    Returns
    -------

    eigenvalues_real_id : HHandle
                          Matrix handle with the real parts of the
                          eigenvalues.

    eigenvalues_imag_id : HHandle
                          Matrix handle with the imaginary parts of the
                          eigenvalues.

    eigenvectors_real_id : HHandle
                           Matrix handle with the real parts of the
                           eigenvectors.

    eigenvectors_imag_id : HHandle
                           Matrix handle with the imaginary parts of the
                           eigenvectors.

    See Also
    --------
    generalized_eigenvalues_symmetric_matrix,
    eigenvalues_symmetric_matrix, eigenvalues_general_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix, get_diagonal_matrix
    """
    with HalconOperator(847) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.set_input_tuple(2, compute_eigenvectors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # eigenvalues_real_id
            proc.get_output_tuple_s(1),  # eigenvalues_imag_id
            proc.get_output_tuple_s(2),  # eigenvectors_real_id
            proc.get_output_tuple_s(3)   # eigenvectors_imag_id
        )  # type: ignore


def generalized_eigenvalues_symmetric_matrix(
    matrix_aid: HHandle,
    matrix_bid: HHandle,
    compute_eigenvectors: str
) -> Tuple[HHandle, HHandle]:
    """
    Compute the generalized eigenvalues and optionally generalized
    eigenvectors of symmetric input matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the symmetric input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the symmetric positive definite input
                 matrix B.

    compute_eigenvectors : str
                           Computation of the eigenvectors.
                           Value Suggestion: false

    Returns
    -------

    eigenvalues_id : HHandle
                     Matrix handle with the eigenvalues.

    eigenvectors_id : HHandle
                      Matrix handle with the eigenvectors.

    See Also
    --------
    eigenvalues_symmetric_matrix, eigenvalues_general_matrix

    Alternatives
    ------------
    generalized_eigenvalues_general_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    The upper triangular parts of the input matrices MatrixA and MatrixB
    must contain the relevant information of the matrices.  The strictly
    lower triangular parts of the matrices are not referenced.  If the
    referenced parts of the input matrices MatrixA or MatrixB are not of
    the specified type, an exception is raised.
    """
    with HalconOperator(848) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.set_input_tuple(2, compute_eigenvectors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # eigenvalues_id
            proc.get_output_tuple_s(1)   # eigenvectors_id
        )  # type: ignore


def get_aop_info(
    operator_name: Union[str, int],
    index_name: Sequence[str],
    index_value: Sequence[str],
    info_name: str
) -> Sequence[str]:
    """
    Return AOP information for operators.

    Parameters
    ----------

    operator_name : Union[str, int]
                    Operator to get information for

    index_name : Sequence[str]
                 Further index stages
                 Value Suggestion: ['iconic_type','parameter:0']

    index_value : Sequence[str]
                  Further index values
                  Value Suggestion: ['byte','']

    info_name : str
                Scope of information
                Value Suggestion: max_threads

    Returns
    -------

    info_value : Sequence[str]
                 Value of information
    """
    with HalconOperator(567) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, index_name)
        proc.set_input_tuple(2, index_value)
        proc.set_input_tuple(3, info_name)
        proc.init_oct(0)
        proc.execute()
        info_value = proc.get_output_tuple_m(0)
        return info_value  # type: ignore


def get_aop_info_s(
    operator_name: Union[str, int],
    index_name: Sequence[str],
    index_value: Sequence[str],
    info_name: str
) -> str:
    """
    Return AOP information for operators.

    Parameters
    ----------

    operator_name : Union[str, int]
                    Operator to get information for

    index_name : Sequence[str]
                 Further index stages
                 Value Suggestion: ['iconic_type','parameter:0']

    index_value : Sequence[str]
                  Further index values
                  Value Suggestion: ['byte','']

    info_name : str
                Scope of information
                Value Suggestion: max_threads

    Returns
    -------

    info_value : str
                 Value of information
    """
    with HalconOperator(567) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, index_name)
        proc.set_input_tuple(2, index_value)
        proc.set_input_tuple(3, info_name)
        proc.init_oct(0)
        proc.execute()
        info_value = proc.get_output_tuple_s(0)
        return info_value  # type: ignore


def get_bar_code_object(
    bar_code_handle: HHandle,
    candidate_handle: Union[int, str],
    object_name: str
) -> HObject:
    """
    Access iconic objects that were created during the search or decoding
    of bar code symbols.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    candidate_handle : Union[int, str]
                       Indicating the bar code results respectively
                       candidates for which the data is required.
                       Value Suggestion: all

    object_name : str
                  Name of the iconic object to return.
                  Value Suggestion: candidate_regions

    Returns
    -------

    bar_code_objects : HObject
                       Objects that are created as intermediate results
                       during the detection or evaluation of bar codes.

    See Also
    --------
    get_bar_code_result

    Predecessors
    ------------
    find_bar_code
    """
    with HalconOperator(1990) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, candidate_handle)
        proc.set_input_tuple(2, object_name)
        proc.execute()
        bar_code_objects = HObject(proc.get_output_object_key(1))
        return bar_code_objects  # type: ignore


def get_bar_code_param(
    bar_code_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[float, int, str]]:
    """
    Get one or several parameters that describe the bar code model.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the bar code model.
                     Value Suggestion: element_size_min

    Returns
    -------

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.

    Alternatives
    ------------
    get_bar_code_param_specific

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param

    Successors
    ----------
    set_bar_code_param
    """
    with HalconOperator(1996) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_bar_code_param_s(
    bar_code_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[float, int, str]:
    """
    Get one or several parameters that describe the bar code model.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the bar code model.
                     Value Suggestion: element_size_min

    Returns
    -------

    gen_param_value : Union[float, int, str]
                      Values of the generic parameters.

    Alternatives
    ------------
    get_bar_code_param_specific

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param

    Successors
    ----------
    set_bar_code_param
    """
    with HalconOperator(1996) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_bar_code_param_specific(
    bar_code_handle: HHandle,
    code_types: MaybeSequence[str],
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[float, int, str]]:
    """
    Get parameters that are used by the bar code reader when processing a
    specific bar code type.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_types : MaybeSequence[str]
                 Names of the bar code types for which parameters should
                 be queried.
                 Value Suggestion: 'EAN-13'

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the bar code model.
                     Value Suggestion: check_char

    Returns
    -------

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters.

    Alternatives
    ------------
    get_bar_code_param

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param, set_bar_code_param_specific
    """
    with HalconOperator(1995) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_types)
        proc.set_input_tuple(2, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_bar_code_param_specific_s(
    bar_code_handle: HHandle,
    code_types: MaybeSequence[str],
    gen_param_name: MaybeSequence[str]
) -> Union[float, int, str]:
    """
    Get parameters that are used by the bar code reader when processing a
    specific bar code type.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_types : MaybeSequence[str]
                 Names of the bar code types for which parameters should
                 be queried.
                 Value Suggestion: 'EAN-13'

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the bar code model.
                     Value Suggestion: check_char

    Returns
    -------

    gen_param_value : Union[float, int, str]
                      Values of the generic parameters.

    Alternatives
    ------------
    get_bar_code_param

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param, set_bar_code_param_specific
    """
    with HalconOperator(1995) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_types)
        proc.set_input_tuple(2, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_bar_code_result(
    bar_code_handle: HHandle,
    candidate_handle: Union[int, str],
    result_name: str
) -> Sequence[Union[int, float, str]]:
    """
    Get the alphanumerical results that were accumulated during the
    decoding of bar code symbols.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    candidate_handle : Union[int, str]
                       Indicating the bar code results respectively
                       candidates for which the data is required.
                       Value Suggestion: all

    result_name : str
                  Names of the resulting data to return.
                  Value Suggestion: decoded_types

    Returns
    -------

    bar_code_results : Sequence[Union[int, float, str]]
                       List with the results.

    See Also
    --------
    get_bar_code_object

    Predecessors
    ------------
    find_bar_code
    """
    with HalconOperator(1991) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, candidate_handle)
        proc.set_input_tuple(2, result_name)
        proc.init_oct(0)
        proc.execute()
        bar_code_results = proc.get_output_tuple_m(0)
        return bar_code_results  # type: ignore


def get_bar_code_result_s(
    bar_code_handle: HHandle,
    candidate_handle: Union[int, str],
    result_name: str
) -> Union[int, float, str]:
    """
    Get the alphanumerical results that were accumulated during the
    decoding of bar code symbols.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    candidate_handle : Union[int, str]
                       Indicating the bar code results respectively
                       candidates for which the data is required.
                       Value Suggestion: all

    result_name : str
                  Names of the resulting data to return.
                  Value Suggestion: decoded_types

    Returns
    -------

    bar_code_results : Union[int, float, str]
                       List with the results.

    See Also
    --------
    get_bar_code_object

    Predecessors
    ------------
    find_bar_code
    """
    with HalconOperator(1991) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, candidate_handle)
        proc.set_input_tuple(2, result_name)
        proc.init_oct(0)
        proc.execute()
        bar_code_results = proc.get_output_tuple_s(0)
        return bar_code_results  # type: ignore


def get_bead_inspection_param(
    bead_inspection_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Get the value of a parameter in a specific bead inspection model.

    Parameters
    ----------

    bead_inspection_model : HHandle
                            Handle of the bead inspection model.

    gen_param_name : MaybeSequence[str]
                     Name of the model parameter that is queried.
                     Value Suggestion: target_thickness

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Value of the queried model parameter.

    See Also
    --------
    create_bead_inspection_model, set_bead_inspection_param

    Predecessors
    ------------
    create_bead_inspection_model, set_bead_inspection_param

    Successors
    ----------
    apply_bead_inspection_model, set_bead_inspection_param
    """
    with HalconOperator(1981) as proc:
        proc.set_input_tuple(0, bead_inspection_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_bead_inspection_param_s(
    bead_inspection_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Get the value of a parameter in a specific bead inspection model.

    Parameters
    ----------

    bead_inspection_model : HHandle
                            Handle of the bead inspection model.

    gen_param_name : MaybeSequence[str]
                     Name of the model parameter that is queried.
                     Value Suggestion: target_thickness

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Value of the queried model parameter.

    See Also
    --------
    create_bead_inspection_model, set_bead_inspection_param

    Predecessors
    ------------
    create_bead_inspection_model, set_bead_inspection_param

    Successors
    ----------
    apply_bead_inspection_model, set_bead_inspection_param
    """
    with HalconOperator(1981) as proc:
        proc.set_input_tuple(0, bead_inspection_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_bg_esti_params(
    bg_esti_handle: HHandle
) -> Tuple[float, float, str, float, float, str, float, int, float, float]:
    """
    Return the parameters of the data set.

    Parameters
    ----------

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    Returns
    -------

    syspar_1 : float
               1. system matrix parameter.

    syspar_2 : float
               2. system matrix parameter.

    gain_mode : str
                Gain type.

    gain_1 : float
             Kalman gain / foreground adaptation time.

    gain_2 : float
             Kalman gain / background adaptation time.

    adapt_mode : str
                 Threshold adaptation.

    min_diff : float
               Foreground / background threshold.

    stat_num : int
               Number of statistic data sets.

    confidence_c : float
                   Confidence constant.

    time_c : float
             Constant for decay time.

    See Also
    --------
    set_bg_esti_params

    Predecessors
    ------------
    create_bg_esti

    Successors
    ----------
    run_bg_esti
    """
    with HalconOperator(2006) as proc:
        proc.set_input_tuple(0, bg_esti_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # syspar_1
            proc.get_output_tuple_s(1),  # syspar_2
            proc.get_output_tuple_s(2),  # gain_mode
            proc.get_output_tuple_s(3),  # gain_1
            proc.get_output_tuple_s(4),  # gain_2
            proc.get_output_tuple_s(5),  # adapt_mode
            proc.get_output_tuple_s(6),  # min_diff
            proc.get_output_tuple_s(7),  # stat_num
            proc.get_output_tuple_s(8),  # confidence_c
            proc.get_output_tuple_s(9)   # time_c
        )  # type: ignore


def get_calib_data(
    calib_data_id: HHandle,
    item_type: str,
    item_idx: MaybeSequence[Union[int, str]],
    data_name: MaybeSequence[str]
) -> Sequence[Union[float, int, str]]:
    """
    Query data stored or computed in a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    item_type : str
                Type of calibration data item.
                Value Suggestion: camera

    item_idx : MaybeSequence[Union[int, str]]
               Index of the affected item (depending on the selected
               ItemType).
               Value Suggestion: 0

    data_name : MaybeSequence[str]
                The name of the inspected data.
                Value Suggestion: params

    Returns
    -------

    data_value : Sequence[Union[float, int, str]]
                 Requested data.

    Predecessors
    ------------
    calibrate_cameras, calibrate_hand_eye, create_calib_data,
    read_calib_data
    """
    with HalconOperator(1977) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, item_type)
        proc.set_input_tuple(2, item_idx)
        proc.set_input_tuple(3, data_name)
        proc.init_oct(0)
        proc.execute()
        data_value = proc.get_output_tuple_m(0)
        return data_value  # type: ignore


def get_calib_data_observ_contours(
    calib_data_id: HHandle,
    contour_name: str,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int
) -> HObject:
    """
    Get contour-based observation data from a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    contour_name : str
                   Name of contour objects to be returned.
                   Value Suggestion: marks

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the observed calibration plate.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object pose.
                         Value Suggestion: 0

    Returns
    -------

    contours : HObject
               Contour-based result(s).
    """
    with HalconOperator(1971) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, contour_name)
        proc.set_input_tuple(2, camera_idx)
        proc.set_input_tuple(3, calib_obj_idx)
        proc.set_input_tuple(4, calib_obj_pose_idx)
        proc.execute()
        contours = HObject(proc.get_output_object_key(1))
        return contours  # type: ignore


def get_calib_data_observ_points(
    calib_data_id: HHandle,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int
) -> Tuple[Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]], Sequence[Union[float, int]]]:
    """
    Get point-based observation data from a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the observed calibration object.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object pose.
                         Value Suggestion: 0

    Returns
    -------

    row : Sequence[Union[float, int]]
          Row coordinates of the detected points.

    column : Sequence[Union[float, int]]
             Column coordinates of the detected points.

    index : Sequence[Union[float, int]]
            Correspondence of the detected points to the points of the
            observed calibration object.

    pose : Sequence[Union[float, int]]
           Roughly estimated pose of the observed calibration object
           relative to the observing camera.
    """
    with HalconOperator(1974) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, calib_obj_idx)
        proc.set_input_tuple(3, calib_obj_pose_idx)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # index
            proc.get_output_tuple_m(3)   # pose
        )  # type: ignore


def get_calib_data_observ_pose(
    calib_data_id: HHandle,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int
) -> Sequence[Union[float, int]]:
    """
    Get observed calibration object poses from a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the observed calibration object.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object pose.
                         Value Suggestion: 0

    Returns
    -------

    obj_in_camera_pose : Sequence[Union[float, int]]
                         Stored observed calibration object pose relative
                         to the observing camera.
    """
    with HalconOperator(1972) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, calib_obj_idx)
        proc.set_input_tuple(3, calib_obj_pose_idx)
        proc.init_oct(0)
        proc.execute()
        obj_in_camera_pose = proc.get_output_tuple_m(0)
        return obj_in_camera_pose  # type: ignore


def get_calib_data_s(
    calib_data_id: HHandle,
    item_type: str,
    item_idx: MaybeSequence[Union[int, str]],
    data_name: MaybeSequence[str]
) -> Union[float, int, str]:
    """
    Query data stored or computed in a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    item_type : str
                Type of calibration data item.
                Value Suggestion: camera

    item_idx : MaybeSequence[Union[int, str]]
               Index of the affected item (depending on the selected
               ItemType).
               Value Suggestion: 0

    data_name : MaybeSequence[str]
                The name of the inspected data.
                Value Suggestion: params

    Returns
    -------

    data_value : Union[float, int, str]
                 Requested data.

    Predecessors
    ------------
    calibrate_cameras, calibrate_hand_eye, create_calib_data,
    read_calib_data
    """
    with HalconOperator(1977) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, item_type)
        proc.set_input_tuple(2, item_idx)
        proc.set_input_tuple(3, data_name)
        proc.init_oct(0)
        proc.execute()
        data_value = proc.get_output_tuple_s(0)
        return data_value  # type: ignore


def get_camera_setup_param(
    camera_setup_model_id: HHandle,
    camera_idx: MaybeSequence[Union[int, str]],
    gen_param_name: str
) -> Sequence[Union[float, int, str]]:
    """
    Get generic camera setup model parameters.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    camera_idx : MaybeSequence[Union[int, str]]
                 Index of the camera in the setup.
                 Value Suggestion: 0

    gen_param_name : str
                     Names of the generic parameters to be queried.

    Returns
    -------

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters to be queried.
    """
    with HalconOperator(1955) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_camera_setup_param_s(
    camera_setup_model_id: HHandle,
    camera_idx: MaybeSequence[Union[int, str]],
    gen_param_name: str
) -> Union[float, int, str]:
    """
    Get generic camera setup model parameters.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    camera_idx : MaybeSequence[Union[int, str]]
                 Index of the camera in the setup.
                 Value Suggestion: 0

    gen_param_name : str
                     Names of the generic parameters to be queried.

    Returns
    -------

    gen_param_value : Union[float, int, str]
                      Values of the generic parameters to be queried.
    """
    with HalconOperator(1955) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_channel_info(
    object: HObject,
    request: str,
    channel: MaybeSequence[int]
) -> Sequence[str]:
    """
    Information about the components of an image object.

    Parameters
    ----------

    object : HObject
             Image object to be examined.

    request : str
              Required information about object components.
              Value Suggestion: creator

    channel : MaybeSequence[int]
              Components to be examined (0 for region/XLD).
              Value Suggestion: 0

    Returns
    -------

    information : Sequence[str]
                  Requested information.

    See Also
    --------
    count_relation

    Predecessors
    ------------
    read_image
    """
    with HalconOperator(593) as proc:
        proc.set_input_object(1, object)
        proc.set_input_tuple(0, request)
        proc.set_input_tuple(1, channel)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_m(0)
        return information  # type: ignore


def get_channel_info_s(
    object: HObject,
    request: str,
    channel: MaybeSequence[int]
) -> str:
    """
    Information about the components of an image object.

    Parameters
    ----------

    object : HObject
             Image object to be examined.

    request : str
              Required information about object components.
              Value Suggestion: creator

    channel : MaybeSequence[int]
              Components to be examined (0 for region/XLD).
              Value Suggestion: 0

    Returns
    -------

    information : str
                  Requested information.

    See Also
    --------
    count_relation

    Predecessors
    ------------
    read_image
    """
    with HalconOperator(593) as proc:
        proc.set_input_object(1, object)
        proc.set_input_tuple(0, request)
        proc.set_input_tuple(1, channel)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_s(0)
        return information  # type: ignore


def get_chapter_info(chapter: MaybeSequence[str]) -> Sequence[str]:
    """
    Get information concerning the chapters on operators.

    Parameters
    ----------

    chapter : MaybeSequence[str]
              Operator class or subclass of interest.
              Value Suggestion: ''

    Returns
    -------

    info : Sequence[str]
           Operator classes (Chapter = '') or operator subclasses
           respectively operators.

    See Also
    --------
    get_operator_info, get_system, set_system

    Predecessors
    ------------
    get_system, set_system

    Notes
    -----
    The encoding of the result is ISO 8859-1 for English and German, and
    UTF-8 for Japanese.
    """
    with HalconOperator(1118) as proc:
        proc.set_input_tuple(0, chapter)
        proc.init_oct(0)
        proc.execute()
        info = proc.get_output_tuple_m(0)
        return info  # type: ignore


def get_check() -> Sequence[str]:
    """
    State of the HALCON control modes.

    Returns
    -------

    check : Sequence[str]
            Tuple of the currently activated control modes.

    See Also
    --------
    set_check

    Predecessors
    ------------
    set_check
    """
    with HalconOperator(321) as proc:
        proc.init_oct(0)
        proc.execute()
        check = proc.get_output_tuple_m(0)
        return check  # type: ignore


def get_circle_pose(
    contour: HObject,
    camera_param: Sequence[Union[int, float, str]],
    radius: MaybeSequence[float],
    output_type: str
) -> Tuple[Sequence[Union[float, int]], Sequence[Union[float, int]]]:
    """
    Determine the 3D pose of a circle from its perspective 2D projection.

    Parameters
    ----------

    contour : HObject
              Contours to be examined.

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    radius : MaybeSequence[float]
             Radius of the circle in object space.
             Assertion: Radius > 0.0

    output_type : str
                  Type of output parameters.
                  Value Suggestion: pose

    Returns
    -------

    pose_1 : Sequence[Union[float, int]]
             3D pose of the first circle.

    pose_2 : Sequence[Union[float, int]]
             3D pose of the second circle.

    See Also
    --------
    get_rectangle_pose, fit_ellipse_contour_xld

    Alternatives
    ------------
    find_marks_and_pose, camera_calibration

    Predecessors
    ------------
    edges_sub_pix

    Notes
    -----
    The accuracy of the determined poses depends heavily on the accuracy
    of the extracted contours. The extraction of curved edges using
    relatively large filter masks leads to a slightly shifted edge
    position. Edge extraction approaches that are based on the first
    derivative of the image function (e.g., edges_sub_pix) yield edges
    that are shifted towards the center of curvature, i.e., extracted
    ellipses will be slightly to small. Approaches that are based on the
    second derivative of the image function (laplace_of_gauss followed by
    zero_crossing_sub_pix) result in edges that are  shifted away from the
    center of curvature, i.e., extracted ellipses will be slightly too
    large.
    These effects increase with the curvature of the edge and with the
    size of the filter mask that is used for the edge extraction.
    Therefore, to achieve high accuracy, the ellipses should appear large
    in the image and the filter parameter should be chosen such that small
    filter masks are used (see info_edges).
    """
    with HalconOperator(1909) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, radius)
        proc.set_input_tuple(2, output_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose_1
            proc.get_output_tuple_m(1)   # pose_2
        )  # type: ignore


def get_class_box_param(
    classif_handle: HHandle,
    flag: str
) -> Union[int, float]:
    """
    Get information about the current parameter.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    flag : str
           Name of the system parameter.
           Value Suggestion: split_error

    Returns
    -------

    value : Union[int, float]
            Value of the system parameter.

    See Also
    --------
    create_class_box, set_class_box_param

    Predecessors
    ------------
    create_class_box, enquire_class_box, learn_class_box, write_class_box

    Successors
    ----------
    set_class_box_param, learn_class_box, enquire_class_box,
    write_class_box, close_class_box, clear_sampset

    Warnings
    --------
    get_class_box_param is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1892) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, flag)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_class_train_data_gmm(gmmhandle: HHandle) -> HHandle:
    """
    Get the training data of a Gaussian Mixture Model (GMM).

    Parameters
    ----------

    gmmhandle : HHandle
                Handle of a GMM that contains training data.

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data of the
                              classifier.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    add_sample_class_gmm, read_samples_class_gmm

    Successors
    ----------
    add_class_train_data_svm, add_class_train_data_svm,
    add_class_train_data_knn
    """
    with HalconOperator(1785) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def get_class_train_data_knn(knnhandle: HHandle) -> HHandle:
    """
    Get the training data of a k-nearest neighbors (k-NN) classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier  that contains training data.

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data of the
                              classifier.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    add_sample_class_knn

    Successors
    ----------
    add_class_train_data_svm, add_class_train_data_gmm,
    add_class_train_data_knn
    """
    with HalconOperator(1789) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def get_class_train_data_mlp(mlphandle: HHandle) -> HHandle:
    """
    Get the training data of a multilayer perceptron (MLP).

    Parameters
    ----------

    mlphandle : HHandle
                Handle of a MLP that contains training data.

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data of the
                              classifier.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    add_sample_class_mlp, read_samples_class_mlp

    Successors
    ----------
    add_class_train_data_svm, add_class_train_data_gmm,
    add_class_train_data_knn
    """
    with HalconOperator(1787) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def get_class_train_data_svm(svmhandle: HHandle) -> HHandle:
    """
    Get the training data of a support vector machine (SVM).

    Parameters
    ----------

    svmhandle : HHandle
                Handle of a SVM that contains training data.

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data of the
                              classifier.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    add_sample_class_svm, read_samples_class_svm

    Successors
    ----------
    add_class_train_data_mlp, add_class_train_data_gmm,
    add_class_train_data_knn
    """
    with HalconOperator(1791) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def get_component_model_params(
    component_model_id: HHandle
) -> Tuple[Sequence[float], Sequence[int], Sequence[HHandle]]:
    """
    Return the parameters of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    Returns
    -------

    min_score_comp : Sequence[float]
                     Minimum score of the instances of the components to
                     be found.

    root_ranking : Sequence[int]
                   Ranking of the model components expressing their
                   suitability to act as root component.

    shape_model_ids : Sequence[HHandle]
                      Handles of the shape models of the individual model
                      components.

    See Also
    --------
    get_shape_model_params

    Predecessors
    ------------
    create_trained_component_model, create_component_model
    """
    with HalconOperator(999) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # min_score_comp
            proc.get_output_tuple_m(1),  # root_ranking
            proc.get_output_tuple_m(2)   # shape_model_ids
        )  # type: ignore


def get_component_model_params_s(
    component_model_id: HHandle
) -> Tuple[float, int, HHandle]:
    """
    Return the parameters of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    Returns
    -------

    min_score_comp : float
                     Minimum score of the instances of the components to
                     be found.

    root_ranking : int
                   Ranking of the model components expressing their
                   suitability to act as root component.

    shape_model_ids : HHandle
                      Handles of the shape models of the individual model
                      components.

    See Also
    --------
    get_shape_model_params

    Predecessors
    ------------
    create_trained_component_model, create_component_model
    """
    with HalconOperator(999) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # min_score_comp
            proc.get_output_tuple_s(1),  # root_ranking
            proc.get_output_tuple_s(2)   # shape_model_ids
        )  # type: ignore


def get_component_model_tree(
    component_model_id: HHandle,
    root_component: MaybeSequence[int],
    image: Union[str, int]
) -> Tuple[HObject, HObject, Sequence[int], Sequence[int], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return the search tree of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    root_component : MaybeSequence[int]
                     Index of the root component.

    image : Union[str, int]
            Image for which the tree is to be returned.
            Value Suggestion: model_image

    Returns
    -------

    tree : HObject
           Search tree.

    relations : HObject
                Relations of components that are connected in the search
                tree.

    start_node : Sequence[int]
                 Component index of the start node of an arc in the search
                 tree.

    end_node : Sequence[int]
               Component index of the end node of an arc in the search
               tree.

    row : Sequence[float]
          Row coordinate of the center of the rectangle representing the
          relation.

    column : Sequence[float]
             Column index of the center of the rectangle representing the
             relation.

    phi : Sequence[float]
          Orientation of the rectangle representing the relation (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : Sequence[float]
               First radius (half length) of the rectangle representing
               the relation.
               Assertion: Length1 >= 0.0

    length_2 : Sequence[float]
               Second radius (half width) of the rectangle representing
               the relation.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    angle_start : Sequence[float]
                  Smallest relative orientation angle.

    angle_extent : Sequence[float]
                   Extent of the relative orientation angle.

    See Also
    --------
    train_model_components

    Predecessors
    ------------
    create_trained_component_model, create_component_model
    """
    with HalconOperator(998) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, root_component)
        proc.set_input_tuple(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # tree
            HObject(proc.get_output_object_key(2)),  # relations
            proc.get_output_tuple_m(0),  # start_node
            proc.get_output_tuple_m(1),  # end_node
            proc.get_output_tuple_m(2),  # row
            proc.get_output_tuple_m(3),  # column
            proc.get_output_tuple_m(4),  # phi
            proc.get_output_tuple_m(5),  # length_1
            proc.get_output_tuple_m(6),  # length_2
            proc.get_output_tuple_m(7),  # angle_start
            proc.get_output_tuple_m(8)   # angle_extent
        )  # type: ignore


def get_component_model_tree_s(
    component_model_id: HHandle,
    root_component: MaybeSequence[int],
    image: Union[str, int]
) -> Tuple[HObject, HObject, int, int, float, float, float, float, float, float, float]:
    """
    Return the search tree of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    root_component : MaybeSequence[int]
                     Index of the root component.

    image : Union[str, int]
            Image for which the tree is to be returned.
            Value Suggestion: model_image

    Returns
    -------

    tree : HObject
           Search tree.

    relations : HObject
                Relations of components that are connected in the search
                tree.

    start_node : int
                 Component index of the start node of an arc in the search
                 tree.

    end_node : int
               Component index of the end node of an arc in the search
               tree.

    row : float
          Row coordinate of the center of the rectangle representing the
          relation.

    column : float
             Column index of the center of the rectangle representing the
             relation.

    phi : float
          Orientation of the rectangle representing the relation (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : float
               First radius (half length) of the rectangle representing
               the relation.
               Assertion: Length1 >= 0.0

    length_2 : float
               Second radius (half width) of the rectangle representing
               the relation.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    angle_start : float
                  Smallest relative orientation angle.

    angle_extent : float
                   Extent of the relative orientation angle.

    See Also
    --------
    train_model_components

    Predecessors
    ------------
    create_trained_component_model, create_component_model
    """
    with HalconOperator(998) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, root_component)
        proc.set_input_tuple(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # tree
            HObject(proc.get_output_object_key(2)),  # relations
            proc.get_output_tuple_s(0),  # start_node
            proc.get_output_tuple_s(1),  # end_node
            proc.get_output_tuple_s(2),  # row
            proc.get_output_tuple_s(3),  # column
            proc.get_output_tuple_s(4),  # phi
            proc.get_output_tuple_s(5),  # length_1
            proc.get_output_tuple_s(6),  # length_2
            proc.get_output_tuple_s(7),  # angle_start
            proc.get_output_tuple_s(8)   # angle_extent
        )  # type: ignore


def get_component_relations(
    component_training_id: HHandle,
    reference_component: int,
    image: Union[str, int]
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return the relations between the model components that are contained
    in a training result.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    reference_component : int
                          Index of reference component.
                          Assertion: ReferenceComponent >= 0

    image : Union[str, int]
            Image for which the component relations are to be returned.
            Value Suggestion: model_image

    Returns
    -------

    relations : HObject
                Region representation of the relations.

    row : Sequence[float]
          Row coordinate of the center of the rectangle representing the
          relation.

    column : Sequence[float]
             Column index of the center of the rectangle representing the
             relation.

    phi : Sequence[float]
          Orientation of the rectangle representing the relation (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : Sequence[float]
               First radius (half length) of the rectangle representing
               the relation.
               Assertion: Length1 >= 0.0

    length_2 : Sequence[float]
               Second radius (half width) of the rectangle representing
               the relation.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    angle_start : Sequence[float]
                  Smallest relative orientation angle.

    angle_extent : Sequence[float]
                   Extent of the relative orientation angles.

    See Also
    --------
    gen_rectangle2

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    train_model_components
    """
    with HalconOperator(1008) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, reference_component)
        proc.set_input_tuple(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # relations
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # phi
            proc.get_output_tuple_m(3),  # length_1
            proc.get_output_tuple_m(4),  # length_2
            proc.get_output_tuple_m(5),  # angle_start
            proc.get_output_tuple_m(6)   # angle_extent
        )  # type: ignore


def get_component_relations_s(
    component_training_id: HHandle,
    reference_component: int,
    image: Union[str, int]
) -> Tuple[HObject, float, float, float, float, float, float, float]:
    """
    Return the relations between the model components that are contained
    in a training result.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    reference_component : int
                          Index of reference component.
                          Assertion: ReferenceComponent >= 0

    image : Union[str, int]
            Image for which the component relations are to be returned.
            Value Suggestion: model_image

    Returns
    -------

    relations : HObject
                Region representation of the relations.

    row : float
          Row coordinate of the center of the rectangle representing the
          relation.

    column : float
             Column index of the center of the rectangle representing the
             relation.

    phi : float
          Orientation of the rectangle representing the relation (radians).
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : float
               First radius (half length) of the rectangle representing
               the relation.
               Assertion: Length1 >= 0.0

    length_2 : float
               Second radius (half width) of the rectangle representing
               the relation.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    angle_start : float
                  Smallest relative orientation angle.

    angle_extent : float
                   Extent of the relative orientation angles.

    See Also
    --------
    gen_rectangle2

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    train_model_components
    """
    with HalconOperator(1008) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, reference_component)
        proc.set_input_tuple(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # relations
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # length_1
            proc.get_output_tuple_s(4),  # length_2
            proc.get_output_tuple_s(5),  # angle_start
            proc.get_output_tuple_s(6)   # angle_extent
        )  # type: ignore


def get_comprise(window_handle: HHandle) -> str:
    """
    Get the output treatment of an image matrix.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : str
           Display mode for images.

    See Also
    --------
    set_comprise, disp_image, disp_color

    Successors
    ----------
    set_comprise, disp_image, disp_image

    Warnings
    --------
    get_comprise is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1251) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_s(0)
        return mode  # type: ignore


def get_compute_device_info(
    device_identifier: int,
    info_name: str
) -> Sequence[Union[str, int, float]]:
    """
    Get information on a compute device.

    Parameters
    ----------

    device_identifier : int
                        Compute device handle.

    info_name : str
                Name of Information to query.
                Value Suggestion: name

    Returns
    -------

    info : Sequence[Union[str, int, float]]
           Returned information.

    Predecessors
    ------------
    query_available_compute_devices

    Successors
    ----------
    activate_compute_device
    """
    with HalconOperator(305) as proc:
        proc.set_input_tuple(0, device_identifier)
        proc.set_input_tuple(1, info_name)
        proc.init_oct(0)
        proc.execute()
        info = proc.get_output_tuple_m(0)
        return info  # type: ignore


def get_compute_device_info_s(
    device_identifier: int,
    info_name: str
) -> Union[str, int, float]:
    """
    Get information on a compute device.

    Parameters
    ----------

    device_identifier : int
                        Compute device handle.

    info_name : str
                Name of Information to query.
                Value Suggestion: name

    Returns
    -------

    info : Union[str, int, float]
           Returned information.

    Predecessors
    ------------
    query_available_compute_devices

    Successors
    ----------
    activate_compute_device
    """
    with HalconOperator(305) as proc:
        proc.set_input_tuple(0, device_identifier)
        proc.set_input_tuple(1, info_name)
        proc.init_oct(0)
        proc.execute()
        info = proc.get_output_tuple_s(0)
        return info  # type: ignore


def get_compute_device_param(
    device_handle: HHandle,
    gen_param_name: str
) -> Sequence[Union[str, int, float]]:
    """
    Query compute device parameters.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    gen_param_name : str
                     Name of the parameter to query.
                     Value Suggestion: buffer_cache_capacity

    Returns
    -------

    gen_param_value : Sequence[Union[str, int, float]]
                      Value of the parameter.

    See Also
    --------
    set_compute_device_param, get_compute_device_info

    Predecessors
    ------------
    activate_compute_device
    """
    with HalconOperator(296) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_compute_device_param_s(
    device_handle: HHandle,
    gen_param_name: str
) -> Union[str, int, float]:
    """
    Query compute device parameters.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    gen_param_name : str
                     Name of the parameter to query.
                     Value Suggestion: buffer_cache_capacity

    Returns
    -------

    gen_param_value : Union[str, int, float]
                      Value of the parameter.

    See Also
    --------
    set_compute_device_param, get_compute_device_info

    Predecessors
    ------------
    activate_compute_device
    """
    with HalconOperator(296) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_contour_angle_xld(
    contour: HObject,
    angle_mode: str,
    calc_mode: str,
    lookaround: int
) -> Sequence[float]:
    """
    Calculate the direction of an XLD contour for each contour point.

    Parameters
    ----------

    contour : HObject
              Input contour.

    angle_mode : str
                 Return type of the angles.
                 Value Suggestion: abs

    calc_mode : str
                Method for computing the angles.
                Value Suggestion: range

    lookaround : int
                 Number of points to take into account.
                 Value Suggestion: 3
                 Assertion: Lookaround > 0

    Returns
    -------

    angles : Sequence[float]
             Direction of the tangent to the contour points.

    See Also
    --------
    get_contour_xld, get_contour_attrib_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix
    """
    with HalconOperator(62) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, angle_mode)
        proc.set_input_tuple(1, calc_mode)
        proc.set_input_tuple(2, lookaround)
        proc.init_oct(0)
        proc.execute()
        angles = proc.get_output_tuple_m(0)
        return angles  # type: ignore


def get_contour_attrib_xld(
    contour: HObject,
    name: str
) -> Sequence[float]:
    """
    Return point attribute values of an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input XLD contour.

    name : str
           Name of the attribute.
           Value Suggestion: angle

    Returns
    -------

    attrib : Sequence[float]
             Attribute values.

    See Also
    --------
    query_contour_attribs_xld, get_contour_global_attrib_xld,
    query_contour_global_attribs_xld

    Predecessors
    ------------
    lines_gauss, lines_facet, edges_sub_pix, distance_contours_xld,
    apply_distance_transform_xld
    """
    with HalconOperator(68) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, name)
        proc.init_oct(0)
        proc.execute()
        attrib = proc.get_output_tuple_m(0)
        return attrib  # type: ignore


def get_contour_global_attrib_xld(
    contour: HObject,
    name: MaybeSequence[str]
) -> Sequence[float]:
    """
    Return global attributes values of an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input XLD contour.

    name : MaybeSequence[str]
           Name of the attribute.
           Value Suggestion: regr_norm_row

    Returns
    -------

    attrib : Sequence[float]
             Attribute values.

    See Also
    --------
    query_contour_global_attribs_xld, get_contour_attrib_xld,
    query_contour_attribs_xld

    Predecessors
    ------------
    lines_gauss, lines_facet, edges_sub_pix, segment_contours_xld

    Successors
    ----------
    fit_circle_contour_xld, fit_ellipse_contour_xld, fit_line_contour_xld,
    fit_rectangle2_contour_xld
    """
    with HalconOperator(66) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, name)
        proc.init_oct(0)
        proc.execute()
        attrib = proc.get_output_tuple_m(0)
        return attrib  # type: ignore


def get_contour_style(window_handle: HHandle) -> str:
    """
    Get the current contour display fill style.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    style : str
            Current contour fill style.

    See Also
    --------
    set_contour_style, disp_xld

    Successors
    ----------
    set_contour_style, disp_xld
    """
    with HalconOperator(2177) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        style = proc.get_output_tuple_s(0)
        return style  # type: ignore


def get_contour_xld(
    contour: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Return the coordinates of an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input XLD contour.

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the contour's points.

    col : Sequence[float]
          Column coordinate of the contour's points.

    See Also
    --------
    get_contour_attrib_xld, query_contour_attribs_xld,
    get_contour_global_attrib_xld, query_contour_global_attribs_xld,
    gen_contour_polygon_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix
    """
    with HalconOperator(69) as proc:
        proc.set_input_object(1, contour)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # col
        )  # type: ignore


def get_current_dir() -> str:
    """
    Get the current working directory.

    Returns
    -------

    dir_name : str
               Name of current working directory.
    """
    with HalconOperator(1640) as proc:
        proc.init_oct(0)
        proc.execute()
        dir_name = proc.get_output_tuple_s(0)
        return dir_name  # type: ignore


def get_current_hthread_id() -> int:
    """
    Return the HALCON thread ID of the current thread.

    Returns
    -------

    hthread_id : int
                 ID representing the current thread.

    See Also
    --------
    interrupt_operator, set_operator_timeout

    Successors
    ----------
    interrupt_operator
    """
    with HalconOperator(2152) as proc:
        proc.init_oct(0)
        proc.execute()
        hthread_id = proc.get_output_tuple_s(0)
        return hthread_id  # type: ignore


def get_data_code_2d_objects(
    data_code_handle: HHandle,
    candidate_handle: Union[int, str],
    object_name: str
) -> HObject:
    """
    Access iconic objects that were created during the search for 2D data
    code symbols.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    candidate_handle : Union[int, str]
                       Handle of the 2D data code candidate. Either an
                       integer (usually the ResultHandle of
                       find_data_code_2d) or a string representing a group
                       of candidates.
                       Value Suggestion: all_candidates

    object_name : str
                  Name of the iconic object to return.
                  Value Suggestion: candidate_xld

    Returns
    -------

    data_code_objects : HObject
                        Objects that are created as intermediate results
                        during the detection or evaluation of 2D data
                        codes.

    See Also
    --------
    query_data_code_2d_params, get_data_code_2d_results,
    get_data_code_2d_param, set_data_code_2d_param

    Predecessors
    ------------
    find_data_code_2d, query_data_code_2d_params

    Successors
    ----------
    get_data_code_2d_results
    """
    with HalconOperator(1766) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, candidate_handle)
        proc.set_input_tuple(2, object_name)
        proc.execute()
        data_code_objects = HObject(proc.get_output_object_key(1))
        return data_code_objects  # type: ignore


def get_data_code_2d_param(
    data_code_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, str, float]]:
    """
    Get one or several parameters that describe the 2D data code model.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the 2D data code model.
                     Value Suggestion: polarity

    Returns
    -------

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters.

    See Also
    --------
    query_data_code_2d_params, set_data_code_2d_param,
    get_data_code_2d_results, get_data_code_2d_objects, find_data_code_2d

    Alternatives
    ------------
    write_data_code_2d_model

    Predecessors
    ------------
    query_data_code_2d_params, set_data_code_2d_param, find_data_code_2d

    Successors
    ----------
    find_data_code_2d, write_data_code_2d_model
    """
    with HalconOperator(1770) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_data_code_2d_param_s(
    data_code_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, str, float]:
    """
    Get one or several parameters that describe the 2D data code model.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the 2D data code model.
                     Value Suggestion: polarity

    Returns
    -------

    gen_param_value : Union[int, str, float]
                      Values of the generic parameters.

    See Also
    --------
    query_data_code_2d_params, set_data_code_2d_param,
    get_data_code_2d_results, get_data_code_2d_objects, find_data_code_2d

    Alternatives
    ------------
    write_data_code_2d_model

    Predecessors
    ------------
    query_data_code_2d_params, set_data_code_2d_param, find_data_code_2d

    Successors
    ----------
    find_data_code_2d, write_data_code_2d_model
    """
    with HalconOperator(1770) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_data_code_2d_results(
    data_code_handle: HHandle,
    candidate_handle: Union[int, str],
    result_names: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Get the alphanumerical results that were accumulated during the search
    for 2D data code symbols.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    candidate_handle : Union[int, str]
                       Handle of the 2D data code candidate. Either an
                       integer (usually the ResultHandle of
                       find_data_code_2d) or a string representing a group
                       of candidates.
                       Value Suggestion: all_candidates

    result_names : MaybeSequence[str]
                   Names of the results of the 2D data code to return.
                   Value Suggestion: status

    Returns
    -------

    result_values : Sequence[Union[int, float, str]]
                    List with the results.

    See Also
    --------
    query_data_code_2d_params, get_data_code_2d_objects,
    get_data_code_2d_param, set_data_code_2d_param

    Predecessors
    ------------
    find_data_code_2d, query_data_code_2d_params

    Successors
    ----------
    get_data_code_2d_objects
    """
    with HalconOperator(1767) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, candidate_handle)
        proc.set_input_tuple(2, result_names)
        proc.init_oct(0)
        proc.execute()
        result_values = proc.get_output_tuple_m(0)
        return result_values  # type: ignore


def get_data_code_2d_results_s(
    data_code_handle: HHandle,
    candidate_handle: Union[int, str],
    result_names: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Get the alphanumerical results that were accumulated during the search
    for 2D data code symbols.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    candidate_handle : Union[int, str]
                       Handle of the 2D data code candidate. Either an
                       integer (usually the ResultHandle of
                       find_data_code_2d) or a string representing a group
                       of candidates.
                       Value Suggestion: all_candidates

    result_names : MaybeSequence[str]
                   Names of the results of the 2D data code to return.
                   Value Suggestion: status

    Returns
    -------

    result_values : Union[int, float, str]
                    List with the results.

    See Also
    --------
    query_data_code_2d_params, get_data_code_2d_objects,
    get_data_code_2d_param, set_data_code_2d_param

    Predecessors
    ------------
    find_data_code_2d, query_data_code_2d_params

    Successors
    ----------
    get_data_code_2d_objects
    """
    with HalconOperator(1767) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, candidate_handle)
        proc.set_input_tuple(2, result_names)
        proc.init_oct(0)
        proc.execute()
        result_values = proc.get_output_tuple_s(0)
        return result_values  # type: ignore


def get_deep_ocr_param(
    deep_ocr_handle: HHandle,
    gen_param_name: str
) -> Sequence[HTupleElementType]:
    """
    Return the parameters of a Deep OCR model.

    Parameters
    ----------

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: recognition_model

    Returns
    -------

    gen_param_value : Sequence[HTupleElementType]
                      Value of the generic parameter.

    See Also
    --------
    set_deep_ocr_param

    Predecessors
    ------------
    create_deep_ocr, set_deep_ocr_param

    Successors
    ----------
    set_deep_ocr_param
    """
    with HalconOperator(2211) as proc:
        proc.set_input_tuple(0, deep_ocr_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_deep_ocr_param_s(
    deep_ocr_handle: HHandle,
    gen_param_name: str
) -> HTupleElementType:
    """
    Return the parameters of a Deep OCR model.

    Parameters
    ----------

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: recognition_model

    Returns
    -------

    gen_param_value : HTupleElementType
                      Value of the generic parameter.

    See Also
    --------
    set_deep_ocr_param

    Predecessors
    ------------
    create_deep_ocr, set_deep_ocr_param

    Successors
    ----------
    set_deep_ocr_param
    """
    with HalconOperator(2211) as proc:
        proc.set_input_tuple(0, deep_ocr_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_deformable_model_contours(
    model_id: HHandle,
    level: int
) -> HObject:
    """
    Return the contour representation of a deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    level : int
            Pyramid level for which the contour representation should be
            returned.
            Value Suggestion: 1
            Assertion: Level >= 1

    Returns
    -------

    model_contours : HObject
                     Contour representation of the deformable model.

    See Also
    --------
    set_deformable_model_param, find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_uncalib_deformable_model_xld, read_deformable_model,
    create_planar_calib_deformable_model,
    create_planar_calib_deformable_model_xld,
    create_local_deformable_model, create_local_deformable_model_xld
    """
    with HalconOperator(961) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, level)
        proc.execute()
        model_contours = HObject(proc.get_output_object_key(1))
        return model_contours  # type: ignore


def get_deformable_model_origin(model_id: HHandle) -> Tuple[float, float]:
    """
    Return the origin (reference point) of a deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    row : float
          Row coordinate of the origin of the deformable model.

    column : float
             Column coordinate of the origin of the deformable model.

    See Also
    --------
    area_center

    Predecessors
    ------------
    create_planar_uncalib_deformable_model, read_deformable_model,
    set_deformable_model_origin

    Successors
    ----------
    find_planar_uncalib_deformable_model
    """
    with HalconOperator(957) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def get_deformable_model_params(
    model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, str, float]]:
    """
    Return the parameters of a deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the deformable model.
                     Value Suggestion: angle_start

    Returns
    -------

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters.

    See Also
    --------
    set_deformable_model_param

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model
    """
    with HalconOperator(960) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_deformable_model_params_s(
    model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, str, float]:
    """
    Return the parameters of a deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the deformable model.
                     Value Suggestion: angle_start

    Returns
    -------

    gen_param_value : Union[int, str, float]
                      Values of the generic parameters.

    See Also
    --------
    set_deformable_model_param

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model
    """
    with HalconOperator(960) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_deformable_surface_matching_result(
    deformable_surface_matching_result: HHandle,
    result_name: MaybeSequence[str],
    result_index: MaybeSequence[Union[int, str]]
) -> Sequence[HTupleElementType]:
    """
    Get details of a result from deformable surface based matching.

    Parameters
    ----------

    deformable_surface_matching_result : HHandle
                                         Handle of the deformable surface
                                         matching result.

    result_name : MaybeSequence[str]
                  Name of the result property.
                  Value Suggestion: sampled_scene

    result_index : MaybeSequence[Union[int, str]]
                   Index of the result property.
                   Value Suggestion: 0
                   Assertion: ResultIndex >= 0

    Returns
    -------

    result_value : Sequence[HTupleElementType]
                   Value of the result property.

    See Also
    --------
    find_deformable_surface_model, refine_deformable_surface_model,
    read_deformable_surface_model, write_deformable_surface_model,
    clear_deformable_surface_model

    Predecessors
    ------------
    find_deformable_surface_model, refine_deformable_surface_model

    Successors
    ----------
    clear_deformable_surface_model
    """
    with HalconOperator(1019) as proc:
        proc.set_input_tuple(0, deformable_surface_matching_result)
        proc.set_input_tuple(1, result_name)
        proc.set_input_tuple(2, result_index)
        proc.init_oct(0)
        proc.execute()
        result_value = proc.get_output_tuple_m(0)
        return result_value  # type: ignore


def get_deformable_surface_matching_result_s(
    deformable_surface_matching_result: HHandle,
    result_name: MaybeSequence[str],
    result_index: MaybeSequence[Union[int, str]]
) -> HTupleElementType:
    """
    Get details of a result from deformable surface based matching.

    Parameters
    ----------

    deformable_surface_matching_result : HHandle
                                         Handle of the deformable surface
                                         matching result.

    result_name : MaybeSequence[str]
                  Name of the result property.
                  Value Suggestion: sampled_scene

    result_index : MaybeSequence[Union[int, str]]
                   Index of the result property.
                   Value Suggestion: 0
                   Assertion: ResultIndex >= 0

    Returns
    -------

    result_value : HTupleElementType
                   Value of the result property.

    See Also
    --------
    find_deformable_surface_model, refine_deformable_surface_model,
    read_deformable_surface_model, write_deformable_surface_model,
    clear_deformable_surface_model

    Predecessors
    ------------
    find_deformable_surface_model, refine_deformable_surface_model

    Successors
    ----------
    clear_deformable_surface_model
    """
    with HalconOperator(1019) as proc:
        proc.set_input_tuple(0, deformable_surface_matching_result)
        proc.set_input_tuple(1, result_name)
        proc.set_input_tuple(2, result_index)
        proc.init_oct(0)
        proc.execute()
        result_value = proc.get_output_tuple_s(0)
        return result_value  # type: ignore


def get_deformable_surface_model_param(
    deformable_surface_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[str, float, int]]:
    """
    Return the parameters and properties of a deformable surface model.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    gen_param_name : MaybeSequence[str]
                     Name of the parameter.
                     Value Suggestion: sampled_model

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the parameter.

    See Also
    --------
    create_deformable_surface_model

    Predecessors
    ------------
    create_deformable_surface_model, read_deformable_surface_model,
    add_deformable_surface_model_reference_point

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    write_deformable_surface_model
    """
    with HalconOperator(1028) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_deformable_surface_model_param_s(
    deformable_surface_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[str, float, int]:
    """
    Return the parameters and properties of a deformable surface model.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    gen_param_name : MaybeSequence[str]
                     Name of the parameter.
                     Value Suggestion: sampled_model

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Value of the parameter.

    See Also
    --------
    create_deformable_surface_model

    Predecessors
    ------------
    create_deformable_surface_model, read_deformable_surface_model,
    add_deformable_surface_model_reference_point

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    write_deformable_surface_model
    """
    with HalconOperator(1028) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_descriptor_model_origin(
    model_id: HHandle
) -> Tuple[Union[float, int], Union[float, int]]:
    """
    Return the origin of a descriptor model.

    Parameters
    ----------

    model_id : HHandle
               Handle of a descriptor model.

    Returns
    -------

    row : Union[float, int]
          Position of origin in row direction.

    column : Union[float, int]
             Position of origin in column direction.

    See Also
    --------
    set_descriptor_model_origin, create_uncalib_descriptor_model

    Predecessors
    ------------
    create_uncalib_descriptor_model, read_descriptor_model
    """
    with HalconOperator(955) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def get_descriptor_model_params(
    model_id: HHandle
) -> Tuple[str, Sequence[str], Sequence[Union[int, float, str]], Sequence[str], Sequence[Union[int, float, str]]]:
    """
    Return the parameters of a descriptor model.

    Parameters
    ----------

    model_id : HHandle
               The object handle to the descriptor model.

    Returns
    -------

    detector_type : str
                    The type of the detector.

    detector_param_name : Sequence[str]
                          The detectors parameter names.

    detector_param_value : Sequence[Union[int, float, str]]
                           Values of the detectors parameters.

    descriptor_param_name : Sequence[str]
                            The descriptors parameter names.

    descriptor_param_value : Sequence[Union[int, float, str]]
                             Values of the descriptors parameters.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model

    Predecessors
    ------------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    read_descriptor_model
    """
    with HalconOperator(951) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # detector_type
            proc.get_output_tuple_m(1),  # detector_param_name
            proc.get_output_tuple_m(2),  # detector_param_value
            proc.get_output_tuple_m(3),  # descriptor_param_name
            proc.get_output_tuple_m(4)   # descriptor_param_value
        )  # type: ignore


def get_descriptor_model_points(
    model_id: HHandle,
    set: str,
    subset: Union[int, str]
) -> Tuple[Sequence[Union[float, int]], Sequence[Union[float, int]]]:
    """
    Query the interest points of the descriptor model or the last
    processed search image.

    Parameters
    ----------

    model_id : HHandle
               The handle to the descriptor model.

    set : str
          Set of interest points.
          Value Suggestion: model

    subset : Union[int, str]
             Subset of interest points.
             Value Suggestion: all

    Returns
    -------

    row : Sequence[Union[float, int]]
          Row coordinates of interest points.

    column : Sequence[Union[float, int]]
             Column coordinates of interest points.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model

    Predecessors
    ------------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    find_uncalib_descriptor_model, find_calib_descriptor_model,
    read_descriptor_model
    """
    with HalconOperator(950) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, set)
        proc.set_input_tuple(2, subset)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def get_descriptor_model_results(
    model_id: HHandle,
    object_id: Union[int, str],
    result_names: str
) -> Sequence[Union[int, float, str]]:
    """
    Query alphanumerical results that were accumulated during
    descriptor-based matching.

    Parameters
    ----------

    model_id : HHandle
               Handle of a descriptor model.

    object_id : Union[int, str]
                Handle of the object for which the results are queried.
                Value Suggestion: all

    result_names : str
                   Name of the results to be queried.
                   Value Suggestion: num_points

    Returns
    -------

    results : Sequence[Union[int, float, str]]
              Returned results.

    See Also
    --------
    get_descriptor_model_origin, get_descriptor_model_params,
    get_descriptor_model_points

    Predecessors
    ------------
    find_uncalib_descriptor_model, find_calib_descriptor_model
    """
    with HalconOperator(954) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, object_id)
        proc.set_input_tuple(2, result_names)
        proc.init_oct(0)
        proc.execute()
        results = proc.get_output_tuple_m(0)
        return results  # type: ignore


def get_descriptor_model_results_s(
    model_id: HHandle,
    object_id: Union[int, str],
    result_names: str
) -> Union[int, float, str]:
    """
    Query alphanumerical results that were accumulated during
    descriptor-based matching.

    Parameters
    ----------

    model_id : HHandle
               Handle of a descriptor model.

    object_id : Union[int, str]
                Handle of the object for which the results are queried.
                Value Suggestion: all

    result_names : str
                   Name of the results to be queried.
                   Value Suggestion: num_points

    Returns
    -------

    results : Union[int, float, str]
              Returned results.

    See Also
    --------
    get_descriptor_model_origin, get_descriptor_model_params,
    get_descriptor_model_points

    Predecessors
    ------------
    find_uncalib_descriptor_model, find_calib_descriptor_model
    """
    with HalconOperator(954) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, object_id)
        proc.set_input_tuple(2, result_names)
        proc.init_oct(0)
        proc.execute()
        results = proc.get_output_tuple_s(0)
        return results  # type: ignore


def get_diagonal_matrix(matrix_id: HHandle, diagonal: int) -> HHandle:
    """
    Get the diagonal elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    diagonal : int
               Number of the desired diagonal.
               Value Suggestion: 0

    Returns
    -------

    vector_id : HHandle
                Matrix handle containing the diagonal elements.

    See Also
    --------
    set_diagonal_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(888) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, diagonal)
        proc.init_oct(0)
        proc.execute()
        vector_id = proc.get_output_tuple_s(0)
        return vector_id  # type: ignore


def get_dict_object(
    dict_handle: HHandle,
    key: Union[str, int]
) -> HObject:
    """
    Retrieve an object associated with the key from the dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    key : Union[str, int]
          Key string.
          Assertion: length(Key) > 0

    Returns
    -------

    object : HObject
             Object value retrieved from the dictionary.

    See Also
    --------
    create_dict, set_dict_tuple, get_dict_tuple, set_dict_object,
    remove_dict_key, get_dict_param

    Alternatives
    ------------
    get_dict_tuple

    Predecessors
    ------------
    set_dict_object
    """
    with HalconOperator(2153) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, key)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def get_dict_param(
    dict_handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[Union[str, int]]
) -> Sequence[Union[int, float, str]]:
    """
    Query dictionary parameters or information about a dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    gen_param_name : str
                     Names of the dictionary parameters or info queries.
                     Value Suggestion: keys

    key : MaybeSequence[Union[str, int]]
          Dictionary keys the parameter/query should be applied to (empty
          for GenParamName = 'keys').

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the dictionary parameters or info queries.

    See Also
    --------
    create_dict, set_dict_tuple, get_dict_tuple, set_dict_object,
    get_dict_object, remove_dict_key

    Predecessors
    ------------
    create_dict
    """
    with HalconOperator(2154) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_dict_param_s(
    dict_handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[Union[str, int]]
) -> Union[int, float, str]:
    """
    Query dictionary parameters or information about a dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    gen_param_name : str
                     Names of the dictionary parameters or info queries.
                     Value Suggestion: keys

    key : MaybeSequence[Union[str, int]]
          Dictionary keys the parameter/query should be applied to (empty
          for GenParamName = 'keys').

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Values of the dictionary parameters or info queries.

    See Also
    --------
    create_dict, set_dict_tuple, get_dict_tuple, set_dict_object,
    get_dict_object, remove_dict_key

    Predecessors
    ------------
    create_dict
    """
    with HalconOperator(2154) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_dict_tuple(
    dict_handle: HHandle,
    key: Union[str, int]
) -> Sequence[Union[int, float, str]]:
    """
    Retrieve a tuple associated with the key from the dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    key : Union[str, int]
          Key string.
          Assertion: length(Key) > 0

    Returns
    -------

    tuple : Sequence[Union[int, float, str]]
            Tuple value retrieved from the dictionary.

    See Also
    --------
    create_dict, set_dict_tuple, set_dict_object, get_dict_object,
    remove_dict_key, get_dict_param

    Alternatives
    ------------
    get_dict_object

    Predecessors
    ------------
    set_dict_tuple
    """
    with HalconOperator(2155) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, key)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_m(0)
        return tuple  # type: ignore


def get_dict_tuple_s(
    dict_handle: HHandle,
    key: Union[str, int]
) -> Union[int, float, str]:
    """
    Retrieve a tuple associated with the key from the dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    key : Union[str, int]
          Key string.
          Assertion: length(Key) > 0

    Returns
    -------

    tuple : Union[int, float, str]
            Tuple value retrieved from the dictionary.

    See Also
    --------
    create_dict, set_dict_tuple, set_dict_object, get_dict_object,
    remove_dict_key, get_dict_param

    Alternatives
    ------------
    get_dict_object

    Predecessors
    ------------
    set_dict_tuple
    """
    with HalconOperator(2155) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, key)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_s(0)
        return tuple  # type: ignore


def get_disp_object_model_3d_info(
    window_handle: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    information: MaybeSequence[str]
) -> Sequence[Union[int, float]]:
    """
    Get the depth or the index of a displayed 3D object model.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : MaybeSequence[Union[float, int]]
          Row coordinates.

    column : MaybeSequence[Union[float, int]]
             Column coordinates.

    information : MaybeSequence[str]
                  Information.
                  Value Suggestion: depth

    Returns
    -------

    value : Sequence[Union[int, float]]
            Indices or the depth of the objects at (Row,Column).

    See Also
    --------
    disp_object_model_3d

    Predecessors
    ------------
    disp_object_model_3d, get_mbutton, get_mbutton_sub_pix, get_mposition,
    get_mposition_sub_pix
    """
    with HalconOperator(1087) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, information)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def get_disp_object_model_3d_info_s(
    window_handle: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    information: MaybeSequence[str]
) -> Union[int, float]:
    """
    Get the depth or the index of a displayed 3D object model.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : MaybeSequence[Union[float, int]]
          Row coordinates.

    column : MaybeSequence[Union[float, int]]
             Column coordinates.

    information : MaybeSequence[str]
                  Information.
                  Value Suggestion: depth

    Returns
    -------

    value : Union[int, float]
            Indices or the depth of the objects at (Row,Column).

    See Also
    --------
    disp_object_model_3d

    Predecessors
    ------------
    disp_object_model_3d, get_mbutton, get_mbutton_sub_pix, get_mposition,
    get_mposition_sub_pix
    """
    with HalconOperator(1087) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, information)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_display_scene_3d_info(
    window_handle: HHandle,
    scene_3d: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    information: MaybeSequence[str]
) -> Sequence[Union[int, float]]:
    """
    Get the depth or the index of instances in a displayed 3D scene.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    scene_3d : HHandle
               Handle of the 3D scene.

    row : MaybeSequence[Union[float, int]]
          Row coordinates.

    column : MaybeSequence[Union[float, int]]
             Column coordinates.

    information : MaybeSequence[str]
                  Information.
                  Value Suggestion: depth

    Returns
    -------

    value : Sequence[Union[int, float]]
            Indices or the depth of the objects at (Row,Column).

    See Also
    --------
    display_scene_3d

    Predecessors
    ------------
    display_scene_3d, get_mbutton, get_mbutton_sub_pix, get_mposition,
    get_mposition_sub_pix
    """
    with HalconOperator(1204) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, scene_3d)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, information)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def get_display_scene_3d_info_s(
    window_handle: HHandle,
    scene_3d: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    information: MaybeSequence[str]
) -> Union[int, float]:
    """
    Get the depth or the index of instances in a displayed 3D scene.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    scene_3d : HHandle
               Handle of the 3D scene.

    row : MaybeSequence[Union[float, int]]
          Row coordinates.

    column : MaybeSequence[Union[float, int]]
             Column coordinates.

    information : MaybeSequence[str]
                  Information.
                  Value Suggestion: depth

    Returns
    -------

    value : Union[int, float]
            Indices or the depth of the objects at (Row,Column).

    See Also
    --------
    display_scene_3d

    Predecessors
    ------------
    display_scene_3d, get_mbutton, get_mbutton_sub_pix, get_mposition,
    get_mposition_sub_pix
    """
    with HalconOperator(1204) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, scene_3d)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, information)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_distance_transform_xld_contour(
    distance_transform_id: HHandle
) -> HObject:
    """
    Get the reference contour used to build the XLD distance transform.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    Returns
    -------

    contour : HObject
              Reference contour.

    See Also
    --------
    get_distance_transform_xld_param, set_distance_transform_xld_param,
    create_distance_transform_xld, apply_distance_transform_xld,
    clear_distance_transform_xld, write_distance_transform_xld,
    serialize_distance_transform_xld

    Predecessors
    ------------
    read_distance_transform_xld, deserialize_distance_transform_xld
    """
    with HalconOperator(1359) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.execute()
        contour = HObject(proc.get_output_object_key(1))
        return contour  # type: ignore


def get_distance_transform_xld_param(
    distance_transform_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[float, str]]:
    """
    Get the parameters used to build an XLD distance transform.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: mode

    Returns
    -------

    gen_param_value : Sequence[Union[float, str]]
                      Values of the generic parameters.

    See Also
    --------
    get_distance_transform_xld_contour, create_distance_transform_xld,
    apply_distance_transform_xld, clear_distance_transform_xld,
    write_distance_transform_xld, serialize_distance_transform_xld

    Predecessors
    ------------
    read_distance_transform_xld, deserialize_distance_transform_xld

    Successors
    ----------
    set_distance_transform_xld_param
    """
    with HalconOperator(1358) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_distance_transform_xld_param_s(
    distance_transform_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[float, str]:
    """
    Get the parameters used to build an XLD distance transform.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: mode

    Returns
    -------

    gen_param_value : Union[float, str]
                      Values of the generic parameters.

    See Also
    --------
    get_distance_transform_xld_contour, create_distance_transform_xld,
    apply_distance_transform_xld, clear_distance_transform_xld,
    write_distance_transform_xld, serialize_distance_transform_xld

    Predecessors
    ------------
    read_distance_transform_xld, deserialize_distance_transform_xld

    Successors
    ----------
    set_distance_transform_xld_param
    """
    with HalconOperator(1358) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_dl_classifier_param(
    dlclassifier_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[str, float, int]]:
    """
    Return the parameters of a deep-learning-based classifier.

    Parameters
    ----------

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: gpu

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the generic parameter.

    See Also
    --------
    set_dl_classifier_param

    Alternatives
    ------------
    get_dl_model_param

    Predecessors
    ------------
    read_dl_classifier, set_dl_classifier_param

    Successors
    ----------
    train_dl_classifier_batch, apply_dl_classifier

    Warnings
    --------
    get_dl_classifier_param is obsolete and is only provided for reasons
    of backward compatibility. New applications should use common
    CNN-based operator get_dl_model_param instead.
    """
    with HalconOperator(2114) as proc:
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_dl_classifier_param_s(
    dlclassifier_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[str, float, int]:
    """
    Return the parameters of a deep-learning-based classifier.

    Parameters
    ----------

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: gpu

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Value of the generic parameter.

    See Also
    --------
    set_dl_classifier_param

    Alternatives
    ------------
    get_dl_model_param

    Predecessors
    ------------
    read_dl_classifier, set_dl_classifier_param

    Successors
    ----------
    train_dl_classifier_batch, apply_dl_classifier

    Warnings
    --------
    get_dl_classifier_param is obsolete and is only provided for reasons
    of backward compatibility. New applications should use common
    CNN-based operator get_dl_model_param instead.
    """
    with HalconOperator(2114) as proc:
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_dl_classifier_result(
    dlclassifier_result_handle: HHandle,
    index: Union[int, str],
    gen_result_name: MaybeSequence[str]
) -> Sequence[Union[str, float, int]]:
    """
    Retrieve classification results inferred by a deep-learning-based
    classifier.

    Parameters
    ----------

    dlclassifier_result_handle : HHandle
                                 Handle of the deep learning
                                 classification  results.

    index : Union[int, str]
            Index of the image in the batch.
            Value Suggestion: 'all'

    gen_result_name : MaybeSequence[str]
                      Name of the generic parameter.
                      Value Suggestion: predicted_classes

    Returns
    -------

    gen_result_value : Sequence[Union[str, float, int]]
                       Value of the generic parameter, either the
                       confidence  values, the class names or class
                       indices.

    Predecessors
    ------------
    apply_dl_classifier

    Successors
    ----------
    clear_dl_classifier_result

    Warnings
    --------
    get_dl_classifier_result is obsolete and is only provided for reasons
    of backward compatibility.
    """
    with HalconOperator(2115) as proc:
        proc.set_input_tuple(0, dlclassifier_result_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, gen_result_name)
        proc.init_oct(0)
        proc.execute()
        gen_result_value = proc.get_output_tuple_m(0)
        return gen_result_value  # type: ignore


def get_dl_classifier_result_s(
    dlclassifier_result_handle: HHandle,
    index: Union[int, str],
    gen_result_name: MaybeSequence[str]
) -> Union[str, float, int]:
    """
    Retrieve classification results inferred by a deep-learning-based
    classifier.

    Parameters
    ----------

    dlclassifier_result_handle : HHandle
                                 Handle of the deep learning
                                 classification  results.

    index : Union[int, str]
            Index of the image in the batch.
            Value Suggestion: 'all'

    gen_result_name : MaybeSequence[str]
                      Name of the generic parameter.
                      Value Suggestion: predicted_classes

    Returns
    -------

    gen_result_value : Union[str, float, int]
                       Value of the generic parameter, either the
                       confidence  values, the class names or class
                       indices.

    Predecessors
    ------------
    apply_dl_classifier

    Successors
    ----------
    clear_dl_classifier_result

    Warnings
    --------
    get_dl_classifier_result is obsolete and is only provided for reasons
    of backward compatibility.
    """
    with HalconOperator(2115) as proc:
        proc.set_input_tuple(0, dlclassifier_result_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, gen_result_name)
        proc.init_oct(0)
        proc.execute()
        gen_result_value = proc.get_output_tuple_s(0)
        return gen_result_value  # type: ignore


def get_dl_classifier_train_result(
    dlclassifier_train_result_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Return the results for the single training step of a
    deep-learning-based  classifier.

    Parameters
    ----------

    dlclassifier_train_result_handle : HHandle
                                       Handle of the training results from
                                       the  deep-learning-based classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: loss

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Value of the generic parameter.

    Predecessors
    ------------
    train_dl_classifier_batch

    Successors
    ----------
    clear_dl_classifier_train_result

    Warnings
    --------
    get_dl_classifier_train_result is obsolete and is only provided for
    reasons of backward compatibility.
    """
    with HalconOperator(2116) as proc:
        proc.set_input_tuple(0, dlclassifier_train_result_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_dl_classifier_train_result_s(
    dlclassifier_train_result_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Return the results for the single training step of a
    deep-learning-based  classifier.

    Parameters
    ----------

    dlclassifier_train_result_handle : HHandle
                                       Handle of the training results from
                                       the  deep-learning-based classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: loss

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Value of the generic parameter.

    Predecessors
    ------------
    train_dl_classifier_batch

    Successors
    ----------
    clear_dl_classifier_train_result

    Warnings
    --------
    get_dl_classifier_train_result is obsolete and is only provided for
    reasons of backward compatibility.
    """
    with HalconOperator(2116) as proc:
        proc.set_input_tuple(0, dlclassifier_train_result_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_dl_device_param(
    dldevice_handle: HHandle,
    gen_param_name: str
) -> Sequence[Union[str, float, int]]:
    """
    Return the parameters of a deep-learning-capable hardware device.

    Parameters
    ----------

    dldevice_handle : HHandle
                      Handle of the deep-learning-capable hardware device.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: type

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the generic parameter.

    Predecessors
    ------------
    query_available_dl_devices

    Successors
    ----------
    set_dl_model_param
    """
    with HalconOperator(2212) as proc:
        proc.set_input_tuple(0, dldevice_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_dl_device_param_s(
    dldevice_handle: HHandle,
    gen_param_name: str
) -> Union[str, float, int]:
    """
    Return the parameters of a deep-learning-capable hardware device.

    Parameters
    ----------

    dldevice_handle : HHandle
                      Handle of the deep-learning-capable hardware device.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: type

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Value of the generic parameter.

    Predecessors
    ------------
    query_available_dl_devices

    Successors
    ----------
    set_dl_model_param
    """
    with HalconOperator(2212) as proc:
        proc.set_input_tuple(0, dldevice_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_dl_model_param(
    dlmodel_handle: HHandle,
    gen_param_name: str
) -> Sequence[Union[str, float, int]]:
    """
    Return the parameters of a deep learning model.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: batch_size

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the generic parameter.

    See Also
    --------
    set_dl_model_param

    Predecessors
    ------------
    read_dl_model, set_dl_model_param

    Successors
    ----------
    set_dl_model_param, apply_dl_model, train_dl_model_batch,
    train_dl_model_anomaly_dataset
    """
    with HalconOperator(2156) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_dl_model_param_s(
    dlmodel_handle: HHandle,
    gen_param_name: str
) -> Union[str, float, int]:
    """
    Return the parameters of a deep learning model.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: batch_size

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Value of the generic parameter.

    See Also
    --------
    set_dl_model_param

    Predecessors
    ------------
    read_dl_model, set_dl_model_param

    Successors
    ----------
    set_dl_model_param, apply_dl_model, train_dl_model_batch,
    train_dl_model_anomaly_dataset
    """
    with HalconOperator(2156) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_dl_pruning_param(
    dlpruning_handle: HHandle,
    gen_param_name: str
) -> Sequence[Union[str, float, int]]:
    """
    Get information from a pruning data handle.

    Parameters
    ----------

    dlpruning_handle : HHandle
                       Pruning data handle.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: percentage

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the generic parameter.

    See Also
    --------
    set_dl_pruning_param

    Predecessors
    ------------
    create_dl_pruning, set_dl_pruning_param
    """
    with HalconOperator(2213) as proc:
        proc.set_input_tuple(0, dlpruning_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_dl_pruning_param_s(
    dlpruning_handle: HHandle,
    gen_param_name: str
) -> Union[str, float, int]:
    """
    Get information from a pruning data handle.

    Parameters
    ----------

    dlpruning_handle : HHandle
                       Pruning data handle.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: percentage

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Value of the generic parameter.

    See Also
    --------
    set_dl_pruning_param

    Predecessors
    ------------
    create_dl_pruning, set_dl_pruning_param
    """
    with HalconOperator(2213) as proc:
        proc.set_input_tuple(0, dlpruning_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_domain(image: HObject) -> HObject:
    """
    Get the domain of an image.

    Parameters
    ----------

    image : HObject
            Input images.

    Returns
    -------

    domain : HObject
             Definition domains of input images.

    See Also
    --------
    change_domain, reduce_domain, full_domain

    Successors
    ----------
    change_domain, reduce_domain, full_domain
    """
    with HalconOperator(1148) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        domain = HObject(proc.get_output_object_key(1))
        return domain  # type: ignore


def get_draw(window_handle: HHandle) -> str:
    """
    Get the current region fill mode.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : str
           Current region fill mode.

    See Also
    --------
    set_draw, disp_region, set_paint

    Successors
    ----------
    set_draw, disp_region
    """
    with HalconOperator(1250) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_s(0)
        return mode  # type: ignore


def get_drawing_object_iconic(draw_id: HHandle) -> HObject:
    """
    Return the iconic object of a drawing object.

    Parameters
    ----------

    draw_id : HHandle
              Handle of the drawing object.

    Returns
    -------

    object : HObject
             Copy of the iconic object represented by the drawing object.

    See Also
    --------
    get_drawing_object_params, attach_drawing_object_to_window

    Alternatives
    ------------
    get_drawing_object_params

    Predecessors
    ------------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle,
    create_drawing_object_line, create_drawing_object_ellipse_sector,
    create_drawing_object_circle_sector, create_drawing_object_xld

    Successors
    ----------
    reduce_domain, gen_region_contour_xld, attach_drawing_object_to_window
    """
    with HalconOperator(1302) as proc:
        proc.set_input_tuple(0, draw_id)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def get_drawing_object_params(
    draw_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[float, int, str]]:
    """
    Get the parameters of a drawing object.

    Parameters
    ----------

    draw_id : HHandle
              Handle of the drawing object.

    gen_param_name : MaybeSequence[str]
                     Parameter names of the drawing object.

    Returns
    -------

    gen_param_value : Sequence[Union[float, int, str]]
                      Parameter values.

    See Also
    --------
    attach_drawing_object_to_window, get_drawing_object_iconic,
    set_drawing_object_params

    Alternatives
    ------------
    get_drawing_object_iconic

    Predecessors
    ------------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle,
    create_drawing_object_line, create_drawing_object_ellipse_sector,
    create_drawing_object_circle_sector, create_drawing_object_xld,
    create_drawing_object_text, attach_drawing_object_to_window

    Successors
    ----------
    set_drawing_object_params, attach_drawing_object_to_window,
    get_drawing_object_iconic
    """
    with HalconOperator(1305) as proc:
        proc.set_input_tuple(0, draw_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_drawing_object_params_s(
    draw_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[float, int, str]:
    """
    Get the parameters of a drawing object.

    Parameters
    ----------

    draw_id : HHandle
              Handle of the drawing object.

    gen_param_name : MaybeSequence[str]
                     Parameter names of the drawing object.

    Returns
    -------

    gen_param_value : Union[float, int, str]
                      Parameter values.

    See Also
    --------
    attach_drawing_object_to_window, get_drawing_object_iconic,
    set_drawing_object_params

    Alternatives
    ------------
    get_drawing_object_iconic

    Predecessors
    ------------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle,
    create_drawing_object_line, create_drawing_object_ellipse_sector,
    create_drawing_object_circle_sector, create_drawing_object_xld,
    create_drawing_object_text, attach_drawing_object_to_window

    Successors
    ----------
    set_drawing_object_params, attach_drawing_object_to_window,
    get_drawing_object_iconic
    """
    with HalconOperator(1305) as proc:
        proc.set_input_tuple(0, draw_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_error_text(error_code: int) -> str:
    """
    Inquiry after the error text of a HALCON error number.

    Parameters
    ----------

    error_code : int
                 HALCON error code.
                 Assertion: 1 <= ErrorCode && ErrorCode <= 36000

    Returns
    -------

    error_message : str
                    Corresponding error message.

    See Also
    --------
    set_check

    Predecessors
    ------------
    set_check

    Notes
    -----
    Unknown error codes will trigger a standard message.
    """
    with HalconOperator(322) as proc:
        proc.set_input_tuple(0, error_code)
        proc.init_oct(0)
        proc.execute()
        error_message = proc.get_output_tuple_s(0)
        return error_message  # type: ignore


def get_extended_error_info() -> Tuple[str, int, str]:
    """
    Returns the extended error information for the calling thread's last
    HALCON error.

    Returns
    -------

    operator_name : str
                    Operator that set the error code.

    error_code : int
                 Extended error code.

    error_message : str
                    Extended error message.

    See Also
    --------
    get_error_text
    """
    with HalconOperator(344) as proc:
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # operator_name
            proc.get_output_tuple_s(1),  # error_code
            proc.get_output_tuple_s(2)   # error_message
        )  # type: ignore


def get_features_ocr_class_knn(
    character: HObject,
    ocrhandle: HHandle,
    transform: str
) -> Sequence[float]:
    """
    Compute the features of a character.

    Parameters
    ----------

    character : HObject
                Input character.

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    transform : str
                Should the feature vector be transformed with the
                preprocessing?
                Value Suggestion: true

    Returns
    -------

    features : Sequence[float]
               Feature vector of the character.

    See Also
    --------
    create_ocr_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn
    """
    with HalconOperator(656) as proc:
        proc.set_input_object(1, character)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, transform)
        proc.init_oct(0)
        proc.execute()
        features = proc.get_output_tuple_m(0)
        return features  # type: ignore


def get_features_ocr_class_mlp(
    character: HObject,
    ocrhandle: HHandle,
    transform: str
) -> Sequence[float]:
    """
    Compute the features of a character.

    Parameters
    ----------

    character : HObject
                Input character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    transform : str
                Should the feature vector be transformed with the
                preprocessing?
                Value Suggestion: true

    Returns
    -------

    features : Sequence[float]
               Feature vector of the character.

    See Also
    --------
    create_ocr_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp
    """
    with HalconOperator(696) as proc:
        proc.set_input_object(1, character)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, transform)
        proc.init_oct(0)
        proc.execute()
        features = proc.get_output_tuple_m(0)
        return features  # type: ignore


def get_features_ocr_class_svm(
    character: HObject,
    ocrhandle: HHandle,
    transform: str
) -> Sequence[float]:
    """
    Compute the features of a character.

    Parameters
    ----------

    character : HObject
                Input character.

    ocrhandle : HHandle
                Handle of the OCR classifier.

    transform : str
                Should the feature vector be transformed with the
                preprocessing?
                Value Suggestion: true

    Returns
    -------

    features : Sequence[float]
               Feature vector of the character.

    See Also
    --------
    create_ocr_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm
    """
    with HalconOperator(678) as proc:
        proc.set_input_object(1, character)
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, transform)
        proc.init_oct(0)
        proc.execute()
        features = proc.get_output_tuple_m(0)
        return features  # type: ignore


def get_fix(window_handle: HHandle) -> str:
    """
    Get mode of fixing of current look-up-table (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : str
           Current Mode of fixing.

    See Also
    --------
    set_fix

    Successors
    ----------
    set_fix, set_pixel, set_rgb

    Warnings
    --------
    get_fix is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1291) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_s(0)
        return mode  # type: ignore


def get_fixed_lut(window_handle: HHandle) -> str:
    """
    Get fixing of "`look-up-table"' (lut) for "`real color images"'

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : str
           Mode of fixing.

    Successors
    ----------
    set_fixed_lut

    Warnings
    --------
    get_fixed_lut is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1293) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_s(0)
        return mode  # type: ignore


def get_font(window_handle: HHandle) -> str:
    """
    Get the current font.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    font : str
           Name of the current font.

    See Also
    --------
    set_font, query_font, open_window, set_system

    Predecessors
    ------------
    open_window, query_font

    Successors
    ----------
    set_font
    """
    with HalconOperator(1203) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        font = proc.get_output_tuple_s(0)
        return font  # type: ignore


def get_font_extents(
    window_handle: HHandle
) -> Tuple[Union[int, float], Union[int, float], Union[int, float], Union[int, float]]:
    """
    Get the maximum size of all characters of a font.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    max_ascent : Union[int, float]
                 Maximum height above baseline.

    max_descent : Union[int, float]
                  Maximum extension below baseline.

    max_width : Union[int, float]
                Maximum character width.

    max_height : Union[int, float]
                 Maximum character height.

    See Also
    --------
    get_string_extents, set_tposition, set_font

    Predecessors
    ------------
    open_window, set_font

    Successors
    ----------
    set_tposition, write_string, read_string, read_char
    """
    with HalconOperator(1198) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # max_ascent
            proc.get_output_tuple_s(1),  # max_descent
            proc.get_output_tuple_s(2),  # max_width
            proc.get_output_tuple_s(3)   # max_height
        )  # type: ignore


def get_found_component_model(
    component_model_id: HHandle,
    model_start: MaybeSequence[int],
    model_end: MaybeSequence[int],
    row_comp: MaybeSequence[float],
    column_comp: MaybeSequence[float],
    angle_comp: MaybeSequence[float],
    score_comp: MaybeSequence[float],
    model_comp: MaybeSequence[int],
    model_match: int,
    mark_orientation: str
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return the components of a found instance of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    model_start : MaybeSequence[int]
                  Start index of each found instance of the component
                  model in the tuples describing the component matches.

    model_end : MaybeSequence[int]
                End index of each found instance of the component model to
                the tuples describing the component matches.

    row_comp : MaybeSequence[float]
               Row coordinate of the found component matches.

    column_comp : MaybeSequence[float]
                  Column coordinate of the found component matches.

    angle_comp : MaybeSequence[float]
                 Rotation angle of the found component matches.

    score_comp : MaybeSequence[float]
                 Score of the found component matches.

    model_comp : MaybeSequence[int]
                 Index of the found components.

    model_match : int
                  Index of the found instance of the component model to be
                  returned.

    mark_orientation : str
                       Mark the orientation of the components.
                       Value Suggestion: false

    Returns
    -------

    found_components : HObject
                       Found components of the selected component model
                       instance.

    row_comp_inst : Sequence[float]
                    Row coordinate of all components of the selected model
                    instance.

    column_comp_inst : Sequence[float]
                       Column coordinate of all components of the selected
                       model instance.

    angle_comp_inst : Sequence[float]
                      Rotation angle of all components of the selected
                      model instance.

    score_comp_inst : Sequence[float]
                      Score of all components of the selected model
                      instance.

    See Also
    --------
    train_model_components, create_component_model

    Predecessors
    ------------
    find_component_model
    """
    with HalconOperator(994) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, model_start)
        proc.set_input_tuple(2, model_end)
        proc.set_input_tuple(3, row_comp)
        proc.set_input_tuple(4, column_comp)
        proc.set_input_tuple(5, angle_comp)
        proc.set_input_tuple(6, score_comp)
        proc.set_input_tuple(7, model_comp)
        proc.set_input_tuple(8, model_match)
        proc.set_input_tuple(9, mark_orientation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # found_components
            proc.get_output_tuple_m(0),  # row_comp_inst
            proc.get_output_tuple_m(1),  # column_comp_inst
            proc.get_output_tuple_m(2),  # angle_comp_inst
            proc.get_output_tuple_m(3)   # score_comp_inst
        )  # type: ignore


def get_found_component_model_s(
    component_model_id: HHandle,
    model_start: MaybeSequence[int],
    model_end: MaybeSequence[int],
    row_comp: MaybeSequence[float],
    column_comp: MaybeSequence[float],
    angle_comp: MaybeSequence[float],
    score_comp: MaybeSequence[float],
    model_comp: MaybeSequence[int],
    model_match: int,
    mark_orientation: str
) -> Tuple[HObject, float, float, float, float]:
    """
    Return the components of a found instance of a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    model_start : MaybeSequence[int]
                  Start index of each found instance of the component
                  model in the tuples describing the component matches.

    model_end : MaybeSequence[int]
                End index of each found instance of the component model to
                the tuples describing the component matches.

    row_comp : MaybeSequence[float]
               Row coordinate of the found component matches.

    column_comp : MaybeSequence[float]
                  Column coordinate of the found component matches.

    angle_comp : MaybeSequence[float]
                 Rotation angle of the found component matches.

    score_comp : MaybeSequence[float]
                 Score of the found component matches.

    model_comp : MaybeSequence[int]
                 Index of the found components.

    model_match : int
                  Index of the found instance of the component model to be
                  returned.

    mark_orientation : str
                       Mark the orientation of the components.
                       Value Suggestion: false

    Returns
    -------

    found_components : HObject
                       Found components of the selected component model
                       instance.

    row_comp_inst : float
                    Row coordinate of all components of the selected model
                    instance.

    column_comp_inst : float
                       Column coordinate of all components of the selected
                       model instance.

    angle_comp_inst : float
                      Rotation angle of all components of the selected
                      model instance.

    score_comp_inst : float
                      Score of all components of the selected model
                      instance.

    See Also
    --------
    train_model_components, create_component_model

    Predecessors
    ------------
    find_component_model
    """
    with HalconOperator(994) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, model_start)
        proc.set_input_tuple(2, model_end)
        proc.set_input_tuple(3, row_comp)
        proc.set_input_tuple(4, column_comp)
        proc.set_input_tuple(5, angle_comp)
        proc.set_input_tuple(6, score_comp)
        proc.set_input_tuple(7, model_comp)
        proc.set_input_tuple(8, model_match)
        proc.set_input_tuple(9, mark_orientation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # found_components
            proc.get_output_tuple_s(0),  # row_comp_inst
            proc.get_output_tuple_s(1),  # column_comp_inst
            proc.get_output_tuple_s(2),  # angle_comp_inst
            proc.get_output_tuple_s(3)   # score_comp_inst
        )  # type: ignore


def get_framegrabber_callback(
    acq_handle: HHandle,
    callback_type: str
) -> Tuple[int, int]:
    """
    Query callback function of an image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    callback_type : str
                    Callback type.
                    Value Suggestion: transfer_end

    Returns
    -------

    callback_function : int
                        Pointer to the callback function.

    user_context : int
                   Pointer to user-specific context data.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_callback

    Predecessors
    ------------
    open_framegrabber, set_framegrabber_callback

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async, set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    get_framegrabber_callback runs in parallel with all non-exclusive
    operators inside and outside of this group.
    """
    with HalconOperator(2027) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, callback_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # callback_function
            proc.get_output_tuple_s(1)   # user_context
        )  # type: ignore


def get_framegrabber_lut(
    acq_handle: HHandle
) -> Tuple[Sequence[int], Sequence[int], Sequence[int]]:
    """
    Query look-up table of the image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    Returns
    -------

    image_red : Sequence[int]
                Red level of the LUT entries.

    image_green : Sequence[int]
                  Green level of the LUT entries.

    image_blue : Sequence[int]
                 Blue level of the LUT entries.

    See Also
    --------
    set_framegrabber_lut, open_framegrabber

    Predecessors
    ------------
    open_framegrabber

    Successors
    ----------
    set_framegrabber_lut

    Notes
    -----
    For a multithreaded application the image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    get_framegrabber_lut runs in parallel with all non-exclusive operators
    inside and outside of this group.
    """
    with HalconOperator(2038) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # image_red
            proc.get_output_tuple_m(1),  # image_green
            proc.get_output_tuple_m(2)   # image_blue
        )  # type: ignore


def get_framegrabber_param(
    acq_handle: HHandle,
    param: MaybeSequence[str]
) -> Sequence[Union[str, float, int]]:
    """
    Query specific parameters of an image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    param : MaybeSequence[str]
            Parameter of interest.
            Value Suggestion: revision

    Returns
    -------

    value : Sequence[Union[str, float, int]]
            Parameter value.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, set_framegrabber_param

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async, set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    get_framegrabber_param runs in parallel with all non-exclusive
    operators inside and outside of this group.
    """
    with HalconOperator(2025) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, param)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def get_framegrabber_param_s(
    acq_handle: HHandle,
    param: MaybeSequence[str]
) -> Union[str, float, int]:
    """
    Query specific parameters of an image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    param : MaybeSequence[str]
            Parameter of interest.
            Value Suggestion: revision

    Returns
    -------

    value : Union[str, float, int]
            Parameter value.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, set_framegrabber_param

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async, set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    get_framegrabber_param runs in parallel with all non-exclusive
    operators inside and outside of this group.
    """
    with HalconOperator(2025) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, param)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_full_matrix(matrix_id: HHandle) -> Sequence[float]:
    """
    Return all values of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    values : Sequence[float]
             Values of the matrix elements.

    See Also
    --------
    set_full_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(892) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        values = proc.get_output_tuple_m(0)
        return values  # type: ignore


def get_full_matrix_s(matrix_id: HHandle) -> float:
    """
    Return all values of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    values : float
             Values of the matrix elements.

    See Also
    --------
    set_full_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(892) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        values = proc.get_output_tuple_s(0)
        return values  # type: ignore


def get_grayval(
    image: HObject,
    row: MaybeSequence[int],
    column: MaybeSequence[int]
) -> Sequence[Union[int, float]]:
    """
    Access the gray values of an image object.

    Parameters
    ----------

    image : HObject
            Image whose gray value is to be accessed.

    row : MaybeSequence[int]
          Row coordinates of pixels to be viewed.
          Value Suggestion: 0
          Assertion: 0 <= Row && Row < height(Image)

    column : MaybeSequence[int]
             Column coordinates of pixels to be viewed.
             Value Suggestion: 0
             Assertion: 0 <= Column && Column < width(Image)

    Returns
    -------

    grayval : Sequence[Union[int, float]]
              Gray values of indicated pixels.

    See Also
    --------
    set_grayval

    Alternatives
    ------------
    get_image_pointer1, get_grayval_interpolated, get_grayval_contour_xld

    Predecessors
    ------------
    read_image

    Notes
    -----
    The type of the values of Grayval depends on the type of the gray
    values of the channels of the image Image.  The operator get_grayval
    produces quite some overhead. Typically, it is used to get single gray
    values of an image (e.g., get_mposition followed by get_grayval).  It
    is not suitable for programming image processing operations such as
    filters.  In this case it is more useful to use the operator
    get_image_pointer1 and to directly use the C or C++ interface for
    integrating own procedures.
    """
    with HalconOperator(630) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        grayval = proc.get_output_tuple_m(0)
        return grayval  # type: ignore


def get_grayval_contour_xld(
    image: HObject,
    contour: HObject,
    interpolation: str
) -> Sequence[Union[int, float]]:
    """
    Return gray values of an image at the positions of an XLD contour.

    Parameters
    ----------

    image : HObject
            Image whose gray values are to be accessed.

    contour : HObject
              Input XLD contour with the coordinates of the positions.

    interpolation : str
                    Interpolation method.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    grayval : Sequence[Union[int, float]]
              Gray values of the selected image coordinates.

    Alternatives
    ------------
    get_grayval_interpolated

    Predecessors
    ------------
    read_image, draw_xld, gen_contour_polygon_xld, edges_sub_pix
    """
    with HalconOperator(1668) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, contour)
        proc.set_input_tuple(0, interpolation)
        proc.init_oct(0)
        proc.execute()
        grayval = proc.get_output_tuple_m(0)
        return grayval  # type: ignore


def get_grayval_contour_xld_s(
    image: HObject,
    contour: HObject,
    interpolation: str
) -> Union[int, float]:
    """
    Return gray values of an image at the positions of an XLD contour.

    Parameters
    ----------

    image : HObject
            Image whose gray values are to be accessed.

    contour : HObject
              Input XLD contour with the coordinates of the positions.

    interpolation : str
                    Interpolation method.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    grayval : Union[int, float]
              Gray values of the selected image coordinates.

    Alternatives
    ------------
    get_grayval_interpolated

    Predecessors
    ------------
    read_image, draw_xld, gen_contour_polygon_xld, edges_sub_pix
    """
    with HalconOperator(1668) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, contour)
        proc.set_input_tuple(0, interpolation)
        proc.init_oct(0)
        proc.execute()
        grayval = proc.get_output_tuple_s(0)
        return grayval  # type: ignore


def get_grayval_interpolated(
    image: HObject,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    interpolation: str
) -> Sequence[float]:
    """
    Return gray values of an image at the positions given by tuples of
    rows and columns.

    Parameters
    ----------

    image : HObject
            Image whose gray values are to be accessed.

    row : MaybeSequence[Union[float, int]]
          Row coordinates of positions.
          Value Suggestion: 0
          Assertion: -0.5 <= Row && Row < height(Image) - 0.5

    column : MaybeSequence[Union[float, int]]
             Column coordinates of positions.
             Value Suggestion: 0
             Assertion: -0.5 <= Column && Column < width(Image) - 0.5

    interpolation : str
                    Interpolation method.
                    Value Suggestion: bilinear

    Returns
    -------

    grayval : Sequence[float]
              Gray values of the selected image coordinates.

    Alternatives
    ------------
    get_grayval_contour_xld, get_grayval

    Predecessors
    ------------
    read_image
    """
    with HalconOperator(629) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, interpolation)
        proc.init_oct(0)
        proc.execute()
        grayval = proc.get_output_tuple_m(0)
        return grayval  # type: ignore


def get_grayval_interpolated_s(
    image: HObject,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    interpolation: str
) -> float:
    """
    Return gray values of an image at the positions given by tuples of
    rows and columns.

    Parameters
    ----------

    image : HObject
            Image whose gray values are to be accessed.

    row : MaybeSequence[Union[float, int]]
          Row coordinates of positions.
          Value Suggestion: 0
          Assertion: -0.5 <= Row && Row < height(Image) - 0.5

    column : MaybeSequence[Union[float, int]]
             Column coordinates of positions.
             Value Suggestion: 0
             Assertion: -0.5 <= Column && Column < width(Image) - 0.5

    interpolation : str
                    Interpolation method.
                    Value Suggestion: bilinear

    Returns
    -------

    grayval : float
              Gray values of the selected image coordinates.

    Alternatives
    ------------
    get_grayval_contour_xld, get_grayval

    Predecessors
    ------------
    read_image
    """
    with HalconOperator(629) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, interpolation)
        proc.init_oct(0)
        proc.execute()
        grayval = proc.get_output_tuple_s(0)
        return grayval  # type: ignore


def get_handle_object(handle: HHandle, key: Union[str, int]) -> HObject:
    """
    Retrieve an object associated with a key from a handle.

    Parameters
    ----------

    handle : HHandle
             Handle of which to get the key.

    key : Union[str, int]
          Key to get.

    Returns
    -------

    object : HObject
             Iconic value of the key.

    See Also
    --------
    get_handle_param

    Alternatives
    ------------
    get_handle_tuple
    """
    with HalconOperator(2157) as proc:
        proc.set_input_tuple(0, handle)
        proc.set_input_tuple(1, key)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def get_handle_param(
    handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Return information about a handle.

    Parameters
    ----------

    handle : HHandle
             Handle of which to get the parameter.

    gen_param_name : str
                     Parameter to get.
                     Value Suggestion: keys

    key : MaybeSequence[str]
          Optional key.
          Value Suggestion: []

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Returned value.

    See Also
    --------
    get_handle_tuple, get_handle_object

    Successors
    ----------
    clear_handle, get_handle_tuple, get_handle_object
    """
    with HalconOperator(2158) as proc:
        proc.set_input_tuple(0, handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_handle_param_s(
    handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Return information about a handle.

    Parameters
    ----------

    handle : HHandle
             Handle of which to get the parameter.

    gen_param_name : str
                     Parameter to get.
                     Value Suggestion: keys

    key : MaybeSequence[str]
          Optional key.
          Value Suggestion: []

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Returned value.

    See Also
    --------
    get_handle_tuple, get_handle_object

    Successors
    ----------
    clear_handle, get_handle_tuple, get_handle_object
    """
    with HalconOperator(2158) as proc:
        proc.set_input_tuple(0, handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_handle_tuple(
    handle: HHandle,
    key: Union[str, int]
) -> Sequence[Union[int, float, str]]:
    """
    Retrieve a tuple associated with a key from a handle.

    Parameters
    ----------

    handle : HHandle
             Handle of which to get the key.

    key : Union[str, int]
          Key to get.
          Assertion: length(Key) > 0

    Returns
    -------

    tuple : Sequence[Union[int, float, str]]
            Control value of the key.

    See Also
    --------
    get_handle_param, get_handle_object

    Alternatives
    ------------
    get_handle_object

    Predecessors
    ------------
    get_handle_param
    """
    with HalconOperator(2159) as proc:
        proc.set_input_tuple(0, handle)
        proc.set_input_tuple(1, key)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_m(0)
        return tuple  # type: ignore


def get_handle_tuple_s(
    handle: HHandle,
    key: Union[str, int]
) -> Union[int, float, str]:
    """
    Retrieve a tuple associated with a key from a handle.

    Parameters
    ----------

    handle : HHandle
             Handle of which to get the key.

    key : Union[str, int]
          Key to get.
          Assertion: length(Key) > 0

    Returns
    -------

    tuple : Union[int, float, str]
            Control value of the key.

    See Also
    --------
    get_handle_param, get_handle_object

    Alternatives
    ------------
    get_handle_object

    Predecessors
    ------------
    get_handle_param
    """
    with HalconOperator(2159) as proc:
        proc.set_input_tuple(0, handle)
        proc.set_input_tuple(1, key)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_s(0)
        return tuple  # type: ignore


def get_hsi(
    window_handle: HHandle
) -> Tuple[Sequence[int], Sequence[int], Sequence[int]]:
    """
    Get the HSI coding of the current color.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    hue : Sequence[int]
          Hue (color value) of the current color.

    saturation : Sequence[int]
                 Saturation of the current color.

    intensity : Sequence[int]
                Intensity of the current color.

    See Also
    --------
    set_hsi, set_color, set_rgb, trans_to_rgb, trans_from_rgb

    Successors
    ----------
    set_hsi, set_rgb, disp_image

    Notes
    -----
    The values returned by get_hsi may be inaccurate due to rounding
    errors. They do not necessarily match the values set with set_hsi
    exactly (colors are stored in RGB internally).
    """
    with HalconOperator(1249) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hue
            proc.get_output_tuple_m(1),  # saturation
            proc.get_output_tuple_m(2)   # intensity
        )  # type: ignore


def get_icon(window_handle: HHandle) -> HObject:
    """
    Query the icon for region output

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    icon : HObject
           Icon for the regions center of gravity.

    Predecessors
    ------------
    set_icon

    Successors
    ----------
    disp_region
    """
    with HalconOperator(1260) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()
        icon = HObject(proc.get_output_object_key(1))
        return icon  # type: ignore


def get_image_pointer1(
    image: HObject
) -> Tuple[Sequence[int], Sequence[str], Sequence[int], Sequence[int]]:
    """
    Access the pointer of a channel.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    pointer : Sequence[int]
              Pointer to the image data in the HALCON database.

    type : Sequence[str]
           Type of image.

    width : Sequence[int]
            Width of image.

    height : Sequence[int]
             Height of image.

    See Also
    --------
    paint_region, paint_gray

    Alternatives
    ------------
    set_grayval, get_grayval, get_image_pointer3, get_image_size,
    get_image_type

    Predecessors
    ------------
    read_image

    Notes
    -----
    The pointer returned by get_image_pointer1 may only be used as long as
    the corresponding image object exists in the HALCON  database.  This
    is the case as long as the corresponding variable in the programming
    language in which HALCON is used is valid.  If this is not observed,
    unexpected behavior or program crashes may result.
    If data is written to an existing image via the pointer, all image
    objects that reference the image are modified.  If, for example, the
    domain of an image is restricted via reduce_domain, the original image
    object with the full domain and the image object with the reduced
    domain share the same image matrix (i.e., get_image_pointer1 returns
    the same pointer for both images).  Consequently, if one of the two
    images in this example is modified, both image objects are affected.
    Therefore, if the pointer is used to write image data in the
    programming language in which HALCON is used, the image data should be
    written into an image object that has been created solely for this
    purpose, e.g., using gen_image1. For multi-channel input images the
    type and the pointer of the first channel is returned.
    """
    with HalconOperator(625) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pointer
            proc.get_output_tuple_m(1),  # type
            proc.get_output_tuple_m(2),  # width
            proc.get_output_tuple_m(3)   # height
        )  # type: ignore


def get_image_pointer1_rect(
    image: HObject
) -> Tuple[int, int, int, int, int, int]:
    """
    Access to the image data pointer and the image data inside the
    smallest rectangle of the domain of the input image.

    Parameters
    ----------

    image : HObject
            Input image (Himage).

    Returns
    -------

    pixel_pointer : int
                    Pointer to the image data.

    width : int
            Width of the output image.

    height : int
             Height of the output image.

    vertical_pitch : int
                     Width(input image)*(HorizontalBitPitch/8).

    horizontal_bit_pitch : int
                           Distance between two neighboring pixels in bits
                           .

    bits_per_pixel : int
                     Number of used bits per pixel.

    See Also
    --------
    paint_region, paint_gray, gen_image1_rect

    Alternatives
    ------------
    set_grayval, get_grayval, get_image_pointer3, get_image_pointer1

    Predecessors
    ------------
    read_image, gen_image1_rect

    Notes
    -----
    The operator get_image_pointer1_rect should only be used for entry
    into newly created images, since otherwise the gray values of other
    images might be overwritten (see relational structure).
    """
    with HalconOperator(623) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # pixel_pointer
            proc.get_output_tuple_s(1),  # width
            proc.get_output_tuple_s(2),  # height
            proc.get_output_tuple_s(3),  # vertical_pitch
            proc.get_output_tuple_s(4),  # horizontal_bit_pitch
            proc.get_output_tuple_s(5)   # bits_per_pixel
        )  # type: ignore


def get_image_pointer1_s(image: HObject) -> Tuple[int, str, int, int]:
    """
    Access the pointer of a channel.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    pointer : int
              Pointer to the image data in the HALCON database.

    type : str
           Type of image.

    width : int
            Width of image.

    height : int
             Height of image.

    See Also
    --------
    paint_region, paint_gray

    Alternatives
    ------------
    set_grayval, get_grayval, get_image_pointer3, get_image_size,
    get_image_type

    Predecessors
    ------------
    read_image

    Notes
    -----
    The pointer returned by get_image_pointer1 may only be used as long as
    the corresponding image object exists in the HALCON  database.  This
    is the case as long as the corresponding variable in the programming
    language in which HALCON is used is valid.  If this is not observed,
    unexpected behavior or program crashes may result.
    If data is written to an existing image via the pointer, all image
    objects that reference the image are modified.  If, for example, the
    domain of an image is restricted via reduce_domain, the original image
    object with the full domain and the image object with the reduced
    domain share the same image matrix (i.e., get_image_pointer1 returns
    the same pointer for both images).  Consequently, if one of the two
    images in this example is modified, both image objects are affected.
    Therefore, if the pointer is used to write image data in the
    programming language in which HALCON is used, the image data should be
    written into an image object that has been created solely for this
    purpose, e.g., using gen_image1. For multi-channel input images the
    type and the pointer of the first channel is returned.
    """
    with HalconOperator(625) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # pointer
            proc.get_output_tuple_s(1),  # type
            proc.get_output_tuple_s(2),  # width
            proc.get_output_tuple_s(3)   # height
        )  # type: ignore


def get_image_pointer3(
    image_rgb: HObject
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[str], Sequence[int], Sequence[int]]:
    """
    Access the pointers of a colored image.

    Parameters
    ----------

    image_rgb : HObject
                Input image.

    Returns
    -------

    pointer_red : Sequence[int]
                  Pointer to the pixels of the first channel.

    pointer_green : Sequence[int]
                    Pointer to the pixels of the second channel.

    pointer_blue : Sequence[int]
                   Pointer to the pixels of the third channel.

    type : Sequence[str]
           Type of image.

    width : Sequence[int]
            Width of image.

    height : Sequence[int]
             Height of image.

    See Also
    --------
    paint_region, paint_gray

    Alternatives
    ------------
    set_grayval, get_grayval, get_image_pointer1

    Predecessors
    ------------
    read_image

    Notes
    -----
    Only one image can be passed. The operator get_image_pointer3 should
    only be used for entry into newly created images, since otherwise the
    gray values of other images might be overwritten (see relational
    structure).
    """
    with HalconOperator(624) as proc:
        proc.set_input_object(1, image_rgb)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pointer_red
            proc.get_output_tuple_m(1),  # pointer_green
            proc.get_output_tuple_m(2),  # pointer_blue
            proc.get_output_tuple_m(3),  # type
            proc.get_output_tuple_m(4),  # width
            proc.get_output_tuple_m(5)   # height
        )  # type: ignore


def get_image_pointer3_s(
    image_rgb: HObject
) -> Tuple[int, int, int, str, int, int]:
    """
    Access the pointers of a colored image.

    Parameters
    ----------

    image_rgb : HObject
                Input image.

    Returns
    -------

    pointer_red : int
                  Pointer to the pixels of the first channel.

    pointer_green : int
                    Pointer to the pixels of the second channel.

    pointer_blue : int
                   Pointer to the pixels of the third channel.

    type : str
           Type of image.

    width : int
            Width of image.

    height : int
             Height of image.

    See Also
    --------
    paint_region, paint_gray

    Alternatives
    ------------
    set_grayval, get_grayval, get_image_pointer1

    Predecessors
    ------------
    read_image

    Notes
    -----
    Only one image can be passed. The operator get_image_pointer3 should
    only be used for entry into newly created images, since otherwise the
    gray values of other images might be overwritten (see relational
    structure).
    """
    with HalconOperator(624) as proc:
        proc.set_input_object(1, image_rgb)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # pointer_red
            proc.get_output_tuple_s(1),  # pointer_green
            proc.get_output_tuple_s(2),  # pointer_blue
            proc.get_output_tuple_s(3),  # type
            proc.get_output_tuple_s(4),  # width
            proc.get_output_tuple_s(5)   # height
        )  # type: ignore


def get_image_size(image: HObject) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Return the size of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    width : Sequence[int]
            Width of image.

    height : Sequence[int]
             Height of image.

    See Also
    --------
    get_image_type

    Alternatives
    ------------
    get_image_pointer1

    Predecessors
    ------------
    read_image
    """
    with HalconOperator(627) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # width
            proc.get_output_tuple_m(1)   # height
        )  # type: ignore


def get_image_size_s(image: HObject) -> Tuple[int, int]:
    """
    Return the size of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    width : int
            Width of image.

    height : int
             Height of image.

    See Also
    --------
    get_image_type

    Alternatives
    ------------
    get_image_pointer1

    Predecessors
    ------------
    read_image
    """
    with HalconOperator(627) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width
            proc.get_output_tuple_s(1)   # height
        )  # type: ignore


def get_image_time(
    image: HObject
) -> Tuple[int, int, int, int, int, int, int, int]:
    """
    Request time at which the image was created.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    msecond : int
              Milliseconds (0..999).

    second : int
             Seconds (0..59).

    minute : int
             Minutes (0..59).

    hour : int
           Hours (0..23).

    day : int
          Day of the month (1..31).

    yday : int
           Day of the year (1..366).

    month : int
            Month (1..12).

    year : int
           Year (xxxx).

    See Also
    --------
    count_seconds

    Predecessors
    ------------
    read_image, grab_image
    """
    with HalconOperator(628) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # msecond
            proc.get_output_tuple_s(1),  # second
            proc.get_output_tuple_s(2),  # minute
            proc.get_output_tuple_s(3),  # hour
            proc.get_output_tuple_s(4),  # day
            proc.get_output_tuple_s(5),  # yday
            proc.get_output_tuple_s(6),  # month
            proc.get_output_tuple_s(7)   # year
        )  # type: ignore


def get_image_type(image: HObject) -> Sequence[str]:
    """
    Return the type of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    type : Sequence[str]
           Type of image.

    See Also
    --------
    get_image_size

    Alternatives
    ------------
    get_image_pointer1

    Predecessors
    ------------
    read_image

    Notes
    -----
    For multi-channel input images the type of the first channel is
    returned.
    """
    with HalconOperator(626) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        type = proc.get_output_tuple_m(0)
        return type  # type: ignore


def get_image_type_s(image: HObject) -> str:
    """
    Return the type of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    type : str
           Type of image.

    See Also
    --------
    get_image_size

    Alternatives
    ------------
    get_image_pointer1

    Predecessors
    ------------
    read_image

    Notes
    -----
    For multi-channel input images the type of the first channel is
    returned.
    """
    with HalconOperator(626) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        type = proc.get_output_tuple_s(0)
        return type  # type: ignore


def get_insert(window_handle: HHandle) -> str:
    """
    Get the current display mode.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : str
           Display mode.

    See Also
    --------
    set_insert, query_insert, disp_region, disp_line

    Predecessors
    ------------
    query_insert

    Successors
    ----------
    set_insert, disp_image

    Warnings
    --------
    get_insert is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1248) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_s(0)
        return mode  # type: ignore


def get_io_channel_param(
    iochannel_handle: MaybeSequence[HHandle],
    gen_param_name: MaybeSequence[str]
) -> Sequence[HTupleElementType]:
    """
    Query specific parameters of I/O channels.

    Parameters
    ----------

    iochannel_handle : MaybeSequence[HHandle]
                       Handles of the opened I/O channels.

    gen_param_name : MaybeSequence[str]
                     Parameter names.
                     Value Suggestion: param_name

    Returns
    -------

    gen_param_value : Sequence[HTupleElementType]
                      Parameter values.

    See Also
    --------
    open_io_channel, query_io_device, set_io_channel_param

    Predecessors
    ------------
    open_io_channel

    Successors
    ----------
    read_io_channel, write_io_channel
    """
    with HalconOperator(2014) as proc:
        proc.set_input_tuple(0, iochannel_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_io_device_param(
    iodevice_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Query settings of an I/O device instance.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    gen_param_name : MaybeSequence[str]
                     Parameter names.
                     Value Suggestion: param_name

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Parameter values.

    See Also
    --------
    open_io_device, query_io_interface, set_io_device_param

    Predecessors
    ------------
    open_io_device, set_io_device_param

    Successors
    ----------
    open_io_channel
    """
    with HalconOperator(2020) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_io_device_param_s(
    iodevice_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Query settings of an I/O device instance.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    gen_param_name : MaybeSequence[str]
                     Parameter names.
                     Value Suggestion: param_name

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Parameter values.

    See Also
    --------
    open_io_device, query_io_interface, set_io_device_param

    Predecessors
    ------------
    open_io_device, set_io_device_param

    Successors
    ----------
    open_io_channel
    """
    with HalconOperator(2020) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_keywords(operator_name: str) -> Sequence[str]:
    """
    Get keywords which are assigned to operators.

    Parameters
    ----------

    operator_name : str
                    Substring in the names of those operators for which
                    keywords are needed.
                    Value Suggestion: get_keywords

    Returns
    -------

    keywords : Sequence[str]
               Keywords for the operators.

    See Also
    --------
    get_operator_name, search_operator, get_param_info

    Alternatives
    ------------
    get_operator_info

    Predecessors
    ------------
    get_chapter_info

    Notes
    -----
    The encoding of the result is ISO 8859-1 for English and German, and
    UTF-8 for Japanese.
    """
    with HalconOperator(1117) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.init_oct(0)
        proc.execute()
        keywords = proc.get_output_tuple_m(0)
        return keywords  # type: ignore


def get_line_approx(window_handle: HHandle) -> int:
    """
    Get the current approximation error for contour display.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    approximation : int
                    Current approximation error for contour display.

    See Also
    --------
    get_region_polygon, set_line_approx, set_line_style, disp_region

    Successors
    ----------
    set_line_approx, set_line_style, disp_region

    Warnings
    --------
    get_line_approx is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1247) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        approximation = proc.get_output_tuple_s(0)
        return approximation  # type: ignore


def get_line_of_sight(
    row: Sequence[float],
    column: Sequence[float],
    camera_param: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the line of sight corresponding to a point in the image.

    Parameters
    ----------

    row : Sequence[float]
          Row coordinate of the pixel.

    column : Sequence[float]
             Column coordinate of the pixel.

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    Returns
    -------

    px : Sequence[float]
         X coordinate of the first point on the line of sight in the
         camera coordinate system

    py : Sequence[float]
         Y coordinate of the first point on the line of sight in the
         camera coordinate system

    pz : Sequence[float]
         Z coordinate of the first point on the line of sight in the
         camera coordinate system

    qx : Sequence[float]
         X coordinate of the second point on the line of sight in the
         camera coordinate system

    qy : Sequence[float]
         Y coordinate of the second point on the line of sight in the
         camera coordinate system

    qz : Sequence[float]
         Z coordinate of the second point on the line of sight in the
         camera coordinate system

    See Also
    --------
    camera_calibration, disp_caltab, read_cam_par, project_3d_point,
    affine_trans_point_3d

    Predecessors
    ------------
    read_cam_par, camera_calibration

    Successors
    ----------
    affine_trans_point_3d
    """
    with HalconOperator(1929) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, camera_param)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # px
            proc.get_output_tuple_m(1),  # py
            proc.get_output_tuple_m(2),  # pz
            proc.get_output_tuple_m(3),  # qx
            proc.get_output_tuple_m(4),  # qy
            proc.get_output_tuple_m(5)   # qz
        )  # type: ignore


def get_line_style(window_handle: HHandle) -> Sequence[int]:
    """
    Get the current graphic mode for contours.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    style : Sequence[int]
            Template for contour display.

    See Also
    --------
    set_line_style, disp_region
    """
    with HalconOperator(1246) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        style = proc.get_output_tuple_m(0)
        return style  # type: ignore


def get_line_width(window_handle: HHandle) -> float:
    """
    Get the current line width for contour display.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    width : float
            Current line width for contour display.

    See Also
    --------
    set_line_width, disp_region

    Successors
    ----------
    set_line_width, set_line_style, disp_region
    """
    with HalconOperator(1245) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        width = proc.get_output_tuple_s(0)
        return width  # type: ignore


def get_lines_xld(
    polygon: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return an XLD polygon's data (as lines).

    Parameters
    ----------

    polygon : HObject
              Input XLD polygons.

    Returns
    -------

    begin_row : Sequence[float]
                Row coordinates of the lines' start points.

    begin_col : Sequence[float]
                Column coordinates of the lines' start points.

    end_row : Sequence[float]
              Column coordinates of the lines' end points.

    end_col : Sequence[float]
              Column coordinates of the lines' end points.

    length : Sequence[float]
             Lengths of the line segments.

    phi : Sequence[float]
          Angles of the line segments.

    Alternatives
    ------------
    get_polygon_xld

    Predecessors
    ------------
    gen_polygons_xld
    """
    with HalconOperator(43) as proc:
        proc.set_input_object(1, polygon)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # begin_row
            proc.get_output_tuple_m(1),  # begin_col
            proc.get_output_tuple_m(2),  # end_row
            proc.get_output_tuple_m(3),  # end_col
            proc.get_output_tuple_m(4),  # length
            proc.get_output_tuple_m(5)   # phi
        )  # type: ignore


def get_lut(window_handle: HHandle) -> Sequence[Union[int, str]]:
    """
    Get current look-up-table (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    look_up_table : Sequence[Union[int, str]]
                    Name of look-up-table or tuple of RGB-values.

    See Also
    --------
    set_lut

    Successors
    ----------
    set_lut
    """
    with HalconOperator(1289) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        look_up_table = proc.get_output_tuple_m(0)
        return look_up_table  # type: ignore


def get_lut_style(window_handle: HHandle) -> Tuple[float, float, float]:
    """
    Get modification parameters of look-up-table (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    hue : float
          Modification of color value.

    saturation : float
                 Modification of saturation.

    intensity : float
                Modification of intensity.

    See Also
    --------
    set_lut_style

    Successors
    ----------
    set_lut_style, set_lut

    Warnings
    --------
    get_lut_style is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1287) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # hue
            proc.get_output_tuple_s(1),  # saturation
            proc.get_output_tuple_s(2)   # intensity
        )  # type: ignore


def get_mbutton(window_handle: HHandle) -> Tuple[int, int, int]:
    """
    Wait until a mouse button is pressed.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : int
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : int
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed.

    See Also
    --------
    open_window

    Alternatives
    ------------
    get_mposition, get_mbutton_sub_pix, get_mposition_sub_pix

    Predecessors
    ------------
    open_window

    Notes
    -----
    get_mbutton only returns if a mouse button is pressed in the window.
    """
    with HalconOperator(1283) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # button
        )  # type: ignore


def get_mbutton_sub_pix(
    window_handle: HHandle
) -> Tuple[float, float, int]:
    """
    Wait until a mouse button is pressed and get the subpixel mouse
    position.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : float
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : float
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed.

    See Also
    --------
    open_window

    Alternatives
    ------------
    get_mbutton, get_mposition, get_mposition_sub_pix

    Predecessors
    ------------
    open_window

    Notes
    -----
    get_mbutton_sub_pix only returns if a mouse button is pressed in the
    window.
    """
    with HalconOperator(1282) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # button
        )  # type: ignore


def get_message_obj(
    message_handle: HHandle,
    key: Union[str, int]
) -> HObject:
    """
    Retrieve an object associated with the key from the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    key : Union[str, int]
          Key string or integer.

    Returns
    -------

    object_data : HObject
                  Tuple value retrieved from the message.

    See Also
    --------
    create_message, clear_message, set_message_tuple, get_message_tuple,
    set_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Alternatives
    ------------
    get_message_tuple

    Predecessors
    ------------
    dequeue_message
    """
    with HalconOperator(536) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, key)
        proc.execute()
        object_data = HObject(proc.get_output_object_key(1))
        return object_data  # type: ignore


def get_message_param(
    message_handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[Union[str, int]]
) -> Sequence[Union[int, float, str]]:
    """
    Query message parameters or information about the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    gen_param_name : str
                     Names of the message parameters or info queries.
                     Value Suggestion: message_keys

    key : MaybeSequence[Union[str, int]]
          Message keys the parameter/query should be applied to.

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the message parameters or info queries.

    See Also
    --------
    create_message, clear_message, set_message_tuple, get_message_tuple,
    set_message_obj, get_message_obj, set_message_param, enqueue_message,
    dequeue_message

    Predecessors
    ------------
    dequeue_message
    """
    with HalconOperator(534) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_message_param_s(
    message_handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[Union[str, int]]
) -> Union[int, float, str]:
    """
    Query message parameters or information about the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    gen_param_name : str
                     Names of the message parameters or info queries.
                     Value Suggestion: message_keys

    key : MaybeSequence[Union[str, int]]
          Message keys the parameter/query should be applied to.

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Values of the message parameters or info queries.

    See Also
    --------
    create_message, clear_message, set_message_tuple, get_message_tuple,
    set_message_obj, get_message_obj, set_message_param, enqueue_message,
    dequeue_message

    Predecessors
    ------------
    dequeue_message
    """
    with HalconOperator(534) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_message_queue_param(
    queue_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Query message queue parameters or information about the queue.

    Parameters
    ----------

    queue_handle : HHandle
                   Message queue handle.
                   Assertion: QueueHandle != 0

    gen_param_name : MaybeSequence[str]
                     Names of the queue parameters or info queries.
                     Value Suggestion: max_message_num

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the queue parameters or info queries.

    See Also
    --------
    create_message_queue, clear_message_queue, enqueue_message,
    dequeue_message, set_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Predecessors
    ------------
    create_message_queue, enqueue_message, dequeue_message
    """
    with HalconOperator(528) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_message_queue_param_s(
    queue_handle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Query message queue parameters or information about the queue.

    Parameters
    ----------

    queue_handle : HHandle
                   Message queue handle.
                   Assertion: QueueHandle != 0

    gen_param_name : MaybeSequence[str]
                     Names of the queue parameters or info queries.
                     Value Suggestion: max_message_num

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Values of the queue parameters or info queries.

    See Also
    --------
    create_message_queue, clear_message_queue, enqueue_message,
    dequeue_message, set_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Predecessors
    ------------
    create_message_queue, enqueue_message, dequeue_message
    """
    with HalconOperator(528) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_message_tuple(
    message_handle: HHandle,
    key: Union[str, int]
) -> Sequence[HTupleElementType]:
    """
    Retrieve a tuple associated with the key from the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    key : Union[str, int]
          Key string or integer.

    Returns
    -------

    tuple_data : Sequence[HTupleElementType]
                 Tuple value retrieved from the message.

    See Also
    --------
    create_message, clear_message, set_message_tuple, set_message_obj,
    get_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Alternatives
    ------------
    get_message_obj

    Predecessors
    ------------
    dequeue_message
    """
    with HalconOperator(538) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, key)
        proc.init_oct(0)
        proc.execute()
        tuple_data = proc.get_output_tuple_m(0)
        return tuple_data  # type: ignore


def get_message_tuple_s(
    message_handle: HHandle,
    key: Union[str, int]
) -> HTupleElementType:
    """
    Retrieve a tuple associated with the key from the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    key : Union[str, int]
          Key string or integer.

    Returns
    -------

    tuple_data : HTupleElementType
                 Tuple value retrieved from the message.

    See Also
    --------
    create_message, clear_message, set_message_tuple, set_message_obj,
    get_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Alternatives
    ------------
    get_message_obj

    Predecessors
    ------------
    dequeue_message
    """
    with HalconOperator(538) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, key)
        proc.init_oct(0)
        proc.execute()
        tuple_data = proc.get_output_tuple_s(0)
        return tuple_data  # type: ignore


def get_metrology_model_param(
    metrology_handle: HHandle,
    gen_param_name: str
) -> Sequence[Union[str, float, int]]:
    """
    Get parameters that are valid for the entire metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: camera_param

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Value of the generic parameter.

    See Also
    --------
    get_metrology_object_param, get_metrology_object_num_instances

    Predecessors
    ------------
    get_metrology_object_indices, set_metrology_model_param

    Successors
    ----------
    get_metrology_object_param
    """
    with HalconOperator(792) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_metrology_model_param_s(
    metrology_handle: HHandle,
    gen_param_name: str
) -> Union[str, float, int]:
    """
    Get parameters that are valid for the entire metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: camera_param

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Value of the generic parameter.

    See Also
    --------
    get_metrology_object_param, get_metrology_object_num_instances

    Predecessors
    ------------
    get_metrology_object_indices, set_metrology_model_param

    Successors
    ----------
    get_metrology_object_param
    """
    with HalconOperator(792) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_metrology_object_fuzzy_param(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]],
    gen_param_name: Sequence[str]
) -> Sequence[Union[float, int]]:
    """
    Get a fuzzy parameter of a metroloy model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: fuzzy_thresh

    Returns
    -------

    gen_param_value : Sequence[Union[float, int]]
                      Values of the generic parameters.

    See Also
    --------
    get_metrology_object_param

    Predecessors
    ------------
    get_metrology_object_indices, set_metrology_object_fuzzy_param

    Successors
    ----------
    set_metrology_object_fuzzy_param
    """
    with HalconOperator(808) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_metrology_object_indices(
    metrology_handle: HHandle
) -> Sequence[int]:
    """
    Get the indices of the metrology objects of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    Returns
    -------

    indices : Sequence[int]
              Indices of the metrology objects.

    See Also
    --------
    get_metrology_object_num_instances

    Predecessors
    ------------
    read_metrology_model

    Successors
    ----------
    get_metrology_object_param, get_metrology_object_fuzzy_param
    """
    with HalconOperator(805) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_m(0)
        return indices  # type: ignore


def get_metrology_object_indices_s(metrology_handle: HHandle) -> int:
    """
    Get the indices of the metrology objects of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    Returns
    -------

    indices : int
              Indices of the metrology objects.

    See Also
    --------
    get_metrology_object_num_instances

    Predecessors
    ------------
    read_metrology_model

    Successors
    ----------
    get_metrology_object_param, get_metrology_object_fuzzy_param
    """
    with HalconOperator(805) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_s(0)
        return indices  # type: ignore


def get_metrology_object_measures(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]],
    transition: str
) -> Tuple[HObject, Sequence[float], Sequence[float]]:
    """
    Get the measure regions and the results of the edge location for the
    metrology objects of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    transition : str
                 Select light/dark or dark/light edges.
                 Value Suggestion: all

    Returns
    -------

    contours : HObject
               Rectangular XLD Contours of measure regions.

    row : Sequence[float]
          Row coordinates of the measured edges.

    column : Sequence[float]
             Column coordinates of the measured edges.

    See Also
    --------
    add_metrology_object_generic, add_metrology_object_ellipse_measure,
    add_metrology_object_line_measure,
    add_metrology_object_rectangle2_measure,
    add_metrology_object_circle_measure

    Predecessors
    ------------
    apply_metrology_model
    """
    with HalconOperator(803) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, transition)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # contours
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def get_metrology_object_model_contour(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[int, str]],
    resolution: float
) -> HObject:
    """
    Query the model contour of a metrology object in image coordinates.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[int, str]]
            Index of the metrology object.
            Value Suggestion: 0

    resolution : float
                 Distance between neighboring contour points.
                 Value Suggestion: 1.5
                 Assertion: Resolution >= 1.192e-7

    Returns
    -------

    contour : HObject
              Model contour.

    See Also
    --------
    set_metrology_model_param, get_metrology_object_measures,
    align_metrology_model

    Predecessors
    ------------
    add_metrology_object_generic, add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure,
    add_metrology_object_rectangle2_measure,
    add_metrology_object_line_measure

    Successors
    ----------
    apply_metrology_model
    """
    with HalconOperator(788) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, resolution)
        proc.execute()
        contour = HObject(proc.get_output_object_key(1))
        return contour  # type: ignore


def get_metrology_object_num_instances(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[int, str]]
) -> Sequence[Union[int, float]]:
    """
    Get the number of instances of the metrology objects of a metrology
    model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[int, str]]
            Index of the metrology objects.
            Value Suggestion: 0

    Returns
    -------

    num_instances : Sequence[Union[int, float]]
                    Number of Instances of the metrology objects.

    See Also
    --------
    get_metrology_object_indices

    Predecessors
    ------------
    apply_metrology_model

    Successors
    ----------
    clear_metrology_model
    """
    with HalconOperator(801) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        num_instances = proc.get_output_tuple_m(0)
        return num_instances  # type: ignore


def get_metrology_object_num_instances_s(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[int, str]]
) -> Union[int, float]:
    """
    Get the number of instances of the metrology objects of a metrology
    model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[int, str]]
            Index of the metrology objects.
            Value Suggestion: 0

    Returns
    -------

    num_instances : Union[int, float]
                    Number of Instances of the metrology objects.

    See Also
    --------
    get_metrology_object_indices

    Predecessors
    ------------
    apply_metrology_model

    Successors
    ----------
    clear_metrology_model
    """
    with HalconOperator(801) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        num_instances = proc.get_output_tuple_s(0)
        return num_instances  # type: ignore


def get_metrology_object_param(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]],
    gen_param_name: Sequence[str]
) -> Sequence[Union[str, float, int]]:
    """
    Get one or several parameters of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: num_measures

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.

    See Also
    --------
    get_metrology_object_fuzzy_param, get_metrology_object_num_instances

    Predecessors
    ------------
    get_metrology_object_indices, set_metrology_object_param

    Successors
    ----------
    set_metrology_object_param
    """
    with HalconOperator(809) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_metrology_object_result(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[int, str]],
    instance: MaybeSequence[Union[int, str]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float]]
) -> Sequence[Union[float, int, str]]:
    """
    Get the results of the measurement of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[int, str]]
            Index of the metrology object.
            Value Suggestion: 0

    instance : MaybeSequence[Union[int, str]]
               Instance of the metrology object.
               Value Suggestion: all

    gen_param_name : Sequence[str]
                     Name of the generic parameter.
                     Value Suggestion: result_type

    gen_param_value : Sequence[Union[str, float]]
                      Value of the generic parameter.
                      Value Suggestion: all_param

    Returns
    -------

    parameter : Sequence[Union[float, int, str]]
                Result values.

    See Also
    --------
    get_metrology_object_result_contour, get_metrology_object_measures

    Predecessors
    ------------
    apply_metrology_model

    Successors
    ----------
    clear_metrology_model
    """
    with HalconOperator(802) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, instance)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        parameter = proc.get_output_tuple_m(0)
        return parameter  # type: ignore


def get_metrology_object_result_contour(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[int, str]],
    instance: MaybeSequence[Union[int, str]],
    resolution: float
) -> HObject:
    """
    Query the result contour of a metrology object.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[int, str]]
            Index of the metrology object.
            Value Suggestion: 0

    instance : MaybeSequence[Union[int, str]]
               Instance of the metrology object.
               Value Suggestion: all

    resolution : float
                 Distance between neighboring contour points.
                 Value Suggestion: 1.5
                 Assertion: Resolution >= 1.192e-7

    Returns
    -------

    contour : HObject
              Result contour for the given metrology object.

    See Also
    --------
    get_metrology_object_result, get_metrology_object_measures

    Predecessors
    ------------
    apply_metrology_model
    """
    with HalconOperator(789) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, instance)
        proc.set_input_tuple(3, resolution)
        proc.execute()
        contour = HObject(proc.get_output_object_key(1))
        return contour  # type: ignore


def get_metrology_object_result_s(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[int, str]],
    instance: MaybeSequence[Union[int, str]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float]]
) -> Union[float, int, str]:
    """
    Get the results of the measurement of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[int, str]]
            Index of the metrology object.
            Value Suggestion: 0

    instance : MaybeSequence[Union[int, str]]
               Instance of the metrology object.
               Value Suggestion: all

    gen_param_name : Sequence[str]
                     Name of the generic parameter.
                     Value Suggestion: result_type

    gen_param_value : Sequence[Union[str, float]]
                      Value of the generic parameter.
                      Value Suggestion: all_param

    Returns
    -------

    parameter : Union[float, int, str]
                Result values.

    See Also
    --------
    get_metrology_object_result_contour, get_metrology_object_measures

    Predecessors
    ------------
    apply_metrology_model

    Successors
    ----------
    clear_metrology_model
    """
    with HalconOperator(802) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, instance)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        parameter = proc.get_output_tuple_s(0)
        return parameter  # type: ignore


def get_modules() -> Tuple[Sequence[str], int]:
    """
    Query of used modules and the module key.

    Returns
    -------

    used_modules : Sequence[str]
                   Names of used modules.

    module_key : int
                 Key for license manager.
    """
    with HalconOperator(345) as proc:
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # used_modules
            proc.get_output_tuple_s(1)   # module_key
        )  # type: ignore


def get_mposition(window_handle: HHandle) -> Tuple[int, int, int]:
    """
    Query the mouse position.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : int
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : int
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed or 0.

    See Also
    --------
    open_window

    Alternatives
    ------------
    get_mbutton, get_mposition_sub_pix, get_mbutton_sub_pix

    Predecessors
    ------------
    open_window

    Notes
    -----
    get_mposition fails (returns FAIL) if the mouse pointer is not located
    within the window.  In this case, no values are returned.
    """
    with HalconOperator(1281) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # button
        )  # type: ignore


def get_mposition_sub_pix(
    window_handle: HHandle
) -> Tuple[float, float, int]:
    """
    Query the subpixel mouse position.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : float
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : float
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed or 0.

    See Also
    --------
    open_window

    Alternatives
    ------------
    get_mbutton, get_mposition, get_mbutton_sub_pix

    Predecessors
    ------------
    open_window

    Notes
    -----
    get_mposition_sub_pix fails (returns FAIL) if the mouse pointer is not
    located within the window.  In this case, no values are returned.
    """
    with HalconOperator(1280) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # button
        )  # type: ignore


def get_mshape(window_handle: HHandle) -> str:
    """
    Query the current mouse pointer shape.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    cursor : str
             Mouse pointer name.

    See Also
    --------
    set_mshape, query_mshape

    Predecessors
    ------------
    open_window, query_mshape

    Successors
    ----------
    set_mshape

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1278) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        cursor = proc.get_output_tuple_s(0)
        return cursor  # type: ignore


def get_ncc_model_origin(model_id: HHandle) -> Tuple[float, float]:
    """
    Return the origin (reference point) of an NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    row : float
          Row coordinate of the origin of the NCC model.

    column : float
             Column coordinate of the origin of the NCC model.

    See Also
    --------
    area_center

    Predecessors
    ------------
    create_ncc_model, read_ncc_model, set_ncc_model_origin

    Successors
    ----------
    find_ncc_model
    """
    with HalconOperator(989) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def get_ncc_model_params(
    model_id: HHandle
) -> Tuple[int, float, float, float, str]:
    """
    Return the parameters of an NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    num_levels : int
                 Number of pyramid levels.

    angle_start : float
                  Smallest rotation of the pattern.

    angle_extent : float
                   Extent of the rotation angles.
                   Assertion: AngleExtent >= 0

    angle_step : float
                 Step length of the angles (resolution).
                 Assertion: AngleStep >= 0

    metric : str
             Match metric.

    See Also
    --------
    find_ncc_model

    Predecessors
    ------------
    create_ncc_model, read_ncc_model
    """
    with HalconOperator(988) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_levels
            proc.get_output_tuple_s(1),  # angle_start
            proc.get_output_tuple_s(2),  # angle_extent
            proc.get_output_tuple_s(3),  # angle_step
            proc.get_output_tuple_s(4)   # metric
        )  # type: ignore


def get_ncc_model_region(model_id: HHandle) -> HObject:
    """
    Return the region used to create an NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    model_region : HObject
                   Model region of the NCC model.

    Predecessors
    ------------
    create_ncc_model
    """
    with HalconOperator(2071) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()
        model_region = HObject(proc.get_output_object_key(1))
        return model_region  # type: ignore


def get_next_socket_data_type(socket: HHandle) -> str:
    """
    Determine the HALCON data type of the next socket data.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    data_type : str
                Data type of next HALCON data.

    See Also
    --------
    send_image, receive_image, send_region, receive_region, send_tuple,
    receive_tuple, send_serialized_item, receive_serialized_item
    """
    with HalconOperator(337) as proc:
        proc.set_input_tuple(0, socket)
        proc.init_oct(0)
        proc.execute()
        data_type = proc.get_output_tuple_s(0)
        return data_type  # type: ignore


def get_obj_class(object: HObject) -> Sequence[str]:
    """
    Name of the class of an image object.

    Parameters
    ----------

    object : HObject
             Image objects to be examined.

    Returns
    -------

    class_val : Sequence[str]
                Name of class.

    See Also
    --------
    get_channel_info, count_relation

    Successors
    ----------
    disp_image, disp_region, disp_xld
    """
    with HalconOperator(594) as proc:
        proc.set_input_object(1, object)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_m(0)
        return class_val  # type: ignore


def get_obj_class_s(object: HObject) -> str:
    """
    Name of the class of an image object.

    Parameters
    ----------

    object : HObject
             Image objects to be examined.

    Returns
    -------

    class_val : str
                Name of class.

    See Also
    --------
    get_channel_info, count_relation

    Successors
    ----------
    disp_image, disp_region, disp_xld
    """
    with HalconOperator(594) as proc:
        proc.set_input_object(1, object)
        proc.init_oct(0)
        proc.execute()
        class_val = proc.get_output_tuple_s(0)
        return class_val  # type: ignore


def get_object_model_3d_params(
    object_model_3d: MaybeSequence[HHandle],
    gen_param_name: Sequence[str]
) -> Sequence[Union[int, str, float]]:
    """
    Return attributes of 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    gen_param_name : Sequence[str]
                     Names of the generic attributes that are queried for
                     the 3D object model.
                     Value Suggestion: num_points

    Returns
    -------

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters.

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d, prepare_object_model_3d,
    sample_object_model_3d, triangulate_object_model_3d,
    intersect_plane_object_model_3d, set_object_model_3d_attrib,
    fit_primitives_object_model_3d, gen_plane_object_model_3d,
    gen_sphere_object_model_3d, gen_cylinder_object_model_3d,
    gen_box_object_model_3d, gen_sphere_object_model_3d_center

    Successors
    ----------
    write_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(1094) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_object_model_3d_params_s(
    object_model_3d: MaybeSequence[HHandle],
    gen_param_name: Sequence[str]
) -> Union[int, str, float]:
    """
    Return attributes of 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    gen_param_name : Sequence[str]
                     Names of the generic attributes that are queried for
                     the 3D object model.
                     Value Suggestion: num_points

    Returns
    -------

    gen_param_value : Union[int, str, float]
                      Values of the generic parameters.

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d, prepare_object_model_3d,
    sample_object_model_3d, triangulate_object_model_3d,
    intersect_plane_object_model_3d, set_object_model_3d_attrib,
    fit_primitives_object_model_3d, gen_plane_object_model_3d,
    gen_sphere_object_model_3d, gen_cylinder_object_model_3d,
    gen_box_object_model_3d, gen_sphere_object_model_3d_center

    Successors
    ----------
    write_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(1094) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_operator_info(operator_name: str, slot: str) -> Sequence[str]:
    """
    Get information concerning a HALCON-operator.

    Parameters
    ----------

    operator_name : str
                    Name of the operator on which more information is
                    needed.
                    Value Suggestion: get_operator_info

    slot : str
           Desired information.
           Value Suggestion: abstract

    Returns
    -------

    information : Sequence[str]
                  Information (empty if no information is available)

    See Also
    --------
    query_operator_info, get_param_info, get_operator_name, get_param_num,
    get_param_types

    Alternatives
    ------------
    get_param_names

    Predecessors
    ------------
    get_keywords, search_operator, get_operator_name, query_operator_info,
    query_param_info, get_param_info

    Successors
    ----------
    get_param_names, get_param_num, get_param_types

    Notes
    -----
    The encoding of the result is ISO 8859-1 for English and German, and
    UTF-8 for Japanese.
    """
    with HalconOperator(1114) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, slot)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_m(0)
        return information  # type: ignore


def get_operator_info_s(operator_name: str, slot: str) -> str:
    """
    Get information concerning a HALCON-operator.

    Parameters
    ----------

    operator_name : str
                    Name of the operator on which more information is
                    needed.
                    Value Suggestion: get_operator_info

    slot : str
           Desired information.
           Value Suggestion: abstract

    Returns
    -------

    information : str
                  Information (empty if no information is available)

    See Also
    --------
    query_operator_info, get_param_info, get_operator_name, get_param_num,
    get_param_types

    Alternatives
    ------------
    get_param_names

    Predecessors
    ------------
    get_keywords, search_operator, get_operator_name, query_operator_info,
    query_param_info, get_param_info

    Successors
    ----------
    get_param_names, get_param_num, get_param_types

    Notes
    -----
    The encoding of the result is ISO 8859-1 for English and German, and
    UTF-8 for Japanese.
    """
    with HalconOperator(1114) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, slot)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_s(0)
        return information  # type: ignore


def get_operator_name(pattern: str) -> Sequence[str]:
    """
    Get operators with the given string as a substring of their name.

    Parameters
    ----------

    pattern : str
              Substring of the seeked names (empty $<=>$ all names).
              Value Suggestion: info

    Returns
    -------

    operator_names : Sequence[str]
                     Detected operator names.

    See Also
    --------
    get_operator_info, get_param_names, get_param_num, get_param_types

    Alternatives
    ------------
    search_operator

    Successors
    ----------
    get_operator_info, get_param_names, get_param_num, get_param_types
    """
    with HalconOperator(1110) as proc:
        proc.set_input_tuple(0, pattern)
        proc.init_oct(0)
        proc.execute()
        operator_names = proc.get_output_tuple_m(0)
        return operator_names  # type: ignore


def get_os_window_handle(window_handle: HHandle) -> Tuple[int, int]:
    """
    Get the operating system window handle.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    oswindow_handle : int
                      Operating system window handle.

    osdisplay_handle : int
                       Operating system display handle (under Unix-like
                       systems only).

    Predecessors
    ------------
    open_window

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1169) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # oswindow_handle
            proc.get_output_tuple_s(1)   # osdisplay_handle
        )  # type: ignore


def get_paint(window_handle: HHandle) -> Sequence[Union[str, int, float]]:
    """
    Get the current display mode for gray values.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : Sequence[Union[str, int, float]]
           Name and parameter values of the current display mode.

    See Also
    --------
    set_paint, query_paint, disp_image

    Predecessors
    ------------
    query_paint

    Successors
    ----------
    set_paint, disp_region, disp_image
    """
    with HalconOperator(1244) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_m(0)
        return mode  # type: ignore


def get_pair_funct_1d(
    function: Sequence[Union[float, int]],
    index: MaybeSequence[int]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Access a function value using the index of the control points.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    index : MaybeSequence[int]
            Index of the control points.

    Returns
    -------

    x : Sequence[float]
        X value at the given control points.

    y : Sequence[float]
        Y value at the given control points.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1386) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1)   # y
        )  # type: ignore


def get_pair_funct_1d_s(
    function: Sequence[Union[float, int]],
    index: MaybeSequence[int]
) -> Tuple[float, float]:
    """
    Access a function value using the index of the control points.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    index : MaybeSequence[int]
            Index of the control points.

    Returns
    -------

    x : float
        X value at the given control points.

    y : float
        Y value at the given control points.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1386) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # x
            proc.get_output_tuple_s(1)   # y
        )  # type: ignore


def get_parallels_xld(
    parallels: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return an XLD parallel's data (as lines).

    Parameters
    ----------

    parallels : HObject
                Input XLD parallels.

    Returns
    -------

    row_1 : Sequence[float]
            Row coordinates of the points on polygon P1.

    col_1 : Sequence[float]
            Column coordinates of the points on polygon P1.

    length_1 : Sequence[float]
               Lengths of the line segments on polygon P1.

    phi_1 : Sequence[float]
            Angles of the line segments on polygon P1.

    row_2 : Sequence[float]
            Row coordinates of the points on polygon P2.

    col_2 : Sequence[float]
            Column coordinates of the points on polygon P2.

    length_2 : Sequence[float]
               Lengths of the line segments on polygon P2.

    phi_2 : Sequence[float]
            Angles of the line segments on polygon P2.

    See Also
    --------
    get_polygon_xld, get_lines_xld

    Predecessors
    ------------
    gen_parallels_xld
    """
    with HalconOperator(41) as proc:
        proc.set_input_object(1, parallels)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_1
            proc.get_output_tuple_m(1),  # col_1
            proc.get_output_tuple_m(2),  # length_1
            proc.get_output_tuple_m(3),  # phi_1
            proc.get_output_tuple_m(4),  # row_2
            proc.get_output_tuple_m(5),  # col_2
            proc.get_output_tuple_m(6),  # length_2
            proc.get_output_tuple_m(7)   # phi_2
        )  # type: ignore


def get_param_info(
    operator_name: str,
    param_name: str,
    slot: str
) -> Sequence[str]:
    """
    Get information concerning the operator parameters.

    Parameters
    ----------

    operator_name : str
                    Name of the operator on whose parameter more
                    information is needed.
                    Value Suggestion: get_param_info

    param_name : str
                 Name of the parameter on which more information is needed.
                 Value Suggestion: Slot

    slot : str
           Desired information.
           Value Suggestion: description

    Returns
    -------

    information : Sequence[str]
                  Information (empty in case there is no information
                  available).

    See Also
    --------
    query_param_info, get_operator_info, get_operator_name

    Alternatives
    ------------
    get_param_names, get_param_num, get_param_types

    Predecessors
    ------------
    get_keywords, search_operator

    Notes
    -----
    The encoding of the result is ISO 8859-1 for English and German, and
    UTF-8 for Japanese.
    """
    with HalconOperator(1115) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, param_name)
        proc.set_input_tuple(2, slot)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_m(0)
        return information  # type: ignore


def get_param_info_s(operator_name: str, param_name: str, slot: str) -> str:
    """
    Get information concerning the operator parameters.

    Parameters
    ----------

    operator_name : str
                    Name of the operator on whose parameter more
                    information is needed.
                    Value Suggestion: get_param_info

    param_name : str
                 Name of the parameter on which more information is needed.
                 Value Suggestion: Slot

    slot : str
           Desired information.
           Value Suggestion: description

    Returns
    -------

    information : str
                  Information (empty in case there is no information
                  available).

    See Also
    --------
    query_param_info, get_operator_info, get_operator_name

    Alternatives
    ------------
    get_param_names, get_param_num, get_param_types

    Predecessors
    ------------
    get_keywords, search_operator

    Notes
    -----
    The encoding of the result is ISO 8859-1 for English and German, and
    UTF-8 for Japanese.
    """
    with HalconOperator(1115) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, param_name)
        proc.set_input_tuple(2, slot)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_s(0)
        return information  # type: ignore


def get_param_names(
    operator_name: str
) -> Tuple[Sequence[str], Sequence[str], Sequence[str], Sequence[str]]:
    """
    Get the names of the parameters of a HALCON-operator.

    Parameters
    ----------

    operator_name : str
                    Name of the operator.
                    Value Suggestion: get_param_names

    Returns
    -------

    inp_obj_par : Sequence[str]
                  Names of the input objects.

    outp_obj_par : Sequence[str]
                   Names of the output objects.

    inp_ctrl_par : Sequence[str]
                   Names of the input control parameters.

    outp_ctrl_par : Sequence[str]
                    Names of the output control parameters.

    See Also
    --------
    get_param_num, get_param_types, get_operator_name

    Alternatives
    ------------
    get_operator_info, get_param_info

    Predecessors
    ------------
    get_keywords, search_operator, get_operator_name, get_operator_info

    Successors
    ----------
    get_param_num, get_param_types
    """
    with HalconOperator(1113) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # inp_obj_par
            proc.get_output_tuple_m(1),  # outp_obj_par
            proc.get_output_tuple_m(2),  # inp_ctrl_par
            proc.get_output_tuple_m(3)   # outp_ctrl_par
        )  # type: ignore


def get_param_num(
    operator_name: str
) -> Tuple[str, int, int, int, int, str]:
    """
    Get number of the different parameter classes of a HALCON-operator.

    Parameters
    ----------

    operator_name : str
                    Name of the operator.
                    Value Suggestion: get_param_num

    Returns
    -------

    cname : str
            Name of the called C-function.

    inp_obj_par : int
                  Number of the input object parameters.

    outp_obj_par : int
                   Number of the output object parameters.

    inp_ctrl_par : int
                   Number of the input control parameters.

    outp_ctrl_par : int
                    Number of the output control parameters.

    type : str
           System operator or user procedure.

    See Also
    --------
    get_param_names, get_param_types, get_operator_name

    Alternatives
    ------------
    get_operator_info, get_param_info

    Predecessors
    ------------
    get_keywords, search_operator, get_operator_name, get_operator_info

    Successors
    ----------
    get_param_types
    """
    with HalconOperator(1112) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # cname
            proc.get_output_tuple_s(1),  # inp_obj_par
            proc.get_output_tuple_s(2),  # outp_obj_par
            proc.get_output_tuple_s(3),  # inp_ctrl_par
            proc.get_output_tuple_s(4),  # outp_ctrl_par
            proc.get_output_tuple_s(5)   # type
        )  # type: ignore


def get_param_types(
    operator_name: str
) -> Tuple[Sequence[str], Sequence[str]]:
    """
    Get default data type for the control parameters of a HALCON-operator.

    Parameters
    ----------

    operator_name : str
                    Name of the operator.
                    Value Suggestion: get_param_types

    Returns
    -------

    inp_ctrl_par_type : Sequence[str]
                        Default type of the input control parameters.

    outp_ctrl_par_type : Sequence[str]
                         Default type of the output control parameters.

    See Also
    --------
    get_param_names, get_param_num, get_operator_info, get_operator_name

    Alternatives
    ------------
    get_param_info

    Predecessors
    ------------
    get_keywords, search_operator, get_operator_name, get_operator_info
    """
    with HalconOperator(1111) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # inp_ctrl_par_type
            proc.get_output_tuple_m(1)   # outp_ctrl_par_type
        )  # type: ignore


def get_params_class_gmm(
    gmmhandle: HHandle
) -> Tuple[int, int, Sequence[int], Sequence[int], str]:
    """
    Return the parameters of a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    Returns
    -------

    num_dim : int
              Number of dimensions of the feature space.

    num_classes : int
                  Number of classes of the GMM.

    min_centers : Sequence[int]
                  Minimum number of centers per GMM class.

    max_centers : Sequence[int]
                  Maximum number of centers per GMM class.

    covar_type : str
                 Type of the covariance matrices.

    See Also
    --------
    evaluate_class_gmm, classify_class_gmm

    Predecessors
    ------------
    create_class_gmm, read_class_gmm

    Successors
    ----------
    add_sample_class_gmm, train_class_gmm
    """
    with HalconOperator(1839) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_dim
            proc.get_output_tuple_s(1),  # num_classes
            proc.get_output_tuple_m(2),  # min_centers
            proc.get_output_tuple_m(3),  # max_centers
            proc.get_output_tuple_s(4)   # covar_type
        )  # type: ignore


def get_params_class_knn(
    knnhandle: HHandle,
    gen_param_name: Sequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Get parameters of a k-NN classification.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    gen_param_name : Sequence[str]
                     Names of the parameters that can be read from the
                     k-NN classifier.
                     Value Suggestion: ['method','k']

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the selected parameters.

    See Also
    --------
    create_class_knn, read_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn

    Successors
    ----------
    classify_class_knn
    """
    with HalconOperator(1811) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_params_class_mlp(
    mlphandle: HHandle
) -> Tuple[int, int, int, str, str, int]:
    """
    Return the parameters of a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    Returns
    -------

    num_input : int
                Number of input variables (features) of the MLP.

    num_hidden : int
                 Number of hidden units of the MLP.

    num_output : int
                 Number of output variables (classes) of the MLP.

    output_function : str
                      Type of the activation function in the output layer
                      of the MLP.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features.

    See Also
    --------
    evaluate_class_mlp, classify_class_mlp

    Predecessors
    ------------
    create_class_mlp, read_class_mlp

    Successors
    ----------
    add_sample_class_mlp, train_class_mlp
    """
    with HalconOperator(1882) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_input
            proc.get_output_tuple_s(1),  # num_hidden
            proc.get_output_tuple_s(2),  # num_output
            proc.get_output_tuple_s(3),  # output_function
            proc.get_output_tuple_s(4),  # preprocessing
            proc.get_output_tuple_s(5)   # num_components
        )  # type: ignore


def get_params_class_svm(
    svmhandle: HHandle
) -> Tuple[int, str, float, float, int, str, str, int]:
    """
    Return the parameters of a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    Returns
    -------

    num_features : int
                   Number of input variables (features) of the SVM.

    kernel_type : str
                  The kernel type.

    kernel_param : float
                   Additional parameter for the kernel.

    nu : float
         Regularization constant of the SVM.

    num_classes : int
                  Number of classes of the test data.

    mode : str
           The mode of the SVM.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').

    See Also
    --------
    classify_class_svm

    Predecessors
    ------------
    create_class_svm, read_class_svm

    Successors
    ----------
    add_sample_class_svm, train_class_svm
    """
    with HalconOperator(1860) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_features
            proc.get_output_tuple_s(1),  # kernel_type
            proc.get_output_tuple_s(2),  # kernel_param
            proc.get_output_tuple_s(3),  # nu
            proc.get_output_tuple_s(4),  # num_classes
            proc.get_output_tuple_s(5),  # mode
            proc.get_output_tuple_s(6),  # preprocessing
            proc.get_output_tuple_s(7)   # num_components
        )  # type: ignore


def get_params_ocr_class_cnn(
    ocrhandle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, str]]:
    """
    Return the parameters of a CNN-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : MaybeSequence[str]
                     A tuple of generic parameter names.
                     Value Suggestion: 'characters'

    Returns
    -------

    gen_param_value : Sequence[Union[int, str]]
                      A tuple of generic parameter values.

    Predecessors
    ------------
    read_ocr_class_cnn

    Successors
    ----------
    do_ocr_single_class_cnn, do_ocr_multi_class_cnn
    """
    with HalconOperator(2072) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_params_ocr_class_cnn_s(
    ocrhandle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, str]:
    """
    Return the parameters of a CNN-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : MaybeSequence[str]
                     A tuple of generic parameter names.
                     Value Suggestion: 'characters'

    Returns
    -------

    gen_param_value : Union[int, str]
                      A tuple of generic parameter values.

    Predecessors
    ------------
    read_ocr_class_cnn

    Successors
    ----------
    do_ocr_single_class_cnn, do_ocr_multi_class_cnn
    """
    with HalconOperator(2072) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_params_ocr_class_knn(
    ocrhandle: HHandle
) -> Tuple[int, int, str, Sequence[str], Sequence[str], str, int]:
    """
    Return the parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.

    interpolation : str
                    Interpolation mode for the zooming of the characters.

    features : Sequence[str]
               Features to be used for classification.

    characters : Sequence[str]
                 Characters of the character set to be read.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_trees : int
                Number of different trees used during the classification.

    See Also
    --------
    trainf_ocr_class_mlp, get_params_class_mlp

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(657) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_character
            proc.get_output_tuple_s(1),  # height_character
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_m(3),  # features
            proc.get_output_tuple_m(4),  # characters
            proc.get_output_tuple_s(5),  # preprocessing
            proc.get_output_tuple_s(6)   # num_trees
        )  # type: ignore


def get_params_ocr_class_knn_s(
    ocrhandle: HHandle
) -> Tuple[int, int, str, str, Sequence[str], str, int]:
    """
    Return the parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.

    interpolation : str
                    Interpolation mode for the zooming of the characters.

    features : str
               Features to be used for classification.

    characters : Sequence[str]
                 Characters of the character set to be read.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_trees : int
                Number of different trees used during the classification.

    See Also
    --------
    trainf_ocr_class_mlp, get_params_class_mlp

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(657) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_character
            proc.get_output_tuple_s(1),  # height_character
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_s(3),  # features
            proc.get_output_tuple_m(4),  # characters
            proc.get_output_tuple_s(5),  # preprocessing
            proc.get_output_tuple_s(6)   # num_trees
        )  # type: ignore


def get_params_ocr_class_mlp(
    ocrhandle: HHandle
) -> Tuple[int, int, str, Sequence[str], Sequence[str], int, str, int]:
    """
    Return the parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.

    interpolation : str
                    Interpolation mode for the zooming of the characters.

    features : Sequence[str]
               Features to be used for classification.

    characters : Sequence[str]
                 Characters of the character set to be read.

    num_hidden : int
                 Number of hidden units of the MLP.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features.

    See Also
    --------
    trainf_ocr_class_mlp, get_params_class_mlp

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(707) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_character
            proc.get_output_tuple_s(1),  # height_character
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_m(3),  # features
            proc.get_output_tuple_m(4),  # characters
            proc.get_output_tuple_s(5),  # num_hidden
            proc.get_output_tuple_s(6),  # preprocessing
            proc.get_output_tuple_s(7)   # num_components
        )  # type: ignore


def get_params_ocr_class_mlp_s(
    ocrhandle: HHandle
) -> Tuple[int, int, str, str, Sequence[str], int, str, int]:
    """
    Return the parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.

    interpolation : str
                    Interpolation mode for the zooming of the characters.

    features : str
               Features to be used for classification.

    characters : Sequence[str]
                 Characters of the character set to be read.

    num_hidden : int
                 Number of hidden units of the MLP.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features.

    See Also
    --------
    trainf_ocr_class_mlp, get_params_class_mlp

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(707) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_character
            proc.get_output_tuple_s(1),  # height_character
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_s(3),  # features
            proc.get_output_tuple_m(4),  # characters
            proc.get_output_tuple_s(5),  # num_hidden
            proc.get_output_tuple_s(6),  # preprocessing
            proc.get_output_tuple_s(7)   # num_components
        )  # type: ignore


def get_params_ocr_class_svm(
    ocrhandle: HHandle
) -> Tuple[int, int, str, Sequence[str], Sequence[str], str, float, float, str, str, int]:
    """
    Return the parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.

    interpolation : str
                    Interpolation mode for the zooming of the characters.

    features : Sequence[str]
               Features to be used for classification.

    characters : Sequence[str]
                 Characters of the character set to be read.

    kernel_type : str
                  The kernel type.

    kernel_param : float
                   Additional parameters for the kernel function.

    nu : float
         Regularization constant of the SVM.

    mode : str
           The mode of the SVM.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').

    See Also
    --------
    trainf_ocr_class_svm, get_params_class_svm

    Predecessors
    ------------
    create_ocr_class_svm, read_ocr_class_svm

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm
    """
    with HalconOperator(688) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.init_oct(10)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_character
            proc.get_output_tuple_s(1),  # height_character
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_m(3),  # features
            proc.get_output_tuple_m(4),  # characters
            proc.get_output_tuple_s(5),  # kernel_type
            proc.get_output_tuple_s(6),  # kernel_param
            proc.get_output_tuple_s(7),  # nu
            proc.get_output_tuple_s(8),  # mode
            proc.get_output_tuple_s(9),  # preprocessing
            proc.get_output_tuple_s(10)   # num_components
        )  # type: ignore


def get_params_ocr_class_svm_s(
    ocrhandle: HHandle
) -> Tuple[int, int, str, str, Sequence[str], str, float, float, str, str, int]:
    """
    Return the parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    width_character : int
                      Width of the rectangle to which the gray values of
                      the segmented character are zoomed.

    height_character : int
                       Height of the rectangle to which the gray values of
                       the segmented character are zoomed.

    interpolation : str
                    Interpolation mode for the zooming of the characters.

    features : str
               Features to be used for classification.

    characters : Sequence[str]
                 Characters of the character set to be read.

    kernel_type : str
                  The kernel type.

    kernel_param : float
                   Additional parameters for the kernel function.

    nu : float
         Regularization constant of the SVM.

    mode : str
           The mode of the SVM.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.

    num_components : int
                     Preprocessing parameter: Number of transformed
                     features (ignored for Preprocessing $=$ 'none' and
                     Preprocessing $=$ 'normalization').

    See Also
    --------
    trainf_ocr_class_svm, get_params_class_svm

    Predecessors
    ------------
    create_ocr_class_svm, read_ocr_class_svm

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm
    """
    with HalconOperator(688) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.init_oct(10)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_character
            proc.get_output_tuple_s(1),  # height_character
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_s(3),  # features
            proc.get_output_tuple_m(4),  # characters
            proc.get_output_tuple_s(5),  # kernel_type
            proc.get_output_tuple_s(6),  # kernel_param
            proc.get_output_tuple_s(7),  # nu
            proc.get_output_tuple_s(8),  # mode
            proc.get_output_tuple_s(9),  # preprocessing
            proc.get_output_tuple_s(10)   # num_components
        )  # type: ignore


def get_part(
    window_handle: HHandle
) -> Tuple[Union[int, float], Union[int, float], Union[int, float], Union[int, float]]:
    """
    Get the image part.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row_1 : Union[int, float]
            Row index of the image part's upper left corner.

    column_1 : Union[int, float]
               Column index of the image part's upper left corner.

    row_2 : Union[int, float]
            Row index of the image part's lower right corner.

    column_2 : Union[int, float]
               Column index of the image part's lower right corner.

    See Also
    --------
    set_part, disp_image, disp_region, disp_color

    Successors
    ----------
    set_part, disp_region, disp_image
    """
    with HalconOperator(1243) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def get_part_style(window_handle: HHandle) -> int:
    """
    Get the current interpolation mode for gray value display.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    style : int
            Interpolation mode for image display: 0 (fast, low quality) to
            2 (slow, high quality).

    See Also
    --------
    set_part_style, set_part, disp_image, disp_color

    Successors
    ----------
    set_part_style, disp_region, disp_image
    """
    with HalconOperator(1242) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        style = proc.get_output_tuple_s(0)
        return style  # type: ignore


def get_pixel(window_handle: HHandle) -> Sequence[int]:
    """
    Get the current color lookup table index.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    pixel : Sequence[int]
            Index of the current color look-up table.

    See Also
    --------
    set_pixel

    Successors
    ----------
    set_pixel, disp_region, disp_image

    Warnings
    --------
    get_pixel is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1241) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        pixel = proc.get_output_tuple_m(0)
        return pixel  # type: ignore


def get_points_ellipse(
    angle: MaybeSequence[float],
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate points on the perimeter of an ellipse.

    Parameters
    ----------

    angle : MaybeSequence[float]
            Angle corresponding to the resulting point [rad].
            Value Suggestion: 0
            Assertion: Angle >= 0 && Angle <= 6.283185307

    row : float
          Row coordinate of the center of the ellipse.

    column : float
             Column coordinate of the center of the ellipse.

    phi : float
          Orientation of the main axis [rad].
          Assertion: Phi >= 0 && Phi <= 6.283185307

    radius_1 : float
               Length of the larger half axis.
               Assertion: Radius1 > 0

    radius_2 : float
               Length of the smaller half axis.
               Assertion: Radius2 >= 0

    Returns
    -------

    row_point : Sequence[float]
                Row coordinate of the point on the ellipse.

    col_point : Sequence[float]
                Column coordinates of the point on the ellipse.

    See Also
    --------
    gen_ellipse_contour_xld

    Predecessors
    ------------
    fit_ellipse_contour_xld, draw_ellipse, gen_ellipse_contour_xld
    """
    with HalconOperator(1339) as proc:
        proc.set_input_tuple(0, angle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, radius_1)
        proc.set_input_tuple(5, radius_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_point
            proc.get_output_tuple_m(1)   # col_point
        )  # type: ignore


def get_points_ellipse_s(
    angle: MaybeSequence[float],
    row: float,
    column: float,
    phi: float,
    radius_1: float,
    radius_2: float
) -> Tuple[float, float]:
    """
    Calculate points on the perimeter of an ellipse.

    Parameters
    ----------

    angle : MaybeSequence[float]
            Angle corresponding to the resulting point [rad].
            Value Suggestion: 0
            Assertion: Angle >= 0 && Angle <= 6.283185307

    row : float
          Row coordinate of the center of the ellipse.

    column : float
             Column coordinate of the center of the ellipse.

    phi : float
          Orientation of the main axis [rad].
          Assertion: Phi >= 0 && Phi <= 6.283185307

    radius_1 : float
               Length of the larger half axis.
               Assertion: Radius1 > 0

    radius_2 : float
               Length of the smaller half axis.
               Assertion: Radius2 >= 0

    Returns
    -------

    row_point : float
                Row coordinate of the point on the ellipse.

    col_point : float
                Column coordinates of the point on the ellipse.

    See Also
    --------
    gen_ellipse_contour_xld

    Predecessors
    ------------
    fit_ellipse_contour_xld, draw_ellipse, gen_ellipse_contour_xld
    """
    with HalconOperator(1339) as proc:
        proc.set_input_tuple(0, angle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, phi)
        proc.set_input_tuple(4, radius_1)
        proc.set_input_tuple(5, radius_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_point
            proc.get_output_tuple_s(1)   # col_point
        )  # type: ignore


def get_polygon_xld(
    polygon: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return an XLD polygon's data.

    Parameters
    ----------

    polygon : HObject
              Input XLD polygon.

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the polygons' points.

    col : Sequence[float]
          Column coordinates of the polygons' points.

    length : Sequence[float]
             Lengths of the line segments.

    phi : Sequence[float]
          Angles of the line segments.

    Alternatives
    ------------
    get_lines_xld

    Predecessors
    ------------
    gen_polygons_xld
    """
    with HalconOperator(44) as proc:
        proc.set_input_object(1, polygon)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # col
            proc.get_output_tuple_m(2),  # length
            proc.get_output_tuple_m(3)   # phi
        )  # type: ignore


def get_pose_type(
    pose: Sequence[Union[int, float]]
) -> Tuple[str, str, str]:
    """
    Get the representation type of a 3D pose.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           3D pose.

    Returns
    -------

    order_of_transform : str
                         Order of rotation and translation.

    order_of_rotation : str
                        Meaning of the rotation values.

    view_of_transform : str
                        View of transformation.

    See Also
    --------
    create_pose, convert_pose_type, write_pose, read_pose

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration

    Successors
    ----------
    convert_pose_type
    """
    with HalconOperator(1919) as proc:
        proc.set_input_tuple(0, pose)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # order_of_transform
            proc.get_output_tuple_s(1),  # order_of_rotation
            proc.get_output_tuple_s(2)   # view_of_transform
        )  # type: ignore


def get_prep_info_class_gmm(
    gmmhandle: HHandle,
    preprocessing: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the information content of the preprocessed feature vectors of
    a GMM.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: principal_components

    Returns
    -------

    information_cont : Sequence[float]
                       Relative information content of the transformed
                       feature vectors.

    cum_information_cont : Sequence[float]
                           Cumulative information content of the
                           transformed feature vectors.

    Predecessors
    ------------
    add_sample_class_gmm, read_samples_class_gmm

    Successors
    ----------
    clear_class_gmm, create_class_gmm
    """
    with HalconOperator(1835) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, preprocessing)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # information_cont
            proc.get_output_tuple_m(1)   # cum_information_cont
        )  # type: ignore


def get_prep_info_class_mlp(
    mlphandle: HHandle,
    preprocessing: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the information content of the preprocessed feature vectors of
    a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: principal_components

    Returns
    -------

    information_cont : Sequence[float]
                       Relative information content of the transformed
                       feature vectors.

    cum_information_cont : Sequence[float]
                           Cumulative information content of the
                           transformed feature vectors.

    Predecessors
    ------------
    add_sample_class_mlp, read_samples_class_mlp

    Successors
    ----------
    clear_class_mlp, create_class_mlp
    """
    with HalconOperator(1874) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, preprocessing)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # information_cont
            proc.get_output_tuple_m(1)   # cum_information_cont
        )  # type: ignore


def get_prep_info_class_svm(
    svmhandle: HHandle,
    preprocessing: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the information content of the preprocessed feature vectors of
    a support vector machine

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: principal_components

    Returns
    -------

    information_cont : Sequence[float]
                       Relative information content of the transformed
                       feature vectors.

    cum_information_cont : Sequence[float]
                           Cumulative information content of the
                           transformed feature vectors.

    Predecessors
    ------------
    add_sample_class_svm, read_samples_class_svm

    Successors
    ----------
    clear_class_svm, create_class_svm
    """
    with HalconOperator(1854) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, preprocessing)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # information_cont
            proc.get_output_tuple_m(1)   # cum_information_cont
        )  # type: ignore


def get_prep_info_ocr_class_mlp(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    preprocessing: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the information content of the preprocessed feature vectors of
    an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: principal_components

    Returns
    -------

    information_cont : Sequence[float]
                       Relative information content of the transformed
                       feature vectors.

    cum_information_cont : Sequence[float]
                           Cumulative information content of the
                           transformed feature vectors.

    Predecessors
    ------------
    create_ocr_class_mlp, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image

    Successors
    ----------
    clear_ocr_class_mlp, create_ocr_class_mlp
    """
    with HalconOperator(702) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, preprocessing)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # information_cont
            proc.get_output_tuple_m(1)   # cum_information_cont
        )  # type: ignore


def get_prep_info_ocr_class_svm(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    preprocessing: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the information content of the preprocessed feature vectors of
    an SVM-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    preprocessing : str
                    Type of preprocessing used to transform the feature
                    vectors.
                    Value Suggestion: principal_components

    Returns
    -------

    information_cont : Sequence[float]
                       Relative information content of the transformed
                       feature vectors.

    cum_information_cont : Sequence[float]
                           Cumulative information content of the
                           transformed feature vectors.

    Predecessors
    ------------
    create_ocr_class_svm, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image

    Successors
    ----------
    clear_ocr_class_svm, create_ocr_class_svm
    """
    with HalconOperator(685) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, preprocessing)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # information_cont
            proc.get_output_tuple_m(1)   # cum_information_cont
        )  # type: ignore


def get_rectangle_pose(
    contour: HObject,
    camera_param: Sequence[Union[int, float, str]],
    width: MaybeSequence[float],
    height: MaybeSequence[float],
    weighting_mode: str,
    clipping_factor: float
) -> Tuple[Sequence[Union[int, float]], Sequence[float], Sequence[float]]:
    """
    Determine the 3D pose of a rectangle from its perspective 2D projection

    Parameters
    ----------

    contour : HObject
              Contour(s) to be examined.

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    width : MaybeSequence[float]
            Width of the rectangle in meters.
            Assertion: Width > 0

    height : MaybeSequence[float]
             Height of the rectangle in meters.
             Assertion: Height > 0

    weighting_mode : str
                     Weighting mode for the optimization phase.
                     Value Suggestion: nonweighted

    clipping_factor : float
                      Clipping factor for the elimination of outliers
                      (typical: 1.0 for 'huber' and 3.0 for 'tukey').
                      Value Suggestion: 2.0
                      Assertion: ClippingFactor > 0

    Returns
    -------

    pose : Sequence[Union[int, float]]
           3D pose of the rectangle.

    cov_pose : Sequence[float]
               Covariances of the pose values.

    error : Sequence[float]
            Root-mean-square value of the final residual error.

    See Also
    --------
    get_circle_pose, set_origin_pose, camera_calibration

    Predecessors
    ------------
    edges_sub_pix
    """
    with HalconOperator(1908) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.set_input_tuple(3, weighting_mode)
        proc.set_input_tuple(4, clipping_factor)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # cov_pose
            proc.get_output_tuple_m(2)   # error
        )  # type: ignore


def get_region_chain(region: HObject) -> Tuple[int, int, Sequence[int]]:
    """
    Contour of an object as chain code.

    Parameters
    ----------

    region : HObject
             Region to be transformed.

    Returns
    -------

    row : int
          Line of starting point.

    column : int
             Column of starting point.

    chain : Sequence[int]
            Direction code of the contour (from starting point).

    See Also
    --------
    copy_obj, get_region_contour, get_region_polygon

    Predecessors
    ------------
    sobel_amp, threshold, skeleton, edges_image, gen_rectangle1, gen_circle

    Successors
    ----------
    approx_chain, approx_chain_simple

    Warnings
    --------
    get_region_chain is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    Holes of the region are ignored. Only one region may be passed, and it
    must have exactly one connection component.
    """
    with HalconOperator(636) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_m(2)   # chain
        )  # type: ignore


def get_region_contour(
    region: HObject
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Access the contour of an object.

    Parameters
    ----------

    region : HObject
             Output region.

    Returns
    -------

    rows : Sequence[int]
           Line numbers of the contour pixels.

    columns : Sequence[int]
              Column numbers of the contour pixels.

    See Also
    --------
    copy_obj, get_region_polygon

    Predecessors
    ------------
    sobel_amp, threshold, skeleton, edges_image, gen_rectangle1, gen_circle

    Notes
    -----
    Holes of the region are ignored. Only one region may be passed, and
    this region must have exactly one connection component.
    """
    with HalconOperator(634) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rows
            proc.get_output_tuple_m(1)   # columns
        )  # type: ignore


def get_region_convex(
    region: HObject
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Access convex hull as contour.

    Parameters
    ----------

    region : HObject
             Output region.

    Returns
    -------

    rows : Sequence[int]
           Line numbers of contour pixels.

    columns : Sequence[int]
              Column numbers of the contour pixels.

    See Also
    --------
    select_obj, get_region_contour

    Alternatives
    ------------
    shape_trans

    Predecessors
    ------------
    threshold, skeleton, dyn_threshold

    Successors
    ----------
    disp_polygon
    """
    with HalconOperator(637) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rows
            proc.get_output_tuple_m(1)   # columns
        )  # type: ignore


def get_region_index(
    regions: HObject,
    row: int,
    column: int
) -> Sequence[int]:
    """
    Index of all regions containing a given pixel.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    row : int
          Line index of the test pixel.
          Value Suggestion: 100

    column : int
             Column index of the test pixel.
             Value Suggestion: 100

    Returns
    -------

    index : Sequence[int]
            Index of the regions containing the test pixel.

    See Also
    --------
    get_mbutton, get_mposition, test_region_point

    Alternatives
    ------------
    select_region_point

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    If the regions overlap more than one region might contain the pixel.
    In this case all these regions are returned. If no region contains the
    indicated pixel the empty tuple (= no region) is returned.
    """
    with HalconOperator(1713) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_m(0)
        return index  # type: ignore


def get_region_index_s(regions: HObject, row: int, column: int) -> int:
    """
    Index of all regions containing a given pixel.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    row : int
          Line index of the test pixel.
          Value Suggestion: 100

    column : int
             Column index of the test pixel.
             Value Suggestion: 100

    Returns
    -------

    index : int
            Index of the regions containing the test pixel.

    See Also
    --------
    get_mbutton, get_mposition, test_region_point

    Alternatives
    ------------
    select_region_point

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    If the regions overlap more than one region might contain the pixel.
    In this case all these regions are returned. If no region contains the
    indicated pixel the empty tuple (= no region) is returned.
    """
    with HalconOperator(1713) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def get_region_points(
    region: HObject
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Access the pixels of a region.

    Parameters
    ----------

    region : HObject
             This region is accessed.

    Returns
    -------

    rows : Sequence[int]
           Line numbers of the pixels in the region

    columns : Sequence[int]
              Column numbers of the pixels in the region.

    See Also
    --------
    copy_obj, gen_region_points

    Alternatives
    ------------
    get_region_runs

    Predecessors
    ------------
    sobel_amp, threshold, connection

    Notes
    -----
    Only one region may be passed.
    """
    with HalconOperator(633) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rows
            proc.get_output_tuple_m(1)   # columns
        )  # type: ignore


def get_region_polygon(
    region: HObject,
    tolerance: Union[int, float]
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Polygon approximation of a region.

    Parameters
    ----------

    region : HObject
             Region to be approximated.

    tolerance : Union[int, float]
                Maximum distance between the polygon and the edge of the
                region.
                Value Suggestion: 5.0

    Returns
    -------

    rows : Sequence[int]
           Line numbers of the base points of the contour.

    columns : Sequence[int]
              Column numbers of the base points of the contour.

    See Also
    --------
    copy_obj, gen_region_polygon, disp_polygon, get_region_contour,
    set_line_approx

    Predecessors
    ------------
    sobel_amp, threshold, skeleton, edges_image

    Notes
    -----
    Holes of the region are ignored. Only one region may be passed, and
    this region must have exactly one connection component.
    """
    with HalconOperator(632) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, tolerance)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rows
            proc.get_output_tuple_m(1)   # columns
        )  # type: ignore


def get_region_runs(
    region: HObject
) -> Tuple[Sequence[int], Sequence[int], Sequence[int]]:
    """
    Access the runlength coding of a region.

    Parameters
    ----------

    region : HObject
             Output region.

    Returns
    -------

    row : Sequence[int]
          Line numbers of the chords.

    column_begin : Sequence[int]
                   Column numbers of the starting points of the chords.

    column_end : Sequence[int]
                 Column numbers of the ending points of the chords.

    See Also
    --------
    copy_obj, gen_region_runs

    Alternatives
    ------------
    get_region_points

    Predecessors
    ------------
    threshold, connection

    Notes
    -----
    Only one region may be passed.
    """
    with HalconOperator(635) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column_begin
            proc.get_output_tuple_m(2)   # column_end
        )  # type: ignore


def get_region_thickness(
    region: HObject
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Access the thickness of a region along the main axis.

    Parameters
    ----------

    region : HObject
             Region to be analyzed.

    Returns
    -------

    thickness : Sequence[int]
                Thickness of the region along its main axis.

    histogramm : Sequence[int]
                 Histogram of the thickness of the region along its main
                 axis.

    See Also
    --------
    copy_obj, elliptic_axis

    Predecessors
    ------------
    sobel_amp, threshold, connection, select_shape, select_obj

    Notes
    -----
    Only one region may be passed.  If the region has several connection
    components, only the first one is investigated.  All other components
    are ignored.
    """
    with HalconOperator(631) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # thickness
            proc.get_output_tuple_m(1)   # histogramm
        )  # type: ignore


def get_regress_params_xld(
    contours: HObject
) -> Tuple[Sequence[int], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return XLD contour parameters.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    Returns
    -------

    length : Sequence[int]
             Number of contour points.

    nx : Sequence[float]
         X-coordinate of the normal vector of the regression line.

    ny : Sequence[float]
         Y-coordinate of the normal vector of the regression line.

    dist : Sequence[float]
           Distance of the regression line from the origin.

    fpx : Sequence[float]
          X-coordinate of the projection of the start point of the contour
          onto the regression line.

    fpy : Sequence[float]
          Y-coordinate of the projection of the start point of the contour
          onto the regression line.

    lpx : Sequence[float]
          X-coordinate of the projection of the end point of the contour
          onto the regression line.

    lpy : Sequence[float]
          Y-coordinate of the projection of the end point of the contour
          onto the regression line.

    mean : Sequence[float]
           Mean distance of the contour points from the regression line.

    deviation : Sequence[float]
                Standard deviation of the distances from the regression
                line.

    See Also
    --------
    fit_line_contour_xld, get_contour_global_attrib_xld,
    query_contour_global_attribs_xld, get_contour_xld,
    get_contour_attrib_xld, gen_contours_skeleton_xld, lines_gauss,
    lines_facet, edges_sub_pix

    Predecessors
    ------------
    regress_contours_xld

    Successors
    ----------
    disp_line, line_orientation

    Notes
    -----
    Before the contour parameters can be returned by
    get_regress_params_xld, the parameters of the regression line to the
    contour must be calculated by calling regress_contours_xld.
    """
    with HalconOperator(60) as proc:
        proc.set_input_object(1, contours)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # length
            proc.get_output_tuple_m(1),  # nx
            proc.get_output_tuple_m(2),  # ny
            proc.get_output_tuple_m(3),  # dist
            proc.get_output_tuple_m(4),  # fpx
            proc.get_output_tuple_m(5),  # fpy
            proc.get_output_tuple_m(6),  # lpx
            proc.get_output_tuple_m(7),  # lpy
            proc.get_output_tuple_m(8),  # mean
            proc.get_output_tuple_m(9)   # deviation
        )  # type: ignore


def get_regularization_params_class_mlp(
    mlphandle: HHandle,
    gen_param_name: str
) -> Sequence[Union[float, int]]:
    """
    Return the regularization parameters of a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : str
                     Name of the regularization parameter to return.
                     Value Suggestion: weight_prior

    Returns
    -------

    gen_param_value : Sequence[Union[float, int]]
                      Value of the regularization parameter.

    Predecessors
    ------------
    set_regularization_params_class_mlp, read_class_mlp

    Successors
    ----------
    train_class_mlp
    """
    with HalconOperator(1880) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_regularization_params_class_mlp_s(
    mlphandle: HHandle,
    gen_param_name: str
) -> Union[float, int]:
    """
    Return the regularization parameters of a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : str
                     Name of the regularization parameter to return.
                     Value Suggestion: weight_prior

    Returns
    -------

    gen_param_value : Union[float, int]
                      Value of the regularization parameter.

    Predecessors
    ------------
    set_regularization_params_class_mlp, read_class_mlp

    Successors
    ----------
    train_class_mlp
    """
    with HalconOperator(1880) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_regularization_params_ocr_class_mlp(
    ocrhandle: HHandle,
    gen_param_name: str
) -> Sequence[Union[float, int]]:
    """
    Return the regularization parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : str
                     Name of the regularization parameter to return.
                     Value Suggestion: weight_prior

    Returns
    -------

    gen_param_value : Sequence[Union[float, int]]
                      Value of the regularization parameter.

    Predecessors
    ------------
    set_regularization_params_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    trainf_ocr_class_mlp
    """
    with HalconOperator(705) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_regularization_params_ocr_class_mlp_s(
    ocrhandle: HHandle,
    gen_param_name: str
) -> Union[float, int]:
    """
    Return the regularization parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : str
                     Name of the regularization parameter to return.
                     Value Suggestion: weight_prior

    Returns
    -------

    gen_param_value : Union[float, int]
                      Value of the regularization parameter.

    Predecessors
    ------------
    set_regularization_params_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    trainf_ocr_class_mlp
    """
    with HalconOperator(705) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_rejection_params_class_mlp(
    mlphandle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[str, float, int]]:
    """
    Get the parameters of a rejection class.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters to return.
                     Value Suggestion: sampling_strategy

    Returns
    -------

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    train_class_mlp
    """
    with HalconOperator(1877) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_rejection_params_class_mlp_s(
    mlphandle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[str, float, int]:
    """
    Get the parameters of a rejection class.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters to return.
                     Value Suggestion: sampling_strategy

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Values of the generic parameters.

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    train_class_mlp
    """
    with HalconOperator(1877) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_rejection_params_ocr_class_mlp(
    ocrhandle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[str]:
    """
    Return the rejection class parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the general parameter.
                     Value Suggestion: sampling_strategy

    Returns
    -------

    gen_param_value : Sequence[str]
                      Value of the general parameter.

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    trainf_ocr_class_mlp
    """
    with HalconOperator(703) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_rejection_params_ocr_class_mlp_s(
    ocrhandle: HHandle,
    gen_param_name: MaybeSequence[str]
) -> str:
    """
    Return the rejection class parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the general parameter.
                     Value Suggestion: sampling_strategy

    Returns
    -------

    gen_param_value : str
                      Value of the general parameter.

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    trainf_ocr_class_mlp
    """
    with HalconOperator(703) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_rgb(
    window_handle: HHandle
) -> Tuple[Sequence[int], Sequence[int], Sequence[int]]:
    """
    Get the current color in RGB-coding.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    red : Sequence[int]
          The current color's red value.

    green : Sequence[int]
            The current color's green value.

    blue : Sequence[int]
           The current color's blue value.

    See Also
    --------
    set_rgb

    Successors
    ----------
    set_rgb, disp_region, disp_image
    """
    with HalconOperator(1240) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # red
            proc.get_output_tuple_m(1),  # green
            proc.get_output_tuple_m(2)   # blue
        )  # type: ignore


def get_rgba(
    window_handle: HHandle
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Get the current color in RGBA-coding.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    red : Sequence[int]
          The current color's red value.

    green : Sequence[int]
            The current color's green value.

    blue : Sequence[int]
           The current color's blue value.

    alpha : Sequence[int]
            The current color's alpha value.

    See Also
    --------
    set_rgba

    Successors
    ----------
    set_rgba, disp_obj

    Notes
    -----
    get_rgba depends on the library libcanvas, which might not be
    available on embedded systems.
    """
    with HalconOperator(2073) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # red
            proc.get_output_tuple_m(1),  # green
            proc.get_output_tuple_m(2),  # blue
            proc.get_output_tuple_m(3)   # alpha
        )  # type: ignore


def get_sample_class_gmm(
    gmmhandle: HHandle,
    num_sample: int
) -> Tuple[Sequence[float], int]:
    """
    Return a training sample from the training data of a Gaussian Mixture
    Models (GMM).

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    num_sample : int
                 Index of the stored training sample.

    Returns
    -------

    features : Sequence[float]
               Feature vector of the training sample.

    class_id : int
               Class of the training sample.

    See Also
    --------
    create_class_gmm

    Predecessors
    ------------
    add_sample_class_gmm, add_samples_image_class_gmm,
    read_samples_class_gmm, get_sample_num_class_gmm

    Successors
    ----------
    classify_class_gmm, evaluate_class_gmm
    """
    with HalconOperator(1837) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, num_sample)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # features
            proc.get_output_tuple_s(1)   # class_id
        )  # type: ignore


def get_sample_class_knn(
    knnhandle: HHandle,
    index_sample: int
) -> Tuple[Sequence[float], Sequence[int]]:
    """
    Return a training sample from the training data of a k-nearest
    neighbors  (k-NN) classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    index_sample : int
                   Index of the training sample.

    Returns
    -------

    features : Sequence[float]
               Feature vector of the training sample.

    class_id : Sequence[int]
               Class of the training sample.

    See Also
    --------
    create_class_knn

    Predecessors
    ------------
    add_sample_class_train_data
    """
    with HalconOperator(1806) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, index_sample)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # features
            proc.get_output_tuple_m(1)   # class_id
        )  # type: ignore


def get_sample_class_mlp(
    mlphandle: HHandle,
    index_sample: int
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Return a training sample from the training data of a multilayer
    perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    index_sample : int
                   Number of stored training sample.

    Returns
    -------

    features : Sequence[float]
               Feature vector of the training sample.

    target : Sequence[float]
             Target vector of the training sample.

    See Also
    --------
    create_class_mlp

    Predecessors
    ------------
    add_sample_class_mlp, read_samples_class_mlp, get_sample_num_class_mlp

    Successors
    ----------
    classify_class_mlp, evaluate_class_mlp
    """
    with HalconOperator(1876) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, index_sample)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # features
            proc.get_output_tuple_m(1)   # target
        )  # type: ignore


def get_sample_class_svm(
    svmhandle: HHandle,
    index_sample: int
) -> Tuple[Sequence[float], int]:
    """
    Return a training sample from the training data of a support vector
    machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    index_sample : int
                   Number of the stored training sample.

    Returns
    -------

    features : Sequence[float]
               Feature vector of the training sample.

    target : int
             Target vector of the training sample.

    See Also
    --------
    create_class_svm

    Predecessors
    ------------
    add_sample_class_svm, read_samples_class_svm,
    get_sample_num_class_svm, get_support_vector_class_svm

    Successors
    ----------
    classify_class_svm
    """
    with HalconOperator(1858) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, index_sample)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # features
            proc.get_output_tuple_s(1)   # target
        )  # type: ignore


def get_sample_class_train_data(
    class_train_data_handle: HHandle,
    index_sample: int
) -> Tuple[Sequence[float], int]:
    """
    Return a training sample from training data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of training data for a classifier.

    index_sample : int
                   Number of stored training sample.

    Returns
    -------

    features : Sequence[float]
               Feature vector of the training sample.

    class_id : int
               Class of the training sample.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    add_sample_class_train_data
    """
    with HalconOperator(1794) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, index_sample)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # features
            proc.get_output_tuple_s(1)   # class_id
        )  # type: ignore


def get_sample_identifier_object_info(
    sample_identifier: HHandle,
    object_idx: MaybeSequence[Union[int, str]],
    info_name: MaybeSequence[str]
) -> Sequence[Union[int, str]]:
    """
    Retrieve information about an object of a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : MaybeSequence[Union[int, str]]
                 Index of the object for which information is retrieved.

    info_name : MaybeSequence[str]
                Define, for which kind of object information is retrieved.
                Value Suggestion: num_training_objects

    Returns
    -------

    info_value : Sequence[Union[int, str]]
                 Information about the object.

    See Also
    --------
    create_sample_identifier, prepare_sample_identifier,
    train_sample_identifier, apply_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    read_sample_identifier, serialize_sample_identifier,
    deserialize_sample_identifier, clear_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_preparation_data,
    add_sample_identifier_training_data
    """
    with HalconOperator(907) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, info_name)
        proc.init_oct(0)
        proc.execute()
        info_value = proc.get_output_tuple_m(0)
        return info_value  # type: ignore


def get_sample_identifier_object_info_s(
    sample_identifier: HHandle,
    object_idx: MaybeSequence[Union[int, str]],
    info_name: MaybeSequence[str]
) -> Union[int, str]:
    """
    Retrieve information about an object of a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : MaybeSequence[Union[int, str]]
                 Index of the object for which information is retrieved.

    info_name : MaybeSequence[str]
                Define, for which kind of object information is retrieved.
                Value Suggestion: num_training_objects

    Returns
    -------

    info_value : Union[int, str]
                 Information about the object.

    See Also
    --------
    create_sample_identifier, prepare_sample_identifier,
    train_sample_identifier, apply_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    read_sample_identifier, serialize_sample_identifier,
    deserialize_sample_identifier, clear_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_preparation_data,
    add_sample_identifier_training_data
    """
    with HalconOperator(907) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, info_name)
        proc.init_oct(0)
        proc.execute()
        info_value = proc.get_output_tuple_s(0)
        return info_value  # type: ignore


def get_sample_identifier_param(
    sample_identifier: HHandle,
    gen_param_name: str
) -> Union[str, float, int]:
    """
    Get selected parameters of a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    gen_param_name : str
                     Parameter name.
                     Value Suggestion: rating_method

    Returns
    -------

    gen_param_value : Union[str, float, int]
                      Parameter value.

    See Also
    --------
    add_sample_identifier_preparation_data, prepare_sample_identifier,
    add_sample_identifier_training_data, train_sample_identifier,
    apply_sample_identifier, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    read_sample_identifier, serialize_sample_identifier,
    deserialize_sample_identifier, clear_sample_identifier,
    set_sample_identifier_object_info

    Predecessors
    ------------
    create_sample_identifier, set_sample_identifier_param
    """
    with HalconOperator(905) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_sample_num_class_gmm(gmmhandle: HHandle) -> int:
    """
    Return the number of training samples stored in the training data of a
    Gaussian Mixture Model (GMM).

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    Returns
    -------

    num_samples : int
                  Number of stored training samples.

    See Also
    --------
    create_class_gmm

    Predecessors
    ------------
    add_sample_class_gmm, add_samples_image_class_gmm,
    read_samples_class_gmm

    Successors
    ----------
    get_sample_class_gmm
    """
    with HalconOperator(1836) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.init_oct(0)
        proc.execute()
        num_samples = proc.get_output_tuple_s(0)
        return num_samples  # type: ignore


def get_sample_num_class_knn(knnhandle: HHandle) -> int:
    """
    Return the number of training samples stored in the training data of a
    k-nearest neighbors (k-NN) classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    Returns
    -------

    num_samples : int
                  Number of stored training samples.

    See Also
    --------
    create_class_knn

    Predecessors
    ------------
    add_sample_class_knn

    Successors
    ----------
    get_sample_class_knn
    """
    with HalconOperator(1805) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.init_oct(0)
        proc.execute()
        num_samples = proc.get_output_tuple_s(0)
        return num_samples  # type: ignore


def get_sample_num_class_mlp(mlphandle: HHandle) -> int:
    """
    Return the number of training samples stored in the training data of a
    multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    Returns
    -------

    num_samples : int
                  Number of stored training samples.

    See Also
    --------
    create_class_mlp

    Predecessors
    ------------
    add_sample_class_mlp, read_samples_class_mlp

    Successors
    ----------
    get_sample_class_mlp
    """
    with HalconOperator(1875) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.init_oct(0)
        proc.execute()
        num_samples = proc.get_output_tuple_s(0)
        return num_samples  # type: ignore


def get_sample_num_class_svm(svmhandle: HHandle) -> int:
    """
    Return the number of training samples stored in the training data of a
    support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    Returns
    -------

    num_samples : int
                  Number of stored training samples.

    See Also
    --------
    create_class_svm

    Predecessors
    ------------
    add_sample_class_svm, read_samples_class_svm

    Successors
    ----------
    get_sample_class_svm
    """
    with HalconOperator(1857) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.init_oct(0)
        proc.execute()
        num_samples = proc.get_output_tuple_s(0)
        return num_samples  # type: ignore


def get_sample_num_class_train_data(
    class_train_data_handle: HHandle
) -> int:
    """
    Return the number of training samples stored in the training data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of training data.

    Returns
    -------

    num_samples : int
                  Number of stored training samples.

    See Also
    --------
    create_class_train_data

    Predecessors
    ------------
    add_sample_class_train_data

    Successors
    ----------
    get_sample_class_train_data
    """
    with HalconOperator(1793) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.init_oct(0)
        proc.execute()
        num_samples = proc.get_output_tuple_s(0)
        return num_samples  # type: ignore


def get_serial_param(
    serial_handle: HHandle
) -> Tuple[int, int, str, str, int, int, int]:
    """
    Get the parameters of a serial device.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    Returns
    -------

    baud_rate : int
                Speed of the serial interface.

    data_bits : int
                Number of data bits of the serial interface.

    flow_control : str
                   Type of flow control of the serial interface.

    parity : str
             Parity of the serial interface.

    stop_bits : int
                Number of stop bits of the serial interface.

    total_time_out : int
                     Total timeout of the serial interface in ms.

    inter_char_time_out : int
                          Inter-character timeout of the serial interface
                          in ms.

    See Also
    --------
    set_serial_param

    Predecessors
    ------------
    open_serial

    Successors
    ----------
    read_serial, write_serial
    """
    with HalconOperator(310) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # baud_rate
            proc.get_output_tuple_s(1),  # data_bits
            proc.get_output_tuple_s(2),  # flow_control
            proc.get_output_tuple_s(3),  # parity
            proc.get_output_tuple_s(4),  # stop_bits
            proc.get_output_tuple_s(5),  # total_time_out
            proc.get_output_tuple_s(6)   # inter_char_time_out
        )  # type: ignore


def get_serialized_item_ptr(
    serialized_item_handle: HHandle
) -> Tuple[int, int]:
    """
    Access the data pointer of a serialized item.

    Parameters
    ----------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Returns
    -------

    pointer : int
              Data pointer of the serialized item.

    size : int
           Size of the serialized item.

    Predecessors
    ------------
    create_serialized_item_ptr

    Warnings
    --------
    It is not recommended to use the operator get_serialized_item_ptr in
    HDevelop.
    """
    with HalconOperator(409) as proc:
        proc.set_input_tuple(0, serialized_item_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # pointer
            proc.get_output_tuple_s(1)   # size
        )  # type: ignore


def get_shape(window_handle: HHandle) -> str:
    """
    Get the current region output shape.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    display_shape : str
                    Current region output shape.

    See Also
    --------
    set_shape, query_shape, disp_region

    Predecessors
    ------------
    query_shape

    Successors
    ----------
    set_shape, disp_region
    """
    with HalconOperator(1239) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        display_shape = proc.get_output_tuple_s(0)
        return display_shape  # type: ignore


def get_shape_model_3d_contours(
    shape_model_3did: HHandle,
    level: int,
    view: int
) -> Tuple[HObject, Sequence[Union[int, float]]]:
    """
    Return the contour representation of a 3D shape model view.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    level : int
            Pyramid level for which the contour representation should be
            returned.
            Value Suggestion: 1
            Assertion: Level >= 1

    view : int
           View for which the contour representation should be returned.
           Value Suggestion: 1
           Assertion: View >= 1

    Returns
    -------

    model_contours : HObject
                     Contour representation of the model view.

    view_pose : Sequence[Union[int, float]]
                3D pose of the 3D shape model at the current view.

    Predecessors
    ------------
    create_shape_model_3d, read_shape_model_3d, get_shape_model_3d_params

    Successors
    ----------
    create_shape_model_3d
    """
    with HalconOperator(1056) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, level)
        proc.set_input_tuple(2, view)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # model_contours
            proc.get_output_tuple_m(0)   # view_pose
        )  # type: ignore


def get_shape_model_3d_params(
    shape_model_3did: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, str, float]]:
    """
    Return the parameters of a 3D shape model.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the 3D shape model.
                     Value Suggestion: num_levels_max

    Returns
    -------

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters.

    See Also
    --------
    convert_point_3d_cart_to_spher, convert_point_3d_spher_to_cart,
    create_cam_pose_look_at_point, trans_pose_shape_model_3d

    Predecessors
    ------------
    create_shape_model_3d, read_shape_model_3d

    Successors
    ----------
    find_shape_model_3d
    """
    with HalconOperator(1057) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_shape_model_3d_params_s(
    shape_model_3did: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, str, float]:
    """
    Return the parameters of a 3D shape model.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that are to be
                     queried for the 3D shape model.
                     Value Suggestion: num_levels_max

    Returns
    -------

    gen_param_value : Union[int, str, float]
                      Values of the generic parameters.

    See Also
    --------
    convert_point_3d_cart_to_spher, convert_point_3d_spher_to_cart,
    create_cam_pose_look_at_point, trans_pose_shape_model_3d

    Predecessors
    ------------
    create_shape_model_3d, read_shape_model_3d

    Successors
    ----------
    find_shape_model_3d
    """
    with HalconOperator(1057) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_shape_model_clutter(
    model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Tuple[HObject, Sequence[Union[float, int, str]], Sequence[float], int]:
    """
    Get the clutter parameters of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : MaybeSequence[str]
                     Parameter names.
                     Value Suggestion: use_clutter

    Returns
    -------

    clutter_region : HObject
                     Region where no clutter should occur.

    gen_param_value : Sequence[Union[float, int, str]]
                      Parameter values.

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    clutter_contrast : int
                       Minimum contrast of clutter in the search images.

    See Also
    --------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, set_shape_model_param

    Predecessors
    ------------
    set_shape_model_clutter, read_shape_model, deserialize_shape_model

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models
    """
    with HalconOperator(2178) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # clutter_region
            proc.get_output_tuple_m(0),  # gen_param_value
            proc.get_output_tuple_m(1),  # hom_mat_2d
            proc.get_output_tuple_s(2)   # clutter_contrast
        )  # type: ignore


def get_shape_model_clutter_s(
    model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Tuple[HObject, Union[float, int, str], Sequence[float], int]:
    """
    Get the clutter parameters of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : MaybeSequence[str]
                     Parameter names.
                     Value Suggestion: use_clutter

    Returns
    -------

    clutter_region : HObject
                     Region where no clutter should occur.

    gen_param_value : Union[float, int, str]
                      Parameter values.

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    clutter_contrast : int
                       Minimum contrast of clutter in the search images.

    See Also
    --------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, set_shape_model_param

    Predecessors
    ------------
    set_shape_model_clutter, read_shape_model, deserialize_shape_model

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models
    """
    with HalconOperator(2178) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # clutter_region
            proc.get_output_tuple_s(0),  # gen_param_value
            proc.get_output_tuple_m(1),  # hom_mat_2d
            proc.get_output_tuple_s(2)   # clutter_contrast
        )  # type: ignore


def get_shape_model_contours(model_id: HHandle, level: int) -> HObject:
    """
    Return the contour representation of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    level : int
            Pyramid level for which the contour representation should be
            returned.
            Value Suggestion: 1
            Assertion: Level >= 1

    Returns
    -------

    model_contours : HObject
                     Contour representation of the shape model.

    See Also
    --------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, read_shape_model
    """
    with HalconOperator(922) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, level)
        proc.execute()
        model_contours = HObject(proc.get_output_object_key(1))
        return model_contours  # type: ignore


def get_shape_model_origin(model_id: HHandle) -> Tuple[float, float]:
    """
    Return the origin (reference point) of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    row : float
          Row coordinate of the origin of the shape model.

    column : float
             Column coordinate of the origin of the shape model.

    See Also
    --------
    area_center

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, read_shape_model, set_shape_model_origin

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models
    """
    with HalconOperator(925) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def get_shape_model_params(
    model_id: HHandle
) -> Tuple[Sequence[int], float, float, float, Sequence[float], Sequence[float], Sequence[float], str, int]:
    """
    Return the parameters of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    num_levels : Sequence[int]
                 Number of pyramid levels.

    angle_start : float
                  Smallest rotation of the pattern.

    angle_extent : float
                   Extent of the rotation angles.
                   Assertion: AngleExtent >= 0

    angle_step : float
                 Step length of the angles (resolution).
                 Assertion: AngleStep >= 0 && AngleStep <= pi / 16

    scale_min : Sequence[float]
                Minimum scale of the pattern.
                Assertion: ScaleMin > 0

    scale_max : Sequence[float]
                Maximum scale of the pattern.
                Assertion: ScaleMax >= ScaleMin

    scale_step : Sequence[float]
                 Scale step length (resolution).
                 Assertion: ScaleStep >= 0

    metric : str
             Match metric.

    min_contrast : int
                   Minimum contrast of the objects in the search images.

    See Also
    --------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, read_shape_model
    """
    with HalconOperator(924) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # num_levels
            proc.get_output_tuple_s(1),  # angle_start
            proc.get_output_tuple_s(2),  # angle_extent
            proc.get_output_tuple_s(3),  # angle_step
            proc.get_output_tuple_m(4),  # scale_min
            proc.get_output_tuple_m(5),  # scale_max
            proc.get_output_tuple_m(6),  # scale_step
            proc.get_output_tuple_s(7),  # metric
            proc.get_output_tuple_s(8)   # min_contrast
        )  # type: ignore


def get_shape_model_params_s(
    model_id: HHandle
) -> Tuple[int, float, float, float, float, float, float, str, int]:
    """
    Return the parameters of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    num_levels : int
                 Number of pyramid levels.

    angle_start : float
                  Smallest rotation of the pattern.

    angle_extent : float
                   Extent of the rotation angles.
                   Assertion: AngleExtent >= 0

    angle_step : float
                 Step length of the angles (resolution).
                 Assertion: AngleStep >= 0 && AngleStep <= pi / 16

    scale_min : float
                Minimum scale of the pattern.
                Assertion: ScaleMin > 0

    scale_max : float
                Maximum scale of the pattern.
                Assertion: ScaleMax >= ScaleMin

    scale_step : float
                 Scale step length (resolution).
                 Assertion: ScaleStep >= 0

    metric : str
             Match metric.

    min_contrast : int
                   Minimum contrast of the objects in the search images.

    See Also
    --------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, read_shape_model
    """
    with HalconOperator(924) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_levels
            proc.get_output_tuple_s(1),  # angle_start
            proc.get_output_tuple_s(2),  # angle_extent
            proc.get_output_tuple_s(3),  # angle_step
            proc.get_output_tuple_s(4),  # scale_min
            proc.get_output_tuple_s(5),  # scale_max
            proc.get_output_tuple_s(6),  # scale_step
            proc.get_output_tuple_s(7),  # metric
            proc.get_output_tuple_s(8)   # min_contrast
        )  # type: ignore


def get_sheet_of_light_param(
    sheet_of_light_model_id: HHandle,
    gen_param_name: str
) -> Sequence[Union[int, float, str]]:
    """
    Get the value of a parameter, which has been set in a sheet-of-light
    model.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    gen_param_name : str
                     Name of the generic parameter that shall be queried.
                     Value Suggestion: method

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Value of the model parameter that shall be queried.

    Predecessors
    ------------
    query_sheet_of_light_params, set_sheet_of_light_param

    Successors
    ----------
    measure_profile_sheet_of_light, set_sheet_of_light_param,
    apply_sheet_of_light_calibration
    """
    with HalconOperator(386) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_sheet_of_light_param_s(
    sheet_of_light_model_id: HHandle,
    gen_param_name: str
) -> Union[int, float, str]:
    """
    Get the value of a parameter, which has been set in a sheet-of-light
    model.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    gen_param_name : str
                     Name of the generic parameter that shall be queried.
                     Value Suggestion: method

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Value of the model parameter that shall be queried.

    Predecessors
    ------------
    query_sheet_of_light_params, set_sheet_of_light_param

    Successors
    ----------
    measure_profile_sheet_of_light, set_sheet_of_light_param,
    apply_sheet_of_light_calibration
    """
    with HalconOperator(386) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_sheet_of_light_result(
    sheet_of_light_model_id: HHandle,
    result_name: MaybeSequence[str]
) -> HObject:
    """
    Get the iconic results of a measurement performed with the sheet-of
    light technique.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model to be
                              used.

    result_name : MaybeSequence[str]
                  Specify which result of the measurement shall be
                  provided.
                  Value Suggestion: disparity

    Returns
    -------

    result_value : HObject
                   Desired measurement result.
    """
    with HalconOperator(381) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, result_name)
        proc.execute()
        result_value = HObject(proc.get_output_object_key(1))
        return result_value  # type: ignore


def get_sheet_of_light_result_object_model_3d(
    sheet_of_light_model_id: HHandle
) -> HHandle:
    """
    Get the result of a calibrated measurement performed with the
    sheet-of-light technique as a 3D object model.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle for accessing the sheet-of-light
                              model.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the resulting 3D object model.

    Predecessors
    ------------
    create_sheet_of_light_model, measure_profile_sheet_of_light,
    calibrate_sheet_of_light

    Successors
    ----------
    clear_object_model_3d
    """
    with HalconOperator(380) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def get_size_matrix(matrix_id: HHandle) -> Tuple[int, int]:
    """
    Get the size of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    rows : int
           Number of rows of the matrix.

    columns : int
              Number of columns of the matrix.

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(884) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # rows
            proc.get_output_tuple_s(1)   # columns
        )  # type: ignore


def get_socket_descriptor(socket: HHandle) -> int:
    """
    Get the socket descriptor of a socket used by the operating system.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    socket_descriptor : int
                        Socket descriptor used by the operating system.

    See Also
    --------
    set_socket_param

    Predecessors
    ------------
    open_socket_accept, open_socket_connect, socket_accept_connect
    """
    with HalconOperator(338) as proc:
        proc.set_input_tuple(0, socket)
        proc.init_oct(0)
        proc.execute()
        socket_descriptor = proc.get_output_tuple_s(0)
        return socket_descriptor  # type: ignore


def get_socket_param(
    socket: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[float, int, str]:
    """
    Get the value of a socket parameter.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    gen_param_name : MaybeSequence[str]
                     Name of the socket parameter.

    Returns
    -------

    gen_param_value : Union[float, int, str]
                      Value of the socket parameter.

    See Also
    --------
    set_socket_param

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect

    Successors
    ----------
    set_socket_param
    """
    with HalconOperator(335) as proc:
        proc.set_input_tuple(0, socket)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_spy(class_val: str) -> Union[str, int, float]:
    """
    Current configuration of the HALCON debugging-tool.

    Parameters
    ----------

    class_val : str
                Control mode
                Value Suggestion: mode

    Returns
    -------

    value : Union[str, int, float]
            State of the control mode.

    See Also
    --------
    set_spy, query_spy

    Predecessors
    ------------
    reset_obj_db
    """
    with HalconOperator(373) as proc:
        proc.set_input_tuple(0, class_val)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_stereo_model_image_pairs(
    stereo_model_id: HHandle
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Return the list of image pairs set in a stereo model.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    Returns
    -------

    from_val : Sequence[int]
               Camera indices for the from cameras in the image pairs.

    to : Sequence[int]
         Camera indices for the to cameras in the image pairs.

    See Also
    --------
    set_stereo_model_image_pairs

    Predecessors
    ------------
    set_stereo_model_image_pairs

    Successors
    ----------
    reconstruct_surface_stereo
    """
    with HalconOperator(523) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # from_val
            proc.get_output_tuple_m(1)   # to
        )  # type: ignore


def get_stereo_model_object(
    stereo_model_id: HHandle,
    pair_index: MaybeSequence[Union[int, str, float]],
    object_name: str
) -> HObject:
    """
    Get intermediate iconic results of a stereo reconstruction.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    pair_index : MaybeSequence[Union[int, str, float]]
                 Camera indices of the pair ([From, To]).

    object_name : str
                  Name of the iconic result to be returned.

    Returns
    -------

    object : HObject
             Iconic result.

    Predecessors
    ------------
    reconstruct_surface_stereo
    """
    with HalconOperator(522) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, pair_index)
        proc.set_input_tuple(2, object_name)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def get_stereo_model_object_model_3d(
    stereo_model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> HHandle:
    """
    Get intermediate 3D object model of a stereo reconstruction

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    gen_param_name : MaybeSequence[str]
                     Names of the model parameters.

    Returns
    -------

    object_model_3d : HHandle
                      Values of the model parameters.

    See Also
    --------
    set_stereo_model_param

    Predecessors
    ------------
    reconstruct_surface_stereo, set_stereo_model_param
    """
    with HalconOperator(2074) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def get_stereo_model_param(
    stereo_model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[float, int, str]]:
    """
    Get stereo model parameters.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    gen_param_name : MaybeSequence[str]
                     Names of the parameters to be set.

    Returns
    -------

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the parameters to be set.

    See Also
    --------
    set_stereo_model_param

    Predecessors
    ------------
    create_stereo_model, set_stereo_model_param

    Successors
    ----------
    reconstruct_surface_stereo, reconstruct_points_stereo
    """
    with HalconOperator(525) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_string_extents(
    window_handle: HHandle,
    values: MaybeSequence[Union[str, float, int]]
) -> Tuple[Union[int, float], Union[int, float], Union[int, float], Union[int, float]]:
    """
    Get the spatial size of a string.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    values : MaybeSequence[Union[str, float, int]]
             Values to consider.
             Value Suggestion: test_string

    Returns
    -------

    ascent : Union[int, float]
             Maximum height above baseline.

    descent : Union[int, float]
              Maximum extension below baseline.

    width : Union[int, float]
            Text width.

    height : Union[int, float]
             Text height.

    See Also
    --------
    get_font_extents, set_tposition, set_font

    Predecessors
    ------------
    open_window, set_font

    Successors
    ----------
    set_tposition, write_string, read_string, read_char
    """
    with HalconOperator(1199) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, values)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ascent
            proc.get_output_tuple_s(1),  # descent
            proc.get_output_tuple_s(2),  # width
            proc.get_output_tuple_s(3)   # height
        )  # type: ignore


def get_structured_light_model_param(
    structured_light_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Query parameters of a structured light model.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    gen_param_name : MaybeSequence[str]
                     Name of the queried model parameter.
                     Value Suggestion: min_stripe_width

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Value of the queried model parameter.

    See Also
    --------
    set_structured_light_model_param

    Predecessors
    ------------
    create_structured_light_model
    """
    with HalconOperator(2117) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_structured_light_model_param_s(
    structured_light_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Query parameters of a structured light model.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    gen_param_name : MaybeSequence[str]
                     Name of the queried model parameter.
                     Value Suggestion: min_stripe_width

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Value of the queried model parameter.

    See Also
    --------
    set_structured_light_model_param

    Predecessors
    ------------
    create_structured_light_model
    """
    with HalconOperator(2117) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_structured_light_object(
    structured_light_model: HHandle,
    object_name: MaybeSequence[str]
) -> HObject:
    """
    Get (intermediate) iconic results of a structured light model.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    object_name : MaybeSequence[str]
                  Name of the iconic result to be returned.
                  Value Suggestion: correspondence_image

    Returns
    -------

    object : HObject
             Iconic result.

    See Also
    --------
    gen_structured_light_pattern

    Predecessors
    ------------
    decode_structured_light_pattern

    Successors
    ----------
    clear_structured_light_model
    """
    with HalconOperator(2118) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.set_input_tuple(1, object_name)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def get_sub_matrix(
    matrix_id: HHandle,
    row: int,
    column: int,
    rows_sub: int,
    columns_sub: int
) -> HHandle:
    """
    Get a sub-matrix of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    row : int
          Upper row position of the sub-matrix in the input matrix.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : int
             Left column position of the sub-matrix in the input matrix.
             Value Suggestion: 0
             Assertion: Column >= 0

    rows_sub : int
               Number of rows of the sub-matrix.
               Value Suggestion: 1
               Assertion: RowsSub >= 1

    columns_sub : int
                  Number of columns of the sub-matrix.
                  Value Suggestion: 1
                  Assertion: ColumnsSub >= 1

    Returns
    -------

    matrix_sub_id : HHandle
                    Matrix handle of the sub-matrix.

    See Also
    --------
    set_sub_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    The conditions 0 <=$- Row $<$ size of Matrix in row direction, Row $+$
    RowsSub <=$- size of Matrix in the row direction, 0 <=$- Column $<$
    size of Matrix in the column direction, and Column $+$ ColumnsSub <=$-
    size of matrix Matrix in the column direction must be satisfied.
    """
    with HalconOperator(890) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, rows_sub)
        proc.set_input_tuple(4, columns_sub)
        proc.init_oct(0)
        proc.execute()
        matrix_sub_id = proc.get_output_tuple_s(0)
        return matrix_sub_id  # type: ignore


def get_support_vector_class_svm(
    svmhandle: HHandle,
    index_support_vector: int
) -> float:
    """
    Return the index of a support vector from a trained support vector
    machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    index_support_vector : int
                           Index of the stored support vector.

    Returns
    -------

    index : float
            Index of the support vector in the training set.

    See Also
    --------
    create_class_svm

    Predecessors
    ------------
    train_class_svm, get_support_vector_num_class_svm

    Successors
    ----------
    get_sample_class_svm
    """
    with HalconOperator(1856) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, index_support_vector)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def get_support_vector_num_class_svm(
    svmhandle: HHandle
) -> Tuple[int, Sequence[int]]:
    """
    Return the number of support vectors of a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    Returns
    -------

    num_support_vectors : int
                          Total number of support vectors.

    num_svper_svm : Sequence[int]
                    Number of SV of each sub-SVM.

    See Also
    --------
    create_class_svm

    Predecessors
    ------------
    train_class_svm

    Successors
    ----------
    get_sample_class_svm
    """
    with HalconOperator(1855) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_support_vectors
            proc.get_output_tuple_m(1)   # num_svper_svm
        )  # type: ignore


def get_support_vector_num_ocr_class_svm(
    ocrhandle: HHandle
) -> Tuple[int, Sequence[int]]:
    """
    Return the number of support vectors of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                OCR handle.

    Returns
    -------

    num_support_vectors : int
                          Total number of support vectors.

    num_svper_svm : Sequence[int]
                    Number of SV of each sub-SVM.

    See Also
    --------
    create_ocr_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm

    Successors
    ----------
    get_support_vector_ocr_class_svm
    """
    with HalconOperator(686) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_support_vectors
            proc.get_output_tuple_m(1)   # num_svper_svm
        )  # type: ignore


def get_support_vector_ocr_class_svm(
    ocrhandle: HHandle,
    index_support_vector: Sequence[int]
) -> float:
    """
    Return the index of a support vector from a trained OCR classifier
    that is based on support vector machines.

    Parameters
    ----------

    ocrhandle : HHandle
                OCR handle.

    index_support_vector : Sequence[int]
                           Number of stored support vectors.

    Returns
    -------

    index : float
            Index of the support vector in the training set.

    See Also
    --------
    create_ocr_class_svm, read_ocr_trainf, append_ocr_trainf,
    concat_ocr_trainf

    Predecessors
    ------------
    trainf_ocr_class_svm, get_support_vector_num_ocr_class_svm
    """
    with HalconOperator(687) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, index_support_vector)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def get_surface_matching_result(
    surface_matching_result_id: HHandle,
    result_name: MaybeSequence[str],
    result_index: int
) -> Sequence[HTupleElementType]:
    """
    Get details of a result from surface based matching.

    Parameters
    ----------

    surface_matching_result_id : HHandle
                                 Handle of the surface matching result.

    result_name : MaybeSequence[str]
                  Name of the result property.
                  Value Suggestion: pose

    result_index : int
                   Index of the matching result, starting with 0.
                   Value Suggestion: 0
                   Assertion: ResultIndex >= 0

    Returns
    -------

    result_value : Sequence[HTupleElementType]
                   Value of the result property.

    See Also
    --------
    find_surface_model, refine_surface_model_pose, read_surface_model,
    write_surface_model, clear_surface_model

    Predecessors
    ------------
    find_surface_model, refine_surface_model_pose

    Successors
    ----------
    clear_surface_model
    """
    with HalconOperator(1032) as proc:
        proc.set_input_tuple(0, surface_matching_result_id)
        proc.set_input_tuple(1, result_name)
        proc.set_input_tuple(2, result_index)
        proc.init_oct(0)
        proc.execute()
        result_value = proc.get_output_tuple_m(0)
        return result_value  # type: ignore


def get_surface_matching_result_s(
    surface_matching_result_id: HHandle,
    result_name: MaybeSequence[str],
    result_index: int
) -> HTupleElementType:
    """
    Get details of a result from surface based matching.

    Parameters
    ----------

    surface_matching_result_id : HHandle
                                 Handle of the surface matching result.

    result_name : MaybeSequence[str]
                  Name of the result property.
                  Value Suggestion: pose

    result_index : int
                   Index of the matching result, starting with 0.
                   Value Suggestion: 0
                   Assertion: ResultIndex >= 0

    Returns
    -------

    result_value : HTupleElementType
                   Value of the result property.

    See Also
    --------
    find_surface_model, refine_surface_model_pose, read_surface_model,
    write_surface_model, clear_surface_model

    Predecessors
    ------------
    find_surface_model, refine_surface_model_pose

    Successors
    ----------
    clear_surface_model
    """
    with HalconOperator(1032) as proc:
        proc.set_input_tuple(0, surface_matching_result_id)
        proc.set_input_tuple(1, result_name)
        proc.set_input_tuple(2, result_index)
        proc.init_oct(0)
        proc.execute()
        result_value = proc.get_output_tuple_s(0)
        return result_value  # type: ignore


def get_surface_model_param(
    surface_model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[HTupleElementType]:
    """
    Return the parameters and properties of a surface model.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    gen_param_name : MaybeSequence[str]
                     Name of the parameter.
                     Value Suggestion: diameter

    Returns
    -------

    gen_param_value : Sequence[HTupleElementType]
                      Value of the parameter.

    See Also
    --------
    create_surface_model, set_surface_model_param

    Predecessors
    ------------
    create_surface_model, read_surface_model

    Successors
    ----------
    find_surface_model, refine_surface_model_pose, write_surface_model
    """
    with HalconOperator(1043) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_surface_model_param_s(
    surface_model_id: HHandle,
    gen_param_name: MaybeSequence[str]
) -> HTupleElementType:
    """
    Return the parameters and properties of a surface model.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    gen_param_name : MaybeSequence[str]
                     Name of the parameter.
                     Value Suggestion: diameter

    Returns
    -------

    gen_param_value : HTupleElementType
                      Value of the parameter.

    See Also
    --------
    create_surface_model, set_surface_model_param

    Predecessors
    ------------
    create_surface_model, read_surface_model

    Successors
    ----------
    find_surface_model, refine_surface_model_pose, write_surface_model
    """
    with HalconOperator(1043) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_system(
    query: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Get current value of HALCON system parameters.

    Parameters
    ----------

    query : MaybeSequence[str]
            Desired system parameter.
            Value Suggestion: init_new_image

    Returns
    -------

    information : Sequence[Union[int, float, str]]
                  Current value of the system parameter.

    See Also
    --------
    set_system

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    set_system
    """
    with HalconOperator(320) as proc:
        proc.set_input_tuple(0, query)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_m(0)
        return information  # type: ignore


def get_system_info(
    query: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Get current value of system information without requiring a license.

    Parameters
    ----------

    query : MaybeSequence[str]
            Desired system parameter.
            Value Suggestion: available_parameters

    Returns
    -------

    information : Sequence[Union[int, float, str]]
                  Current value of the system parameter.

    See Also
    --------
    get_system
    """
    with HalconOperator(2160) as proc:
        proc.set_input_tuple(0, query)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_m(0)
        return information  # type: ignore


def get_system_info_s(query: MaybeSequence[str]) -> Union[int, float, str]:
    """
    Get current value of system information without requiring a license.

    Parameters
    ----------

    query : MaybeSequence[str]
            Desired system parameter.
            Value Suggestion: available_parameters

    Returns
    -------

    information : Union[int, float, str]
                  Current value of the system parameter.

    See Also
    --------
    get_system
    """
    with HalconOperator(2160) as proc:
        proc.set_input_tuple(0, query)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_s(0)
        return information  # type: ignore


def get_system_s(query: MaybeSequence[str]) -> Union[int, float, str]:
    """
    Get current value of HALCON system parameters.

    Parameters
    ----------

    query : MaybeSequence[str]
            Desired system parameter.
            Value Suggestion: init_new_image

    Returns
    -------

    information : Union[int, float, str]
                  Current value of the system parameter.

    See Also
    --------
    set_system

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    set_system
    """
    with HalconOperator(320) as proc:
        proc.set_input_tuple(0, query)
        proc.init_oct(0)
        proc.execute()
        information = proc.get_output_tuple_s(0)
        return information  # type: ignore


def get_system_time() -> Tuple[int, int, int, int, int, int, int, int]:
    """
    Read out the system time.

    Returns
    -------

    msecond : int
              Milliseconds (0..999).

    second : int
             Seconds (0..59).

    minute : int
             Minutes (0..59).

    hour : int
           Hours (0..23).

    day : int
          Day of the month (1..31).

    yday : int
           Day of the year (1..366).

    month : int
            Month (1..12).

    year : int
           Year (xxxx).

    See Also
    --------
    get_image_time
    """
    with HalconOperator(295) as proc:
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # msecond
            proc.get_output_tuple_s(1),  # second
            proc.get_output_tuple_s(2),  # minute
            proc.get_output_tuple_s(3),  # hour
            proc.get_output_tuple_s(4),  # day
            proc.get_output_tuple_s(5),  # yday
            proc.get_output_tuple_s(6),  # month
            proc.get_output_tuple_s(7)   # year
        )  # type: ignore


def get_text_model_param(
    text_model: HHandle,
    gen_param_name: str
) -> Sequence[Union[int, float, str]]:
    """
    Query parameters of a text model.

    Parameters
    ----------

    text_model : HHandle
                 Text model.

    gen_param_name : str
                     Parameters to be queried.
                     Value Suggestion: min_contrast

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of Parameters.

    See Also
    --------
    set_text_model_param
    """
    with HalconOperator(418) as proc:
        proc.set_input_tuple(0, text_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_text_model_param_s(
    text_model: HHandle,
    gen_param_name: str
) -> Union[int, float, str]:
    """
    Query parameters of a text model.

    Parameters
    ----------

    text_model : HHandle
                 Text model.

    gen_param_name : str
                     Parameters to be queried.
                     Value Suggestion: min_contrast

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Values of Parameters.

    See Also
    --------
    set_text_model_param
    """
    with HalconOperator(418) as proc:
        proc.set_input_tuple(0, text_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_text_object(
    text_result_id: HHandle,
    result_name: MaybeSequence[Union[str, int]]
) -> HObject:
    """
    Query an iconic value of a text segmentation result.

    Parameters
    ----------

    text_result_id : HHandle
                     Text result.

    result_name : MaybeSequence[Union[str, int]]
                  Name of the result to be returned.
                  Value Suggestion: all_lines

    Returns
    -------

    characters : HObject
                 Returned result.

    See Also
    --------
    get_text_result

    Predecessors
    ------------
    find_text
    """
    with HalconOperator(415) as proc:
        proc.set_input_tuple(0, text_result_id)
        proc.set_input_tuple(1, result_name)
        proc.execute()
        characters = HObject(proc.get_output_object_key(1))
        return characters  # type: ignore


def get_text_result(
    text_result_id: HHandle,
    result_name: MaybeSequence[Union[str, int]]
) -> Sequence[Union[int, float, str]]:
    """
    Query a control value of a text segmentation result.

    Parameters
    ----------

    text_result_id : HHandle
                     Text result.

    result_name : MaybeSequence[Union[str, int]]
                  Name of the result to be returned.
                  Value Suggestion: class

    Returns
    -------

    result_value : Sequence[Union[int, float, str]]
                   Value of ResultName.

    See Also
    --------
    get_text_object

    Predecessors
    ------------
    find_text
    """
    with HalconOperator(416) as proc:
        proc.set_input_tuple(0, text_result_id)
        proc.set_input_tuple(1, result_name)
        proc.init_oct(0)
        proc.execute()
        result_value = proc.get_output_tuple_m(0)
        return result_value  # type: ignore


def get_text_result_s(
    text_result_id: HHandle,
    result_name: MaybeSequence[Union[str, int]]
) -> Union[int, float, str]:
    """
    Query a control value of a text segmentation result.

    Parameters
    ----------

    text_result_id : HHandle
                     Text result.

    result_name : MaybeSequence[Union[str, int]]
                  Name of the result to be returned.
                  Value Suggestion: class

    Returns
    -------

    result_value : Union[int, float, str]
                   Value of ResultName.

    See Also
    --------
    get_text_object

    Predecessors
    ------------
    find_text
    """
    with HalconOperator(416) as proc:
        proc.set_input_tuple(0, text_result_id)
        proc.set_input_tuple(1, result_name)
        proc.init_oct(0)
        proc.execute()
        result_value = proc.get_output_tuple_s(0)
        return result_value  # type: ignore


def get_texture_inspection_model_image(
    texture_inspection_model: HHandle
) -> HObject:
    """
    Get the training images contained in a texture inspection model.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    Returns
    -------

    model_images : HObject
                   Training images contained in the texture inspection
                   model.

    Predecessors
    ------------
    create_texture_inspection_model, set_texture_inspection_model_param,
    get_texture_inspection_model_param, add_texture_inspection_model_image

    Successors
    ----------
    train_texture_inspection_model, clear_texture_inspection_model,
    remove_texture_inspection_model_image
    """
    with HalconOperator(2075) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.execute()
        model_images = HObject(proc.get_output_object_key(1))
        return model_images  # type: ignore


def get_texture_inspection_model_param(
    texture_inspection_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Query parameters of a texture inspection model.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    gen_param_name : MaybeSequence[str]
                     Name of the queried model parameter.
                     Value Suggestion: novelty_threshold

    Returns
    -------

    gen_param_value : Sequence[Union[int, float, str]]
                      Value of the queried model parameter.

    See Also
    --------
    set_texture_inspection_model_param

    Predecessors
    ------------
    create_texture_inspection_model, train_texture_inspection_model

    Successors
    ----------
    add_texture_inspection_model_image, train_texture_inspection_model
    """
    with HalconOperator(2076) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_m(0)
        return gen_param_value  # type: ignore


def get_texture_inspection_model_param_s(
    texture_inspection_model: HHandle,
    gen_param_name: MaybeSequence[str]
) -> Union[int, float, str]:
    """
    Query parameters of a texture inspection model.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    gen_param_name : MaybeSequence[str]
                     Name of the queried model parameter.
                     Value Suggestion: novelty_threshold

    Returns
    -------

    gen_param_value : Union[int, float, str]
                      Value of the queried model parameter.

    See Also
    --------
    set_texture_inspection_model_param

    Predecessors
    ------------
    create_texture_inspection_model, train_texture_inspection_model

    Successors
    ----------
    add_texture_inspection_model_image, train_texture_inspection_model
    """
    with HalconOperator(2076) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_value = proc.get_output_tuple_s(0)
        return gen_param_value  # type: ignore


def get_texture_inspection_result_object(
    texture_inspection_result_id: HHandle,
    result_name: MaybeSequence[Union[str, int]]
) -> HObject:
    """
    Query iconic results of a texture inspection.

    Parameters
    ----------

    texture_inspection_result_id : HHandle
                                   Handle of the texture inspection result.

    result_name : MaybeSequence[Union[str, int]]
                  Name of the iconic object to be returned.
                  Value Suggestion: novelty_region

    Returns
    -------

    object : HObject
             Returned iconic object.

    Predecessors
    ------------
    apply_texture_inspection_model

    Successors
    ----------
    clear_texture_inspection_result, clear_texture_inspection_model
    """
    with HalconOperator(2077) as proc:
        proc.set_input_tuple(0, texture_inspection_result_id)
        proc.set_input_tuple(1, result_name)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def get_threading_attrib(
    threading_handle: int
) -> Tuple[Sequence[str], Sequence[str], Sequence[Union[int, float, str]]]:
    """
    Query the attributes of a threading / synchronization object.

    Parameters
    ----------

    threading_handle : int
                       Threading object.

    Returns
    -------

    threading_class : Sequence[str]
                      Class name of threading object.

    attrib_name : Sequence[str]
                  Name of an attribute.

    attrib_value : Sequence[Union[int, float, str]]
                   Value of the attribute.

    See Also
    --------
    create_mutex, create_event, create_condition, create_barrier

    Successors
    ----------
    create_mutex, create_event, create_condition, create_barrier
    """
    with HalconOperator(565) as proc:
        proc.set_input_tuple(0, threading_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # threading_class
            proc.get_output_tuple_m(1),  # attrib_name
            proc.get_output_tuple_m(2)   # attrib_value
        )  # type: ignore


def get_thresh_images_variation_model(
    model_id: HHandle
) -> Tuple[HObject, HObject]:
    """
    Return the threshold images used for image comparison by a variation
    model.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    Returns
    -------

    min_image : HObject
                Threshold image for the lower threshold.

    max_image : HObject
                Threshold image for the upper threshold.

    See Also
    --------
    compare_variation_model, compare_ext_variation_model

    Predecessors
    ------------
    prepare_variation_model, prepare_direct_variation_model
    """
    with HalconOperator(85) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # min_image
            HObject(proc.get_output_object_key(2))   # max_image
        )  # type: ignore


def get_tposition(window_handle: HHandle) -> Tuple[int, int]:
    """
    Get cursor position.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : int
          Row index of text cursor position.

    column : int
             Column index of text cursor position.

    See Also
    --------
    new_line, read_string, set_tposition, write_string, set_check

    Predecessors
    ------------
    open_window, set_font

    Successors
    ----------
    set_tposition, write_string, read_string, read_char

    Notes
    -----
    If the output text does not fit completely into the window, an
    exception is raised. This can be avoided by set_check('~text')
    set_check('text')}.
    """
    with HalconOperator(1197) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def get_training_components(
    component_training_id: HHandle,
    components: Union[str, int],
    image: Union[str, int],
    mark_orientation: str
) -> Tuple[HObject, Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Return the initial or model components in a certain image.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    components : Union[str, int]
                 Type of returned components or index of an initial
                 component.
                 Value Suggestion: model_components

    image : Union[str, int]
            Image for which the components are to be returned.
            Value Suggestion: model_image

    mark_orientation : str
                       Mark the orientation of the components.
                       Value Suggestion: false

    Returns
    -------

    training_components : HObject
                          Contour regions of the initial components or of
                          the model components.

    row : Sequence[float]
          Row coordinate of the found instances of all initial components
          or model components.

    column : Sequence[float]
             Column coordinate of the found instances of all initial
             components or model components.

    angle : Sequence[float]
            Rotation angle of the found instances of all components.

    score : Sequence[float]
            Score of the found instances of all components.

    See Also
    --------
    find_shape_model

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    train_model_components
    """
    with HalconOperator(1009) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, components)
        proc.set_input_tuple(2, image)
        proc.set_input_tuple(3, mark_orientation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # training_components
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # angle
            proc.get_output_tuple_m(3)   # score
        )  # type: ignore


def get_training_components_s(
    component_training_id: HHandle,
    components: Union[str, int],
    image: Union[str, int],
    mark_orientation: str
) -> Tuple[HObject, float, float, float, float]:
    """
    Return the initial or model components in a certain image.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    components : Union[str, int]
                 Type of returned components or index of an initial
                 component.
                 Value Suggestion: model_components

    image : Union[str, int]
            Image for which the components are to be returned.
            Value Suggestion: model_image

    mark_orientation : str
                       Mark the orientation of the components.
                       Value Suggestion: false

    Returns
    -------

    training_components : HObject
                          Contour regions of the initial components or of
                          the model components.

    row : float
          Row coordinate of the found instances of all initial components
          or model components.

    column : float
             Column coordinate of the found instances of all initial
             components or model components.

    angle : float
            Rotation angle of the found instances of all components.

    score : float
            Score of the found instances of all components.

    See Also
    --------
    find_shape_model

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    train_model_components
    """
    with HalconOperator(1009) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, components)
        proc.set_input_tuple(2, image)
        proc.set_input_tuple(3, mark_orientation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # training_components
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # angle
            proc.get_output_tuple_s(3)   # score
        )  # type: ignore


def get_tshape(window_handle: HHandle) -> str:
    """
    Get the shape of the text cursor.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    text_cursor : str
                  Name of the current text cursor.

    See Also
    --------
    set_tshape, query_tshape, write_string, read_string

    Predecessors
    ------------
    open_window, set_font

    Successors
    ----------
    set_tshape, set_tposition, write_string, read_string, read_char

    Warnings
    --------
    get_tshape is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1196) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        text_cursor = proc.get_output_tuple_s(0)
        return text_cursor  # type: ignore


def get_value_matrix(
    matrix_id: HHandle,
    row: MaybeSequence[int],
    column: MaybeSequence[int]
) -> Sequence[float]:
    """
    Return one ore more elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    row : MaybeSequence[int]
          Row numbers of matrix elements to be returned.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : MaybeSequence[int]
             Column numbers of matrix elements to be returned.
             Value Suggestion: 0
             Assertion: Column >= 0

    Returns
    -------

    value : Sequence[float]
            Values of indicated matrix elements.

    See Also
    --------
    set_value_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(894) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def get_value_matrix_s(
    matrix_id: HHandle,
    row: MaybeSequence[int],
    column: MaybeSequence[int]
) -> float:
    """
    Return one ore more elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    row : MaybeSequence[int]
          Row numbers of matrix elements to be returned.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : MaybeSequence[int]
             Column numbers of matrix elements to be returned.
             Value Suggestion: 0
             Assertion: Column >= 0

    Returns
    -------

    value : float
            Values of indicated matrix elements.

    See Also
    --------
    set_value_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(894) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_variation_model(model_id: HHandle) -> Tuple[HObject, HObject]:
    """
    Return the images used for image comparison by a variation model.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    Returns
    -------

    image : HObject
            Image of the trained object.

    var_image : HObject
                Variation image of the trained object.

    See Also
    --------
    prepare_variation_model, compare_variation_model,
    compare_ext_variation_model

    Predecessors
    ------------
    train_variation_model
    """
    with HalconOperator(86) as proc:
        proc.set_input_tuple(0, model_id)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image
            HObject(proc.get_output_object_key(2))   # var_image
        )  # type: ignore


def get_window_attr(attribute_name: str) -> Union[str, int]:
    """
    Get window characteristics.

    Parameters
    ----------

    attribute_name : str
                     Name of the attribute that should be returned.

    Returns
    -------

    attribute_value : Union[str, int]
                      Attribute value.

    See Also
    --------
    open_window, set_window_attr

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width
    """
    with HalconOperator(1175) as proc:
        proc.set_input_tuple(0, attribute_name)
        proc.init_oct(0)
        proc.execute()
        attribute_value = proc.get_output_tuple_s(0)
        return attribute_value  # type: ignore


def get_window_background_image(window_handle: HHandle) -> HObject:
    """
    Gets a copy of the background image of the HALCON window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    background_image : HObject
                       Copy of the background image.

    See Also
    --------
    attach_background_to_window, detach_drawing_object_from_window

    Predecessors
    ------------
    attach_background_to_window

    Successors
    ----------
    close_window, detach_background_from_window,
    attach_drawing_object_to_window
    """
    with HalconOperator(1161) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()
        background_image = HObject(proc.get_output_object_key(1))
        return background_image  # type: ignore


def get_window_extents(
    window_handle: HHandle
) -> Tuple[int, int, int, int]:
    """
    Information about a window's size and position.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    row : int
          Row index of upper left corner of the window.

    column : int
             Column index of upper left corner of the window.

    width : int
            Window width.

    height : int
             Window height.

    See Also
    --------
    set_window_extents, open_window

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width

    Notes
    -----
    Size and position of a window may be modified by the window manager,
    without explicit instruction in the program. Therefore the values
    which are returned by get_window_extents may change cause of side
    effects.
    """
    with HalconOperator(1183) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # width
            proc.get_output_tuple_s(3)   # height
        )  # type: ignore


def get_window_param(
    window_handle: HHandle,
    param: str
) -> Sequence[Union[str, float, int]]:
    """
    Get window parameters.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    param : str
            Name of the parameter.
            Value Suggestion: flush

    Returns
    -------

    value : Sequence[Union[str, float, int]]
            Value of the parameter.

    See Also
    --------
    get_window_attr, get_part_style

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_window_param

    Notes
    -----
    The parameters 'anti_aliasing', 'flush', 'graphics_stack',
    'graphics_stack_max_element_num', 'graphics_stack_max_memory_size',
    and 'region_quality' depend on the library libcanvas, which might not
    be available on embedded systems.
    """
    with HalconOperator(1221) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, param)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def get_window_param_s(
    window_handle: HHandle,
    param: str
) -> Union[str, float, int]:
    """
    Get window parameters.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    param : str
            Name of the parameter.
            Value Suggestion: flush

    Returns
    -------

    value : Union[str, float, int]
            Value of the parameter.

    See Also
    --------
    get_window_attr, get_part_style

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_window_param

    Notes
    -----
    The parameters 'anti_aliasing', 'flush', 'graphics_stack',
    'graphics_stack_max_element_num', 'graphics_stack_max_memory_size',
    and 'region_quality' depend on the library libcanvas, which might not
    be available on embedded systems.
    """
    with HalconOperator(1221) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, param)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def get_window_pointer3(
    window_handle: HHandle
) -> Tuple[int, int, int, int, int]:
    """
    Access to a window's pixel data.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    image_red : int
                Pointer on red channel of pixel data.

    image_green : int
                  Pointer on green channel of pixel data.

    image_blue : int
                 Pointer on blue channel of pixel data.

    width : int
            Length of an image line.

    height : int
             Number of image lines.

    See Also
    --------
    open_window, set_window_type

    Predecessors
    ------------
    open_window

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.

    Notes
    -----
    get_window_pointer3 is usable only for window type 'pixmap'.
    """
    with HalconOperator(1182) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # image_red
            proc.get_output_tuple_s(1),  # image_green
            proc.get_output_tuple_s(2),  # image_blue
            proc.get_output_tuple_s(3),  # width
            proc.get_output_tuple_s(4)   # height
        )  # type: ignore


def get_window_type(window_handle: HHandle) -> str:
    """
    Get the window type.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    window_type : str
                  Window type

    See Also
    --------
    query_window_type, set_window_type, get_window_pointer3, open_window

    Predecessors
    ------------
    open_window
    """
    with HalconOperator(1181) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        window_type = proc.get_output_tuple_s(0)
        return window_type  # type: ignore


def get_y_value_funct_1d(
    function: Sequence[Union[float, int]],
    x: MaybeSequence[float],
    border: str
) -> Sequence[float]:
    """
    Return the value of a function at an arbitrary position.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    x : MaybeSequence[float]
        X coordinate at which the function should be evaluated.

    border : str
             Border treatment for the input function.
             Value Suggestion: constant

    Returns
    -------

    y : Sequence[float]
        Y value at the given x value.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1385) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, x)
        proc.set_input_tuple(2, border)
        proc.init_oct(0)
        proc.execute()
        y = proc.get_output_tuple_m(0)
        return y  # type: ignore


def get_y_value_funct_1d_s(
    function: Sequence[Union[float, int]],
    x: MaybeSequence[float],
    border: str
) -> float:
    """
    Return the value of a function at an arbitrary position.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    x : MaybeSequence[float]
        X coordinate at which the function should be evaluated.

    border : str
             Border treatment for the input function.
             Value Suggestion: constant

    Returns
    -------

    y : float
        Y value at the given x value.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1385) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, x)
        proc.set_input_tuple(2, border)
        proc.init_oct(0)
        proc.execute()
        y = proc.get_output_tuple_s(0)
        return y  # type: ignore


def give_bg_esti(bg_esti_handle: HHandle) -> HObject:
    """
    Return the estimated background image.

    Parameters
    ----------

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    Returns
    -------

    background_image : HObject
                       Estimated background image of the current data set.

    See Also
    --------
    run_bg_esti, update_bg_esti, create_bg_esti

    Predecessors
    ------------
    run_bg_esti

    Successors
    ----------
    run_bg_esti, create_bg_esti, update_bg_esti
    """
    with HalconOperator(2003) as proc:
        proc.set_input_tuple(0, bg_esti_handle)
        proc.execute()
        background_image = HObject(proc.get_output_object_key(1))
        return background_image  # type: ignore


def gnuplot_close(gnuplot_file_id: HHandle) -> None:
    """
    Close all open gnuplot files or terminate an active gnuplot
    sub-process.

    Parameters
    ----------

    gnuplot_file_id : HHandle
                      Identifier for the gnuplot output stream.

    See Also
    --------
    gnuplot_open_pipe, gnuplot_open_file, gnuplot_plot_image

    Predecessors
    ------------
    gnuplot_open_pipe, gnuplot_open_file, gnuplot_plot_image

    Warnings
    --------
    gnuplot_close is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1298) as proc:
        proc.set_input_tuple(0, gnuplot_file_id)
        proc.execute()


def gnuplot_open_file(file_name: str) -> HHandle:
    """
    Open a gnuplot file for visualization of images and control values.

    Parameters
    ----------

    file_name : str
                Base name for control and data files.

    Returns
    -------

    gnuplot_file_id : HHandle
                      Identifier for the gnuplot output stream.

    See Also
    --------
    gnuplot_open_pipe, gnuplot_close, gnuplot_plot_image

    Alternatives
    ------------
    gnuplot_open_pipe

    Successors
    ----------
    gnuplot_plot_image, gnuplot_close

    Warnings
    --------
    gnuplot_open_file is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1299) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        gnuplot_file_id = proc.get_output_tuple_s(0)
        return gnuplot_file_id  # type: ignore


def gnuplot_open_pipe() -> HHandle:
    """
    Open a pipe to a gnuplot process for visualization of images and
    control values.

    Returns
    -------

    gnuplot_file_id : HHandle
                      Identifier for the gnuplot output stream.

    Alternatives
    ------------
    gnuplot_open_file

    Successors
    ----------
    gnuplot_plot_image, gnuplot_plot_ctrl, gnuplot_close

    Warnings
    --------
    gnuplot_open_pipe is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    gnuplot_open_pipe is only implemented for Unix-like systems because
    gnuplot for Windows (wgnuplot) cannot be controlled by an external
    process.
    """
    with HalconOperator(1300) as proc:
        proc.init_oct(0)
        proc.execute()
        gnuplot_file_id = proc.get_output_tuple_s(0)
        return gnuplot_file_id  # type: ignore


def gnuplot_plot_ctrl(
    gnuplot_file_id: HHandle,
    values: Sequence[Union[float, int]]
) -> None:
    """
    Plot control values using gnuplot.

    Parameters
    ----------

    gnuplot_file_id : HHandle
                      Identifier for the gnuplot output stream.

    values : Sequence[Union[float, int]]
             Control values to be plotted (y-values).

    See Also
    --------
    gnuplot_open_pipe, gnuplot_open_file, gnuplot_close

    Predecessors
    ------------
    gnuplot_open_pipe, gnuplot_open_file

    Successors
    ----------
    gnuplot_close

    Warnings
    --------
    gnuplot_plot_ctrl is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1296) as proc:
        proc.set_input_tuple(0, gnuplot_file_id)
        proc.set_input_tuple(1, values)
        proc.execute()


def gnuplot_plot_funct_1d(
    gnuplot_file_id: HHandle,
    function: Sequence[Union[float, int]]
) -> None:
    """
    Plot a function using gnuplot.

    Parameters
    ----------

    gnuplot_file_id : HHandle
                      Identifier for the gnuplot output stream.

    function : Sequence[Union[float, int]]
               Function to be plotted.

    See Also
    --------
    gnuplot_open_pipe, gnuplot_open_file, gnuplot_close

    Alternatives
    ------------
    gnuplot_plot_ctrl

    Predecessors
    ------------
    gnuplot_open_pipe, gnuplot_open_file

    Successors
    ----------
    gnuplot_close

    Warnings
    --------
    gnuplot_plot_funct_1d is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1295) as proc:
        proc.set_input_tuple(0, gnuplot_file_id)
        proc.set_input_tuple(1, function)
        proc.execute()


def gnuplot_plot_image(
    image: HObject,
    gnuplot_file_id: HHandle,
    samples_x: int,
    samples_y: int,
    view_rot_x: Union[int, float],
    view_rot_z: Union[int, float],
    hidden_3d: str
) -> None:
    """
    Visualize images using gnuplot.

    Parameters
    ----------

    image : HObject
            Image to be plotted.

    gnuplot_file_id : HHandle
                      Identifier for the gnuplot output stream.

    samples_x : int
                Number of samples in the x-direction.
                Value Suggestion: 64
                Assertion: SamplesX >= 2

    samples_y : int
                Number of samples in the y-direction.
                Value Suggestion: 64
                Assertion: SamplesY >= 2

    view_rot_x : Union[int, float]
                 Rotation of the plot about the x-axis.
                 Value Suggestion: 60
                 Assertion: 0 <= ViewRotX && ViewRotX <= 180

    view_rot_z : Union[int, float]
                 Rotation of the plot about the z-axis.
                 Value Suggestion: 30
                 Assertion: 0 <= ViewRotZ && ViewRotZ <= 360

    hidden_3d : str
                Plot the image with hidden surfaces removed.
                Value Suggestion: hidden3d

    See Also
    --------
    gnuplot_open_pipe, gnuplot_open_file, gnuplot_close

    Predecessors
    ------------
    gnuplot_open_pipe, gnuplot_open_file

    Successors
    ----------
    gnuplot_close

    Warnings
    --------
    gnuplot_plot_image is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1297) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, gnuplot_file_id)
        proc.set_input_tuple(1, samples_x)
        proc.set_input_tuple(2, samples_y)
        proc.set_input_tuple(3, view_rot_x)
        proc.set_input_tuple(4, view_rot_z)
        proc.set_input_tuple(5, hidden_3d)
        proc.execute()


def golay_elements(
    golay_element: str,
    rotation: int,
    row: int,
    column: int
) -> Tuple[HObject, HObject]:
    """
    Generate the structuring elements of the Golay alphabet.

    Parameters
    ----------

    golay_element : str
                    Name of the structuring element.
                    Value Suggestion: l

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 16

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 16

    Returns
    -------

    struct_element_1 : HObject
                       Structuring element for the foreground.

    struct_element_2 : HObject
                       Structuring element for the background.

    See Also
    --------
    dilation_golay, erosion_golay, opening_golay, closing_golay,
    hit_or_miss_golay, thickening_golay

    Alternatives
    ------------
    gen_region_points, gen_struct_elements, gen_region_polygon_filled

    Successors
    ----------
    hit_or_miss

    Warnings
    --------
    golay_elements is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(749) as proc:
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, rotation)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # struct_element_1
            HObject(proc.get_output_object_key(2))   # struct_element_2
        )  # type: ignore


def grab_data(
    acq_handle: HHandle
) -> Tuple[HObject, HObject, HObject, Sequence[HTupleElementType]]:
    """
    Synchronous grab of images and preprocessed image data from the
    specified image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    Returns
    -------

    image : HObject
            Grabbed image data.

    region : HObject
             Preprocessed image regions.

    contours : HObject
               Preprocessed XLD contours.

    data : Sequence[HTupleElementType]
           Preprocessed control data.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, grab_image_start, set_framegrabber_param

    Successors
    ----------
    grab_data_async, grab_image_start, grab_image, grab_image_async,
    set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_data runs in parallel with all non-exclusive operators inside and
    outside of this group.
    """
    with HalconOperator(2030) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image
            HObject(proc.get_output_object_key(2)),  # region
            HObject(proc.get_output_object_key(3)),  # contours
            proc.get_output_tuple_m(0)   # data
        )  # type: ignore


def grab_data_async(
    acq_handle: HHandle,
    max_delay: float
) -> Tuple[HObject, HObject, HObject, Sequence[HTupleElementType]]:
    """
    Asynchronous grab of images and preprocessed image data from the
    specified image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    max_delay : float
                Maximum tolerated delay between the start of the
                asynchronous grab and the delivery of the image [ms].
                Value Suggestion: -1.0

    Returns
    -------

    image : HObject
            Grabbed image data.

    region : HObject
             Pre-processed image regions.

    contours : HObject
               Pre-processed XLD contours.

    data : Sequence[HTupleElementType]
           Pre-processed control data.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, grab_image_start, set_framegrabber_param

    Successors
    ----------
    grab_image_async, set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_data_async runs in parallel with all non-exclusive operators
    inside and outside of this group.
    """
    with HalconOperator(2029) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, max_delay)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image
            HObject(proc.get_output_object_key(2)),  # region
            HObject(proc.get_output_object_key(3)),  # contours
            proc.get_output_tuple_m(0)   # data
        )  # type: ignore


def grab_data_async_s(
    acq_handle: HHandle,
    max_delay: float
) -> Tuple[HObject, HObject, HObject, HTupleElementType]:
    """
    Asynchronous grab of images and preprocessed image data from the
    specified image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    max_delay : float
                Maximum tolerated delay between the start of the
                asynchronous grab and the delivery of the image [ms].
                Value Suggestion: -1.0

    Returns
    -------

    image : HObject
            Grabbed image data.

    region : HObject
             Pre-processed image regions.

    contours : HObject
               Pre-processed XLD contours.

    data : HTupleElementType
           Pre-processed control data.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, grab_image_start, set_framegrabber_param

    Successors
    ----------
    grab_image_async, set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_data_async runs in parallel with all non-exclusive operators
    inside and outside of this group.
    """
    with HalconOperator(2029) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, max_delay)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image
            HObject(proc.get_output_object_key(2)),  # region
            HObject(proc.get_output_object_key(3)),  # contours
            proc.get_output_tuple_s(0)   # data
        )  # type: ignore


def grab_data_s(
    acq_handle: HHandle
) -> Tuple[HObject, HObject, HObject, HTupleElementType]:
    """
    Synchronous grab of images and preprocessed image data from the
    specified image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    Returns
    -------

    image : HObject
            Grabbed image data.

    region : HObject
             Preprocessed image regions.

    contours : HObject
               Preprocessed XLD contours.

    data : HTupleElementType
           Preprocessed control data.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, grab_image_start, set_framegrabber_param

    Successors
    ----------
    grab_data_async, grab_image_start, grab_image, grab_image_async,
    set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_data runs in parallel with all non-exclusive operators inside and
    outside of this group.
    """
    with HalconOperator(2030) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image
            HObject(proc.get_output_object_key(2)),  # region
            HObject(proc.get_output_object_key(3)),  # contours
            proc.get_output_tuple_s(0)   # data
        )  # type: ignore


def grab_image(acq_handle: HHandle) -> HObject:
    """
    Synchronous grab of an image from the specified image acquisition
    device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    Returns
    -------

    image : HObject
            Grabbed image.

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, set_framegrabber_param

    Successors
    ----------
    grab_image_start, grab_image_async, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_image runs in parallel with all non-exclusive operators inside
    and outside of this group.
    """
    with HalconOperator(2033) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def grab_image_async(acq_handle: HHandle, max_delay: float) -> HObject:
    """
    Asynchronous grab of an image from the specified image acquisition
    device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    max_delay : float
                Maximum tolerated delay between the start of the
                asynchronous grab and the delivery of the image [ms].
                Value Suggestion: -1.0

    Returns
    -------

    image : HObject
            Grabbed image.

    See Also
    --------
    grab_image_start, open_framegrabber, info_framegrabber,
    set_framegrabber_param

    Predecessors
    ------------
    grab_image_start, open_framegrabber, set_framegrabber_param

    Successors
    ----------
    grab_data_async, set_framegrabber_param, close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_image_async runs in parallel with all non-exclusive operators
    inside and outside of this group.
    """
    with HalconOperator(2031) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, max_delay)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def grab_image_start(acq_handle: HHandle, max_delay: float) -> None:
    """
    Start an asynchronous grab from the specified image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    max_delay : float
                This parameter is obsolete and has no effect.
                Value Suggestion: -1.0

    See Also
    --------
    open_framegrabber, info_framegrabber, set_framegrabber_param

    Predecessors
    ------------
    open_framegrabber, set_framegrabber_param

    Successors
    ----------
    grab_image_async, grab_data_async, set_framegrabber_param,
    close_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    grab_image_start runs in parallel with all non-exclusive operators
    inside and outside of this group.
    """
    with HalconOperator(2032) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, max_delay)
        proc.execute()


def gray_bothat(image: HObject, se: HObject) -> HObject:
    """
    Perform a gray value bottom hat transformation on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    se : HObject
         Structuring element.

    Returns
    -------

    image_bot_hat : HObject
                    Bottom hat image.

    See Also
    --------
    gray_tophat, top_hat, gray_erosion_rect, sub_image

    Alternatives
    ------------
    gray_closing

    Predecessors
    ------------
    read_gray_se, gen_disc_se, read_image

    Successors
    ----------
    threshold
    """
    with HalconOperator(780) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, se)
        proc.execute()
        image_bot_hat = HObject(proc.get_output_object_key(1))
        return image_bot_hat  # type: ignore


def gray_closing(image: HObject, se: HObject) -> HObject:
    """
    Perform a gray value closing on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    se : HObject
         Structuring element.

    Returns
    -------

    image_closing : HObject
                    Gray-closed image.

    See Also
    --------
    closing, gray_dilation, gray_erosion

    Alternatives
    ------------
    dual_rank, gray_closing_rect, gray_closing_shape

    Predecessors
    ------------
    read_gray_se, gen_disc_se, read_image
    """
    with HalconOperator(782) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, se)
        proc.execute()
        image_closing = HObject(proc.get_output_object_key(1))
        return image_closing  # type: ignore


def gray_closing_rect(
    image: HObject,
    mask_height: int,
    mask_width: int
) -> HObject:
    """
    Perform a gray value closing with a rectangular mask.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 11
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 11
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    Returns
    -------

    image_closing : HObject
                    Gray-closed image.

    See Also
    --------
    closing_rectangle1, gray_dilation_rect, gray_erosion_rect

    Alternatives
    ------------
    gray_closing, gray_closing_shape

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1464) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.execute()
        image_closing = HObject(proc.get_output_object_key(1))
        return image_closing  # type: ignore


def gray_closing_shape(
    image: HObject,
    mask_height: Union[int, float],
    mask_width: Union[int, float],
    mask_shape: str
) -> HObject:
    """
    Perform a gray value closing with a selected mask.

    Parameters
    ----------

    image : HObject
            Image for which the minimum gray values are to be calculated.

    mask_height : Union[int, float]
                  Height of the filter mask.
                  Value Suggestion: 11

    mask_width : Union[int, float]
                 Width of the filter mask.
                 Value Suggestion: 11

    mask_shape : str
                 Shape of the mask.
                 Value Suggestion: octagon

    Returns
    -------

    image_closing : HObject
                    Image containing the minimum gray values.

    See Also
    --------
    gray_dilation_shape, gray_erosion_shape, closing

    Alternatives
    ------------
    gray_closing

    Notes
    -----
    Note that gray_closing_shape requires considerably more time for mask
    sizes of type float than for mask sizes of type integer. This is
    especially true for rectangular masks with different width and height!
    gray_closing_shape can be executed on OpenCL devices. In case of mask
    sizes of type float the result can vary slightly from the CPU as the
    interpolation is calculated in single precision on the OpenCL device.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1459) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.set_input_tuple(2, mask_shape)
        proc.execute()
        image_closing = HObject(proc.get_output_object_key(1))
        return image_closing  # type: ignore


def gray_dilation(image: HObject, se: HObject) -> HObject:
    """
    Perform a gray value dilation on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    se : HObject
         Structuring element.

    Returns
    -------

    image_dilation : HObject
                     Gray-dilated image.

    See Also
    --------
    gray_opening, gray_closing, dilation1, gray_skeleton

    Alternatives
    ------------
    gray_dilation_rect, gray_dilation_shape

    Predecessors
    ------------
    read_gray_se, gen_disc_se, read_image

    Successors
    ----------
    sub_image, gray_erosion
    """
    with HalconOperator(784) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, se)
        proc.execute()
        image_dilation = HObject(proc.get_output_object_key(1))
        return image_dilation  # type: ignore


def gray_dilation_rect(
    image: HObject,
    mask_height: int,
    mask_width: int
) -> HObject:
    """
    Determine the maximum gray value within a rectangle.

    Parameters
    ----------

    image : HObject
            Image for which the maximum gray values are to be calculated.

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 11
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 11
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    Returns
    -------

    image_max : HObject
                Image containing the maximum gray values.

    See Also
    --------
    gray_skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1467) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.execute()
        image_max = HObject(proc.get_output_object_key(1))
        return image_max  # type: ignore


def gray_dilation_shape(
    image: HObject,
    mask_height: Union[int, float],
    mask_width: Union[int, float],
    mask_shape: str
) -> HObject:
    """
    Determine the maximum gray value within a selected mask.

    Parameters
    ----------

    image : HObject
            Image for which the maximum gray values are to be calculated.

    mask_height : Union[int, float]
                  Height of the filter mask.
                  Value Suggestion: 11

    mask_width : Union[int, float]
                 Width of the filter mask.
                 Value Suggestion: 11

    mask_shape : str
                 Shape of the mask.
                 Value Suggestion: octagon

    Returns
    -------

    image_max : HObject
                Image containing the maximum gray values.

    See Also
    --------
    gray_opening_shape, gray_closing_shape, gray_skeleton

    Alternatives
    ------------
    gray_dilation, gray_dilation_rect

    Notes
    -----
    Note that gray_dilation_shape requires considerably more time for mask
    sizes of type float than for mask sizes of type integer. This is
    especially true for rectangular masks with different width and height!
    gray_dilation_shape can be executed on OpenCL devices. In case of mask
    sizes of type float the result can vary slightly from the CPU as the
    interpolation is calculated in single precision on the OpenCL device.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1462) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.set_input_tuple(2, mask_shape)
        proc.execute()
        image_max = HObject(proc.get_output_object_key(1))
        return image_max  # type: ignore


def gray_erosion(image: HObject, se: HObject) -> HObject:
    """
    Perform a gray value erosion on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    se : HObject
         Structuring element.

    Returns
    -------

    image_erosion : HObject
                    Gray-eroded image.

    See Also
    --------
    gray_opening, gray_closing, erosion1, gray_skeleton

    Alternatives
    ------------
    gray_erosion_rect, gray_erosion_shape

    Predecessors
    ------------
    read_gray_se, gen_disc_se, read_image

    Successors
    ----------
    gray_dilation, sub_image
    """
    with HalconOperator(785) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, se)
        proc.execute()
        image_erosion = HObject(proc.get_output_object_key(1))
        return image_erosion  # type: ignore


def gray_erosion_rect(
    image: HObject,
    mask_height: int,
    mask_width: int
) -> HObject:
    """
    Determine the minimum gray value within a rectangle.

    Parameters
    ----------

    image : HObject
            Image for which the minimum gray values are to be calculated.

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 11
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 11
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    Returns
    -------

    image_min : HObject
                Image containing the minimum gray values.

    See Also
    --------
    gray_dilation_rect

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1466) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.execute()
        image_min = HObject(proc.get_output_object_key(1))
        return image_min  # type: ignore


def gray_erosion_shape(
    image: HObject,
    mask_height: Union[int, float],
    mask_width: Union[int, float],
    mask_shape: str
) -> HObject:
    """
    Determine the minimum gray value within a selected mask.

    Parameters
    ----------

    image : HObject
            Image for which the minimum gray values are to be calculated.

    mask_height : Union[int, float]
                  Height of the filter mask.
                  Value Suggestion: 11

    mask_width : Union[int, float]
                 Width of the filter mask.
                 Value Suggestion: 11

    mask_shape : str
                 Shape of the mask.
                 Value Suggestion: octagon

    Returns
    -------

    image_min : HObject
                Image containing the minimum gray values.

    See Also
    --------
    gray_opening_shape, gray_closing_shape, gray_skeleton

    Alternatives
    ------------
    gray_erosion, gray_erosion_rect

    Notes
    -----
    Note that gray_erosion_shape requires considerably more time for mask
    sizes of type float than for mask sizes of type integer. This is
    especially true for rectangular masks with different width and height!
    gray_erosion_shape can be executed on OpenCL devices. In case of mask
    sizes of type float the result can vary slightly from the CPU as the
    interpolation is calculated in single precision on the OpenCL device.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1461) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.set_input_tuple(2, mask_shape)
        proc.execute()
        image_min = HObject(proc.get_output_object_key(1))
        return image_min  # type: ignore


def gray_features(
    regions: HObject,
    image: HObject,
    features: MaybeSequence[str]
) -> Sequence[float]:
    """
    Calculates gray value features for a set of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    image : HObject
            Gray value image.

    features : MaybeSequence[str]
               Names of the features.
               Value Suggestion: mean

    Returns
    -------

    value : Sequence[float]
            Values of the features.

    See Also
    --------
    select_gray, deviation_image, entropy_gray, intensity, mean_image,
    min_max_gray, select_obj

    Predecessors
    ------------
    connection, mean_image, entropy_image, sobel_amp, median_separate

    Successors
    ----------
    select_gray, shape_trans, reduce_domain, count_obj

    Notes
    -----
    Several features are processed in the order in which they are entered.
    Note that the operator gray_features only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1749) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, features)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def gray_features_s(
    regions: HObject,
    image: HObject,
    features: MaybeSequence[str]
) -> float:
    """
    Calculates gray value features for a set of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    image : HObject
            Gray value image.

    features : MaybeSequence[str]
               Names of the features.
               Value Suggestion: mean

    Returns
    -------

    value : float
            Values of the features.

    See Also
    --------
    select_gray, deviation_image, entropy_gray, intensity, mean_image,
    min_max_gray, select_obj

    Predecessors
    ------------
    connection, mean_image, entropy_image, sobel_amp, median_separate

    Successors
    ----------
    select_gray, shape_trans, reduce_domain, count_obj

    Notes
    -----
    Several features are processed in the order in which they are entered.
    Note that the operator gray_features only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1749) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, features)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def gray_histo(
    regions: HObject,
    image: HObject
) -> Tuple[Sequence[int], Sequence[float]]:
    """
    Calculate the gray value distribution.

    Parameters
    ----------

    regions : HObject
              Region in which the histogram is to be calculated.

    image : HObject
            Image the gray value distribution of which is to be calculated.

    Returns
    -------

    absolute_histo : Sequence[int]
                     Absolute frequencies of the gray values.

    relative_histo : Sequence[float]
                     Frequencies, normalized to the area of the region.

    See Also
    --------
    set_paint, histo_2dim, scale_image_max, entropy_gray

    Alternatives
    ------------
    min_max_gray, intensity, gray_histo_abs, gray_histo_range

    Successors
    ----------
    histo_to_thresh, gen_region_histo

    Notes
    -----
    Note that the operator gray_histo only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    Real, int2, uint2, and int4 images are reduced to 256 gray values.
    gray_histo can be executed on OpenCL devices for byte, int1,
    directional and cyclic images if the OpenCL device supports the
    cl_khr_local_int32_base_atomics and cl_khr_global_int32_base_atomics
    extensions (which are optional in OpenCL 1.0). Unlike most other
    HALCON operators, gray_histo can be substantially slower on an OpenCL
    device if the Image is not completely included in the  Regions.
    OpenCL support is not available in HALCON XL, as 64 bit atomic integer
    arithmetic would be required.
    """
    with HalconOperator(1756) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # absolute_histo
            proc.get_output_tuple_m(1)   # relative_histo
        )  # type: ignore


def gray_histo_abs(
    regions: HObject,
    image: HObject,
    quantization: Union[int, float]
) -> Sequence[int]:
    """
    Calculate the gray value distribution.

    Parameters
    ----------

    regions : HObject
              Region in which the histogram is to be calculated.

    image : HObject
            Image the gray value distribution of which is to be calculated.

    quantization : Union[int, float]
                   Quantization of the gray values.
                   Value Suggestion: 1.0
                   Assertion: Quantization >= 1.0

    Returns
    -------

    absolute_histo : Sequence[int]
                     Absolute frequencies of the gray values.

    See Also
    --------
    disp_image, histo_2dim, scale_image_max, entropy_gray

    Alternatives
    ------------
    min_max_gray, intensity, gray_histo, gray_histo_range

    Successors
    ----------
    histo_to_thresh, gen_region_histo

    Notes
    -----
    Note that the operator gray_histo_abs only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1755) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, quantization)
        proc.init_oct(0)
        proc.execute()
        absolute_histo = proc.get_output_tuple_m(0)
        return absolute_histo  # type: ignore


def gray_histo_range(
    regions: HObject,
    image: HObject,
    min: Union[float, int],
    max: Union[float, int],
    num_bins: int
) -> Tuple[Sequence[int], float]:
    """
    Calculate the gray value distribution of a single channel image within
    a certain gray value range.

    Parameters
    ----------

    regions : HObject
              Region in which the histogram is to be calculated.

    image : HObject
            Input image.

    min : Union[float, int]
          Minimum gray value.
          Value Suggestion: 0

    max : Union[float, int]
          Maximum gray value.
          Value Suggestion: 255
          Assertion: Max >= Min

    num_bins : int
               Number of bins.
               Value Suggestion: 256
               Assertion: NumBins >= 1

    Returns
    -------

    histo : Sequence[int]
            Histogram to be calculated.

    bin_size : float
               Bin size.

    See Also
    --------
    histo_2dim, scale_image_max

    Alternatives
    ------------
    gray_histo, gray_histo_abs

    Predecessors
    ------------
    min_max_gray

    Successors
    ----------
    create_funct_1d_array

    Notes
    -----
    Note that the operator gray_histo_range only considers  the given
    Regions and ignores any previously set domain of the input image
    Image.
    If the Image has discrete gray values the value of BinSize may cause
    the following effects: For BinSize $>$ 1 multiple neighboring gray
    values are assigned to the same bin. If BinSize is no integer the gray
    values are distributed uneven among the bins, e.g., for BinSize $=$
    1.5 the first and second gray value are assigned to the first bin, the
    third gray value is assigned to the second bin, and the fourth and
    fifth gray value are assigned to the third bin. This becomes
    noticeable in several peeks in the histogram Histo. If BinSize $<$ 1
    some classes are not assigned by any gray value, e.g., for BinSize $=$
    0.5 the first gray value is assigned to the first bin and the second
    gray value is assigned to the third bin. The histogram Histo shows
    some gaps, which resembles the structure of a comb.
    If the Image is of type real and  $Min = Max$, all pixels of the
    corresponding gray value are assigned only to the first bin.
    """
    with HalconOperator(1753) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, min)
        proc.set_input_tuple(1, max)
        proc.set_input_tuple(2, num_bins)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # histo
            proc.get_output_tuple_s(1)   # bin_size
        )  # type: ignore


def gray_histo_range_s(
    regions: HObject,
    image: HObject,
    min: Union[float, int],
    max: Union[float, int],
    num_bins: int
) -> Tuple[int, float]:
    """
    Calculate the gray value distribution of a single channel image within
    a certain gray value range.

    Parameters
    ----------

    regions : HObject
              Region in which the histogram is to be calculated.

    image : HObject
            Input image.

    min : Union[float, int]
          Minimum gray value.
          Value Suggestion: 0

    max : Union[float, int]
          Maximum gray value.
          Value Suggestion: 255
          Assertion: Max >= Min

    num_bins : int
               Number of bins.
               Value Suggestion: 256
               Assertion: NumBins >= 1

    Returns
    -------

    histo : int
            Histogram to be calculated.

    bin_size : float
               Bin size.

    See Also
    --------
    histo_2dim, scale_image_max

    Alternatives
    ------------
    gray_histo, gray_histo_abs

    Predecessors
    ------------
    min_max_gray

    Successors
    ----------
    create_funct_1d_array

    Notes
    -----
    Note that the operator gray_histo_range only considers  the given
    Regions and ignores any previously set domain of the input image
    Image.
    If the Image has discrete gray values the value of BinSize may cause
    the following effects: For BinSize $>$ 1 multiple neighboring gray
    values are assigned to the same bin. If BinSize is no integer the gray
    values are distributed uneven among the bins, e.g., for BinSize $=$
    1.5 the first and second gray value are assigned to the first bin, the
    third gray value is assigned to the second bin, and the fourth and
    fifth gray value are assigned to the third bin. This becomes
    noticeable in several peeks in the histogram Histo. If BinSize $<$ 1
    some classes are not assigned by any gray value, e.g., for BinSize $=$
    0.5 the first gray value is assigned to the first bin and the second
    gray value is assigned to the third bin. The histogram Histo shows
    some gaps, which resembles the structure of a comb.
    If the Image is of type real and  $Min = Max$, all pixels of the
    corresponding gray value are assigned only to the first bin.
    """
    with HalconOperator(1753) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, min)
        proc.set_input_tuple(1, max)
        proc.set_input_tuple(2, num_bins)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # histo
            proc.get_output_tuple_s(1)   # bin_size
        )  # type: ignore


def gray_inside(image: HObject) -> HObject:
    """
    Calculate the lowest possible gray value on an arbitrary path to the
    image border for each point in the image.

    Parameters
    ----------

    image : HObject
            Image being processed.

    Returns
    -------

    image_dist : HObject
                 Result image.

    See Also
    --------
    watersheds

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image, mean_image, median_image

    Successors
    ----------
    select_shape, area_center, count_obj

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1477) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_dist = HObject(proc.get_output_object_key(1))
        return image_dist  # type: ignore


def gray_opening(image: HObject, se: HObject) -> HObject:
    """
    Perform a gray value opening on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    se : HObject
         Structuring element.

    Returns
    -------

    image_opening : HObject
                    Gray-opened image.

    See Also
    --------
    opening, gray_dilation, gray_erosion

    Alternatives
    ------------
    dual_rank, gray_opening_rect, gray_opening_shape

    Predecessors
    ------------
    read_gray_se, gen_disc_se, read_image
    """
    with HalconOperator(783) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, se)
        proc.execute()
        image_opening = HObject(proc.get_output_object_key(1))
        return image_opening  # type: ignore


def gray_opening_rect(
    image: HObject,
    mask_height: int,
    mask_width: int
) -> HObject:
    """
    Perform a gray value opening with a rectangular mask.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 11
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 11
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    Returns
    -------

    image_opening : HObject
                    Gray-opened image.

    See Also
    --------
    opening_rectangle1, gray_dilation_rect, gray_erosion_rect

    Alternatives
    ------------
    gray_opening, gray_opening_shape

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1465) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.execute()
        image_opening = HObject(proc.get_output_object_key(1))
        return image_opening  # type: ignore


def gray_opening_shape(
    image: HObject,
    mask_height: Union[int, float],
    mask_width: Union[int, float],
    mask_shape: str
) -> HObject:
    """
    Perform a gray value opening with a selected mask.

    Parameters
    ----------

    image : HObject
            Image for which the minimum gray values are to be calculated.

    mask_height : Union[int, float]
                  Height of the filter mask.
                  Value Suggestion: 11

    mask_width : Union[int, float]
                 Width of the filter mask.
                 Value Suggestion: 11

    mask_shape : str
                 Shape of the mask.
                 Value Suggestion: octagon

    Returns
    -------

    image_opening : HObject
                    Image containing the minimum gray values.

    See Also
    --------
    gray_dilation_shape, gray_erosion_shape, opening

    Alternatives
    ------------
    gray_opening

    Notes
    -----
    Note that gray_opening_shape requires considerably more time for mask
    sizes of type float than for mask sizes of type integer. This is
    especially true for rectangular masks with different width and height!
    gray_opening_shape can be executed on OpenCL devices. In case of mask
    sizes of type float the result can vary slightly from the CPU as the
    interpolation is calculated in single precision on the OpenCL device.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1460) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.set_input_tuple(2, mask_shape)
        proc.execute()
        image_opening = HObject(proc.get_output_object_key(1))
        return image_opening  # type: ignore


def gray_projections(
    region: HObject,
    image: HObject,
    mode: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate horizontal and vertical gray-value projections.

    Parameters
    ----------

    region : HObject
             Region to be processed.

    image : HObject
            Grayvalues for projections.

    mode : str
           Method to compute the projections.
           Value Suggestion: simple

    Returns
    -------

    hor_projection : Sequence[float]
                     Horizontal projection.

    vert_projection : Sequence[float]
                      Vertical projection.

    Notes
    -----
    The operator gray_projections only considers the given Region and
    ignores any previously set domain of the input image Image.
    If $n(x) = 0$, i.e., if there are no region points in the
    corresponding row $r+r'$ or column $c+c'$, the respective value of
    HorProjection or VertProjection is set to $-1$.
    gray_projections can be executed on an OpenCL device for the 'simple'
    mode if the OpenCL device supports the
    cl_khr_global_int32_base_atomics OpenCL extension. For processing
    images of type real, the OpenCL device must support the cl_khr_fp64
    and cl_khr_int64_base_atomics extensions.
    """
    with HalconOperator(1765) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, mode)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hor_projection
            proc.get_output_tuple_m(1)   # vert_projection
        )  # type: ignore


def gray_range_rect(
    image: HObject,
    mask_height: int,
    mask_width: int
) -> HObject:
    """
    Determine the gray value range within a rectangle.

    Parameters
    ----------

    image : HObject
            Image for which the gray value range is to be calculated.

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 11
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 11
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    Returns
    -------

    image_result : HObject
                   Image containing the gray value range.

    Alternatives
    ------------
    gray_dilation_rect, gray_erosion_rect, sub_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1463) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def gray_skeleton(image: HObject) -> HObject:
    """
    Thinning of gray value images.

    Parameters
    ----------

    image : HObject
            Image to be thinned.

    Returns
    -------

    gray_skeleton : HObject
                    Thinned image.

    See Also
    --------
    skeleton, gray_dilation_rect

    Alternatives
    ------------
    nonmax_suppression_amp, nonmax_suppression_dir, local_max

    Successors
    ----------
    mean_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1468) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        gray_skeleton = HObject(proc.get_output_object_key(1))
        return gray_skeleton  # type: ignore


def gray_tophat(image: HObject, se: HObject) -> HObject:
    """
    Perform a gray value top hat transformation on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    se : HObject
         Structuring element.

    Returns
    -------

    image_top_hat : HObject
                    Top hat image.

    See Also
    --------
    gray_bothat, top_hat, gray_erosion_rect, sub_image

    Alternatives
    ------------
    gray_opening

    Predecessors
    ------------
    read_gray_se, gen_disc_se, read_image

    Successors
    ----------
    threshold
    """
    with HalconOperator(781) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, se)
        proc.execute()
        image_top_hat = HObject(proc.get_output_object_key(1))
        return image_top_hat  # type: ignore


def guided_filter(
    image: HObject,
    image_guide: HObject,
    radius: int,
    amplitude: float
) -> HObject:
    """
    Guided filtering of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    image_guide : HObject
                  Guidance image.

    radius : int
             Radius of the filtering operation.
             Value Suggestion: 3
             Assertion: Radius > 0

    amplitude : float
                Controls the influence of edges on the smoothing.
                Value Suggestion: 20.0
                Assertion: Amplitude > 0

    Returns
    -------

    image_guided : HObject
                   Output image.

    Alternatives
    ------------
    bilateral_filter, anisotropic_diffusion, median_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing
    """
    with HalconOperator(2078) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, image_guide)
        proc.set_input_tuple(0, radius)
        proc.set_input_tuple(1, amplitude)
        proc.execute()
        image_guided = HObject(proc.get_output_object_key(1))
        return image_guided  # type: ignore


def hamming_change_region(
    input_region: HObject,
    width: int,
    height: int,
    distance: int
) -> HObject:
    """
    Generate a region having a given Hamming distance.

    Parameters
    ----------

    input_region : HObject
                   Region to be modified.

    width : int
            Width of the region to be changed.
            Value Suggestion: 100
            Assertion: Width > 0

    height : int
             Height of the region to be changed.
             Value Suggestion: 100
             Assertion: Height > 0

    distance : int
               Hamming distance between the old and new regions.
               Value Suggestion: 1000
               Assertion: Distance >= 0 && Distance < Width * Height

    Returns
    -------

    output_region : HObject
                    Regions having the required Hamming distance.

    See Also
    --------
    hamming_distance

    Predecessors
    ------------
    connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape

    Warnings
    --------
    hamming_change_region is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    If Width and Height are chosen too large the resulting region requires
    a lot of memory.
    """
    with HalconOperator(506) as proc:
        proc.set_input_object(1, input_region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, distance)
        proc.execute()
        output_region = HObject(proc.get_output_object_key(1))
        return output_region  # type: ignore


def hamming_distance(
    regions_1: HObject,
    regions_2: HObject
) -> Tuple[Sequence[int], Sequence[float]]:
    """
    Hamming distance between two regions.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Comparative regions.

    Returns
    -------

    distance : Sequence[int]
               Hamming distance of two regions.
               Assertion: Distance >= 0

    similarity : Sequence[float]
                 Similarity of two regions.
                 Assertion: 0 <= Similarity && Similarity <= 1

    See Also
    --------
    hamming_change_region

    Alternatives
    ------------
    intersection, complement, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    In both input parameters the same number of regions must be passed.
    """
    with HalconOperator(1717) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance
            proc.get_output_tuple_m(1)   # similarity
        )  # type: ignore


def hamming_distance_norm(
    regions_1: HObject,
    regions_2: HObject,
    norm: MaybeSequence[str]
) -> Tuple[Sequence[int], Sequence[float]]:
    """
    Hamming distance between two regions using normalization.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Comparative regions.

    norm : MaybeSequence[str]
           Type of normalization.
           Value Suggestion: center

    Returns
    -------

    distance : Sequence[int]
               Hamming distance of two regions.
               Assertion: Distance >= 0

    similarity : Sequence[float]
                 Similarity of two regions.
                 Assertion: 0 <= Similarity && Similarity <= 1

    See Also
    --------
    hamming_change_region

    Alternatives
    ------------
    intersection, complement, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    In both input parameters the same number of regions must be passed.
    """
    with HalconOperator(1716) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.set_input_tuple(0, norm)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance
            proc.get_output_tuple_m(1)   # similarity
        )  # type: ignore


def hamming_distance_norm_s(
    regions_1: HObject,
    regions_2: HObject,
    norm: MaybeSequence[str]
) -> Tuple[int, float]:
    """
    Hamming distance between two regions using normalization.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Comparative regions.

    norm : MaybeSequence[str]
           Type of normalization.
           Value Suggestion: center

    Returns
    -------

    distance : int
               Hamming distance of two regions.
               Assertion: Distance >= 0

    similarity : float
                 Similarity of two regions.
                 Assertion: 0 <= Similarity && Similarity <= 1

    See Also
    --------
    hamming_change_region

    Alternatives
    ------------
    intersection, complement, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    In both input parameters the same number of regions must be passed.
    """
    with HalconOperator(1716) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.set_input_tuple(0, norm)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance
            proc.get_output_tuple_s(1)   # similarity
        )  # type: ignore


def hamming_distance_s(
    regions_1: HObject,
    regions_2: HObject
) -> Tuple[int, float]:
    """
    Hamming distance between two regions.

    Parameters
    ----------

    regions_1 : HObject
                Regions to be examined.

    regions_2 : HObject
                Comparative regions.

    Returns
    -------

    distance : int
               Hamming distance of two regions.
               Assertion: Distance >= 0

    similarity : float
                 Similarity of two regions.
                 Assertion: 0 <= Similarity && Similarity <= 1

    See Also
    --------
    hamming_change_region

    Alternatives
    ------------
    intersection, complement, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    In both input parameters the same number of regions must be passed.
    """
    with HalconOperator(1717) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance
            proc.get_output_tuple_s(1)   # similarity
        )  # type: ignore


def hand_eye_calibration(
    x: Sequence[Union[float, int]],
    y: Sequence[Union[float, int]],
    z: Sequence[Union[float, int]],
    row: Sequence[Union[float, int]],
    col: Sequence[Union[float, int]],
    num_points: Sequence[int],
    robot_poses: Sequence[Union[int, float]],
    camera_param: Sequence[Union[int, float, str]],
    method: str,
    quality_type: MaybeSequence[str]
) -> Tuple[Sequence[Union[int, float]], Sequence[Union[int, float]], Sequence[float]]:
    """
    Perform a hand-eye calibration.

    Parameters
    ----------

    x : Sequence[Union[float, int]]
        Linear list containing all the x coordinates of the calibration
        points (in the order of the images).

    y : Sequence[Union[float, int]]
        Linear list containing all the y coordinates of the calibration
        points (in the order of the images).

    z : Sequence[Union[float, int]]
        Linear list containing all the z coordinates of the calibration
        points (in the order of the images).

    row : Sequence[Union[float, int]]
          Linear list containing all row coordinates of the calibration
          points (in the order of the images).

    col : Sequence[Union[float, int]]
          Linear list containing all the column coordinates of the
          calibration points (in the order of the images).

    num_points : Sequence[int]
                 Number of the calibration points for each image.

    robot_poses : Sequence[Union[int, float]]
                  Known 3D pose of the robot for each image (moving
                  camera: robot base in robot tool coordinates; stationary
                  camera: robot tool in robot base coordinates).

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    method : str
             Method of hand-eye calibration.
             Value Suggestion: 'nonlinear'

    quality_type : MaybeSequence[str]
                   Type of quality assessment.
                   Value Suggestion: 'error_pose'

    Returns
    -------

    camera_pose : Sequence[Union[int, float]]
                  Computed relative camera pose: 3D pose of the robot tool
                  (moving camera) or robot base (stationary camera),
                  respectively, in camera coordinates.

    calibration_pose : Sequence[Union[int, float]]
                       Computed 3D pose of the calibration points in robot
                       base coordinates (moving camera) or in robot tool
                       coordinates (stationary camera), respectively.

    quality : Sequence[float]
              Quality assessment of the result.

    See Also
    --------
    find_caltab, find_marks_and_pose, disp_caltab, sim_caltab,
    write_cam_par, read_cam_par, create_pose, convert_pose_type,
    write_pose, read_pose, pose_to_hom_mat3d, hom_mat3d_to_pose,
    caltab_points, gen_caltab, calibrate_hand_eye

    Alternatives
    ------------
    calibrate_hand_eye

    Predecessors
    ------------
    find_marks_and_pose, camera_calibration, calibrate_cameras

    Successors
    ----------
    write_pose, convert_pose_type, pose_to_hom_mat3d, disp_caltab,
    sim_caltab
    """
    with HalconOperator(1918) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, row)
        proc.set_input_tuple(4, col)
        proc.set_input_tuple(5, num_points)
        proc.set_input_tuple(6, robot_poses)
        proc.set_input_tuple(7, camera_param)
        proc.set_input_tuple(8, method)
        proc.set_input_tuple(9, quality_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_pose
            proc.get_output_tuple_m(1),  # calibration_pose
            proc.get_output_tuple_m(2)   # quality
        )  # type: ignore


def hand_eye_calibration_s(
    x: Sequence[Union[float, int]],
    y: Sequence[Union[float, int]],
    z: Sequence[Union[float, int]],
    row: Sequence[Union[float, int]],
    col: Sequence[Union[float, int]],
    num_points: Sequence[int],
    robot_poses: Sequence[Union[int, float]],
    camera_param: Sequence[Union[int, float, str]],
    method: str,
    quality_type: MaybeSequence[str]
) -> Tuple[Sequence[Union[int, float]], Sequence[Union[int, float]], float]:
    """
    Perform a hand-eye calibration.

    Parameters
    ----------

    x : Sequence[Union[float, int]]
        Linear list containing all the x coordinates of the calibration
        points (in the order of the images).

    y : Sequence[Union[float, int]]
        Linear list containing all the y coordinates of the calibration
        points (in the order of the images).

    z : Sequence[Union[float, int]]
        Linear list containing all the z coordinates of the calibration
        points (in the order of the images).

    row : Sequence[Union[float, int]]
          Linear list containing all row coordinates of the calibration
          points (in the order of the images).

    col : Sequence[Union[float, int]]
          Linear list containing all the column coordinates of the
          calibration points (in the order of the images).

    num_points : Sequence[int]
                 Number of the calibration points for each image.

    robot_poses : Sequence[Union[int, float]]
                  Known 3D pose of the robot for each image (moving
                  camera: robot base in robot tool coordinates; stationary
                  camera: robot tool in robot base coordinates).

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    method : str
             Method of hand-eye calibration.
             Value Suggestion: 'nonlinear'

    quality_type : MaybeSequence[str]
                   Type of quality assessment.
                   Value Suggestion: 'error_pose'

    Returns
    -------

    camera_pose : Sequence[Union[int, float]]
                  Computed relative camera pose: 3D pose of the robot tool
                  (moving camera) or robot base (stationary camera),
                  respectively, in camera coordinates.

    calibration_pose : Sequence[Union[int, float]]
                       Computed 3D pose of the calibration points in robot
                       base coordinates (moving camera) or in robot tool
                       coordinates (stationary camera), respectively.

    quality : float
              Quality assessment of the result.

    See Also
    --------
    find_caltab, find_marks_and_pose, disp_caltab, sim_caltab,
    write_cam_par, read_cam_par, create_pose, convert_pose_type,
    write_pose, read_pose, pose_to_hom_mat3d, hom_mat3d_to_pose,
    caltab_points, gen_caltab, calibrate_hand_eye

    Alternatives
    ------------
    calibrate_hand_eye

    Predecessors
    ------------
    find_marks_and_pose, camera_calibration, calibrate_cameras

    Successors
    ----------
    write_pose, convert_pose_type, pose_to_hom_mat3d, disp_caltab,
    sim_caltab
    """
    with HalconOperator(1918) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, row)
        proc.set_input_tuple(4, col)
        proc.set_input_tuple(5, num_points)
        proc.set_input_tuple(6, robot_poses)
        proc.set_input_tuple(7, camera_param)
        proc.set_input_tuple(8, method)
        proc.set_input_tuple(9, quality_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_pose
            proc.get_output_tuple_m(1),  # calibration_pose
            proc.get_output_tuple_s(2)   # quality
        )  # type: ignore


def handle_to_integer(handle: MaybeSequence[HHandle]) -> Sequence[int]:
    """
    Convert a handle into an integer.

    Parameters
    ----------

    handle : MaybeSequence[HHandle]
             The handle to be casted.

    Returns
    -------

    casted_handle : Sequence[int]
                    The handle casted to an integer value.

    See Also
    --------
    integer_to_handle

    Warnings
    --------
    It is not recommended to use this operator in HDevelop. This operator
    is only provided for reasons of backward compatibility.

    Notes
    -----
    It is not recommended to use this operator in HDevelop. It is solely
    provided to enable backward compatibility with legacy code.
    """
    with HalconOperator(2136) as proc:
        proc.set_input_tuple(0, handle)
        proc.init_oct(0)
        proc.execute()
        casted_handle = proc.get_output_tuple_m(0)
        return casted_handle  # type: ignore


def handle_to_integer_s(handle: MaybeSequence[HHandle]) -> int:
    """
    Convert a handle into an integer.

    Parameters
    ----------

    handle : MaybeSequence[HHandle]
             The handle to be casted.

    Returns
    -------

    casted_handle : int
                    The handle casted to an integer value.

    See Also
    --------
    integer_to_handle

    Warnings
    --------
    It is not recommended to use this operator in HDevelop. This operator
    is only provided for reasons of backward compatibility.

    Notes
    -----
    It is not recommended to use this operator in HDevelop. It is solely
    provided to enable backward compatibility with legacy code.
    """
    with HalconOperator(2136) as proc:
        proc.set_input_tuple(0, handle)
        proc.init_oct(0)
        proc.execute()
        casted_handle = proc.get_output_tuple_s(0)
        return casted_handle  # type: ignore


def harmonic_interpolation(
    image: HObject,
    region: HObject,
    precision: float
) -> HObject:
    """
    Perform a harmonic interpolation on an image region.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             Inpainting region.

    precision : float
                Computational accuracy.
                Value Suggestion: 0.001
                Assertion: Precision >= 0.0

    Returns
    -------

    inpainted_image : HObject
                      Output image.

    Alternatives
    ------------
    inpainting_ct, inpainting_aniso, inpainting_mcf, inpainting_texture,
    inpainting_ced

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1451) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, precision)
        proc.execute()
        inpainted_image = HObject(proc.get_output_object_key(1))
        return inpainted_image  # type: ignore


def height_width_ratio(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[int], Sequence[float]]:
    """
    Compute the width, height, and aspect ratio of the surrounding
    rectangle parallel to the coordinate axes.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    height : Sequence[int]
             Height of the surrounding rectangle of the region.

    width : Sequence[int]
            Width of the surrounding rectangle of the region.

    ratio : Sequence[float]
            Aspect ratio of the surrounding rectangle of the region.

    See Also
    --------
    select_shape, smallest_circle, elliptic_axis, area_center

    Alternatives
    ------------
    smallest_rectangle1, smallest_rectangle2, region_features

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features
    """
    with HalconOperator(2119) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # height
            proc.get_output_tuple_m(1),  # width
            proc.get_output_tuple_m(2)   # ratio
        )  # type: ignore


def height_width_ratio_s(regions: HObject) -> Tuple[int, int, float]:
    """
    Compute the width, height, and aspect ratio of the surrounding
    rectangle parallel to the coordinate axes.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    height : int
             Height of the surrounding rectangle of the region.

    width : int
            Width of the surrounding rectangle of the region.

    ratio : float
            Aspect ratio of the surrounding rectangle of the region.

    See Also
    --------
    select_shape, smallest_circle, elliptic_axis, area_center

    Alternatives
    ------------
    smallest_rectangle1, smallest_rectangle2, region_features

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features
    """
    with HalconOperator(2119) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # height
            proc.get_output_tuple_s(1),  # width
            proc.get_output_tuple_s(2)   # ratio
        )  # type: ignore


def height_width_ratio_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the width, height, and aspect ratio of the enclosing rectangle
    parallel to the coordinate axes of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    height : Sequence[float]
             Height of the enclosing rectangle.

    width : Sequence[float]
            Width of the enclosing rectangle.

    ratio : Sequence[float]
            Aspect ratio of the enclosing rectangle.

    See Also
    --------
    shape_trans_xld, smallest_circle_xld, elliptic_axis_xld,
    area_center_xld

    Alternatives
    ------------
    smallest_rectangle1_xld, smallest_rectangle2_xld, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    If $Width=0$Width=0, Ratio is set to DBL_MAX (1.797e308).
    """
    with HalconOperator(2120) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # height
            proc.get_output_tuple_m(1),  # width
            proc.get_output_tuple_m(2)   # ratio
        )  # type: ignore


def height_width_ratio_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Compute the width, height, and aspect ratio of the enclosing rectangle
    parallel to the coordinate axes of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    height : float
             Height of the enclosing rectangle.

    width : float
            Width of the enclosing rectangle.

    ratio : float
            Aspect ratio of the enclosing rectangle.

    See Also
    --------
    shape_trans_xld, smallest_circle_xld, elliptic_axis_xld,
    area_center_xld

    Alternatives
    ------------
    smallest_rectangle1_xld, smallest_rectangle2_xld, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    If $Width=0$Width=0, Ratio is set to DBL_MAX (1.797e308).
    """
    with HalconOperator(2120) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # height
            proc.get_output_tuple_s(1),  # width
            proc.get_output_tuple_s(2)   # ratio
        )  # type: ignore


def highpass_image(image: HObject, width: int, height: int) -> HObject:
    """
    Extract high frequency components from an image.

    Parameters
    ----------

    image : HObject
            Input image.

    width : int
            Width of the filter mask.
            Value Suggestion: 9
            Assertion: Width >= 3 && odd(Width)

    height : int
             Height of the filter mask.
             Value Suggestion: 9
             Assertion: Height >= 3 && odd(Height)

    Returns
    -------

    highpass : HObject
               High-pass-filtered result image.

    See Also
    --------
    dyn_threshold

    Alternatives
    ------------
    mean_image, sub_image, convol_image, bandpass_image

    Successors
    ----------
    threshold, skeleton

    Notes
    -----
    If even values are passed for Height or Width, the operator uses the
    next larger odd value instead.  Thus, the center of the filter mask is
    always uniquely determined.
    highpass_image can be executed on OpenCL devices. The same limitations
    as for mean_image and sub_image apply.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1564) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        highpass = HObject(proc.get_output_object_key(1))
        return highpass  # type: ignore


def histo_2dim(
    regions: HObject,
    image_col: HObject,
    image_row: HObject
) -> HObject:
    """
    Calculate the histogram of two-channel gray value images.

    Parameters
    ----------

    regions : HObject
              Region in which the histogram is to be calculated.

    image_col : HObject
                Channel 1.

    image_row : HObject
                Channel 2.

    Returns
    -------

    histo_2dim : HObject
                 Histogram to be calculated.

    See Also
    --------
    get_grayval

    Alternatives
    ------------
    gray_histo, gray_histo_abs

    Predecessors
    ------------
    decompose3, decompose2, draw_region

    Successors
    ----------
    threshold, class_2dim_sup, pouring, local_max, gray_skeleton

    Notes
    -----
    Note that the operator histo_2dim only considers  the given Regions
    and ignores any previously set domain of the input images.
    """
    with HalconOperator(1754) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image_col)
        proc.set_input_object(3, image_row)
        proc.execute()
        histo_2dim = HObject(proc.get_output_object_key(1))
        return histo_2dim  # type: ignore


def histo_to_thresh(
    histogramm: Sequence[Union[int, float]],
    sigma: float
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Determine gray value thresholds from a histogram.

    Parameters
    ----------

    histogramm : Sequence[Union[int, float]]
                 Gray value histogram.

    sigma : float
            Sigma for the Gaussian smoothing of the histogram.
            Value Suggestion: 2.0

    Returns
    -------

    min_thresh : Sequence[int]
                 Minimum thresholds.

    max_thresh : Sequence[int]
                 Maximum thresholds.

    See Also
    --------
    auto_threshold, binary_threshold, char_threshold

    Predecessors
    ------------
    gray_histo

    Successors
    ----------
    threshold
    """
    with HalconOperator(471) as proc:
        proc.set_input_tuple(0, histogramm)
        proc.set_input_tuple(1, sigma)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # min_thresh
            proc.get_output_tuple_m(1)   # max_thresh
        )  # type: ignore


def hit_or_miss(
    region: HObject,
    struct_element_1: HObject,
    struct_element_2: HObject,
    row: int,
    column: int
) -> HObject:
    """
    Hit-or-miss operation for regions.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_element_1 : HObject
                       Erosion mask for the input regions.

    struct_element_2 : HObject
                       Erosion mask for the complements of the input
                       regions.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 16

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 16

    Returns
    -------

    region_hit_miss : HObject
                      Result of the hit-or-miss operation.

    See Also
    --------
    gen_region_points, gen_region_polygon_filled

    Alternatives
    ------------
    erosion2, dilation2

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    difference, reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(748) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element_1)
        proc.set_input_object(3, struct_element_2)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.execute()
        region_hit_miss = HObject(proc.get_output_object_key(1))
        return region_hit_miss  # type: ignore


def hit_or_miss_golay(
    region: HObject,
    golay_element: str,
    rotation: int
) -> HObject:
    """
    Hit-or-miss operation for regions using the Golay alphabet.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_hit_miss : HObject
                      Result of the hit-or-miss operation.

    See Also
    --------
    erosion_golay, dilation_golay, opening_golay, closing_golay,
    thinning_golay, thickening_golay, golay_elements

    Alternatives
    ------------
    hit_or_miss_seq, hit_or_miss

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    hit_or_miss_golay is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.
    """
    with HalconOperator(747) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, rotation)
        proc.execute()
        region_hit_miss = HObject(proc.get_output_object_key(1))
        return region_hit_miss  # type: ignore


def hit_or_miss_seq(region: HObject, golay_element: str) -> HObject:
    """
    Hit-or-miss operation for regions using the Golay alphabet
    (sequential).

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    Returns
    -------

    region_hit_miss : HObject
                      Result of the hit-or-miss operation.

    See Also
    --------
    thinning_seq, thickening_seq

    Alternatives
    ------------
    hit_or_miss_golay, hit_or_miss

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    hit_or_miss_seq is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(746) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.execute()
        region_hit_miss = HObject(proc.get_output_object_key(1))
        return region_hit_miss  # type: ignore


def hom_mat2d_compose(
    hom_mat_2dleft: Sequence[float],
    hom_mat_2dright: Sequence[float]
) -> Sequence[float]:
    """
    Multiply two homogeneous 2D transformation matrices.

    Parameters
    ----------

    hom_mat_2dleft : Sequence[float]
                     Left input transformation matrix.

    hom_mat_2dright : Sequence[float]
                      Right input transformation matrix.

    Returns
    -------

    hom_mat_2dcompose : Sequence[float]
                        Output transformation matrix.

    Predecessors
    ------------
    hom_mat2d_compose, hom_mat2d_translate, hom_mat2d_translate_local,
    hom_mat2d_scale, hom_mat2d_scale_local, hom_mat2d_rotate,
    hom_mat2d_rotate_local, hom_mat2d_slant, hom_mat2d_slant_local,
    hom_mat2d_reflect, hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_compose, hom_mat2d_translate, hom_mat2d_translate_local,
    hom_mat2d_scale, hom_mat2d_scale_local, hom_mat2d_rotate,
    hom_mat2d_rotate_local, hom_mat2d_slant, hom_mat2d_slant_local,
    hom_mat2d_reflect, hom_mat2d_reflect_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  2cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(277) as proc:
        proc.set_input_tuple(0, hom_mat_2dleft)
        proc.set_input_tuple(1, hom_mat_2dright)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dcompose = proc.get_output_tuple_m(0)
        return hom_mat_2dcompose  # type: ignore


def hom_mat2d_determinant(hom_mat_2d: Sequence[float]) -> float:
    """
    Compute the determinant of a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    determinant : float
                  Determinant of the input matrix.

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local
    """
    with HalconOperator(274) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.init_oct(0)
        proc.execute()
        determinant = proc.get_output_tuple_s(0)
        return determinant  # type: ignore


def hom_mat2d_identity() -> Sequence[float]:
    """
    Generate the homogeneous transformation matrix of the identical 2D
    transformation.

    Returns
    -------

    hom_mat_2didentity : Sequence[float]
                         Transformation matrix.

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is not stored because it is identical for all homogeneous
    matrices that describe an affine transformation. Thus,
    HomMat2DIdentity is stored as the tuple [1,0,0,0,1,0].
    """
    with HalconOperator(288) as proc:
        proc.init_oct(0)
        proc.execute()
        hom_mat_2didentity = proc.get_output_tuple_m(0)
        return hom_mat_2didentity  # type: ignore


def hom_mat2d_invert(hom_mat_2d: Sequence[float]) -> Sequence[float]:
    """
    Invert a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    hom_mat_2dinvert : Sequence[float]
                       Output transformation matrix.

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  2cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(276) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dinvert = proc.get_output_tuple_m(0)
        return hom_mat_2dinvert  # type: ignore


def hom_mat2d_reflect(
    hom_mat_2d: Sequence[float],
    px: Union[float, int],
    py: Union[float, int],
    qx: Union[float, int],
    qy: Union[float, int]
) -> Sequence[float]:
    """
    Add a reflection to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    px : Union[float, int]
         First point of the axis (x coordinate).
         Value Suggestion: 0

    py : Union[float, int]
         First point of the axis (y coordinate).
         Value Suggestion: 0

    qx : Union[float, int]
         Second point of the axis (x coordinate).
         Value Suggestion: 16

    qy : Union[float, int]
         Second point of the axis (y coordinate).
         Value Suggestion: 32

    Returns
    -------

    hom_mat_2dreflect : Sequence[float]
                        Output transformation matrix.

    See Also
    --------
    hom_mat2d_reflect_local

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_scale,
    hom_mat2d_rotate, hom_mat2d_slant, hom_mat2d_reflect

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_scale, hom_mat2d_rotate,
    hom_mat2d_slant, hom_mat2d_reflect

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(279) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, qx)
        proc.set_input_tuple(4, qy)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dreflect = proc.get_output_tuple_m(0)
        return hom_mat_2dreflect  # type: ignore


def hom_mat2d_reflect_local(
    hom_mat_2d: Sequence[float],
    px: Union[float, int],
    py: Union[float, int]
) -> Sequence[float]:
    """
    Add a reflection to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    px : Union[float, int]
         Point that defines the axis (x coordinate).
         Value Suggestion: 16

    py : Union[float, int]
         Point that defines the axis (y coordinate).
         Value Suggestion: 32

    Returns
    -------

    hom_mat_2dreflect : Sequence[float]
                        Output transformation matrix.

    See Also
    --------
    hom_mat2d_reflect

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  2cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(278) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dreflect = proc.get_output_tuple_m(0)
        return hom_mat_2dreflect  # type: ignore


def hom_mat2d_rotate(
    hom_mat_2d: Sequence[float],
    phi: Union[float, int],
    px: Union[float, int],
    py: Union[float, int]
) -> Sequence[float]:
    """
    Add a rotation to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    phi : Union[float, int]
          Rotation angle.
          Value Suggestion: 0.78

    px : Union[float, int]
         Fixed point of the transformation (x coordinate).
         Value Suggestion: 0

    py : Union[float, int]
         Fixed point of the transformation (y coordinate).
         Value Suggestion: 0

    Returns
    -------

    hom_mat_2drotate : Sequence[float]
                       Output transformation matrix.

    See Also
    --------
    hom_mat2d_rotate_local

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_scale,
    hom_mat2d_rotate, hom_mat2d_slant, hom_mat2d_reflect

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_scale, hom_mat2d_rotate,
    hom_mat2d_slant, hom_mat2d_reflect

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(283) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, phi)
        proc.set_input_tuple(2, px)
        proc.set_input_tuple(3, py)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2drotate = proc.get_output_tuple_m(0)
        return hom_mat_2drotate  # type: ignore


def hom_mat2d_rotate_local(
    hom_mat_2d: Sequence[float],
    phi: Union[float, int]
) -> Sequence[float]:
    """
    Add a rotation to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    phi : Union[float, int]
          Rotation angle.
          Value Suggestion: 0.78

    Returns
    -------

    hom_mat_2drotate : Sequence[float]
                       Output transformation matrix.

    See Also
    --------
    hom_mat2d_rotate

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(282) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, phi)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2drotate = proc.get_output_tuple_m(0)
        return hom_mat_2drotate  # type: ignore


def hom_mat2d_scale(
    hom_mat_2d: Sequence[float],
    sx: Union[float, int],
    sy: Union[float, int],
    px: Union[float, int],
    py: Union[float, int]
) -> Sequence[float]:
    """
    Add a scaling to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    sx : Union[float, int]
         Scale factor along the x-axis.
         Value Suggestion: 2
         Assertion: Sx != 0

    sy : Union[float, int]
         Scale factor along the y-axis.
         Value Suggestion: 2
         Assertion: Sy != 0

    px : Union[float, int]
         Fixed point of the transformation (x coordinate).
         Value Suggestion: 0

    py : Union[float, int]
         Fixed point of the transformation (y coordinate).
         Value Suggestion: 0

    Returns
    -------

    hom_mat_2dscale : Sequence[float]
                      Output transformation matrix.

    See Also
    --------
    hom_mat2d_scale_local

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_scale,
    hom_mat2d_rotate, hom_mat2d_slant, hom_mat2d_reflect

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_scale, hom_mat2d_rotate,
    hom_mat2d_slant, hom_mat2d_reflect

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(285) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, sx)
        proc.set_input_tuple(2, sy)
        proc.set_input_tuple(3, px)
        proc.set_input_tuple(4, py)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dscale = proc.get_output_tuple_m(0)
        return hom_mat_2dscale  # type: ignore


def hom_mat2d_scale_local(
    hom_mat_2d: Sequence[float],
    sx: Union[float, int],
    sy: Union[float, int]
) -> Sequence[float]:
    """
    Add a scaling to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    sx : Union[float, int]
         Scale factor along the x-axis.
         Value Suggestion: 2
         Assertion: Sx != 0

    sy : Union[float, int]
         Scale factor along the y-axis.
         Value Suggestion: 2
         Assertion: Sy != 0

    Returns
    -------

    hom_mat_2dscale : Sequence[float]
                      Output transformation matrix.

    See Also
    --------
    hom_mat2d_scale

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  2cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(284) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, sx)
        proc.set_input_tuple(2, sy)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dscale = proc.get_output_tuple_m(0)
        return hom_mat_2dscale  # type: ignore


def hom_mat2d_slant(
    hom_mat_2d: Sequence[float],
    theta: Union[float, int],
    axis: str,
    px: Union[float, int],
    py: Union[float, int]
) -> Sequence[float]:
    """
    Add a slant to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    theta : Union[float, int]
            Slant angle.
            Value Suggestion: 0.78

    axis : str
           Coordinate axis that is slanted.
           Value Suggestion: x

    px : Union[float, int]
         Fixed point of the transformation (x coordinate).
         Value Suggestion: 0

    py : Union[float, int]
         Fixed point of the transformation (y coordinate).
         Value Suggestion: 0

    Returns
    -------

    hom_mat_2dslant : Sequence[float]
                      Output transformation matrix.

    See Also
    --------
    hom_mat2d_slant_local

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_scale,
    hom_mat2d_rotate, hom_mat2d_slant, hom_mat2d_reflect

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_scale, hom_mat2d_rotate,
    hom_mat2d_slant, hom_mat2d_reflect

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(281) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, theta)
        proc.set_input_tuple(2, axis)
        proc.set_input_tuple(3, px)
        proc.set_input_tuple(4, py)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dslant = proc.get_output_tuple_m(0)
        return hom_mat_2dslant  # type: ignore


def hom_mat2d_slant_local(
    hom_mat_2d: Sequence[float],
    theta: Union[float, int],
    axis: str
) -> Sequence[float]:
    """
    Add a slant to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    theta : Union[float, int]
            Slant angle.
            Value Suggestion: 0.78

    axis : str
           Coordinate axis that is slanted.
           Value Suggestion: x

    Returns
    -------

    hom_mat_2dslant : Sequence[float]
                      Output transformation matrix.

    See Also
    --------
    hom_mat2d_slant

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect

    Successors
    ----------
    hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(280) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, theta)
        proc.set_input_tuple(2, axis)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dslant = proc.get_output_tuple_m(0)
        return hom_mat_2dslant  # type: ignore


def hom_mat2d_to_affine_par(
    hom_mat_2d: Sequence[float]
) -> Tuple[float, float, float, float, float, float]:
    """
    Compute the affine transformation parameters from a homogeneous 2D
    transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    sx : float
         Scaling factor along the x direction.

    sy : float
         Scaling factor along the y direction.

    phi : float
          Rotation angle.

    theta : float
            Slant angle.

    tx : float
         Translation along the x direction.

    ty : float
         Translation along the y direction.

    Predecessors
    ------------
    vector_to_hom_mat2d, vector_to_rigid, vector_to_similarity,
    vector_to_aniso, point_line_to_hom_mat2d

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_scale, hom_mat2d_rotate, hom_mat2d_slant
    """
    with HalconOperator(263) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # sx
            proc.get_output_tuple_s(1),  # sy
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # theta
            proc.get_output_tuple_s(4),  # tx
            proc.get_output_tuple_s(5)   # ty
        )  # type: ignore


def hom_mat2d_translate(
    hom_mat_2d: Sequence[float],
    tx: Union[float, int],
    ty: Union[float, int]
) -> Sequence[float]:
    """
    Add a translation to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    tx : Union[float, int]
         Translation along the x-axis.
         Value Suggestion: 64

    ty : Union[float, int]
         Translation along the y-axis.
         Value Suggestion: 64

    Returns
    -------

    hom_mat_2dtranslate : Sequence[float]
                          Output transformation matrix.

    See Also
    --------
    hom_mat2d_translate_local

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate, hom_mat2d_scale,
    hom_mat2d_rotate, hom_mat2d_slant, hom_mat2d_reflect

    Successors
    ----------
    hom_mat2d_translate, hom_mat2d_scale, hom_mat2d_rotate,
    hom_mat2d_slant, hom_mat2d_reflect

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(287) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, tx)
        proc.set_input_tuple(2, ty)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dtranslate = proc.get_output_tuple_m(0)
        return hom_mat_2dtranslate  # type: ignore


def hom_mat2d_translate_local(
    hom_mat_2d: Sequence[float],
    tx: Union[float, int],
    ty: Union[float, int]
) -> Sequence[float]:
    """
    Add a translation to a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    tx : Union[float, int]
         Translation along the x-axis.
         Value Suggestion: 64

    ty : Union[float, int]
         Translation along the y-axis.
         Value Suggestion: 64

    Returns
    -------

    hom_mat_2dtranslate : Sequence[float]
                          Output transformation matrix.

    See Also
    --------
    hom_mat2d_translate

    Predecessors
    ------------
    hom_mat2d_identity, hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_translate_local, hom_mat2d_scale_local,
    hom_mat2d_rotate_local, hom_mat2d_slant_local, hom_mat2d_reflect_local

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb tc -    | rd re tf | - 0  0
    1  /  1cm $ra & rb & tc
    rd & re & tf$  is stored as the tuple [ra, rb, tc, rd, re, tf].
    However, it is also possible to process full 3$- matrices, which
    represent a projective 2D transformation.
    """
    with HalconOperator(286) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, tx)
        proc.set_input_tuple(2, ty)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dtranslate = proc.get_output_tuple_m(0)
        return hom_mat_2dtranslate  # type: ignore


def hom_mat2d_transpose(hom_mat_2d: Sequence[float]) -> Sequence[float]:
    """
    Transpose a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    hom_mat_2dtranspose : Sequence[float]
                          Output transformation matrix.

    Predecessors
    ------------
    hom_mat2d_translate, hom_mat2d_translate_local, hom_mat2d_scale,
    hom_mat2d_scale_local, hom_mat2d_rotate, hom_mat2d_rotate_local,
    hom_mat2d_slant, hom_mat2d_slant_local, hom_mat2d_reflect,
    hom_mat2d_reflect_local

    Successors
    ----------
    hom_mat2d_compose, hom_mat2d_invert
    """
    with HalconOperator(275) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2dtranspose = proc.get_output_tuple_m(0)
        return hom_mat_2dtranspose  # type: ignore


def hom_mat3d_compose(
    hom_mat_3dleft: Sequence[float],
    hom_mat_3dright: Sequence[float]
) -> Sequence[float]:
    """
    Multiply two homogeneous 3D transformation matrices.

    Parameters
    ----------

    hom_mat_3dleft : Sequence[float]
                     Left input transformation matrix.

    hom_mat_3dright : Sequence[float]
                      Right input transformation matrix.

    Returns
    -------

    hom_mat_3dcompose : Sequence[float]
                        Output transformation matrix.

    See Also
    --------
    affine_trans_point_3d, hom_mat3d_identity, hom_mat3d_rotate,
    hom_mat3d_translate, pose_to_hom_mat3d, hom_mat3d_to_pose

    Alternatives
    ------------
    pose_compose, dual_quat_compose

    Predecessors
    ------------
    hom_mat3d_compose, hom_mat3d_translate, hom_mat3d_translate_local,
    hom_mat3d_scale, hom_mat3d_scale_local, hom_mat3d_rotate,
    hom_mat3d_rotate_local, pose_to_hom_mat3d

    Successors
    ----------
    hom_mat3d_compose, hom_mat3d_translate, hom_mat3d_translate_local,
    hom_mat3d_scale, hom_mat3d_scale_local, hom_mat3d_rotate,
    hom_mat3d_rotate_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(246) as proc:
        proc.set_input_tuple(0, hom_mat_3dleft)
        proc.set_input_tuple(1, hom_mat_3dright)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dcompose = proc.get_output_tuple_m(0)
        return hom_mat_3dcompose  # type: ignore


def hom_mat3d_determinant(hom_mat_3d: Sequence[float]) -> float:
    """
    Compute the determinant of a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    determinant : float
                  Determinant of the input matrix.

    Predecessors
    ------------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local,
    vector_to_hom_mat3d
    """
    with HalconOperator(243) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        determinant = proc.get_output_tuple_s(0)
        return determinant  # type: ignore


def hom_mat3d_identity() -> Sequence[float]:
    """
    Generate the homogeneous transformation matrix of the identical 3D
    transformation.

    Returns
    -------

    hom_mat_3didentity : Sequence[float]
                         Transformation matrix.

    Alternatives
    ------------
    pose_to_hom_mat3d

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is not stored because it is identical for all homogeneous
    matrices that describe an affine transformation. Thus,
    HomMat3DIdentity is stored as the tuple [1,0,0,0,0,1,0,0,0,0,1,0].
    """
    with HalconOperator(253) as proc:
        proc.init_oct(0)
        proc.execute()
        hom_mat_3didentity = proc.get_output_tuple_m(0)
        return hom_mat_3didentity  # type: ignore


def hom_mat3d_invert(hom_mat_3d: Sequence[float]) -> Sequence[float]:
    """
    Invert a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    hom_mat_3dinvert : Sequence[float]
                       Output transformation matrix.

    See Also
    --------
    affine_trans_point_3d, hom_mat3d_identity, hom_mat3d_rotate,
    hom_mat3d_translate, pose_to_hom_mat3d, hom_mat3d_to_pose,
    hom_mat3d_compose

    Alternatives
    ------------
    pose_invert, dual_quat_conjugate

    Predecessors
    ------------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local,
    pose_to_hom_mat3d

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local,
    hom_mat3d_to_pose

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(245) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dinvert = proc.get_output_tuple_m(0)
        return hom_mat_3dinvert  # type: ignore


def hom_mat3d_project(
    hom_mat_3d: Sequence[float],
    principal_point_row: Union[float, int],
    principal_point_col: Union[float, int],
    focus: Union[float, int]
) -> Sequence[float]:
    """
    Project an affine 3D transformation matrix to a 2D projective
    transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 $3- 3D transformation matrix.

    principal_point_row : Union[float, int]
                          Row coordinate of the principal point.
                          Value Suggestion: 256

    principal_point_col : Union[float, int]
                          Column coordinate of the principal point.
                          Value Suggestion: 256

    focus : Union[float, int]
            Focal length in pixels.
            Value Suggestion: 256

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_rotate, hom_mat3d_translate,
    hom_mat3d_scale

    Successors
    ----------
    projective_trans_image, projective_trans_point_2d,
    projective_trans_region, projective_trans_contour_xld, hom_mat2d_invert
    """
    with HalconOperator(254) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, principal_point_row)
        proc.set_input_tuple(2, principal_point_col)
        proc.set_input_tuple(3, focus)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def hom_mat3d_rotate(
    hom_mat_3d: Sequence[float],
    phi: Union[float, int],
    axis: MaybeSequence[Union[str, float, int]],
    px: Union[float, int],
    py: Union[float, int],
    pz: Union[float, int]
) -> Sequence[float]:
    """
    Add a rotation to a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    phi : Union[float, int]
          Rotation angle.
          Value Suggestion: 0.78

    axis : MaybeSequence[Union[str, float, int]]
           Axis, to be rotated around.
           Value Suggestion: x

    px : Union[float, int]
         Fixed point of the transformation (x coordinate).
         Value Suggestion: 0

    py : Union[float, int]
         Fixed point of the transformation (y coordinate).
         Value Suggestion: 0

    pz : Union[float, int]
         Fixed point of the transformation (z coordinate).
         Value Suggestion: 0

    Returns
    -------

    hom_mat_3drotate : Sequence[float]
                       Output transformation matrix.

    See Also
    --------
    hom_mat3d_invert, hom_mat3d_identity, hom_mat3d_rotate_local,
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_translate, hom_mat3d_scale,
    hom_mat3d_rotate

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_scale, hom_mat3d_rotate

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(248) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, phi)
        proc.set_input_tuple(2, axis)
        proc.set_input_tuple(3, px)
        proc.set_input_tuple(4, py)
        proc.set_input_tuple(5, pz)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3drotate = proc.get_output_tuple_m(0)
        return hom_mat_3drotate  # type: ignore


def hom_mat3d_rotate_local(
    hom_mat_3d: Sequence[float],
    phi: Union[float, int],
    axis: MaybeSequence[Union[str, float, int]]
) -> Sequence[float]:
    """
    Add a rotation to a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    phi : Union[float, int]
          Rotation angle.
          Value Suggestion: 0.78

    axis : MaybeSequence[Union[str, float, int]]
           Axis, to be rotated around.
           Value Suggestion: x

    Returns
    -------

    hom_mat_3drotate : Sequence[float]
                       Output transformation matrix.

    See Also
    --------
    hom_mat3d_invert, hom_mat3d_identity, hom_mat3d_rotate,
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_translate_local, hom_mat3d_scale_local,
    hom_mat3d_rotate_local

    Successors
    ----------
    hom_mat3d_translate_local, hom_mat3d_scale_local,
    hom_mat3d_rotate_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(247) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, phi)
        proc.set_input_tuple(2, axis)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3drotate = proc.get_output_tuple_m(0)
        return hom_mat_3drotate  # type: ignore


def hom_mat3d_scale(
    hom_mat_3d: Sequence[float],
    sx: Union[float, int],
    sy: Union[float, int],
    sz: Union[float, int],
    px: Union[float, int],
    py: Union[float, int],
    pz: Union[float, int]
) -> Sequence[float]:
    """
    Add a scaling to a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    sx : Union[float, int]
         Scale factor along the x-axis.
         Value Suggestion: 2
         Assertion: Sx != 0

    sy : Union[float, int]
         Scale factor along the y-axis.
         Value Suggestion: 2
         Assertion: Sy != 0

    sz : Union[float, int]
         Scale factor along the z-axis.
         Value Suggestion: 2
         Assertion: Sz != 0

    px : Union[float, int]
         Fixed point of the transformation (x coordinate).
         Value Suggestion: 0

    py : Union[float, int]
         Fixed point of the transformation (y coordinate).
         Value Suggestion: 0

    pz : Union[float, int]
         Fixed point of the transformation (z coordinate).
         Value Suggestion: 0

    Returns
    -------

    hom_mat_3dscale : Sequence[float]
                      Output transformation matrix.

    See Also
    --------
    hom_mat3d_invert, hom_mat3d_identity, hom_mat3d_scale_local,
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_translate, hom_mat3d_scale,
    hom_mat3d_rotate

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_scale, hom_mat3d_rotate

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(250) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, sx)
        proc.set_input_tuple(2, sy)
        proc.set_input_tuple(3, sz)
        proc.set_input_tuple(4, px)
        proc.set_input_tuple(5, py)
        proc.set_input_tuple(6, pz)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dscale = proc.get_output_tuple_m(0)
        return hom_mat_3dscale  # type: ignore


def hom_mat3d_scale_local(
    hom_mat_3d: Sequence[float],
    sx: Union[float, int],
    sy: Union[float, int],
    sz: Union[float, int]
) -> Sequence[float]:
    """
    Add a scaling to a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    sx : Union[float, int]
         Scale factor along the x-axis.
         Value Suggestion: 2
         Assertion: Sx != 0

    sy : Union[float, int]
         Scale factor along the y-axis.
         Value Suggestion: 2
         Assertion: Sy != 0

    sz : Union[float, int]
         Scale factor along the z-axis.
         Value Suggestion: 2
         Assertion: Sz != 0

    Returns
    -------

    hom_mat_3dscale : Sequence[float]
                      Output transformation matrix.

    See Also
    --------
    hom_mat3d_invert, hom_mat3d_identity, hom_mat3d_scale,
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_translate_local, hom_mat3d_scale_local,
    hom_mat3d_rotate_local

    Successors
    ----------
    hom_mat3d_translate_local, hom_mat3d_scale_local,
    hom_mat3d_rotate_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(249) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, sx)
        proc.set_input_tuple(2, sy)
        proc.set_input_tuple(3, sz)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dscale = proc.get_output_tuple_m(0)
        return hom_mat_3dscale  # type: ignore


def hom_mat3d_to_pose(
    hom_mat_3d: Sequence[float]
) -> Sequence[Union[int, float]]:
    """
    Convert a homogeneous transformation matrix into a 3D pose.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Homogeneous transformation matrix.

    Returns
    -------

    pose : Sequence[Union[int, float]]
           Equivalent 3D pose.

    See Also
    --------
    create_pose, camera_calibration, disp_caltab, sim_caltab, write_pose,
    read_pose, pose_to_hom_mat3d, project_3d_point, get_line_of_sight,
    hom_mat3d_rotate, hom_mat3d_translate, hom_mat3d_invert,
    affine_trans_point_3d

    Predecessors
    ------------
    hom_mat3d_rotate, hom_mat3d_translate, hom_mat3d_invert

    Successors
    ----------
    camera_calibration, write_pose, disp_caltab, sim_caltab

    Notes
    -----
    hom_mat3d_to_pose only supports rigid transformations in HomMat3D.
    """
    with HalconOperator(1934) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def hom_mat3d_translate(
    hom_mat_3d: Sequence[float],
    tx: Union[float, int],
    ty: Union[float, int],
    tz: Union[float, int]
) -> Sequence[float]:
    """
    Add a translation to a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    tx : Union[float, int]
         Translation along the x-axis.
         Value Suggestion: 64

    ty : Union[float, int]
         Translation along the y-axis.
         Value Suggestion: 64

    tz : Union[float, int]
         Translation along the z-axis.
         Value Suggestion: 64

    Returns
    -------

    hom_mat_3dtranslate : Sequence[float]
                          Output transformation matrix.

    See Also
    --------
    hom_mat3d_invert, hom_mat3d_identity, hom_mat3d_translate_local,
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_translate, hom_mat3d_scale,
    hom_mat3d_rotate

    Successors
    ----------
    hom_mat3d_translate, hom_mat3d_scale, hom_mat3d_rotate

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(252) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, tx)
        proc.set_input_tuple(2, ty)
        proc.set_input_tuple(3, tz)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dtranslate = proc.get_output_tuple_m(0)
        return hom_mat_3dtranslate  # type: ignore


def hom_mat3d_translate_local(
    hom_mat_3d: Sequence[float],
    tx: Union[float, int],
    ty: Union[float, int],
    tz: Union[float, int]
) -> Sequence[float]:
    """
    Add a translation to a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    tx : Union[float, int]
         Translation along the x-axis.
         Value Suggestion: 64

    ty : Union[float, int]
         Translation along the y-axis.
         Value Suggestion: 64

    tz : Union[float, int]
         Translation along the z-axis.
         Value Suggestion: 64

    Returns
    -------

    hom_mat_3dtranslate : Sequence[float]
                          Output transformation matrix.

    See Also
    --------
    hom_mat3d_invert, hom_mat3d_identity, hom_mat3d_translate,
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Predecessors
    ------------
    hom_mat3d_identity, hom_mat3d_translate_local, hom_mat3d_scale_local,
    hom_mat3d_rotate_local

    Successors
    ----------
    hom_mat3d_translate_local, hom_mat3d_scale_local,
    hom_mat3d_rotate_local

    Notes
    -----
    Note that homogeneous matrices are stored row-by-row as a tuple; the
    last row is usually not stored because it is identical for all
    homogeneous matrices that describe an affine transformation. For
    example, the homogeneous matrix  / ra rb rc td -    | re rf rg th | |
    ri rj rk tl | - 0  0  0  1  /  1cm $% ra & rb & rc & td
    re & rf & rg & th \\ ri & rj & rk & tl$  is stored as the tuple [ra,
    rb, rc, td, re, rf, rg, th, ri, rj, rk, tl]. However, it is also
    possible to process full 4$- matrices, which represent a projective 4D
    transformation.
    """
    with HalconOperator(251) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, tx)
        proc.set_input_tuple(2, ty)
        proc.set_input_tuple(3, tz)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dtranslate = proc.get_output_tuple_m(0)
        return hom_mat_3dtranslate  # type: ignore


def hom_mat3d_transpose(hom_mat_3d: Sequence[float]) -> Sequence[float]:
    """
    Transpose a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Input transformation matrix.

    Returns
    -------

    hom_mat_3dtranspose : Sequence[float]
                          Output transformation matrix.

    Predecessors
    ------------
    hom_mat3d_translate, hom_mat3d_translate_local, hom_mat3d_scale,
    hom_mat3d_scale_local, hom_mat3d_rotate, hom_mat3d_rotate_local,
    vector_to_hom_mat3d

    Successors
    ----------
    hom_mat3d_compose, hom_mat3d_invert
    """
    with HalconOperator(244) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3dtranspose = proc.get_output_tuple_m(0)
        return hom_mat_3dtranspose  # type: ignore


def hom_vector_to_proj_hom_mat2d(
    px: Sequence[Union[float, int]],
    py: Sequence[Union[float, int]],
    pw: Sequence[Union[float, int]],
    qx: Sequence[float],
    qy: Sequence[float],
    qw: Sequence[float],
    method: str
) -> Sequence[float]:
    """
    Compute a homogeneous transformation matrix using given point
    correspondences.

    Parameters
    ----------

    px : Sequence[Union[float, int]]
         Input points 1 (x coordinate).

    py : Sequence[Union[float, int]]
         Input points 1 (y coordinate).

    pw : Sequence[Union[float, int]]
         Input points 1 (w coordinate).

    qx : Sequence[float]
         Input points 2 (x coordinate).

    qy : Sequence[float]
         Input points 2 (y coordinate).

    qw : Sequence[float]
         Input points 2 (w coordinate).

    method : str
             Estimation algorithm.
             Value Suggestion: normalized_dlt

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    Alternatives
    ------------
    vector_to_proj_hom_mat2d, proj_match_points_ransac,
    proj_match_points_ransac_guided

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided,
    points_foerstner, points_harris

    Successors
    ----------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d, projective_trans_pixel

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(261) as proc:
        proc.set_input_tuple(0, px)
        proc.set_input_tuple(1, py)
        proc.set_input_tuple(2, pw)
        proc.set_input_tuple(3, qx)
        proc.set_input_tuple(4, qy)
        proc.set_input_tuple(5, qw)
        proc.set_input_tuple(6, method)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def hough_circle_trans(
    region: HObject,
    radius: MaybeSequence[int]
) -> HObject:
    """
    Return the Hough-Transform for circles with a given radius.

    Parameters
    ----------

    region : HObject
             Binary edge image in which the circles are to be detected.

    radius : MaybeSequence[int]
             Radius of the circle to be searched in the image.
             Value Suggestion: 12

    Returns
    -------

    hough_image : HObject
                  Hough transform for circles with a given radius.
    """
    with HalconOperator(1150) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, radius)
        proc.execute()
        hough_image = HObject(proc.get_output_object_key(1))
        return hough_image  # type: ignore


def hough_circles(
    region_in: HObject,
    radius: MaybeSequence[int],
    percent: MaybeSequence[int],
    mode: MaybeSequence[int]
) -> HObject:
    """
    centers of circles for a specific radius.

    Parameters
    ----------

    region_in : HObject
                Binary edge image in which the circles are to be detected.

    radius : MaybeSequence[int]
             Radius of the circle to be searched in the image.
             Value Suggestion: 12

    percent : MaybeSequence[int]
              Indicates the percentage (approximately) of the (ideal)
              circle which must be present in the edge image RegionIn.
              Value Suggestion: 60

    mode : MaybeSequence[int]
           The mode defines the position of the circle in question:
           0 - the radius is equivalent to the outer border of the set
           pixels.
           1 - the radius is equivalent to the centers of the circle
           lines' pixels.
           2 - both 0 and 1 (a little more fuzzy, but more reliable in
           contrast to circles set slightly differently, necessitates 50 -
           more processing capacity compared to 0 or 1 alone).

    Returns
    -------

    region_out : HObject
                 Centers of those circles which are included in the edge
                 image by Percent percent.
    """
    with HalconOperator(1149) as proc:
        proc.set_input_object(1, region_in)
        proc.set_input_tuple(0, radius)
        proc.set_input_tuple(1, percent)
        proc.set_input_tuple(2, mode)
        proc.execute()
        region_out = HObject(proc.get_output_object_key(1))
        return region_out  # type: ignore


def hough_line_trans(region: HObject, angle_resolution: int) -> HObject:
    """
    Produce the Hough transform for lines within regions.

    Parameters
    ----------

    region : HObject
             Binary edge image in which lines are to be detected.

    angle_resolution : int
                       Adjusting the resolution in the angle area.
                       Value Suggestion: 4

    Returns
    -------

    hough_image : HObject
                  Hough transform for lines.

    See Also
    --------
    hough_circle_trans, gen_region_hline

    Predecessors
    ------------
    threshold, skeleton

    Successors
    ----------
    threshold, local_max
    """
    with HalconOperator(1154) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, angle_resolution)
        proc.execute()
        hough_image = HObject(proc.get_output_object_key(1))
        return hough_image  # type: ignore


def hough_line_trans_dir(
    image_dir: HObject,
    direction_uncertainty: int,
    angle_resolution: int
) -> HObject:
    """
    Compute the Hough transform for lines using local gradient direction.

    Parameters
    ----------

    image_dir : HObject
                Image containing the edge direction. The edges must be
                described by the image domain.

    direction_uncertainty : int
                            Uncertainty of the edge direction (in degrees).
                            Value Suggestion: 2

    angle_resolution : int
                       Resolution in the angle area (in 1/degrees).
                       Value Suggestion: 4

    Returns
    -------

    hough_image : HObject
                  Hough transform.

    See Also
    --------
    hough_line_trans, hough_lines, hough_lines_dir

    Predecessors
    ------------
    edges_image, sobel_dir, threshold, hysteresis_threshold,
    nonmax_suppression_dir, reduce_domain

    Successors
    ----------
    binomial_filter, gauss_filter, threshold, local_max, plateaus_center
    """
    with HalconOperator(1152) as proc:
        proc.set_input_object(1, image_dir)
        proc.set_input_tuple(0, direction_uncertainty)
        proc.set_input_tuple(1, angle_resolution)
        proc.execute()
        hough_image = HObject(proc.get_output_object_key(1))
        return hough_image  # type: ignore


def hough_lines(
    region_in: HObject,
    angle_resolution: int,
    threshold: int,
    angle_gap: int,
    dist_gap: int
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Detect lines in edge images with the help of the Hough transform and
    returns it in HNF.

    Parameters
    ----------

    region_in : HObject
                Binary edge image in which the lines are to be detected.

    angle_resolution : int
                       Adjusting the resolution in the angle area.
                       Value Suggestion: 4

    threshold : int
                Threshold value in the Hough image.
                Value Suggestion: 100

    angle_gap : int
                Minimal distance of two maxima in the Hough image
                (direction: angle).
                Value Suggestion: 5

    dist_gap : int
               Minimal distance of two maxima in the Hough image
               (direction: distance).
               Value Suggestion: 5

    Returns
    -------

    angle : Sequence[float]
            Angles (in radians) of the detected lines' normal vectors.

    dist : Sequence[float]
           Distance of the detected lines from the origin.

    See Also
    --------
    hough_line_trans, gen_region_hline, hough_circles

    Predecessors
    ------------
    threshold, skeleton

    Successors
    ----------
    select_matching_lines
    """
    with HalconOperator(1153) as proc:
        proc.set_input_object(1, region_in)
        proc.set_input_tuple(0, angle_resolution)
        proc.set_input_tuple(1, threshold)
        proc.set_input_tuple(2, angle_gap)
        proc.set_input_tuple(3, dist_gap)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # angle
            proc.get_output_tuple_m(1)   # dist
        )  # type: ignore


def hough_lines_dir(
    image_dir: HObject,
    direction_uncertainty: int,
    angle_resolution: int,
    smoothing: str,
    filter_size: int,
    threshold: int,
    angle_gap: int,
    dist_gap: int,
    gen_lines: str
) -> Tuple[HObject, HObject, Sequence[float], Sequence[float]]:
    """
    Detect lines in edge images with the help of the Hough transform using
    local gradient direction and return them in normal form.

    Parameters
    ----------

    image_dir : HObject
                Image containing the edge direction. The edges are
                described by the image domain.

    direction_uncertainty : int
                            Uncertainty of edge direction (in degrees).
                            Value Suggestion: 2

    angle_resolution : int
                       Resolution in the angle area (in 1/degrees).
                       Value Suggestion: 4

    smoothing : str
                Smoothing filter for hough image.
                Value Suggestion: mean

    filter_size : int
                  Required smoothing filter size.
                  Value Suggestion: 5

    threshold : int
                Threshold value in the Hough image.
                Value Suggestion: 100

    angle_gap : int
                Minimum distance of two maxima in the Hough image
                (direction: angle).
                Value Suggestion: 5

    dist_gap : int
               Minimum distance of two maxima in the Hough image
               (direction: distance).
               Value Suggestion: 5

    gen_lines : str
                Create line regions if 'true'.
                Value Suggestion: true

    Returns
    -------

    hough_image : HObject
                  Hough transform.

    lines : HObject
            Regions of the input image that contributed to the local
            maxima.

    angle : Sequence[float]
            Angles (in radians) of the detected lines' normal vectors.

    dist : Sequence[float]
           Distance of the detected lines from the origin.

    See Also
    --------
    hough_line_trans_dir, hough_line_trans, gen_region_hline, hough_circles

    Predecessors
    ------------
    edges_image, sobel_dir, threshold, nonmax_suppression_dir,
    reduce_domain, skeleton

    Successors
    ----------
    gen_region_hline, select_matching_lines
    """
    with HalconOperator(1151) as proc:
        proc.set_input_object(1, image_dir)
        proc.set_input_tuple(0, direction_uncertainty)
        proc.set_input_tuple(1, angle_resolution)
        proc.set_input_tuple(2, smoothing)
        proc.set_input_tuple(3, filter_size)
        proc.set_input_tuple(4, threshold)
        proc.set_input_tuple(5, angle_gap)
        proc.set_input_tuple(6, dist_gap)
        proc.set_input_tuple(7, gen_lines)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # hough_image
            HObject(proc.get_output_object_key(2)),  # lines
            proc.get_output_tuple_m(0),  # angle
            proc.get_output_tuple_m(1)   # dist
        )  # type: ignore


def hysteresis_threshold(
    image: HObject,
    low: Union[int, float],
    high: Union[int, float],
    max_length: int
) -> HObject:
    """
    Perform a hysteresis threshold operation on an image.

    Parameters
    ----------

    image : HObject
            Input image.

    low : Union[int, float]
          Lower threshold for the gray values.
          Value Suggestion: 30

    high : Union[int, float]
           Upper threshold for the gray values.
           Value Suggestion: 60
           Assertion: High >= Low

    max_length : int
                 Maximum length of a path of ``potential'' points to reach
                 a ``secure'' point.
                 Value Suggestion: 10
                 Assertion: MaxLength > 1

    Returns
    -------

    region_hysteresis : HObject
                        Segmented region.

    See Also
    --------
    edges_image, sobel_dir, background_seg

    Alternatives
    ------------
    dyn_threshold, threshold, class_2dim_sup, fast_threshold

    Notes
    -----
    For images of type byte, uint2, or int4 the lower threshold must be
    Low > 0.
    """
    with HalconOperator(448) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, low)
        proc.set_input_tuple(1, high)
        proc.set_input_tuple(2, max_length)
        proc.execute()
        region_hysteresis = HObject(proc.get_output_object_key(1))
        return region_hysteresis  # type: ignore


def illuminate(
    image: HObject,
    mask_width: int,
    mask_height: int,
    factor: float
) -> HObject:
    """
    Illuminate image.

    Parameters
    ----------

    image : HObject
            Image to be enhanced.

    mask_width : int
                 Width of low pass mask.
                 Value Suggestion: 101
                 Assertion: MaskWidth < width(Image) * 2

    mask_height : int
                  Height of low pass mask.
                  Value Suggestion: 101
                  Assertion: MaskHeight < height(Image) * 2

    factor : float
             Scales the "`correction gray value"' added to the original
             gray values.
             Value Suggestion: 0.7
             Assertion: 0 < Factor && Factor < 5

    Returns
    -------

    image_illuminate : HObject
                       "`Illuminated"' image.

    See Also
    --------
    emphasize, gray_histo

    Alternatives
    ------------
    scale_image_max, equ_histo_image, mean_image, sub_image

    Successors
    ----------
    disp_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1549) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, factor)
        proc.execute()
        image_illuminate = HObject(proc.get_output_object_key(1))
        return image_illuminate  # type: ignore


def image_points_to_world_plane(
    camera_param: Sequence[Union[int, float, str]],
    world_pose: Sequence[Union[int, float]],
    rows: Sequence[Union[int, float]],
    cols: Sequence[Union[int, float]],
    scale: Union[int, float, str]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Transform image points into the plane z=0 of a world coordinate system.

    Parameters
    ----------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    world_pose : Sequence[Union[int, float]]
                 3D pose of the world coordinate system in camera
                 coordinates.

    rows : Sequence[Union[int, float]]
           Row coordinates of the points to be transformed.
           Value Suggestion: 100.0

    cols : Sequence[Union[int, float]]
           Column coordinates of the points to be transformed.
           Value Suggestion: 100.0

    scale : Union[int, float, str]
            Scale or dimension
            Value Suggestion: m
            Assertion: Scale > 0

    Returns
    -------

    x : Sequence[float]
        X coordinates of the points in the world coordinate system.

    y : Sequence[float]
        Y coordinates of the points in the world coordinate system.

    See Also
    --------
    contour_to_world_plane_xld, project_3d_point

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration, set_origin_pose
    """
    with HalconOperator(1916) as proc:
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, world_pose)
        proc.set_input_tuple(2, rows)
        proc.set_input_tuple(3, cols)
        proc.set_input_tuple(4, scale)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1)   # y
        )  # type: ignore


def image_to_channels(multi_channel_image: HObject) -> HObject:
    """
    Convert a multi-channel image into One-channel images

    Parameters
    ----------

    multi_channel_image : HObject
                          Multi-channel image to be decomposed.

    Returns
    -------

    images : HObject
             Generated one-channel images.

    See Also
    --------
    channels_to_image

    Alternatives
    ------------
    access_channel, decompose2, decompose3, decompose4, decompose5

    Predecessors
    ------------
    count_channels

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1120) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.execute()
        images = HObject(proc.get_output_object_key(1))
        return images  # type: ignore


def image_to_world_plane(
    image: HObject,
    camera_param: Sequence[Union[int, float, str]],
    world_pose: Sequence[Union[int, float]],
    width: int,
    height: int,
    scale: Union[int, float, str],
    interpolation: str
) -> HObject:
    """
    Rectify an image by transforming it into the plane z=0 of a world
    coordinate system.

    Parameters
    ----------

    image : HObject
            Input image.

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    world_pose : Sequence[Union[int, float]]
                 3D pose of the world coordinate system in camera
                 coordinates.

    width : int
            Width of the resulting image in pixels.
            Assertion: Width >= 1

    height : int
             Height of the resulting image in pixels.
             Assertion: Height >= 1

    scale : Union[int, float, str]
            Scale or unit
            Value Suggestion: m
            Assertion: Scale > 0

    interpolation : str
                    Type of interpolation.
                    Value Suggestion: bilinear

    Returns
    -------

    image_world : HObject
                  Transformed image.

    See Also
    --------
    contour_to_world_plane_xld, image_points_to_world_plane

    Alternatives
    ------------
    gen_image_to_world_plane_map, map_image

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration, set_origin_pose

    Notes
    -----
    image_to_world_plane can be executed on OpenCL devices if the input
    image does not exceed the maximum size of image objects of the
    selected device. There can be slight differences in the output
    compared to the execution on the CPU.
    """
    with HalconOperator(1914) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, world_pose)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.set_input_tuple(4, scale)
        proc.set_input_tuple(5, interpolation)
        proc.execute()
        image_world = HObject(proc.get_output_object_key(1))
        return image_world  # type: ignore


def import_lexicon(name: str, file_name: str) -> HHandle:
    """
    Create a lexicon from a text file.

    Parameters
    ----------

    name : str
           Unique name for the new lexicon.
           Value Suggestion: 'lex1'

    file_name : str
                Name of a text file containing words for the new lexicon.
                Value Suggestion: 'words.txt'

    Returns
    -------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    See Also
    --------
    lookup_lexicon, suggest_lexicon

    Alternatives
    ------------
    create_lexicon

    Successors
    ----------
    do_ocr_word_mlp, do_ocr_word_svm
    """
    with HalconOperator(670) as proc:
        proc.set_input_tuple(0, name)
        proc.set_input_tuple(1, file_name)
        proc.init_oct(0)
        proc.execute()
        lexicon_handle = proc.get_output_tuple_s(0)
        return lexicon_handle  # type: ignore


def info_edges(
    filter: str,
    mode: str,
    alpha: float
) -> Tuple[int, Sequence[int]]:
    """
    Return the filter coefficients of a filter in edges_image.

    Parameters
    ----------

    filter : str
             Name of the edge operator.
             Value Suggestion: lanser2

    mode : str
           1D edge filter ('edge') or 1D smoothing filter ('smooth').
           Value Suggestion: edge

    alpha : float
            Filter parameter: small values result in strong smoothing, and
            thus less detail (opposite for 'canny').
            Value Suggestion: 0.5
            Assertion: Alpha > 0.0

    Returns
    -------

    size : int
           Filter width in pixels.

    coeffs : Sequence[int]
             For Canny filters: Coefficients of the ``positive'' half of
             the 1D impulse response. All others: Coefficients of a
             corresponding non-recursive  filter.

    See Also
    --------
    edges_image

    Successors
    ----------
    edges_image, threshold, skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1565) as proc:
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, mode)
        proc.set_input_tuple(2, alpha)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # size
            proc.get_output_tuple_m(1)   # coeffs
        )  # type: ignore


def info_framegrabber(
    name: str,
    query: str
) -> Tuple[str, Sequence[Union[str, int, float]]]:
    """
    Query information about the specified image acquisition interface.

    Parameters
    ----------

    name : str
           HALCON image acquisition interface name, i.e., name of the
           corresponding DLL (Windows) or shared library (Linux/macOS).
           Value Suggestion: File

    query : str
            Name of the chosen query.
            Value Suggestion: info_boards

    Returns
    -------

    information : str
                  Textual information (according to Query).

    value_list : Sequence[Union[str, int, float]]
                 List of values (according to Query).

    See Also
    --------
    open_framegrabber

    Predecessors
    ------------
    open_framegrabber

    Successors
    ----------
    open_framegrabber

    Notes
    -----
    For a multithreaded application all image acquisition operators (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    Thus, info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers block the concurrent execution of all other
    operators within this group, but run in parallel with all
    non-exclusive operators outside of this group.
    On Windows Systems, error dialog boxes from the operating system can
    occur  when dependency modules of the interface are not found, e.g.,
    the according  SDK was not installed. The occurrence of the error
    boxes can be controlled  by setting Windows' Error Mode. Please refer
    to the description of  SetErrorMode within the Windows MSDN
    documentation.
    """
    with HalconOperator(2034) as proc:
        proc.set_input_tuple(0, name)
        proc.set_input_tuple(1, query)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # information
            proc.get_output_tuple_m(1)   # value_list
        )  # type: ignore


def info_ocr_class_box(
    ocr_handle: HHandle
) -> Tuple[int, int, int, int, int, Sequence[str], Sequence[str]]:
    """
    Get information about an OCR classifier.

    Parameters
    ----------

    ocr_handle : HHandle
                 ID of the OCR classifier.

    Returns
    -------

    width_pattern : int
                    Width of the scaled characters.

    height_pattern : int
                     Height of the scaled characters.

    interpolation : int
                    Interpolation mode for scaling the characters.

    width_max_char : int
                     Width of the largest trained character.

    height_max_char : int
                      Height of the largest trained character.

    features : Sequence[str]
               Used features.

    characters : Sequence[str]
                 All characters of the set.

    Predecessors
    ------------
    read_ocr, create_ocr_class_box

    Successors
    ----------
    write_ocr

    Warnings
    --------
    info_ocr_class_box is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(715) as proc:
        proc.set_input_tuple(0, ocr_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # width_pattern
            proc.get_output_tuple_s(1),  # height_pattern
            proc.get_output_tuple_s(2),  # interpolation
            proc.get_output_tuple_s(3),  # width_max_char
            proc.get_output_tuple_s(4),  # height_max_char
            proc.get_output_tuple_m(5),  # features
            proc.get_output_tuple_m(6)   # characters
        )  # type: ignore


def info_parallels_xld(
    parallels: HObject,
    image: HObject
) -> Tuple[float, float, int, int, float, float]:
    """
    Return information about the gray values of the area enclosed by XLD
    parallels.

    Parameters
    ----------

    parallels : HObject
                Input XLD Parallels.

    image : HObject
            Corresponding gray value image.

    Returns
    -------

    quality_min : float
                  Minimum quality factor.

    quality_max : float
                  Maximum quality factor.

    gray_min : int
               Minimum mean gray value.

    gray_max : int
               Maximum mean gray value.

    standard_min : float
                   Minimum standard deviation.

    standard_max : float
                   Maximum standard deviation.

    See Also
    --------
    intensity, min_max_gray

    Predecessors
    ------------
    gen_parallels_xld

    Successors
    ----------
    mod_parallels_xld
    """
    with HalconOperator(40) as proc:
        proc.set_input_object(1, parallels)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # quality_min
            proc.get_output_tuple_s(1),  # quality_max
            proc.get_output_tuple_s(2),  # gray_min
            proc.get_output_tuple_s(3),  # gray_max
            proc.get_output_tuple_s(4),  # standard_min
            proc.get_output_tuple_s(5)   # standard_max
        )  # type: ignore


def info_smooth(filter: str, alpha: float) -> Tuple[int, Sequence[int]]:
    """
    Information on smoothing filter smooth_image.

    Parameters
    ----------

    filter : str
             Name of required filter.
             Value Suggestion: deriche2

    alpha : float
            Filter parameter: small values effect strong smoothing
            (reversed in case of 'gauss').
            Value Suggestion: 0.5
            Assertion: Alpha > 0.0

    Returns
    -------

    size : int
           Width of filter is approx. size x size pixels.

    coeffs : Sequence[int]
             In case of gauss filter: coefficients of the ``positive''
             half of the 1D impulse answer.

    See Also
    --------
    smooth_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    smooth_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1419) as proc:
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, alpha)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # size
            proc.get_output_tuple_m(1)   # coeffs
        )  # type: ignore


def init_compute_device(
    device_handle: HHandle,
    operators: Sequence[str]
) -> None:
    """
    Initialize a compute device.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    operators : Sequence[str]
                List of operators to prepare.
                Value Suggestion: all

    Predecessors
    ------------
    query_available_compute_devices, open_compute_device

    Successors
    ----------
    activate_compute_device

    Notes
    -----
    Be aware that the execution time of init_compute_device depends on the
    number of Operators and may last up to several seconds.
    """
    with HalconOperator(303) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.set_input_tuple(1, operators)
        proc.execute()


def inner_circle(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Largest inner circle of a region.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row : Sequence[float]
          Line index of the center.

    column : Sequence[float]
             Column index of the center.

    radius : Sequence[float]
             Radius of the inner circle.
             Assertion: Radius >= 0

    See Also
    --------
    set_shape, select_shape, smallest_circle

    Alternatives
    ------------
    erosion_circle, inner_rectangle1

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    gen_circle, disp_circle

    Notes
    -----
    If several inner circles are present at a region only the most upper
    left solution is returned.
    """
    with HalconOperator(1735) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2)   # radius
        )  # type: ignore


def inner_circle_s(regions: HObject) -> Tuple[float, float, float]:
    """
    Largest inner circle of a region.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row : float
          Line index of the center.

    column : float
             Column index of the center.

    radius : float
             Radius of the inner circle.
             Assertion: Radius >= 0

    See Also
    --------
    set_shape, select_shape, smallest_circle

    Alternatives
    ------------
    erosion_circle, inner_rectangle1

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    gen_circle, disp_circle

    Notes
    -----
    If several inner circles are present at a region only the most upper
    left solution is returned.
    """
    with HalconOperator(1735) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # radius
        )  # type: ignore


def inner_rectangle1(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Largest inner rectangle of a region.

    Parameters
    ----------

    regions : HObject
              Region to be examined.

    Returns
    -------

    row_1 : Sequence[int]
            Row coordinate of the upper left corner point.

    column_1 : Sequence[int]
               Column coordinate of the upper left corner point.

    row_2 : Sequence[int]
            Row coordinate of the lower right corner point.

    column_2 : Sequence[int]
               Column coordinate of the lower right corner point.

    See Also
    --------
    smallest_rectangle1, select_shape

    Alternatives
    ------------
    inner_circle

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    disp_rectangle1, gen_rectangle1
    """
    with HalconOperator(1734) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_1
            proc.get_output_tuple_m(1),  # column_1
            proc.get_output_tuple_m(2),  # row_2
            proc.get_output_tuple_m(3)   # column_2
        )  # type: ignore


def inner_rectangle1_s(regions: HObject) -> Tuple[int, int, int, int]:
    """
    Largest inner rectangle of a region.

    Parameters
    ----------

    regions : HObject
              Region to be examined.

    Returns
    -------

    row_1 : int
            Row coordinate of the upper left corner point.

    column_1 : int
               Column coordinate of the upper left corner point.

    row_2 : int
            Row coordinate of the lower right corner point.

    column_2 : int
               Column coordinate of the lower right corner point.

    See Also
    --------
    smallest_rectangle1, select_shape

    Alternatives
    ------------
    inner_circle

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    disp_rectangle1, gen_rectangle1
    """
    with HalconOperator(1734) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def inpainting_aniso(
    image: HObject,
    region: HObject,
    mode: str,
    contrast: float,
    theta: float,
    iterations: int,
    rho: float
) -> HObject:
    """
    Perform an inpainting by anisotropic diffusion.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             Inpainting region.

    mode : str
           Type of edge sharpening algorithm.
           Value Suggestion: weickert

    contrast : float
               Contrast parameter.
               Value Suggestion: 5.0
               Assertion: Contrast > 0

    theta : float
            Step size.
            Value Suggestion: 0.5
            Assertion: Theta > 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    rho : float
          Smoothing coefficient for edge information.
          Value Suggestion: 3.0
          Assertion: Rho >= 0

    Returns
    -------

    inpainted_image : HObject
                      Output image.

    Alternatives
    ------------
    harmonic_interpolation, inpainting_ct, inpainting_mcf,
    inpainting_texture, inpainting_ced

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1450) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, contrast)
        proc.set_input_tuple(2, theta)
        proc.set_input_tuple(3, iterations)
        proc.set_input_tuple(4, rho)
        proc.execute()
        inpainted_image = HObject(proc.get_output_object_key(1))
        return inpainted_image  # type: ignore


def inpainting_ced(
    image: HObject,
    region: HObject,
    sigma: float,
    rho: float,
    theta: float,
    iterations: int
) -> HObject:
    """
    Perform an inpainting by coherence enhancing diffusion.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             Inpainting region.

    sigma : float
            Smoothing for derivative operator.
            Value Suggestion: 0.5
            Assertion: Sigma >= 0

    rho : float
          Smoothing for diffusion coefficients.
          Value Suggestion: 3.0
          Assertion: Rho >= 0

    theta : float
            Time step.
            Value Suggestion: 0.5
            Assertion: 0 < Theta <= 0.5

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    Returns
    -------

    inpainted_image : HObject
                      Output image.

    Alternatives
    ------------
    harmonic_interpolation, inpainting_ct, inpainting_aniso,
    inpainting_mcf, inpainting_texture

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1449) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, rho)
        proc.set_input_tuple(2, theta)
        proc.set_input_tuple(3, iterations)
        proc.execute()
        inpainted_image = HObject(proc.get_output_object_key(1))
        return inpainted_image  # type: ignore


def inpainting_ct(
    image: HObject,
    region: HObject,
    epsilon: float,
    kappa: float,
    sigma: float,
    rho: float,
    channel_coefficients: MaybeSequence[float]
) -> HObject:
    """
    Perform an inpainting by coherence transport.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             Inpainting region.

    epsilon : float
              Radius of the pixel neighborhood.
              Value Suggestion: 5.0

    kappa : float
            Sharpness parameter in percent.
            Value Suggestion: 25.0

    sigma : float
            Pre-smoothing parameter.
            Value Suggestion: 1.41

    rho : float
          Smoothing parameter for the direction estimation.
          Value Suggestion: 4.0

    channel_coefficients : MaybeSequence[float]
                           Channel weights.
                           Value Suggestion: 1

    Returns
    -------

    inpainted_image : HObject
                      Output image.

    Alternatives
    ------------
    harmonic_interpolation, inpainting_aniso, inpainting_mcf,
    inpainting_ced, inpainting_texture

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1447) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, epsilon)
        proc.set_input_tuple(1, kappa)
        proc.set_input_tuple(2, sigma)
        proc.set_input_tuple(3, rho)
        proc.set_input_tuple(4, channel_coefficients)
        proc.execute()
        inpainted_image = HObject(proc.get_output_object_key(1))
        return inpainted_image  # type: ignore


def inpainting_mcf(
    image: HObject,
    region: HObject,
    sigma: float,
    theta: float,
    iterations: int
) -> HObject:
    """
    Perform an inpainting by smoothing of level lines.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             Inpainting region.

    sigma : float
            Smoothing for derivative operator.
            Value Suggestion: 0.5
            Assertion: Sigma >= 0

    theta : float
            Time step.
            Value Suggestion: 0.5
            Assertion: 0 < Theta <= 0.5

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    Returns
    -------

    inpainted_image : HObject
                      Output image.

    Alternatives
    ------------
    harmonic_interpolation, inpainting_ct, inpainting_aniso,
    inpainting_ced, inpainting_texture

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1448) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, theta)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        inpainted_image = HObject(proc.get_output_object_key(1))
        return inpainted_image  # type: ignore


def inpainting_texture(
    image: HObject,
    region: HObject,
    mask_size: int,
    search_size: int,
    anisotropy: float,
    post_iteration: str,
    smoothness: float
) -> HObject:
    """
    Perform an inpainting by texture propagation.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             Inpainting region.

    mask_size : int
                Size of the inpainting blocks.
                Value Suggestion: 9
                Assertion: MaskSize >= 3 && odd(MaskSize)

    search_size : int
                  Size of the search window.
                  Value Suggestion: 30
                  Assertion: 2 * SearchSize > MaskSize

    anisotropy : float
                 Influence of the edge amplitude on the inpainting order.
                 Value Suggestion: 1.0
                 Assertion: Anisotropy >= 0

    post_iteration : str
                     Post-iteration for artifact reduction.
                     Value Suggestion: none

    smoothness : float
                 Gray value tolerance for post-iteration.
                 Value Suggestion: 1.0
                 Assertion: Smoothness >= 0

    Returns
    -------

    inpainted_image : HObject
                      Output image.

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1446) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, mask_size)
        proc.set_input_tuple(1, search_size)
        proc.set_input_tuple(2, anisotropy)
        proc.set_input_tuple(3, post_iteration)
        proc.set_input_tuple(4, smoothness)
        proc.execute()
        inpainted_image = HObject(proc.get_output_object_key(1))
        return inpainted_image  # type: ignore


def insert_obj(
    objects: HObject,
    objects_insert: HObject,
    index: int
) -> HObject:
    """
    Insert objects into an iconic object tuple.

    Parameters
    ----------

    objects : HObject
              Input object tuple.

    objects_insert : HObject
                     Object tuple to insert.

    index : int
            Index to insert objects.

    Returns
    -------

    objects_extended : HObject
                       Extended object tuple.

    See Also
    --------
    count_obj, select_obj, copy_obj, remove_obj

    Alternatives
    ------------
    concat_obj

    Predecessors
    ------------
    count_obj

    Successors
    ----------
    count_obj
    """
    with HalconOperator(2121) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_object(2, objects_insert)
        proc.set_input_tuple(0, index)
        proc.execute()
        objects_extended = HObject(proc.get_output_object_key(1))
        return objects_extended  # type: ignore


def inspect_clustered_components(
    component_training_id: HHandle,
    ambiguity_criterion: str,
    max_contour_overlap: float,
    cluster_threshold: float
) -> HObject:
    """
    Inspect the rigid model components obtained from the training.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    ambiguity_criterion : str
                          Criterion for solving the ambiguities.
                          Value Suggestion: rigidity

    max_contour_overlap : float
                          Maximum contour overlap of the found initial
                          components.
                          Value Suggestion: 0.2
                          Assertion: 0 <= MaxContourOverlap && MaxContourOverlap <= 1

    cluster_threshold : float
                        Threshold for clustering the initial components.
                        Value Suggestion: 0.5
                        Assertion: 0 <= ClusterThreshold && ClusterThreshold <= 1

    Returns
    -------

    model_components : HObject
                       Contour regions of rigid model components.

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    cluster_model_components
    """
    with HalconOperator(1016) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, ambiguity_criterion)
        proc.set_input_tuple(2, max_contour_overlap)
        proc.set_input_tuple(3, cluster_threshold)
        proc.execute()
        model_components = HObject(proc.get_output_object_key(1))
        return model_components  # type: ignore


def inspect_lexicon(lexicon_handle: HHandle) -> Sequence[str]:
    """
    Query all words from a lexicon.

    Parameters
    ----------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    Returns
    -------

    words : Sequence[str]
            List of all words.

    See Also
    --------
    create_lexicon

    Alternatives
    ------------
    lookup_lexicon
    """
    with HalconOperator(669) as proc:
        proc.set_input_tuple(0, lexicon_handle)
        proc.init_oct(0)
        proc.execute()
        words = proc.get_output_tuple_m(0)
        return words  # type: ignore


def inspect_lexicon_s(lexicon_handle: HHandle) -> str:
    """
    Query all words from a lexicon.

    Parameters
    ----------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    Returns
    -------

    words : str
            List of all words.

    See Also
    --------
    create_lexicon

    Alternatives
    ------------
    lookup_lexicon
    """
    with HalconOperator(669) as proc:
        proc.set_input_tuple(0, lexicon_handle)
        proc.init_oct(0)
        proc.execute()
        words = proc.get_output_tuple_s(0)
        return words  # type: ignore


def inspect_shape_model(
    image: HObject,
    num_levels: int,
    contrast: MaybeSequence[int]
) -> Tuple[HObject, HObject]:
    """
    Create the representation of a shape model.

    Parameters
    ----------

    image : HObject
            Input image.

    num_levels : int
                 Number of pyramid levels.
                 Value Suggestion: 4

    contrast : MaybeSequence[int]
               Threshold or hysteresis thresholds for the contrast of the
               object in the image and optionally minimum size of the
               object parts.
               Value Suggestion: 30

    Returns
    -------

    model_images : HObject
                   Image pyramid of the input image

    model_regions : HObject
                    Model region pyramid

    See Also
    --------
    create_shape_model, create_scaled_shape_model, create_aniso_shape_model

    Predecessors
    ------------
    reduce_domain

    Successors
    ----------
    select_obj
    """
    with HalconOperator(941) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, num_levels)
        proc.set_input_tuple(1, contrast)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # model_images
            HObject(proc.get_output_object_key(2))   # model_regions
        )  # type: ignore


def integer_to_handle(
    integer_handle: MaybeSequence[int]
) -> Sequence[HHandle]:
    """
    Convert an integer into a handle.

    Parameters
    ----------

    integer_handle : MaybeSequence[int]
                     The handle as integer.

    Returns
    -------

    handle : Sequence[HHandle]
             The handle as handle.

    See Also
    --------
    handle_to_integer

    Warnings
    --------
    It is not recommended to use this operator in HDevelop. This operator
    is only provided for reasons of backward compatibility.

    Notes
    -----
    It is not recommended to use this operator in HDevelop. This operator
    is solely provided to enable backward compatibility with legacy code.
    """
    with HalconOperator(2137) as proc:
        proc.set_input_tuple(0, integer_handle)
        proc.init_oct(0)
        proc.execute()
        handle = proc.get_output_tuple_m(0)
        return handle  # type: ignore


def integer_to_handle_s(integer_handle: MaybeSequence[int]) -> HHandle:
    """
    Convert an integer into a handle.

    Parameters
    ----------

    integer_handle : MaybeSequence[int]
                     The handle as integer.

    Returns
    -------

    handle : HHandle
             The handle as handle.

    See Also
    --------
    handle_to_integer

    Warnings
    --------
    It is not recommended to use this operator in HDevelop. This operator
    is only provided for reasons of backward compatibility.

    Notes
    -----
    It is not recommended to use this operator in HDevelop. This operator
    is solely provided to enable backward compatibility with legacy code.
    """
    with HalconOperator(2137) as proc:
        proc.set_input_tuple(0, integer_handle)
        proc.init_oct(0)
        proc.execute()
        handle = proc.get_output_tuple_s(0)
        return handle  # type: ignore


def integer_to_obj(surrogate_tuple: MaybeSequence[int]) -> HObject:
    """
    Convert an ``integer number'' into an iconic object.

    Parameters
    ----------

    surrogate_tuple : MaybeSequence[int]
                      Tuple of object surrogates.

    Returns
    -------

    objects : HObject
              Created objects.

    See Also
    --------
    obj_to_integer

    Notes
    -----
    The objects are duplicated in the database.
    """
    with HalconOperator(581) as proc:
        proc.set_input_tuple(0, surrogate_tuple)
        proc.execute()
        objects = HObject(proc.get_output_object_key(1))
        return objects  # type: ignore


def integrate_funct_1d(
    function: Sequence[float]
) -> Tuple[float, Sequence[float]]:
    """
    Compute the positive and negative areas of a function.

    Parameters
    ----------

    function : Sequence[float]
               Input function.

    Returns
    -------

    positive : float
               Area under the positive part of the function.

    negative : Sequence[float]
               Area under the negative part of the function.

    See Also
    --------
    create_funct_1d_array, create_funct_1d_pairs

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1396) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # positive
            proc.get_output_tuple_m(1)   # negative
        )  # type: ignore


def intensity(
    regions: HObject,
    image: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the mean and deviation of gray values.

    Parameters
    ----------

    regions : HObject
              Regions in which the features are calculated.

    image : HObject
            Gray value image.

    Returns
    -------

    mean : Sequence[float]
           Mean gray value of a region.

    deviation : Sequence[float]
                Deviation of gray values within a region.

    See Also
    --------
    mean_image, gray_histo, gray_histo_abs

    Alternatives
    ------------
    select_gray, min_max_gray

    Successors
    ----------
    threshold

    Notes
    -----
    Note that the operator intensity only considers  the given Regions and
    ignores any previously set domain of the input image Image. The
    calculation of Deviation does not follow the usual definition if the
    region of the image contains only one pixel.  In this case 0.0 is
    returned.
    """
    with HalconOperator(1752) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # mean
            proc.get_output_tuple_m(1)   # deviation
        )  # type: ignore


def intensity_s(
    regions: HObject,
    image: HObject
) -> Tuple[float, float]:
    """
    Calculate the mean and deviation of gray values.

    Parameters
    ----------

    regions : HObject
              Regions in which the features are calculated.

    image : HObject
            Gray value image.

    Returns
    -------

    mean : float
           Mean gray value of a region.

    deviation : float
                Deviation of gray values within a region.

    See Also
    --------
    mean_image, gray_histo, gray_histo_abs

    Alternatives
    ------------
    select_gray, min_max_gray

    Successors
    ----------
    threshold

    Notes
    -----
    Note that the operator intensity only considers  the given Regions and
    ignores any previously set domain of the input image Image. The
    calculation of Deviation does not follow the usual definition if the
    region of the image contains only one pixel.  In this case 0.0 is
    returned.
    """
    with HalconOperator(1752) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # mean
            proc.get_output_tuple_s(1)   # deviation
        )  # type: ignore


def interjacent(region: HObject, mode: str) -> HObject:
    """
    Partition the image plane using given regions.

    Parameters
    ----------

    region : HObject
             Regions for which the separating lines are to be determined.

    mode : str
           Mode of operation.
           Value Suggestion: mixed

    Returns
    -------

    region_interjacent : HObject
                         Output region containing the separating lines.

    See Also
    --------
    expand_region, junctions_skeleton, boundary

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region

    Warnings
    --------
    interjacent is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(494) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, mode)
        proc.execute()
        region_interjacent = HObject(proc.get_output_object_key(1))
        return region_interjacent  # type: ignore


def interleave_channels(
    multichannel_image: HObject,
    pixel_format: str,
    row_bytes: Union[str, int],
    alpha: int
) -> HObject:
    """
    Create an interleaved image from a multichannel image.

    Parameters
    ----------

    multichannel_image : HObject
                         Input multichannel image.

    pixel_format : str
                   Target format for InterleavedImage.
                   Value Suggestion: rgba

    row_bytes : Union[str, int]
                Number of bytes in a row of the output image.
                Value Suggestion: match

    alpha : int
            Alpha value for three channel input images.
            Value Suggestion: 255

    Returns
    -------

    interleaved_image : HObject
                        Output interleaved image.

    See Also
    --------
    gen_image_interleaved
    """
    with HalconOperator(2079) as proc:
        proc.set_input_object(1, multichannel_image)
        proc.set_input_tuple(0, pixel_format)
        proc.set_input_tuple(1, row_bytes)
        proc.set_input_tuple(2, alpha)
        proc.execute()
        interleaved_image = HObject(proc.get_output_object_key(1))
        return interleaved_image  # type: ignore


def interpolate_scattered_data(
    scattered_data_interpolator_handle: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Interpolation of scattered data using a scattered data interpolator.

    Parameters
    ----------

    scattered_data_interpolator_handle : HHandle
                                         Handle of the scattered data
                                         interpolator

    row : MaybeSequence[Union[float, int]]
          Row coordinates of points  to be interpolated

    column : MaybeSequence[Union[float, int]]
             Column coordinates of points  to be interpolated

    Returns
    -------

    value_interpolated : Sequence[Union[float, int]]
                         Values of interpolated points

    Predecessors
    ------------
    create_scattered_data_interpolator

    Successors
    ----------
    clear_scattered_data_interpolator, gen_object_model_3d_from_points
    """
    with HalconOperator(291) as proc:
        proc.set_input_tuple(0, scattered_data_interpolator_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.init_oct(0)
        proc.execute()
        value_interpolated = proc.get_output_tuple_m(0)
        return value_interpolated  # type: ignore


def interpolate_scattered_data_image(
    image: HObject,
    region_interpolate: HObject,
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HObject:
    """
    Interpolation of an image.

    Parameters
    ----------

    image : HObject
            Image to interpolate

    region_interpolate : HObject
                         Region to interpolate

    method : str
             Method for the interpolation
             Value Suggestion: 'thin_plate_splines'

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters that can be adjusted
                      Value Suggestion: []

    Returns
    -------

    image_interpolated : HObject
                         Interpolated image

    Alternatives
    ------------
    interpolate_scattered_data_points_to_image
    """
    with HalconOperator(294) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region_interpolate)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()
        image_interpolated = HObject(proc.get_output_object_key(1))
        return image_interpolated  # type: ignore


def interpolate_scattered_data_points_to_image(
    method: str,
    rows: Sequence[Union[float, int]],
    columns: Sequence[Union[float, int]],
    values: Sequence[Union[float, int]],
    width: int,
    height: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HObject:
    """
    Creating an image from the interpolation of scattered data.

    Parameters
    ----------

    method : str
             Method for the interpolation
             Value Suggestion: 'thin_plate_splines'

    rows : Sequence[Union[float, int]]
           Row coordinates of the points used for the interpolation

    columns : Sequence[Union[float, int]]
              Column coordinates of the points  used for the interpolation

    values : Sequence[Union[float, int]]
             Values of the points used for the interpolation

    width : int
            Width of the interpolated image
            Value Suggestion: 640

    height : int
             Height of the interpolated image
             Value Suggestion: 480

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters that can be adjusted
                      Value Suggestion: []

    Returns
    -------

    image_interpolated : HObject
                         Interpolated image

    Alternatives
    ------------
    interpolate_scattered_data_image
    """
    with HalconOperator(293) as proc:
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, rows)
        proc.set_input_tuple(2, columns)
        proc.set_input_tuple(3, values)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, height)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.execute()
        image_interpolated = HObject(proc.get_output_object_key(1))
        return image_interpolated  # type: ignore


def interpolate_scattered_data_s(
    scattered_data_interpolator_handle: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]]
) -> Union[float, int]:
    """
    Interpolation of scattered data using a scattered data interpolator.

    Parameters
    ----------

    scattered_data_interpolator_handle : HHandle
                                         Handle of the scattered data
                                         interpolator

    row : MaybeSequence[Union[float, int]]
          Row coordinates of points  to be interpolated

    column : MaybeSequence[Union[float, int]]
             Column coordinates of points  to be interpolated

    Returns
    -------

    value_interpolated : Union[float, int]
                         Values of interpolated points

    Predecessors
    ------------
    create_scattered_data_interpolator

    Successors
    ----------
    clear_scattered_data_interpolator, gen_object_model_3d_from_points
    """
    with HalconOperator(291) as proc:
        proc.set_input_tuple(0, scattered_data_interpolator_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.init_oct(0)
        proc.execute()
        value_interpolated = proc.get_output_tuple_s(0)
        return value_interpolated  # type: ignore


def interrupt_operator(hthread_id: int, mode: str) -> None:
    """
    Attempt to interrupt an operator running in a different thread.

    Parameters
    ----------

    hthread_id : int
                 Thread that runs the operator to interrupt.

    mode : str
           Interruption mode.
           Value Suggestion: cancel

    See Also
    --------
    get_current_hthread_id, set_operator_timeout

    Alternatives
    ------------
    set_operator_timeout

    Predecessors
    ------------
    get_current_hthread_id

    Notes
    -----
    Note that not all operators support interruption. If a given operator
    supports interruptions and which modes are supported is described in
    the execution information section of the reference documentation of
    the corresponding operator.
    Also note that there is no hard guarantee about the granularity of the
    interruption. The granularity can depend on the operator, its input
    data and the speed of the device. It is typically finer than 10 ms.
    """
    with HalconOperator(2161) as proc:
        proc.set_input_tuple(0, hthread_id)
        proc.set_input_tuple(1, mode)
        proc.execute()


def intersect_lines_of_sight(
    cam_param_1: Sequence[Union[int, float, str]],
    cam_param_2: Sequence[Union[int, float, str]],
    rel_pose: Sequence[Union[int, float]],
    row_1: MaybeSequence[Union[int, float]],
    col_1: MaybeSequence[Union[int, float]],
    row_2: MaybeSequence[Union[int, float]],
    col_2: MaybeSequence[Union[int, float]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Get a 3D point from the intersection of two lines of sight within a
    binocular camera system.

    Parameters
    ----------

    cam_param_1 : Sequence[Union[int, float, str]]
                  Internal parameters of the projective camera 1.

    cam_param_2 : Sequence[Union[int, float, str]]
                  Internal parameters of the projective camera 2.

    rel_pose : Sequence[Union[int, float]]
               Point transformation from camera 2 to camera 1.

    row_1 : MaybeSequence[Union[int, float]]
            Row coordinate of a point in image 1.

    col_1 : MaybeSequence[Union[int, float]]
            Column coordinate of a point in image 1.

    row_2 : MaybeSequence[Union[int, float]]
            Row coordinate of the corresponding point in image 2.

    col_2 : MaybeSequence[Union[int, float]]
            Column coordinate of the corresponding point in image 2.

    Returns
    -------

    x : Sequence[float]
        X coordinate of the 3D point.

    y : Sequence[float]
        Y coordinate of the 3D point.

    z : Sequence[float]
        Z coordinate of the 3D point.

    dist : Sequence[float]
           Distance of the 3D point to the lines of sight.

    See Also
    --------
    disparity_to_point_3d

    Predecessors
    ------------
    binocular_calibration

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.
    """
    with HalconOperator(364) as proc:
        proc.set_input_tuple(0, cam_param_1)
        proc.set_input_tuple(1, cam_param_2)
        proc.set_input_tuple(2, rel_pose)
        proc.set_input_tuple(3, row_1)
        proc.set_input_tuple(4, col_1)
        proc.set_input_tuple(5, row_2)
        proc.set_input_tuple(6, col_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1),  # y
            proc.get_output_tuple_m(2),  # z
            proc.get_output_tuple_m(3)   # dist
        )  # type: ignore


def intersect_lines_of_sight_s(
    cam_param_1: Sequence[Union[int, float, str]],
    cam_param_2: Sequence[Union[int, float, str]],
    rel_pose: Sequence[Union[int, float]],
    row_1: MaybeSequence[Union[int, float]],
    col_1: MaybeSequence[Union[int, float]],
    row_2: MaybeSequence[Union[int, float]],
    col_2: MaybeSequence[Union[int, float]]
) -> Tuple[float, float, float, float]:
    """
    Get a 3D point from the intersection of two lines of sight within a
    binocular camera system.

    Parameters
    ----------

    cam_param_1 : Sequence[Union[int, float, str]]
                  Internal parameters of the projective camera 1.

    cam_param_2 : Sequence[Union[int, float, str]]
                  Internal parameters of the projective camera 2.

    rel_pose : Sequence[Union[int, float]]
               Point transformation from camera 2 to camera 1.

    row_1 : MaybeSequence[Union[int, float]]
            Row coordinate of a point in image 1.

    col_1 : MaybeSequence[Union[int, float]]
            Column coordinate of a point in image 1.

    row_2 : MaybeSequence[Union[int, float]]
            Row coordinate of the corresponding point in image 2.

    col_2 : MaybeSequence[Union[int, float]]
            Column coordinate of the corresponding point in image 2.

    Returns
    -------

    x : float
        X coordinate of the 3D point.

    y : float
        Y coordinate of the 3D point.

    z : float
        Z coordinate of the 3D point.

    dist : float
           Distance of the 3D point to the lines of sight.

    See Also
    --------
    disparity_to_point_3d

    Predecessors
    ------------
    binocular_calibration

    Notes
    -----
    Stereo setups that contain cameras with and without hypercentric
    lenses at the same time are not supported.
    """
    with HalconOperator(364) as proc:
        proc.set_input_tuple(0, cam_param_1)
        proc.set_input_tuple(1, cam_param_2)
        proc.set_input_tuple(2, rel_pose)
        proc.set_input_tuple(3, row_1)
        proc.set_input_tuple(4, col_1)
        proc.set_input_tuple(5, row_2)
        proc.set_input_tuple(6, col_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # x
            proc.get_output_tuple_s(1),  # y
            proc.get_output_tuple_s(2),  # z
            proc.get_output_tuple_s(3)   # dist
        )  # type: ignore


def intersect_plane_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    plane: Sequence[Union[int, float]]
) -> Sequence[HHandle]:
    """
    Intersect a 3D object model with a plane.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    plane : Sequence[Union[int, float]]
            Pose of the plane.
            Value Suggestion: [0,0,0,0,0,0,0]

    Returns
    -------

    object_model_3dintersection : Sequence[HHandle]
                                  Handle of the 3D object model that
                                  describes the intersection as a set of
                                  lines.

    See Also
    --------
    reduce_object_model_3d_by_view

    Predecessors
    ------------
    read_object_model_3d, select_points_object_model_3d

    Successors
    ----------
    connection_object_model_3d
    """
    with HalconOperator(1077) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, plane)
        proc.init_oct(0)
        proc.execute()
        object_model_3dintersection = proc.get_output_tuple_m(0)
        return object_model_3dintersection  # type: ignore


def intersect_plane_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    plane: Sequence[Union[int, float]]
) -> HHandle:
    """
    Intersect a 3D object model with a plane.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    plane : Sequence[Union[int, float]]
            Pose of the plane.
            Value Suggestion: [0,0,0,0,0,0,0]

    Returns
    -------

    object_model_3dintersection : HHandle
                                  Handle of the 3D object model that
                                  describes the intersection as a set of
                                  lines.

    See Also
    --------
    reduce_object_model_3d_by_view

    Predecessors
    ------------
    read_object_model_3d, select_points_object_model_3d

    Successors
    ----------
    connection_object_model_3d
    """
    with HalconOperator(1077) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, plane)
        proc.init_oct(0)
        proc.execute()
        object_model_3dintersection = proc.get_output_tuple_s(0)
        return object_model_3dintersection  # type: ignore


def intersection(region_1: HObject, region_2: HObject) -> HObject:
    """
    Calculate the intersection of two regions.

    Parameters
    ----------

    region_1 : HObject
               Regions to be intersected with all regions in Region2.

    region_2 : HObject
               Regions with which Region1 is intersected.

    Returns
    -------

    region_intersection : HObject
                          Result of the intersection.

    See Also
    --------
    union1, union2, complement

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region

    Notes
    -----
    Empty input regions are permitted.  Because empty result regions are
    possible, the system flag 'store_empty_region' should be set
    appropriately.
    """
    with HalconOperator(493) as proc:
        proc.set_input_object(1, region_1)
        proc.set_input_object(2, region_2)
        proc.execute()
        region_intersection = HObject(proc.get_output_object_key(1))
        return region_intersection  # type: ignore


def intersection_circle_contour_xld(
    contour: HObject,
    circle_row: Union[float, int],
    circle_column: Union[float, int],
    circle_radius: Union[float, int],
    circle_start_phi: float,
    circle_end_phi: float,
    circle_point_order: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the intersection points of a circle or circular arc and an
    XLD contour

    Parameters
    ----------

    contour : HObject
              XLD contour.

    circle_row : Union[float, int]
                 Row coordinate of the center of the circle or circular
                 arc.

    circle_column : Union[float, int]
                    Column coordinate of the center of the circle or
                    circular arc.

    circle_radius : Union[float, int]
                    Radius of the circle or circular arc.

    circle_start_phi : float
                       Angle of the start point of the circle or circular
                       arc [rad].
                       Value Suggestion: 0.0

    circle_end_phi : float
                     Angle of the end point of the circle or  circular arc
                     [rad].
                     Value Suggestion: 6.28318

    circle_point_order : str
                         Point order along the circle or circular arc.
                         Value Suggestion: positive

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    See Also
    --------
    intersection_line_circle

    Alternatives
    ------------
    intersection_segment_circle
    """
    with HalconOperator(1342) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, circle_row)
        proc.set_input_tuple(1, circle_column)
        proc.set_input_tuple(2, circle_radius)
        proc.set_input_tuple(3, circle_start_phi)
        proc.set_input_tuple(4, circle_end_phi)
        proc.set_input_tuple(5, circle_point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def intersection_circle_contour_xld_s(
    contour: HObject,
    circle_row: Union[float, int],
    circle_column: Union[float, int],
    circle_radius: Union[float, int],
    circle_start_phi: float,
    circle_end_phi: float,
    circle_point_order: str
) -> Tuple[float, float]:
    """
    Calculate the intersection points of a circle or circular arc and an
    XLD contour

    Parameters
    ----------

    contour : HObject
              XLD contour.

    circle_row : Union[float, int]
                 Row coordinate of the center of the circle or circular
                 arc.

    circle_column : Union[float, int]
                    Column coordinate of the center of the circle or
                    circular arc.

    circle_radius : Union[float, int]
                    Radius of the circle or circular arc.

    circle_start_phi : float
                       Angle of the start point of the circle or circular
                       arc [rad].
                       Value Suggestion: 0.0

    circle_end_phi : float
                     Angle of the end point of the circle or  circular arc
                     [rad].
                     Value Suggestion: 6.28318

    circle_point_order : str
                         Point order along the circle or circular arc.
                         Value Suggestion: positive

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    See Also
    --------
    intersection_line_circle

    Alternatives
    ------------
    intersection_segment_circle
    """
    with HalconOperator(1342) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, circle_row)
        proc.set_input_tuple(1, circle_column)
        proc.set_input_tuple(2, circle_radius)
        proc.set_input_tuple(3, circle_start_phi)
        proc.set_input_tuple(4, circle_end_phi)
        proc.set_input_tuple(5, circle_point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def intersection_circles(
    circle_1row: Union[float, int],
    circle_1column: Union[float, int],
    circle_1radius: Union[float, int],
    circle_1start_phi: float,
    circle_1end_phi: float,
    circle_1point_order: str,
    circle_2row: Union[float, int],
    circle_2column: Union[float, int],
    circle_2radius: Union[float, int],
    circle_2start_phi: float,
    circle_2end_phi: float,
    circle_2point_order: str
) -> Tuple[Sequence[float], Sequence[float], int]:
    """
    Calculate the intersection points of two circles or circular arcs

    Parameters
    ----------

    circle_1row : Union[float, int]
                  Row coordinate of the center of the first circle or
                  circular arc.

    circle_1column : Union[float, int]
                     Column coordinate of the center of the first circle
                     or circular arc.

    circle_1radius : Union[float, int]
                     Radius of the first circle or circular arc.

    circle_1start_phi : float
                        Angle of the start point of the first circle or
                        circular arc [rad].
                        Value Suggestion: 0.0

    circle_1end_phi : float
                      Angle of the end point of the first circle or
                      circular arc [rad].
                      Value Suggestion: 6.28318

    circle_1point_order : str
                          Point order along the first circle or circular
                          arc.
                          Value Suggestion: positive

    circle_2row : Union[float, int]
                  Row coordinate of the center of the second circle or
                  circular arc.

    circle_2column : Union[float, int]
                     Column coordinate of the center of the second circle
                     or circular arc.

    circle_2radius : Union[float, int]
                     Radius of the second circle or circular arc.

    circle_2start_phi : float
                        Angle of the start point of the second circle or
                        circular arc [rad].
                        Value Suggestion: 0.0

    circle_2end_phi : float
                      Angle of the end point of the second circle or
                      circular arc [rad].
                      Value Suggestion: 6.28318

    circle_2point_order : str
                          Point order along the second circle or circular
                          arc.
                          Value Suggestion: positive

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    is_overlapping : int
                     Do both circles or circular arcs have a part in
                     common?
    """
    with HalconOperator(1343) as proc:
        proc.set_input_tuple(0, circle_1row)
        proc.set_input_tuple(1, circle_1column)
        proc.set_input_tuple(2, circle_1radius)
        proc.set_input_tuple(3, circle_1start_phi)
        proc.set_input_tuple(4, circle_1end_phi)
        proc.set_input_tuple(5, circle_1point_order)
        proc.set_input_tuple(6, circle_2row)
        proc.set_input_tuple(7, circle_2column)
        proc.set_input_tuple(8, circle_2radius)
        proc.set_input_tuple(9, circle_2start_phi)
        proc.set_input_tuple(10, circle_2end_phi)
        proc.set_input_tuple(11, circle_2point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_circles_s(
    circle_1row: Union[float, int],
    circle_1column: Union[float, int],
    circle_1radius: Union[float, int],
    circle_1start_phi: float,
    circle_1end_phi: float,
    circle_1point_order: str,
    circle_2row: Union[float, int],
    circle_2column: Union[float, int],
    circle_2radius: Union[float, int],
    circle_2start_phi: float,
    circle_2end_phi: float,
    circle_2point_order: str
) -> Tuple[float, float, int]:
    """
    Calculate the intersection points of two circles or circular arcs

    Parameters
    ----------

    circle_1row : Union[float, int]
                  Row coordinate of the center of the first circle or
                  circular arc.

    circle_1column : Union[float, int]
                     Column coordinate of the center of the first circle
                     or circular arc.

    circle_1radius : Union[float, int]
                     Radius of the first circle or circular arc.

    circle_1start_phi : float
                        Angle of the start point of the first circle or
                        circular arc [rad].
                        Value Suggestion: 0.0

    circle_1end_phi : float
                      Angle of the end point of the first circle or
                      circular arc [rad].
                      Value Suggestion: 6.28318

    circle_1point_order : str
                          Point order along the first circle or circular
                          arc.
                          Value Suggestion: positive

    circle_2row : Union[float, int]
                  Row coordinate of the center of the second circle or
                  circular arc.

    circle_2column : Union[float, int]
                     Column coordinate of the center of the second circle
                     or circular arc.

    circle_2radius : Union[float, int]
                     Radius of the second circle or circular arc.

    circle_2start_phi : float
                        Angle of the start point of the second circle or
                        circular arc [rad].
                        Value Suggestion: 0.0

    circle_2end_phi : float
                      Angle of the end point of the second circle or
                      circular arc [rad].
                      Value Suggestion: 6.28318

    circle_2point_order : str
                          Point order along the second circle or circular
                          arc.
                          Value Suggestion: positive

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    is_overlapping : int
                     Do both circles or circular arcs have a part in
                     common?
    """
    with HalconOperator(1343) as proc:
        proc.set_input_tuple(0, circle_1row)
        proc.set_input_tuple(1, circle_1column)
        proc.set_input_tuple(2, circle_1radius)
        proc.set_input_tuple(3, circle_1start_phi)
        proc.set_input_tuple(4, circle_1end_phi)
        proc.set_input_tuple(5, circle_1point_order)
        proc.set_input_tuple(6, circle_2row)
        proc.set_input_tuple(7, circle_2column)
        proc.set_input_tuple(8, circle_2radius)
        proc.set_input_tuple(9, circle_2start_phi)
        proc.set_input_tuple(10, circle_2end_phi)
        proc.set_input_tuple(11, circle_2point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_closed_contours_xld(
    contours_1: HObject,
    contours_2: HObject
) -> HObject:
    """
    Intersect closed contours.

    Parameters
    ----------

    contours_1 : HObject
                 Contours enclosing the first region to be intersected.

    contours_2 : HObject
                 Contours enclosing the second region to be intersected.

    Returns
    -------

    contours_intersection : HObject
                            Contours enclosing the intersection.

    See Also
    --------
    difference_closed_contours_xld, symm_difference_closed_contours_xld,
    union2_closed_contours_xld, intersection_closed_polygons_xld

    Alternatives
    ------------
    intersection

    Predecessors
    ------------
    gen_contour_region_xld, zero_crossing_sub_pix, threshold_sub_pix
    """
    with HalconOperator(12) as proc:
        proc.set_input_object(1, contours_1)
        proc.set_input_object(2, contours_2)
        proc.execute()
        contours_intersection = HObject(proc.get_output_object_key(1))
        return contours_intersection  # type: ignore


def intersection_closed_polygons_xld(
    polygons_1: HObject,
    polygons_2: HObject
) -> HObject:
    """
    Intersect closed polygons.

    Parameters
    ----------

    polygons_1 : HObject
                 Polygons enclosing the first region to be intersected.

    polygons_2 : HObject
                 Polygons enclosing the second region to be intersected.

    Returns
    -------

    polygons_intersection : HObject
                            Polygons enclosing the intersection.

    See Also
    --------
    difference_closed_polygons_xld, symm_difference_closed_polygons_xld,
    union2_closed_polygons_xld, intersection_closed_contours_xld

    Alternatives
    ------------
    intersection

    Predecessors
    ------------
    gen_polygons_xld

    Notes
    -----
    The resulting polygons PolygonsIntersection contain no references to
    the XLD contours that are possibly referenced by Polygons1 and
    Polygons2. Hence, operators that access the contours associated with a
    polygon, e.g., split_contours_xld will not work correctly.
    """
    with HalconOperator(11) as proc:
        proc.set_input_object(1, polygons_1)
        proc.set_input_object(2, polygons_2)
        proc.execute()
        polygons_intersection = HObject(proc.get_output_object_key(1))
        return polygons_intersection  # type: ignore


def intersection_contours_xld(
    contour_1: HObject,
    contour_2: HObject,
    intersection_type: str
) -> Tuple[Sequence[float], Sequence[float], int]:
    """
    Calculate the intersection points of two XLD contours

    Parameters
    ----------

    contour_1 : HObject
                First XLD contour.

    contour_2 : HObject
                Second XLD contour.

    intersection_type : str
                        Intersection points to be returned.
                        Value Suggestion: all

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    is_overlapping : int
                     Does a part of a contour lie above another contour
                     part?

    See Also
    --------
    intersection_segment_line, intersection_lines,
    intersection_line_contour_xld

    Alternatives
    ------------
    intersection_segments, intersection_segment_contour_xld
    """
    with HalconOperator(1341) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, intersection_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_contours_xld_s(
    contour_1: HObject,
    contour_2: HObject,
    intersection_type: str
) -> Tuple[float, float, int]:
    """
    Calculate the intersection points of two XLD contours

    Parameters
    ----------

    contour_1 : HObject
                First XLD contour.

    contour_2 : HObject
                Second XLD contour.

    intersection_type : str
                        Intersection points to be returned.
                        Value Suggestion: all

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    is_overlapping : int
                     Does a part of a contour lie above another contour
                     part?

    See Also
    --------
    intersection_segment_line, intersection_lines,
    intersection_line_contour_xld

    Alternatives
    ------------
    intersection_segments, intersection_segment_contour_xld
    """
    with HalconOperator(1341) as proc:
        proc.set_input_object(1, contour_1)
        proc.set_input_object(2, contour_2)
        proc.set_input_tuple(0, intersection_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_line_circle(
    line_row_1: Union[float, int],
    line_column_1: Union[float, int],
    line_row_2: Union[float, int],
    line_column_2: Union[float, int],
    circle_row: Union[float, int],
    circle_column: Union[float, int],
    circle_radius: Union[float, int],
    circle_start_phi: float,
    circle_end_phi: float,
    circle_point_order: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the intersection points of a line and a circle or circular
    arc

    Parameters
    ----------

    line_row_1 : Union[float, int]
                 Row coordinate of the first point of the line.

    line_column_1 : Union[float, int]
                    Column coordinate of the first point of the line.

    line_row_2 : Union[float, int]
                 Row coordinate of the second point of the line.

    line_column_2 : Union[float, int]
                    Column coordinate of the second point of the line.

    circle_row : Union[float, int]
                 Row coordinate of the center of the circle or circular
                 arc.

    circle_column : Union[float, int]
                    Column coordinate of the center of the circle or
                    circular arc.

    circle_radius : Union[float, int]
                    Radius of the circle or circular arc.

    circle_start_phi : float
                       Angle of the start point of the circle or circular
                       arc [rad].
                       Value Suggestion: 0.0

    circle_end_phi : float
                     Angle of the end point of the circle or  circular arc
                     [rad].
                     Value Suggestion: 6.28318

    circle_point_order : str
                         Point order along the circle or circular arc.
                         Value Suggestion: positive

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    See Also
    --------
    intersection_segment_circle, intersection_circle_contour_xld
    """
    with HalconOperator(1345) as proc:
        proc.set_input_tuple(0, line_row_1)
        proc.set_input_tuple(1, line_column_1)
        proc.set_input_tuple(2, line_row_2)
        proc.set_input_tuple(3, line_column_2)
        proc.set_input_tuple(4, circle_row)
        proc.set_input_tuple(5, circle_column)
        proc.set_input_tuple(6, circle_radius)
        proc.set_input_tuple(7, circle_start_phi)
        proc.set_input_tuple(8, circle_end_phi)
        proc.set_input_tuple(9, circle_point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def intersection_line_circle_s(
    line_row_1: Union[float, int],
    line_column_1: Union[float, int],
    line_row_2: Union[float, int],
    line_column_2: Union[float, int],
    circle_row: Union[float, int],
    circle_column: Union[float, int],
    circle_radius: Union[float, int],
    circle_start_phi: float,
    circle_end_phi: float,
    circle_point_order: str
) -> Tuple[float, float]:
    """
    Calculate the intersection points of a line and a circle or circular
    arc

    Parameters
    ----------

    line_row_1 : Union[float, int]
                 Row coordinate of the first point of the line.

    line_column_1 : Union[float, int]
                    Column coordinate of the first point of the line.

    line_row_2 : Union[float, int]
                 Row coordinate of the second point of the line.

    line_column_2 : Union[float, int]
                    Column coordinate of the second point of the line.

    circle_row : Union[float, int]
                 Row coordinate of the center of the circle or circular
                 arc.

    circle_column : Union[float, int]
                    Column coordinate of the center of the circle or
                    circular arc.

    circle_radius : Union[float, int]
                    Radius of the circle or circular arc.

    circle_start_phi : float
                       Angle of the start point of the circle or circular
                       arc [rad].
                       Value Suggestion: 0.0

    circle_end_phi : float
                     Angle of the end point of the circle or  circular arc
                     [rad].
                     Value Suggestion: 6.28318

    circle_point_order : str
                         Point order along the circle or circular arc.
                         Value Suggestion: positive

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    See Also
    --------
    intersection_segment_circle, intersection_circle_contour_xld
    """
    with HalconOperator(1345) as proc:
        proc.set_input_tuple(0, line_row_1)
        proc.set_input_tuple(1, line_column_1)
        proc.set_input_tuple(2, line_row_2)
        proc.set_input_tuple(3, line_column_2)
        proc.set_input_tuple(4, circle_row)
        proc.set_input_tuple(5, circle_column)
        proc.set_input_tuple(6, circle_radius)
        proc.set_input_tuple(7, circle_start_phi)
        proc.set_input_tuple(8, circle_end_phi)
        proc.set_input_tuple(9, circle_point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def intersection_line_contour_xld(
    contour: HObject,
    line_row_1: Union[float, int],
    line_column_1: Union[float, int],
    line_row_2: Union[float, int],
    line_column_2: Union[float, int]
) -> Tuple[Sequence[float], Sequence[float], int]:
    """
    Calculate the intersection points of a line and an XLD contour

    Parameters
    ----------

    contour : HObject
              XLD contour.

    line_row_1 : Union[float, int]
                 Row coordinate of the first point of the line.

    line_column_1 : Union[float, int]
                    Column coordinate of the first point of the line.

    line_row_2 : Union[float, int]
                 Row coordinate of the second point of the line.

    line_column_2 : Union[float, int]
                    Column coordinate of the second point of the line.

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    is_overlapping : int
                     Does a part of the XLD contour lie on the line?

    See Also
    --------
    intersection_segments, intersection_lines,
    intersection_segment_contour_xld, intersection_contours_xld

    Alternatives
    ------------
    intersection_segment_line
    """
    with HalconOperator(1344) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, line_row_1)
        proc.set_input_tuple(1, line_column_1)
        proc.set_input_tuple(2, line_row_2)
        proc.set_input_tuple(3, line_column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_line_contour_xld_s(
    contour: HObject,
    line_row_1: Union[float, int],
    line_column_1: Union[float, int],
    line_row_2: Union[float, int],
    line_column_2: Union[float, int]
) -> Tuple[float, float, int]:
    """
    Calculate the intersection points of a line and an XLD contour

    Parameters
    ----------

    contour : HObject
              XLD contour.

    line_row_1 : Union[float, int]
                 Row coordinate of the first point of the line.

    line_column_1 : Union[float, int]
                    Column coordinate of the first point of the line.

    line_row_2 : Union[float, int]
                 Row coordinate of the second point of the line.

    line_column_2 : Union[float, int]
                    Column coordinate of the second point of the line.

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    is_overlapping : int
                     Does a part of the XLD contour lie on the line?

    See Also
    --------
    intersection_segments, intersection_lines,
    intersection_segment_contour_xld, intersection_contours_xld

    Alternatives
    ------------
    intersection_segment_line
    """
    with HalconOperator(1344) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, line_row_1)
        proc.set_input_tuple(1, line_column_1)
        proc.set_input_tuple(2, line_row_2)
        proc.set_input_tuple(3, line_column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_lines(
    line_1row_1: Union[float, int],
    line_1column_1: Union[float, int],
    line_1row_2: Union[float, int],
    line_1column_2: Union[float, int],
    line_2row_1: Union[float, int],
    line_2column_1: Union[float, int],
    line_2row_2: Union[float, int],
    line_2column_2: Union[float, int]
) -> Tuple[float, float, int]:
    """
    Calculate the intersection point of two lines

    Parameters
    ----------

    line_1row_1 : Union[float, int]
                  Row coordinate of the first point of the first line.

    line_1column_1 : Union[float, int]
                     Column coordinate of the first point of the first
                     line.

    line_1row_2 : Union[float, int]
                  Row coordinate of the second point of the first line.

    line_1column_2 : Union[float, int]
                     Column coordinate of the second point of the first
                     line.

    line_2row_1 : Union[float, int]
                  Row coordinate of the first point of the second line.

    line_2column_1 : Union[float, int]
                     Column coordinate of the first point of the second
                     line.

    line_2row_2 : Union[float, int]
                  Row coordinate of the second point of the second line.

    line_2column_2 : Union[float, int]
                     Column coordinate of the second point of the second
                     line.

    Returns
    -------

    row : float
          Row coordinate of the intersection point.

    column : float
             Column coordinate of the intersection point.

    is_overlapping : int
                     Are both lines identical?

    See Also
    --------
    intersection_segments, intersection_segment_line,
    intersection_segment_contour_xld, intersection_line_contour_xld,
    intersection_contours_xld
    """
    with HalconOperator(1346) as proc:
        proc.set_input_tuple(0, line_1row_1)
        proc.set_input_tuple(1, line_1column_1)
        proc.set_input_tuple(2, line_1row_2)
        proc.set_input_tuple(3, line_1column_2)
        proc.set_input_tuple(4, line_2row_1)
        proc.set_input_tuple(5, line_2column_1)
        proc.set_input_tuple(6, line_2row_2)
        proc.set_input_tuple(7, line_2column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_ll(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[int]]:
    """
    Calculate the intersection point of two lines.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the first line.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the first line.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the first line.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the first line.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the second line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the second line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the second line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the second line.

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the intersection point.

    column : Sequence[float]
             Column coordinate of the intersection point.

    is_parallel : Sequence[int]
                  Are the two lines parallel?

    Warnings
    --------
    intersection_ll is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the operator
    intersection_lines of the chapter Tools / Geometry instead.

    Notes
    -----
    If the lines are parallel the values of Row and Column are undefined.
    """
    with HalconOperator(1340) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2)   # is_parallel
        )  # type: ignore


def intersection_ll_s(
    row_a1: MaybeSequence[Union[float, int]],
    column_a1: MaybeSequence[Union[float, int]],
    row_a2: MaybeSequence[Union[float, int]],
    column_a2: MaybeSequence[Union[float, int]],
    row_b1: MaybeSequence[Union[float, int]],
    column_b1: MaybeSequence[Union[float, int]],
    row_b2: MaybeSequence[Union[float, int]],
    column_b2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float, int]:
    """
    Calculate the intersection point of two lines.

    Parameters
    ----------

    row_a1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the first line.

    column_a1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the first line.

    row_a2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the first line.

    column_a2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the first line.

    row_b1 : MaybeSequence[Union[float, int]]
             Row coordinate of the first point of the second line.

    column_b1 : MaybeSequence[Union[float, int]]
                Column coordinate of the first point of the second line.

    row_b2 : MaybeSequence[Union[float, int]]
             Row coordinate of the second point of the second line.

    column_b2 : MaybeSequence[Union[float, int]]
                Column coordinate of the second point of the second line.

    Returns
    -------

    row : float
          Row coordinate of the intersection point.

    column : float
             Column coordinate of the intersection point.

    is_parallel : int
                  Are the two lines parallel?

    Warnings
    --------
    intersection_ll is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the operator
    intersection_lines of the chapter Tools / Geometry instead.

    Notes
    -----
    If the lines are parallel the values of Row and Column are undefined.
    """
    with HalconOperator(1340) as proc:
        proc.set_input_tuple(0, row_a1)
        proc.set_input_tuple(1, column_a1)
        proc.set_input_tuple(2, row_a2)
        proc.set_input_tuple(3, column_a2)
        proc.set_input_tuple(4, row_b1)
        proc.set_input_tuple(5, column_b1)
        proc.set_input_tuple(6, row_b2)
        proc.set_input_tuple(7, column_b2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_parallel
        )  # type: ignore


def intersection_segment_circle(
    segment_row_1: Union[float, int],
    segment_column_1: Union[float, int],
    segment_row_2: Union[float, int],
    segment_column_2: Union[float, int],
    circle_row: Union[float, int],
    circle_column: Union[float, int],
    circle_radius: Union[float, int],
    circle_start_phi: float,
    circle_end_phi: float,
    circle_point_order: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the intersection points of a segment and a circle or
    circular arc

    Parameters
    ----------

    segment_row_1 : Union[float, int]
                    Row coordinate of the first point of the segment.

    segment_column_1 : Union[float, int]
                       Column coordinate of the first point of the segment.

    segment_row_2 : Union[float, int]
                    Row coordinate of the second point of the segment.

    segment_column_2 : Union[float, int]
                       Column coordinate of the second point of the
                       segment.

    circle_row : Union[float, int]
                 Row coordinate of the center of the circle or circular
                 arc.

    circle_column : Union[float, int]
                    Column coordinate of the center of the circle or
                    circular arc.

    circle_radius : Union[float, int]
                    Radius of the circle or circular arc.

    circle_start_phi : float
                       Angle of the start point of the circle or circular
                       arc [rad].
                       Value Suggestion: 0.0

    circle_end_phi : float
                     Angle of the end point of the circle or  circular arc
                     [rad].
                     Value Suggestion: 6.28318

    circle_point_order : str
                         Point order along the circle or circular arc.
                         Value Suggestion: positive

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    See Also
    --------
    intersection_line_circle

    Alternatives
    ------------
    intersection_circle_contour_xld
    """
    with HalconOperator(1348) as proc:
        proc.set_input_tuple(0, segment_row_1)
        proc.set_input_tuple(1, segment_column_1)
        proc.set_input_tuple(2, segment_row_2)
        proc.set_input_tuple(3, segment_column_2)
        proc.set_input_tuple(4, circle_row)
        proc.set_input_tuple(5, circle_column)
        proc.set_input_tuple(6, circle_radius)
        proc.set_input_tuple(7, circle_start_phi)
        proc.set_input_tuple(8, circle_end_phi)
        proc.set_input_tuple(9, circle_point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def intersection_segment_circle_s(
    segment_row_1: Union[float, int],
    segment_column_1: Union[float, int],
    segment_row_2: Union[float, int],
    segment_column_2: Union[float, int],
    circle_row: Union[float, int],
    circle_column: Union[float, int],
    circle_radius: Union[float, int],
    circle_start_phi: float,
    circle_end_phi: float,
    circle_point_order: str
) -> Tuple[float, float]:
    """
    Calculate the intersection points of a segment and a circle or
    circular arc

    Parameters
    ----------

    segment_row_1 : Union[float, int]
                    Row coordinate of the first point of the segment.

    segment_column_1 : Union[float, int]
                       Column coordinate of the first point of the segment.

    segment_row_2 : Union[float, int]
                    Row coordinate of the second point of the segment.

    segment_column_2 : Union[float, int]
                       Column coordinate of the second point of the
                       segment.

    circle_row : Union[float, int]
                 Row coordinate of the center of the circle or circular
                 arc.

    circle_column : Union[float, int]
                    Column coordinate of the center of the circle or
                    circular arc.

    circle_radius : Union[float, int]
                    Radius of the circle or circular arc.

    circle_start_phi : float
                       Angle of the start point of the circle or circular
                       arc [rad].
                       Value Suggestion: 0.0

    circle_end_phi : float
                     Angle of the end point of the circle or  circular arc
                     [rad].
                     Value Suggestion: 6.28318

    circle_point_order : str
                         Point order along the circle or circular arc.
                         Value Suggestion: positive

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    See Also
    --------
    intersection_line_circle

    Alternatives
    ------------
    intersection_circle_contour_xld
    """
    with HalconOperator(1348) as proc:
        proc.set_input_tuple(0, segment_row_1)
        proc.set_input_tuple(1, segment_column_1)
        proc.set_input_tuple(2, segment_row_2)
        proc.set_input_tuple(3, segment_column_2)
        proc.set_input_tuple(4, circle_row)
        proc.set_input_tuple(5, circle_column)
        proc.set_input_tuple(6, circle_radius)
        proc.set_input_tuple(7, circle_start_phi)
        proc.set_input_tuple(8, circle_end_phi)
        proc.set_input_tuple(9, circle_point_order)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1)   # column
        )  # type: ignore


def intersection_segment_contour_xld(
    contour: HObject,
    segment_row_1: Union[float, int],
    segment_column_1: Union[float, int],
    segment_row_2: Union[float, int],
    segment_column_2: Union[float, int]
) -> Tuple[Sequence[float], Sequence[float], int]:
    """
    Calculate the intersection points of a segment and an XLD contour

    Parameters
    ----------

    contour : HObject
              XLD contour.

    segment_row_1 : Union[float, int]
                    Row coordinate of the first point of the segment.

    segment_column_1 : Union[float, int]
                       Column coordinate of the first point of the segment.

    segment_row_2 : Union[float, int]
                    Row coordinate of the second point of the segment.

    segment_column_2 : Union[float, int]
                       Column coordinate of the second point of the
                       segment.

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the intersection points.

    column : Sequence[float]
             Column coordinates of the intersection points.

    is_overlapping : int
                     Do the segment and the XLD contour have a part in
                     common?

    See Also
    --------
    intersection_segment_line, intersection_lines,
    intersection_line_contour_xld

    Alternatives
    ------------
    intersection_segments, intersection_contours_xld
    """
    with HalconOperator(1347) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, segment_row_1)
        proc.set_input_tuple(1, segment_column_1)
        proc.set_input_tuple(2, segment_row_2)
        proc.set_input_tuple(3, segment_column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_segment_contour_xld_s(
    contour: HObject,
    segment_row_1: Union[float, int],
    segment_column_1: Union[float, int],
    segment_row_2: Union[float, int],
    segment_column_2: Union[float, int]
) -> Tuple[float, float, int]:
    """
    Calculate the intersection points of a segment and an XLD contour

    Parameters
    ----------

    contour : HObject
              XLD contour.

    segment_row_1 : Union[float, int]
                    Row coordinate of the first point of the segment.

    segment_column_1 : Union[float, int]
                       Column coordinate of the first point of the segment.

    segment_row_2 : Union[float, int]
                    Row coordinate of the second point of the segment.

    segment_column_2 : Union[float, int]
                       Column coordinate of the second point of the
                       segment.

    Returns
    -------

    row : float
          Row coordinates of the intersection points.

    column : float
             Column coordinates of the intersection points.

    is_overlapping : int
                     Do the segment and the XLD contour have a part in
                     common?

    See Also
    --------
    intersection_segment_line, intersection_lines,
    intersection_line_contour_xld

    Alternatives
    ------------
    intersection_segments, intersection_contours_xld
    """
    with HalconOperator(1347) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, segment_row_1)
        proc.set_input_tuple(1, segment_column_1)
        proc.set_input_tuple(2, segment_row_2)
        proc.set_input_tuple(3, segment_column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_segment_line(
    segment_row_1: Union[float, int],
    segment_column_1: Union[float, int],
    segment_row_2: Union[float, int],
    segment_column_2: Union[float, int],
    line_row_1: Union[float, int],
    line_column_1: Union[float, int],
    line_row_2: Union[float, int],
    line_column_2: Union[float, int]
) -> Tuple[Sequence[float], Sequence[float], int]:
    """
    Calculate the intersection point of a segment and a line

    Parameters
    ----------

    segment_row_1 : Union[float, int]
                    Row coordinate of the first point of the segment.

    segment_column_1 : Union[float, int]
                       Column coordinate of the first point of the segment.

    segment_row_2 : Union[float, int]
                    Row coordinate of the second point of the segment.

    segment_column_2 : Union[float, int]
                       Column coordinate of the second point of the
                       segment.

    line_row_1 : Union[float, int]
                 Row coordinate of the first point of the line.

    line_column_1 : Union[float, int]
                    Column coordinate of the first point of the line.

    line_row_2 : Union[float, int]
                 Row coordinate of the second point of the line.

    line_column_2 : Union[float, int]
                    Column coordinate of the second point of the line.

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the intersection point.

    column : Sequence[float]
             Column coordinate of the intersection point.

    is_overlapping : int
                     Do the segment and the line have a part in common?

    See Also
    --------
    intersection_segments, intersection_lines,
    intersection_segment_contour_xld, intersection_contours_xld

    Alternatives
    ------------
    intersection_line_contour_xld
    """
    with HalconOperator(1349) as proc:
        proc.set_input_tuple(0, segment_row_1)
        proc.set_input_tuple(1, segment_column_1)
        proc.set_input_tuple(2, segment_row_2)
        proc.set_input_tuple(3, segment_column_2)
        proc.set_input_tuple(4, line_row_1)
        proc.set_input_tuple(5, line_column_1)
        proc.set_input_tuple(6, line_row_2)
        proc.set_input_tuple(7, line_column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_segment_line_s(
    segment_row_1: Union[float, int],
    segment_column_1: Union[float, int],
    segment_row_2: Union[float, int],
    segment_column_2: Union[float, int],
    line_row_1: Union[float, int],
    line_column_1: Union[float, int],
    line_row_2: Union[float, int],
    line_column_2: Union[float, int]
) -> Tuple[float, float, int]:
    """
    Calculate the intersection point of a segment and a line

    Parameters
    ----------

    segment_row_1 : Union[float, int]
                    Row coordinate of the first point of the segment.

    segment_column_1 : Union[float, int]
                       Column coordinate of the first point of the segment.

    segment_row_2 : Union[float, int]
                    Row coordinate of the second point of the segment.

    segment_column_2 : Union[float, int]
                       Column coordinate of the second point of the
                       segment.

    line_row_1 : Union[float, int]
                 Row coordinate of the first point of the line.

    line_column_1 : Union[float, int]
                    Column coordinate of the first point of the line.

    line_row_2 : Union[float, int]
                 Row coordinate of the second point of the line.

    line_column_2 : Union[float, int]
                    Column coordinate of the second point of the line.

    Returns
    -------

    row : float
          Row coordinate of the intersection point.

    column : float
             Column coordinate of the intersection point.

    is_overlapping : int
                     Do the segment and the line have a part in common?

    See Also
    --------
    intersection_segments, intersection_lines,
    intersection_segment_contour_xld, intersection_contours_xld

    Alternatives
    ------------
    intersection_line_contour_xld
    """
    with HalconOperator(1349) as proc:
        proc.set_input_tuple(0, segment_row_1)
        proc.set_input_tuple(1, segment_column_1)
        proc.set_input_tuple(2, segment_row_2)
        proc.set_input_tuple(3, segment_column_2)
        proc.set_input_tuple(4, line_row_1)
        proc.set_input_tuple(5, line_column_1)
        proc.set_input_tuple(6, line_row_2)
        proc.set_input_tuple(7, line_column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_segments(
    segment_1row_1: Union[float, int],
    segment_1column_1: Union[float, int],
    segment_1row_2: Union[float, int],
    segment_1column_2: Union[float, int],
    segment_2row_1: Union[float, int],
    segment_2column_1: Union[float, int],
    segment_2row_2: Union[float, int],
    segment_2column_2: Union[float, int]
) -> Tuple[Sequence[float], Sequence[float], int]:
    """
    Calculate the intersection point of two line segments

    Parameters
    ----------

    segment_1row_1 : Union[float, int]
                     Row coordinate of the first point  of the first
                     segment.

    segment_1column_1 : Union[float, int]
                        Column coordinate of the first point  of the first
                        segment.

    segment_1row_2 : Union[float, int]
                     Row coordinate of the second point  of the first
                     segment.

    segment_1column_2 : Union[float, int]
                        Column coordinate of the second point  of the
                        first segment.

    segment_2row_1 : Union[float, int]
                     Row coordinate of the first point  of the second
                     segment.

    segment_2column_1 : Union[float, int]
                        Column coordinate of the first point  of the
                        second segment.

    segment_2row_2 : Union[float, int]
                     Row coordinate of the second point  of the second
                     segment.

    segment_2column_2 : Union[float, int]
                        Column coordinate of the second point  of the
                        second segment.

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the intersection point.

    column : Sequence[float]
             Column coordinate of the intersection point.

    is_overlapping : int
                     Do both segments have a part in common?

    See Also
    --------
    intersection_segment_line, intersection_lines,
    intersection_line_contour_xld

    Alternatives
    ------------
    intersection_segment_contour_xld, intersection_contours_xld
    """
    with HalconOperator(1350) as proc:
        proc.set_input_tuple(0, segment_1row_1)
        proc.set_input_tuple(1, segment_1column_1)
        proc.set_input_tuple(2, segment_1row_2)
        proc.set_input_tuple(3, segment_1column_2)
        proc.set_input_tuple(4, segment_2row_1)
        proc.set_input_tuple(5, segment_2column_1)
        proc.set_input_tuple(6, segment_2row_2)
        proc.set_input_tuple(7, segment_2column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def intersection_segments_s(
    segment_1row_1: Union[float, int],
    segment_1column_1: Union[float, int],
    segment_1row_2: Union[float, int],
    segment_1column_2: Union[float, int],
    segment_2row_1: Union[float, int],
    segment_2column_1: Union[float, int],
    segment_2row_2: Union[float, int],
    segment_2column_2: Union[float, int]
) -> Tuple[float, float, int]:
    """
    Calculate the intersection point of two line segments

    Parameters
    ----------

    segment_1row_1 : Union[float, int]
                     Row coordinate of the first point  of the first
                     segment.

    segment_1column_1 : Union[float, int]
                        Column coordinate of the first point  of the first
                        segment.

    segment_1row_2 : Union[float, int]
                     Row coordinate of the second point  of the first
                     segment.

    segment_1column_2 : Union[float, int]
                        Column coordinate of the second point  of the
                        first segment.

    segment_2row_1 : Union[float, int]
                     Row coordinate of the first point  of the second
                     segment.

    segment_2column_1 : Union[float, int]
                        Column coordinate of the first point  of the
                        second segment.

    segment_2row_2 : Union[float, int]
                     Row coordinate of the second point  of the second
                     segment.

    segment_2column_2 : Union[float, int]
                        Column coordinate of the second point  of the
                        second segment.

    Returns
    -------

    row : float
          Row coordinate of the intersection point.

    column : float
             Column coordinate of the intersection point.

    is_overlapping : int
                     Do both segments have a part in common?

    See Also
    --------
    intersection_segment_line, intersection_lines,
    intersection_line_contour_xld

    Alternatives
    ------------
    intersection_segment_contour_xld, intersection_contours_xld
    """
    with HalconOperator(1350) as proc:
        proc.set_input_tuple(0, segment_1row_1)
        proc.set_input_tuple(1, segment_1column_1)
        proc.set_input_tuple(2, segment_1row_2)
        proc.set_input_tuple(3, segment_1column_2)
        proc.set_input_tuple(4, segment_2row_1)
        proc.set_input_tuple(5, segment_2column_1)
        proc.set_input_tuple(6, segment_2row_2)
        proc.set_input_tuple(7, segment_2column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # is_overlapping
        )  # type: ignore


def invert_funct_1d(
    function: Sequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Calculate the inverse of a function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    inverse_function : Sequence[Union[float, int]]
                       Inverse of the input function.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1378) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.execute()
        inverse_function = proc.get_output_tuple_m(0)
        return inverse_function  # type: ignore


def invert_image(image: HObject) -> HObject:
    """
    Invert an image.

    Parameters
    ----------

    image : HObject
            Input image(s).

    Returns
    -------

    image_invert : HObject
                   Image(s) with inverted gray values.

    See Also
    --------
    scale_image, add_image, sub_image

    Alternatives
    ------------
    scale_image

    Successors
    ----------
    watersheds
    """
    with HalconOperator(1614) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_invert = HObject(proc.get_output_object_key(1))
        return image_invert  # type: ignore


def invert_matrix(
    matrix_id: HHandle,
    matrix_type: str,
    epsilon: float
) -> HHandle:
    """
    Invert a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_type : str
                  The type of the input matrix.
                  Value Suggestion: general

    epsilon : float
              Type of inversion.
              Value Suggestion: 0.0

    Returns
    -------

    matrix_inv_id : HHandle
                    Matrix handle with the inverse matrix.

    See Also
    --------
    transpose_matrix, transpose_matrix_mod

    Alternatives
    ------------
    invert_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    For MatrixType = 'symmetric', 'positive_definite', or
    'upper_triangular' the upper triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly lower
    triangular part of the matrix is not referenced.  For MatrixType =
    'lower_triangular' the lower triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly upper
    triangular part of the matrix is not referenced.  For MatrixType =
    'tridiagonal', only the main diagonal, the superdiagonal, and the
    subdiagonal of the input Matrix are used.  The other parts of the
    matrix are not referenced.  If the referenced part of the input Matrix
    is not of the specified type, an exception is raised.
    """
    with HalconOperator(854) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_type)
        proc.set_input_tuple(2, epsilon)
        proc.init_oct(0)
        proc.execute()
        matrix_inv_id = proc.get_output_tuple_s(0)
        return matrix_inv_id  # type: ignore


def invert_matrix_mod(
    matrix_id: HHandle,
    matrix_type: str,
    epsilon: float
) -> None:
    """
    Invert a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_type : str
                  The type of the input matrix.
                  Value Suggestion: general

    epsilon : float
              Type of inversion.
              Value Suggestion: 0.0

    See Also
    --------
    transpose_matrix, transpose_matrix_mod

    Alternatives
    ------------
    invert_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    For MatrixType = 'symmetric', 'positive_definite', or
    'upper_triangular' the upper triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly lower
    triangular part of the matrix is not referenced.  For MatrixType =
    'lower_triangular' the lower triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly upper
    triangular part of the matrix is not referenced.  For MatrixType =
    'tridiagonal', only the main diagonal, the superdiagonal, and the
    subdiagonal of the input Matrix are used.  The other parts of the
    matrix are not referenced.  If the referenced part of the input Matrix
    is not of the specified type, an exception is raised.
    invert_matrix_mod modifies the content of an already existing matrix.
    """
    with HalconOperator(853) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_type)
        proc.set_input_tuple(2, epsilon)
        proc.execute()


def isotropic_diffusion(
    image: HObject,
    sigma: float,
    iterations: int
) -> HObject:
    """
    Perform an isotropic diffusion of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : float
            Standard deviation of the Gauss distribution.
            Value Suggestion: 1.0
            Assertion: Sigma > 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 0

    Returns
    -------

    smoothed_image : HObject
                     Output image.

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1405) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, iterations)
        proc.execute()
        smoothed_image = HObject(proc.get_output_object_key(1))
        return smoothed_image  # type: ignore


def junctions_skeleton(region: HObject) -> Tuple[HObject, HObject]:
    """
    Find junctions and end points in a skeleton.

    Parameters
    ----------

    region : HObject
             Input skeletons.

    Returns
    -------

    end_points : HObject
                 Extracted end points.

    junc_points : HObject
                  Extracted junctions.

    See Also
    --------
    pruning, split_skeleton_region

    Predecessors
    ------------
    skeleton

    Successors
    ----------
    area_center, connection, get_region_points, difference
    """
    with HalconOperator(492) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # end_points
            HObject(proc.get_output_object_key(2))   # junc_points
        )  # type: ignore


def kirsch_amp(image: HObject) -> HObject:
    """
    Detect edges (amplitude) using the Kirsch operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    sobel_amp, frei_amp, prewitt_amp, robinson_amp, roberts

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1555) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_edge_amp = HObject(proc.get_output_object_key(1))
        return image_edge_amp  # type: ignore


def kirsch_dir(image: HObject) -> Tuple[HObject, HObject]:
    """
    Detect edges (amplitude and direction) using the Kirsch operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    image_edge_dir : HObject
                     Edge direction image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    edges_image, sobel_dir, robinson_dir, prewitt_dir, frei_dir

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Successors
    ----------
    hysteresis_threshold, threshold, gray_skeleton,
    nonmax_suppression_dir, close_edges, close_edges_length

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1554) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_edge_amp
            HObject(proc.get_output_object_key(2))   # image_edge_dir
        )  # type: ignore


def label_to_region(label_image: HObject) -> HObject:
    """
    Extract regions with equal gray values from an image.

    Parameters
    ----------

    label_image : HObject
                  Label image.

    Returns
    -------

    regions : HObject
              Regions having a constant gray value.

    See Also
    --------
    threshold, concat_obj, regiongrowing, region_to_label

    Predecessors
    ------------
    min_max_gray, sobel_amp, binomial_filter, gauss_filter, reduce_domain,
    diff_of_gauss

    Successors
    ----------
    connection, dilation1, erosion1, opening, closing, rank_region,
    shape_trans, skeleton

    Notes
    -----
    label_to_region is not implemented for images of type 'real'.  The
    input images must not contain negative gray values.
    """
    with HalconOperator(445) as proc:
        proc.set_input_object(1, label_image)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def laplace(
    image: HObject,
    result_type: str,
    mask_size: MaybeSequence[int],
    filter_mask: str
) -> HObject:
    """
    Calculate the Laplace operator by using finite differences.

    Parameters
    ----------

    image : HObject
            Input image.

    result_type : str
                  Type of the result image, whereas for byte and uint2 the
                  absolute value is used.
                  Value Suggestion: absolute

    mask_size : MaybeSequence[int]
                Size of filter mask.
                Value Suggestion: 3

    filter_mask : str
                  Filter mask used in the Laplace operator
                  Value Suggestion: n_4

    Returns
    -------

    image_laplace : HObject
                    Laplace-filtered result image.

    See Also
    --------
    highpass_image, edges_image

    Alternatives
    ------------
    diff_of_gauss, laplace_of_gauss, derivate_gauss

    Successors
    ----------
    zero_crossing, dual_threshold, threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1563) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, result_type)
        proc.set_input_tuple(1, mask_size)
        proc.set_input_tuple(2, filter_mask)
        proc.execute()
        image_laplace = HObject(proc.get_output_object_key(1))
        return image_laplace  # type: ignore


def laplace_of_gauss(
    image: HObject,
    sigma: Union[float, int]
) -> HObject:
    """
    LoG-Operator (Laplace of Gaussian).

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : Union[float, int]
            Smoothing parameter of the Gaussian.
            Value Suggestion: 2.0
            Assertion: Sigma > 0.7 && Sigma <= 25.0

    Returns
    -------

    image_laplace : HObject
                    Laplace filtered image.

    See Also
    --------
    derivate_gauss

    Alternatives
    ------------
    laplace, diff_of_gauss, derivate_gauss

    Successors
    ----------
    zero_crossing, dual_threshold

    Notes
    -----
    Note that filter operators may return may return unexpected results if
    an image with a reduced domain is used as input. Please refer to the
    chapter Filters.
    """
    with HalconOperator(1571) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.execute()
        image_laplace = HObject(proc.get_output_object_key(1))
        return image_laplace  # type: ignore


def learn_class_box(
    classif_handle: HHandle,
    features: Sequence[Union[int, float, str]],
    class_val: int
) -> None:
    """
    Train the classifier.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    features : Sequence[Union[int, float, str]]
               Array of attributes to learn.
               Value Suggestion: [1.0,1.5,2.0]

    class_val : int
                Class to which the array has to be assigned.
                Value Suggestion: 1

    See Also
    --------
    test_sampset_box, close_class_box, create_class_box,
    enquire_class_box, learn_sampset_box

    Predecessors
    ------------
    create_class_box, enquire_class_box

    Successors
    ----------
    test_sampset_box, enquire_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    learn_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1891) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, class_val)
        proc.execute()


def learn_ndim_box(
    foreground: HObject,
    background: HObject,
    multi_channel_image: HObject,
    classif_handle: HHandle
) -> None:
    """
    Train a classificator using a multi-channel image.

    Parameters
    ----------

    foreground : HObject
                 Foreground pixels to be trained.

    background : HObject
                 Background pixels to be trained (rejection class).

    multi_channel_image : HObject
                          Multi-channel training image.

    classif_handle : HHandle
                     Handle of the classifier.

    Alternatives
    ------------
    learn_class_box, learn_ndim_norm

    Predecessors
    ------------
    create_class_box, draw_region

    Successors
    ----------
    class_ndim_box, descript_class_box

    Warnings
    --------
    learn_ndim_box is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    All channels must be of the same type.
    """
    with HalconOperator(438) as proc:
        proc.set_input_object(1, foreground)
        proc.set_input_object(2, background)
        proc.set_input_object(3, multi_channel_image)
        proc.set_input_tuple(0, classif_handle)
        proc.execute()


def learn_ndim_norm(
    foreground: HObject,
    background: HObject,
    image: HObject,
    metric: str,
    distance: Union[int, float],
    min_number_percent: Union[int, float]
) -> Tuple[Sequence[float], Sequence[float], float]:
    """
    Construct classes for class_ndim_norm.

    Parameters
    ----------

    foreground : HObject
                 Foreground pixels to be trained.

    background : HObject
                 Background pixels to be trained (rejection class).

    image : HObject
            Multi-channel training image.

    metric : str
             Metric to be used.
             Value Suggestion: euclid

    distance : Union[int, float]
               Maximum cluster radius.
               Value Suggestion: 10.0
               Assertion: Distance > 0.0

    min_number_percent : Union[int, float]
                         The ratio of the number of pixels in a cluster to
                         the total number of pixels (in percent) must be
                         larger than MinNumberPercent (otherwise the
                         cluster is not output).
                         Value Suggestion: 0.01
                         Assertion: 0 <= MinNumberPercent && MinNumberPercent <= 100

    Returns
    -------

    radius : Sequence[float]
             Cluster radii or half edge lengths.

    center : Sequence[float]
             Coordinates of all cluster centers.

    quality : float
              Overlap of the rejection class with the classified objects
              (1: no overlap).
              Assertion: 0 <= Quality && Quality <= 1

    See Also
    --------
    class_ndim_norm, histo_2dim

    Alternatives
    ------------
    learn_ndim_box, learn_class_box

    Predecessors
    ------------
    min_max_gray, sobel_amp, binomial_filter, gauss_filter, reduce_domain,
    diff_of_gauss

    Successors
    ----------
    class_ndim_norm, connection, dilation1, erosion1, opening, closing,
    rank_region, shape_trans, skeleton
    """
    with HalconOperator(437) as proc:
        proc.set_input_object(1, foreground)
        proc.set_input_object(2, background)
        proc.set_input_object(3, image)
        proc.set_input_tuple(0, metric)
        proc.set_input_tuple(1, distance)
        proc.set_input_tuple(2, min_number_percent)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # radius
            proc.get_output_tuple_m(1),  # center
            proc.get_output_tuple_s(2)   # quality
        )  # type: ignore


def learn_sampset_box(
    classif_handle: HHandle,
    samp_key: HHandle,
    outfile: str,
    nsamples: int,
    stop_error: float,
    error_n: int
) -> None:
    """
    Train the classifier with one data set.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    samp_key : HHandle
               Number of the data set to train.

    outfile : str
              Name of the protocol file.
              Value Suggestion: training_prot

    nsamples : int
               Number of arrays of attributes to learn.
               Value Suggestion: 500

    stop_error : float
                 Classification error for termination.
                 Value Suggestion: 0.05

    error_n : int
              Error during the assignment.
              Value Suggestion: 100

    See Also
    --------
    test_sampset_box, enquire_class_box, learn_class_box, read_sampset

    Predecessors
    ------------
    create_class_box

    Successors
    ----------
    test_sampset_box, enquire_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    learn_sampset_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1890) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, samp_key)
        proc.set_input_tuple(2, outfile)
        proc.set_input_tuple(3, nsamples)
        proc.set_input_tuple(4, stop_error)
        proc.set_input_tuple(5, error_n)
        proc.execute()


def length_xld(xld: HObject) -> Sequence[float]:
    """
    Length of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    length : Sequence[float]
             Length of the contour or polygon.
             Assertion: Length >= 0

    See Also
    --------
    area_center_xld, moments_any_xld, moments_xld, contlength

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1690) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_m(0)
        return length  # type: ignore


def length_xld_s(xld: HObject) -> float:
    """
    Length of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    length : float
             Length of the contour or polygon.
             Assertion: Length >= 0

    See Also
    --------
    area_center_xld, moments_any_xld, moments_xld, contlength

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1690) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_s(0)
        return length  # type: ignore


def line_orientation(
    row_begin: MaybeSequence[Union[int, float]],
    col_begin: MaybeSequence[Union[int, float]],
    row_end: MaybeSequence[Union[int, float]],
    col_end: MaybeSequence[Union[int, float]]
) -> Sequence[float]:
    """
    Calculate the orientation of lines.

    Parameters
    ----------

    row_begin : MaybeSequence[Union[int, float]]
                Row coordinates of the starting points of the input lines.

    col_begin : MaybeSequence[Union[int, float]]
                Column coordinates of the starting points of the input
                lines.

    row_end : MaybeSequence[Union[int, float]]
              Row coordinates of the ending points of the input lines.

    col_end : MaybeSequence[Union[int, float]]
              Column coordinates  of the ending points of the input lines.

    Returns
    -------

    phi : Sequence[float]
          Orientation of the input lines.

    See Also
    --------
    line_position, detect_edge_segments

    Alternatives
    ------------
    line_position

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line
    """
    with HalconOperator(1740) as proc:
        proc.set_input_tuple(0, row_begin)
        proc.set_input_tuple(1, col_begin)
        proc.set_input_tuple(2, row_end)
        proc.set_input_tuple(3, col_end)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_m(0)
        return phi  # type: ignore


def line_orientation_s(
    row_begin: MaybeSequence[Union[int, float]],
    col_begin: MaybeSequence[Union[int, float]],
    row_end: MaybeSequence[Union[int, float]],
    col_end: MaybeSequence[Union[int, float]]
) -> float:
    """
    Calculate the orientation of lines.

    Parameters
    ----------

    row_begin : MaybeSequence[Union[int, float]]
                Row coordinates of the starting points of the input lines.

    col_begin : MaybeSequence[Union[int, float]]
                Column coordinates of the starting points of the input
                lines.

    row_end : MaybeSequence[Union[int, float]]
              Row coordinates of the ending points of the input lines.

    col_end : MaybeSequence[Union[int, float]]
              Column coordinates  of the ending points of the input lines.

    Returns
    -------

    phi : float
          Orientation of the input lines.

    See Also
    --------
    line_position, detect_edge_segments

    Alternatives
    ------------
    line_position

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line
    """
    with HalconOperator(1740) as proc:
        proc.set_input_tuple(0, row_begin)
        proc.set_input_tuple(1, col_begin)
        proc.set_input_tuple(2, row_end)
        proc.set_input_tuple(3, col_end)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_s(0)
        return phi  # type: ignore


def line_position(
    row_begin: MaybeSequence[Union[int, float]],
    col_begin: MaybeSequence[Union[int, float]],
    row_end: MaybeSequence[Union[int, float]],
    col_end: MaybeSequence[Union[int, float]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the center of gravity, length, and orientation of a line.

    Parameters
    ----------

    row_begin : MaybeSequence[Union[int, float]]
                Row coordinates of the starting points of the input lines.

    col_begin : MaybeSequence[Union[int, float]]
                Column coordinates of the starting points of the input
                lines.

    row_end : MaybeSequence[Union[int, float]]
              Row coordinates of the ending points of the input lines.

    col_end : MaybeSequence[Union[int, float]]
              Column coordinates  of the ending points of the input lines.

    Returns
    -------

    row_center : Sequence[float]
                 Row coordinates of the centers of gravity of the input
                 lines.

    col_center : Sequence[float]
                 Column coordinates of the centers of gravity of the input
                 lines.

    length : Sequence[float]
             Euclidean length of the input lines.

    phi : Sequence[float]
          Orientation of the input lines.

    See Also
    --------
    line_orientation, detect_edge_segments

    Alternatives
    ------------
    line_orientation

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line
    """
    with HalconOperator(1739) as proc:
        proc.set_input_tuple(0, row_begin)
        proc.set_input_tuple(1, col_begin)
        proc.set_input_tuple(2, row_end)
        proc.set_input_tuple(3, col_end)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_center
            proc.get_output_tuple_m(1),  # col_center
            proc.get_output_tuple_m(2),  # length
            proc.get_output_tuple_m(3)   # phi
        )  # type: ignore


def line_position_s(
    row_begin: MaybeSequence[Union[int, float]],
    col_begin: MaybeSequence[Union[int, float]],
    row_end: MaybeSequence[Union[int, float]],
    col_end: MaybeSequence[Union[int, float]]
) -> Tuple[float, float, float, float]:
    """
    Calculate the center of gravity, length, and orientation of a line.

    Parameters
    ----------

    row_begin : MaybeSequence[Union[int, float]]
                Row coordinates of the starting points of the input lines.

    col_begin : MaybeSequence[Union[int, float]]
                Column coordinates of the starting points of the input
                lines.

    row_end : MaybeSequence[Union[int, float]]
              Row coordinates of the ending points of the input lines.

    col_end : MaybeSequence[Union[int, float]]
              Column coordinates  of the ending points of the input lines.

    Returns
    -------

    row_center : float
                 Row coordinates of the centers of gravity of the input
                 lines.

    col_center : float
                 Column coordinates of the centers of gravity of the input
                 lines.

    length : float
             Euclidean length of the input lines.

    phi : float
          Orientation of the input lines.

    See Also
    --------
    line_orientation, detect_edge_segments

    Alternatives
    ------------
    line_orientation

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line
    """
    with HalconOperator(1739) as proc:
        proc.set_input_tuple(0, row_begin)
        proc.set_input_tuple(1, col_begin)
        proc.set_input_tuple(2, row_end)
        proc.set_input_tuple(3, col_end)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_center
            proc.get_output_tuple_s(1),  # col_center
            proc.get_output_tuple_s(2),  # length
            proc.get_output_tuple_s(3)   # phi
        )  # type: ignore


def linear_trans_color(
    image: HObject,
    trans_mat: Sequence[float]
) -> HObject:
    """
    Compute an affine transformation of the color values of a multichannel
    image.

    Parameters
    ----------

    image : HObject
            Multichannel input image.

    trans_mat : Sequence[float]
                Transformation matrix for the color values.

    Returns
    -------

    image_trans : HObject
                  Multichannel output image.

    Alternatives
    ------------
    principal_comp, trans_from_rgb, trans_to_rgb

    Predecessors
    ------------
    gen_principal_comp_trans

    Successors
    ----------
    convert_image_type

    Notes
    -----
    linear_trans_color can be executed on OpenCL devices if the image
    Image consists of nine channels or less and is transformed to an image
    of three channels or less. Since the calculations are done in  single
    precision floating point, the results may differ from those
    calculated by the CPU.
    """
    with HalconOperator(1454) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, trans_mat)
        proc.execute()
        image_trans = HObject(proc.get_output_object_key(1))
        return image_trans  # type: ignore


def lines_color(
    image: HObject,
    sigma: Union[float, int],
    low: Union[float, int],
    high: Union[float, int],
    extract_width: str,
    complete_junctions: str
) -> HObject:
    """
    Detect color lines and their width.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : Union[float, int]
            Amount of Gaussian smoothing to be applied.
            Value Suggestion: 1.5

    low : Union[float, int]
          Lower threshold for the hysteresis threshold operation.
          Value Suggestion: 3
          Assertion: Low >= 0

    high : Union[float, int]
           Upper threshold for the hysteresis threshold operation.
           Value Suggestion: 8
           Assertion: High >= 0 && High >= Low

    extract_width : str
                    Should the line width be extracted?
                    Value Suggestion: true

    complete_junctions : str
                         Should junctions be added where they cannot be
                         extracted?
                         Value Suggestion: true

    Returns
    -------

    lines : HObject
            Extracted lines.

    See Also
    --------
    edges_color, edges_color_sub_pix

    Alternatives
    ------------
    lines_gauss, lines_facet

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    In general, but in particular if the line width is to be extracted,
    $Sigma - w/3$Sigma >= w/sqrt(3) should be selected, where $w$ is the
    width (half the diameter) of the lines in the image.  As the lowest
    allowable value $Sigma - w/2.5$Sigma >= w/2.5 must be selected.  If,
    for example, lines with a width of 4~pixels (diameter 8~pixels) are to
    be extracted, $Sigma - 2.3$Sigma >= 2.3 should be selected.  If it is
    expected that staircase lines are present in at least one channel, and
    if such lines should be extracted, in addition to the above
    restriction, $Sigma - w$Sigma <= w should be selected.  This is
    necessary because staircase lines turn into normal step edges for
    large amounts of smoothing, and therefore no longer appear as dark
    lines in the amplitude image of the color edge filter.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1511) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, low)
        proc.set_input_tuple(2, high)
        proc.set_input_tuple(3, extract_width)
        proc.set_input_tuple(4, complete_junctions)
        proc.execute()
        lines = HObject(proc.get_output_object_key(1))
        return lines  # type: ignore


def lines_facet(
    image: HObject,
    mask_size: int,
    low: Union[float, int],
    high: Union[float, int],
    light_dark: str
) -> HObject:
    """
    Detection of lines using the facet model.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_size : int
                Size of the facet model mask.
                Value Suggestion: 5

    low : Union[float, int]
          Lower threshold for the hysteresis threshold operation.
          Value Suggestion: 3
          Assertion: Low >= 0

    high : Union[float, int]
           Upper threshold for the hysteresis threshold operation.
           Value Suggestion: 8
           Assertion: High >= 0 && High >= Low

    light_dark : str
                 Extract bright or dark lines.
                 Value Suggestion: light

    Returns
    -------

    lines : HObject
            Extracted lines.

    See Also
    --------
    bandpass_image, dyn_threshold, topographic_sketch

    Alternatives
    ------------
    lines_gauss

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    The smaller the filter size MaskSize is chosen, the more short,
    fragmented lines will be extracted.  This can lead to considerably
    longer execution times.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1513) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_size)
        proc.set_input_tuple(1, low)
        proc.set_input_tuple(2, high)
        proc.set_input_tuple(3, light_dark)
        proc.execute()
        lines = HObject(proc.get_output_object_key(1))
        return lines  # type: ignore


def lines_gauss(
    image: HObject,
    sigma: Union[float, int],
    low: Union[float, int],
    high: Union[float, int],
    light_dark: str,
    extract_width: str,
    line_model: str,
    complete_junctions: str
) -> HObject:
    """
    Detect lines and their width.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : Union[float, int]
            Amount of Gaussian smoothing to be applied.
            Value Suggestion: 1.5

    low : Union[float, int]
          Lower threshold for the hysteresis threshold operation.
          Value Suggestion: 3
          Assertion: Low >= 0

    high : Union[float, int]
           Upper threshold for the hysteresis threshold operation.
           Value Suggestion: 8
           Assertion: High >= 0 && High >= Low

    light_dark : str
                 Extract bright or dark lines.
                 Value Suggestion: light

    extract_width : str
                    Should the line width be extracted?
                    Value Suggestion: true

    line_model : str
                 Line model used to correct the line position and width.
                 Value Suggestion: bar-shaped

    complete_junctions : str
                         Should junctions be added where they cannot be
                         extracted?
                         Value Suggestion: true

    Returns
    -------

    lines : HObject
            Extracted lines.

    See Also
    --------
    bandpass_image, dyn_threshold, topographic_sketch

    Alternatives
    ------------
    lines_facet

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    In general, but in particular if the line width is to be extracted,
    $Sigma - w/3$Sigma >= w/sqrt(3) should be selected, where $w$ is the
    width (half the diameter) of the lines in the image.  As the lowest
    allowable value $Sigma - w/2.5$Sigma >= w/2.5 must be selected.  If,
    for example, lines with a width of 4~pixels (diameter 8~pixels) are to
    be extracted, $Sigma - 2.3$Sigma >= 2.3 should be selected.  Note that
    the attributes 'width_left', 'width_right', 'asymmetry', and
    'contrast' are set to zero if Sigma is set too low.
    lines_gauss uses a special implementation that is optimized using SSE2
    instructions if the system parameter 'sse2_enable' is set to 'true'
    (which is default if SSE2 is available on your machine).  This
    implementation is slightly inaccurate compared to the pure C version
    due to numerical issues.  If you prefer accuracy over performance you
    can set 'sse2_enable' to 'false' (using set_system) before you call
    lines_gauss.  This way lines_gauss does not use SSE2 accelerations.
    Don't forget to set 'sse2_enable' back to 'true' afterwards.
    When lines_gauss is run on OpenCL devices, the same limitations apply
    as for derivate_gauss: Sigma must be chosen so that the required
    filter mask is smaller than 129 pixels. Also note that the results can
    vary compared to the CPU implementation.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1512) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, low)
        proc.set_input_tuple(2, high)
        proc.set_input_tuple(3, light_dark)
        proc.set_input_tuple(4, extract_width)
        proc.set_input_tuple(5, line_model)
        proc.set_input_tuple(6, complete_junctions)
        proc.execute()
        lines = HObject(proc.get_output_object_key(1))
        return lines  # type: ignore


def list_files(
    directory: str,
    options: MaybeSequence[str]
) -> Sequence[str]:
    """
    List all files in a directory.

    Parameters
    ----------

    directory : str
                Name of directory to be listed.

    options : MaybeSequence[str]
              Processing options.
              Value Suggestion: files

    Returns
    -------

    files : Sequence[str]
            Found files (and directories).

    Successors
    ----------
    tuple_regexp_select
    """
    with HalconOperator(1643) as proc:
        proc.set_input_tuple(0, directory)
        proc.set_input_tuple(1, options)
        proc.init_oct(0)
        proc.execute()
        files = proc.get_output_tuple_m(0)
        return files  # type: ignore


def local_max(image: HObject) -> HObject:
    """
    Detect all local maxima in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    local_maxima : HObject
                   Extracted local maxima as a region.

    See Also
    --------
    monotony, topographic_sketch, corner_response, texture_laws

    Alternatives
    ------------
    nonmax_suppression_amp, plateaus, plateaus_center

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image

    Successors
    ----------
    get_region_points, connection
    """
    with HalconOperator(468) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        local_maxima = HObject(proc.get_output_object_key(1))
        return local_maxima  # type: ignore


def local_max_contours_xld(
    contours: HObject,
    image: HObject,
    min_percent: Union[int, float],
    min_diff: int,
    distance: int
) -> HObject:
    """
    Select XLD contours with a local maximum of gray values.

    Parameters
    ----------

    contours : HObject
               XLD contours to be examined.

    image : HObject
            Corresponding gray value image.

    min_percent : Union[int, float]
                  Minimum percentage of maximum points.
                  Value Suggestion: 70
                  Assertion: 0.0 <= MinPercent && MinPercent <= 100.0

    min_diff : int
               Minimum amount by which the gray value at the maximum must
               be larger than in the profile.
               Value Suggestion: 15
               Assertion: 0 <= MinDiff && MinDiff <= 255

    distance : int
               Maximum width of profile used to check for maxima.
               Value Suggestion: 4
               Assertion: Distance >= 1

    Returns
    -------

    local_max_contours : HObject
                         Selected contours.

    See Also
    --------
    smooth_contours_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    gen_polygons_xld
    """
    with HalconOperator(53) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, min_percent)
        proc.set_input_tuple(1, min_diff)
        proc.set_input_tuple(2, distance)
        proc.execute()
        local_max_contours = HObject(proc.get_output_object_key(1))
        return local_max_contours  # type: ignore


def local_max_sub_pix(
    image: HObject,
    filter: str,
    sigma: float,
    threshold: float
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Subpixel precise detection of local maxima in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Method for the calculation of the partial derivatives.
             Value Suggestion: facet

    sigma : float
            Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0
            to avoid the smoothing of the input image.
            Assertion: Sigma >= 0.0

    threshold : float
                Minimum absolute value of the eigenvalues of the Hessian
                matrix.
                Value Suggestion: 5.0
                Assertion: Threshold >= 0.0

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the detected maxima.

    column : Sequence[float]
             Column coordinates of the detected maxima.

    See Also
    --------
    local_max, plateaus, plateaus_center

    Alternatives
    ------------
    critical_points_sub_pix, local_min_sub_pix, saddle_points_sub_pix

    Successors
    ----------
    gen_cross_contour_xld, disp_cross

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1432) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def local_min(image: HObject) -> HObject:
    """
    Detect all local minima in an image.

    Parameters
    ----------

    image : HObject
            Image to be processed.

    Returns
    -------

    local_minima : HObject
                   Extracted local minima as regions.

    See Also
    --------
    monotony, topographic_sketch, corner_response, texture_laws

    Alternatives
    ------------
    gray_skeleton, lowlands, lowlands_center

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image

    Successors
    ----------
    get_region_points, connection
    """
    with HalconOperator(465) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        local_minima = HObject(proc.get_output_object_key(1))
        return local_minima  # type: ignore


def local_min_max_funct_1d(
    function: Sequence[Union[float, int]],
    mode: str,
    interpolation: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the local minimum and maximum points of a function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function

    mode : str
           Handling of plateaus
           Value Suggestion: strict_min_max

    interpolation : str
                    Interpolation of the input function
                    Value Suggestion: true

    Returns
    -------

    min : Sequence[float]
          Minimum points of the input function

    max : Sequence[float]
          Maximum points of the input function

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array, smooth_funct_1d_gauss,
    smooth_funct_1d_mean
    """
    with HalconOperator(1380) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, mode)
        proc.set_input_tuple(2, interpolation)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # min
            proc.get_output_tuple_m(1)   # max
        )  # type: ignore


def local_min_sub_pix(
    image: HObject,
    filter: str,
    sigma: float,
    threshold: float
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Subpixel precise detection of local minima in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Method for the calculation of the partial derivatives.
             Value Suggestion: facet

    sigma : float
            Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0
            to avoid the smoothing of the input image.
            Assertion: Sigma >= 0.0

    threshold : float
                Minimum absolute value of the eigenvalues of the Hessian
                matrix.
                Value Suggestion: 5.0
                Assertion: Threshold >= 0.0

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the detected minima.

    column : Sequence[float]
             Column coordinates of the detected minima.

    See Also
    --------
    local_min, lowlands, lowlands_center

    Alternatives
    ------------
    critical_points_sub_pix, local_max_sub_pix, saddle_points_sub_pix

    Successors
    ----------
    gen_cross_contour_xld, disp_cross

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1431) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def local_threshold(
    image: HObject,
    method: str,
    light_dark: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Segment an image using local thresholding.

    Parameters
    ----------

    image : HObject
            Input Image.

    method : str
             Segmentation method.
             Value Suggestion: adapted_std_deviation

    light_dark : str
                 Extract foreground or background?
                 Value Suggestion: dark

    gen_param_name : MaybeSequence[str]
                     List of generic parameter names.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float]]
                      List of generic parameter values.
                      Value Suggestion: []

    Returns
    -------

    region : HObject
             Segmented output region.

    See Also
    --------
    gray_histo, threshold

    Alternatives
    ------------
    auto_threshold, binary_threshold, char_threshold

    Successors
    ----------
    connection, select_shape, select_gray
    """
    with HalconOperator(450) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, light_dark)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def lock_mutex(mutex_handle: HHandle) -> None:
    """
    Lock a mutex synchronization object.

    Parameters
    ----------

    mutex_handle : HHandle
                   Mutex synchronization object.

    See Also
    --------
    try_lock_mutex

    Predecessors
    ------------
    create_mutex

    Successors
    ----------
    unlock_mutex
    """
    with HalconOperator(563) as proc:
        proc.set_input_tuple(0, mutex_handle)
        proc.execute()


def log_image(image: HObject, base: Union[int, float, str]) -> HObject:
    """
    Calculate the logarithm of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    base : Union[int, float, str]
           Base of the logarithm.
           Value Suggestion: e

    Returns
    -------

    log_image : HObject
                Output image.

    See Also
    --------
    pow_image, exp_image

    Notes
    -----
    log_image can be executed on an OpenCL device for byte, int1, int2,
    uint2, int4, and real images. Note that the results of the OpenCL code
    may vary from the results produced by the CPU.
    """
    with HalconOperator(1596) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, base)
        proc.execute()
        log_image = HObject(proc.get_output_object_key(1))
        return log_image  # type: ignore


def lookup_lexicon(lexicon_handle: HHandle, word: str) -> int:
    """
    Check if a word is contained in a lexicon.

    Parameters
    ----------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    word : str
           Word to be looked up.
           Value Suggestion: 'word'

    Returns
    -------

    found : int
            Result of the search.

    See Also
    --------
    create_lexicon

    Alternatives
    ------------
    suggest_lexicon
    """
    with HalconOperator(668) as proc:
        proc.set_input_tuple(0, lexicon_handle)
        proc.set_input_tuple(1, word)
        proc.init_oct(0)
        proc.execute()
        found = proc.get_output_tuple_s(0)
        return found  # type: ignore


def lowlands(image: HObject) -> HObject:
    """
    Detect all gray value lowlands.

    Parameters
    ----------

    image : HObject
            Image to be processed.

    Returns
    -------

    lowlands : HObject
               Extracted lowlands as regions (one region for each lowland).

    See Also
    --------
    monotony, topographic_sketch, corner_response, texture_laws

    Alternatives
    ------------
    lowlands_center, gray_skeleton, local_min

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image

    Successors
    ----------
    area_center, get_region_points, select_shape
    """
    with HalconOperator(466) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        lowlands = HObject(proc.get_output_object_key(1))
        return lowlands  # type: ignore


def lowlands_center(image: HObject) -> HObject:
    """
    Detect the centers of all gray value lowlands.

    Parameters
    ----------

    image : HObject
            Image to be processed.

    Returns
    -------

    lowlands : HObject
               Centers of gravity of the extracted lowlands as regions
               (one region for each lowland).

    See Also
    --------
    monotony, topographic_sketch, corner_response, texture_laws

    Alternatives
    ------------
    lowlands, gray_skeleton, local_min

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image

    Successors
    ----------
    area_center, get_region_points, select_shape
    """
    with HalconOperator(467) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        lowlands = HObject(proc.get_output_object_key(1))
        return lowlands  # type: ignore


def lut_trans(image: HObject, lut: Sequence[int]) -> HObject:
    """
    Transform an image with a gray-value look-up-table

    Parameters
    ----------

    image : HObject
            Image whose gray values are to be transformed.

    lut : Sequence[int]
          Table containing the transformation.

    Returns
    -------

    image_result : HObject
                   Transformed image.

    Notes
    -----
    lut_trans can be executed on OpenCL devices.
    """
    with HalconOperator(1469) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, lut)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def make_dir(dir_name: str) -> None:
    """
    Make a directory.

    Parameters
    ----------

    dir_name : str
               Name of directory to be created.
    """
    with HalconOperator(1642) as proc:
        proc.set_input_tuple(0, dir_name)
        proc.execute()


def map_image(image: HObject, map: HObject) -> HObject:
    """
    Apply a general transformation to an image.

    Parameters
    ----------

    image : HObject
            Image to be mapped.

    map : HObject
          Image containing the mapping data.

    Returns
    -------

    image_mapped : HObject
                   Mapped image.

    See Also
    --------
    affine_trans_image, rotate_image

    Predecessors
    ------------
    gen_image_to_world_plane_map, gen_radial_distortion_map,
    convert_map_type

    Notes
    -----
    The weights must be chosen in a way that the range of values of the
    output image ImageMapped is not exceeded.
    For runtime reasons during the mapping process, it is not checked
    whether the linearized coordinates which are stored in the first
    channel of Map, lie inside  the input image. Thus, it must be ensured
    by the user that this constraint is fulfilled. Otherwise, the program
    may crash!
    map_image is parallelized automatically if and only if Map uses
    bilinear interpolation. map_image is executed on an OpenCL compute
    device only if the input map is of type 'coord_map_sub_pix' and if the
    input image does not exceed the maximum size of image objects of the
    selected device.
    """
    with HalconOperator(1911) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, map)
        proc.execute()
        image_mapped = HObject(proc.get_output_object_key(1))
        return image_mapped  # type: ignore


def match_essential_matrix_ransac(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cam_mat_1: Sequence[Union[float, int]],
    cam_mat_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[int], Sequence[int]]:
    """
    Compute the essential matrix for a pair of stereo images by
    automatically finding correspondences between image points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 3

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.
             Assertion: length(Rows2) >= 6 || length(Rows2) >= 3

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.
             Assertion: length(Cols2) == length(Rows2)

    cam_mat_1 : Sequence[Union[float, int]]
                Camera matrix of the 1st camera.

    cam_mat_2 : Sequence[Union[float, int]]
                Camera matrix of the 2nd camera.

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate shift of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate shift of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative orientation of the right image
               with respect to the left image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Algorithm for the computation of the essential
                        matrix and for special camera orientations.
                        Value Suggestion: normalized_dlt

    distance_threshold : Union[float, int]
                         Maximal deviation of a point from its epipolar
                         line.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    ematrix : Sequence[float]
              Computed essential matrix.

    cov_emat : Sequence[float]
               $9- covariance matrix of the essential matrix.

    error : Sequence[float]
            Root-Mean-Square of the epipolar distance error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    match_fundamental_matrix_ransac, match_rel_pose_ransac,
    stationary_camera_self_calibration

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_essential_matrix
    """
    with HalconOperator(360) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cam_mat_1)
        proc.set_input_tuple(5, cam_mat_2)
        proc.set_input_tuple(6, gray_match_method)
        proc.set_input_tuple(7, mask_size)
        proc.set_input_tuple(8, row_move)
        proc.set_input_tuple(9, col_move)
        proc.set_input_tuple(10, row_tolerance)
        proc.set_input_tuple(11, col_tolerance)
        proc.set_input_tuple(12, rotation)
        proc.set_input_tuple(13, match_threshold)
        proc.set_input_tuple(14, estimation_method)
        proc.set_input_tuple(15, distance_threshold)
        proc.set_input_tuple(16, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ematrix
            proc.get_output_tuple_m(1),  # cov_emat
            proc.get_output_tuple_m(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def match_essential_matrix_ransac_s(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cam_mat_1: Sequence[Union[float, int]],
    cam_mat_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[float], Sequence[float], float, Sequence[int], Sequence[int]]:
    """
    Compute the essential matrix for a pair of stereo images by
    automatically finding correspondences between image points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 3

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.
             Assertion: length(Rows2) >= 6 || length(Rows2) >= 3

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.
             Assertion: length(Cols2) == length(Rows2)

    cam_mat_1 : Sequence[Union[float, int]]
                Camera matrix of the 1st camera.

    cam_mat_2 : Sequence[Union[float, int]]
                Camera matrix of the 2nd camera.

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate shift of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate shift of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative orientation of the right image
               with respect to the left image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Algorithm for the computation of the essential
                        matrix and for special camera orientations.
                        Value Suggestion: normalized_dlt

    distance_threshold : Union[float, int]
                         Maximal deviation of a point from its epipolar
                         line.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    ematrix : Sequence[float]
              Computed essential matrix.

    cov_emat : Sequence[float]
               $9- covariance matrix of the essential matrix.

    error : float
            Root-Mean-Square of the epipolar distance error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    match_fundamental_matrix_ransac, match_rel_pose_ransac,
    stationary_camera_self_calibration

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_essential_matrix
    """
    with HalconOperator(360) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cam_mat_1)
        proc.set_input_tuple(5, cam_mat_2)
        proc.set_input_tuple(6, gray_match_method)
        proc.set_input_tuple(7, mask_size)
        proc.set_input_tuple(8, row_move)
        proc.set_input_tuple(9, col_move)
        proc.set_input_tuple(10, row_tolerance)
        proc.set_input_tuple(11, col_tolerance)
        proc.set_input_tuple(12, rotation)
        proc.set_input_tuple(13, match_threshold)
        proc.set_input_tuple(14, estimation_method)
        proc.set_input_tuple(15, distance_threshold)
        proc.set_input_tuple(16, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ematrix
            proc.get_output_tuple_m(1),  # cov_emat
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def match_funct_1d_trans(
    function_1: Sequence[Union[float, int]],
    function_2: Sequence[Union[float, int]],
    border: str,
    params_const: Sequence[float],
    use_params: Sequence[str]
) -> Tuple[Sequence[float], float, Sequence[float]]:
    """
    Calculate transformation parameters between two functions.

    Parameters
    ----------

    function_1 : Sequence[Union[float, int]]
                 Function 1.

    function_2 : Sequence[Union[float, int]]
                 Function 2.

    border : str
             Border treatment for function 2.
             Value Suggestion: constant

    params_const : Sequence[float]
                   Values of the parameters to remain constant.
                   Value Suggestion: [1.0,0.0,1.0,0.0]

    use_params : Sequence[str]
                 Should a parameter be adapted for it?
                 Value Suggestion: ['true','true','true','true']

    Returns
    -------

    params : Sequence[float]
             Transformation parameters between the functions.

    chi_square : float
                 Quadratic error of the output function.

    covar : Sequence[float]
            Covariance Matrix of the transformation parameters.

    See Also
    --------
    gray_projections

    Predecessors
    ------------
    create_funct_1d_array, create_funct_1d_pairs
    """
    with HalconOperator(1393) as proc:
        proc.set_input_tuple(0, function_1)
        proc.set_input_tuple(1, function_2)
        proc.set_input_tuple(2, border)
        proc.set_input_tuple(3, params_const)
        proc.set_input_tuple(4, use_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # params
            proc.get_output_tuple_s(1),  # chi_square
            proc.get_output_tuple_m(2)   # covar
        )  # type: ignore


def match_fundamental_matrix_distortion_ransac(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[float], float, float, Sequence[int], Sequence[int]]:
    """
    Compute the fundamental matrix and the radial distortion coefficient
    for a pair of stereo images by automatically finding correspondences
    between image points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 9 || length(Rows1) >= 4

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) >= 9 || length(Rows2) >= 4

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows2)

    gray_match_method : str
                        Gray value match metric.
                        Value Suggestion: ncc

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate offset of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate offset of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative rotation of the second image with
               respect to the first image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 0.7

    estimation_method : str
                        Algorithm for the computation of the fundamental
                        matrix and for special camera orientations.
                        Value Suggestion: gold_standard

    distance_threshold : Union[float, int]
                         Maximal deviation of a point from its epipolar
                         line.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    fmatrix : Sequence[float]
              Computed fundamental matrix.

    kappa : float
            Computed radial distortion coefficient.

    error : float
            Root-Mean-Square epipolar distance error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    match_fundamental_matrix_ransac, match_essential_matrix_ransac,
    match_rel_pose_ransac, proj_match_points_ransac, calibrate_cameras

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_fundamental_matrix_distortion,
    change_radial_distortion_cam_par, change_radial_distortion_image,
    change_radial_distortion_points, gen_binocular_proj_rectification
    """
    with HalconOperator(358) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, gray_match_method)
        proc.set_input_tuple(5, mask_size)
        proc.set_input_tuple(6, row_move)
        proc.set_input_tuple(7, col_move)
        proc.set_input_tuple(8, row_tolerance)
        proc.set_input_tuple(9, col_tolerance)
        proc.set_input_tuple(10, rotation)
        proc.set_input_tuple(11, match_threshold)
        proc.set_input_tuple(12, estimation_method)
        proc.set_input_tuple(13, distance_threshold)
        proc.set_input_tuple(14, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # fmatrix
            proc.get_output_tuple_s(1),  # kappa
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def match_fundamental_matrix_ransac(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[float], Sequence[float], float, Sequence[int], Sequence[int]]:
    """
    Compute the fundamental matrix for a pair of stereo images by
    automatically finding correspondences between image points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.
             Assertion: length(Rows1) >= 8 || length(Rows1) >= 3

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.
             Assertion: length(Rows2) >= 8 || length(Rows2) >= 3

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.
             Assertion: length(Cols2) == length(Rows2)

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate shift of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate shift of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative orientation of the right image
               with respect to the left image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Algorithm for the computation of the fundamental
                        matrix and for special camera orientations.
                        Value Suggestion: normalized_dlt

    distance_threshold : Union[float, int]
                         Maximal deviation of a point from its epipolar
                         line.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    fmatrix : Sequence[float]
              Computed fundamental matrix.

    cov_fmat : Sequence[float]
               $9- covariance matrix of the fundamental matrix.

    error : float
            Root-Mean-Square of the epipolar distance error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    match_essential_matrix_ransac, match_rel_pose_ransac,
    proj_match_points_ransac

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_fundamental_matrix, gen_binocular_proj_rectification
    """
    with HalconOperator(361) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, gray_match_method)
        proc.set_input_tuple(5, mask_size)
        proc.set_input_tuple(6, row_move)
        proc.set_input_tuple(7, col_move)
        proc.set_input_tuple(8, row_tolerance)
        proc.set_input_tuple(9, col_tolerance)
        proc.set_input_tuple(10, rotation)
        proc.set_input_tuple(11, match_threshold)
        proc.set_input_tuple(12, estimation_method)
        proc.set_input_tuple(13, distance_threshold)
        proc.set_input_tuple(14, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # fmatrix
            proc.get_output_tuple_m(1),  # cov_fmat
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def match_rel_pose_ransac(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cam_par_1: Sequence[Union[float, int, str]],
    cam_par_2: Sequence[Union[float, int, str]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[Union[int, float]], Sequence[float], Sequence[float], Sequence[int], Sequence[int]]:
    """
    Compute the relative orientation between two cameras by automatically
    finding correspondences between image points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 3

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.
             Assertion: length(Rows2) >= 6 || length(Rows2) >= 3

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.
             Assertion: length(Cols2) == length(Rows2)

    cam_par_1 : Sequence[Union[float, int, str]]
                Parameters of the 1st camera.

    cam_par_2 : Sequence[Union[float, int, str]]
                Parameters of the 2nd camera.

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate shift of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate shift of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative orientation of the right image
               with respect to the left image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Algorithm for the computation of the relative pose
                        and for special pose types.
                        Value Suggestion: normalized_dlt

    distance_threshold : Union[float, int]
                         Maximal deviation of a point from its epipolar
                         line.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    rel_pose : Sequence[Union[int, float]]
               Computed relative orientation of the cameras (3D pose).

    cov_rel_pose : Sequence[float]
                   $6- covariance matrix of the relative orientation.

    error : Sequence[float]
            Root-Mean-Square of the epipolar distance error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    binocular_calibration, match_fundamental_matrix_ransac,
    match_essential_matrix_ransac, create_pose

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_rel_pose, gen_binocular_rectification_map
    """
    with HalconOperator(359) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cam_par_1)
        proc.set_input_tuple(5, cam_par_2)
        proc.set_input_tuple(6, gray_match_method)
        proc.set_input_tuple(7, mask_size)
        proc.set_input_tuple(8, row_move)
        proc.set_input_tuple(9, col_move)
        proc.set_input_tuple(10, row_tolerance)
        proc.set_input_tuple(11, col_tolerance)
        proc.set_input_tuple(12, rotation)
        proc.set_input_tuple(13, match_threshold)
        proc.set_input_tuple(14, estimation_method)
        proc.set_input_tuple(15, distance_threshold)
        proc.set_input_tuple(16, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rel_pose
            proc.get_output_tuple_m(1),  # cov_rel_pose
            proc.get_output_tuple_m(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def match_rel_pose_ransac_s(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cam_par_1: Sequence[Union[float, int, str]],
    cam_par_2: Sequence[Union[float, int, str]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[Union[int, float]], Sequence[float], float, Sequence[int], Sequence[int]]:
    """
    Compute the relative orientation between two cameras by automatically
    finding correspondences between image points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 3

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.
             Assertion: length(Rows2) >= 6 || length(Rows2) >= 3

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.
             Assertion: length(Cols2) == length(Rows2)

    cam_par_1 : Sequence[Union[float, int, str]]
                Parameters of the 1st camera.

    cam_par_2 : Sequence[Union[float, int, str]]
                Parameters of the 2nd camera.

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate shift of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate shift of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative orientation of the right image
               with respect to the left image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Algorithm for the computation of the relative pose
                        and for special pose types.
                        Value Suggestion: normalized_dlt

    distance_threshold : Union[float, int]
                         Maximal deviation of a point from its epipolar
                         line.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    rel_pose : Sequence[Union[int, float]]
               Computed relative orientation of the cameras (3D pose).

    cov_rel_pose : Sequence[float]
                   $6- covariance matrix of the relative orientation.

    error : float
            Root-Mean-Square of the epipolar distance error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    binocular_calibration, match_fundamental_matrix_ransac,
    match_essential_matrix_ransac, create_pose

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_rel_pose, gen_binocular_rectification_map
    """
    with HalconOperator(359) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cam_par_1)
        proc.set_input_tuple(5, cam_par_2)
        proc.set_input_tuple(6, gray_match_method)
        proc.set_input_tuple(7, mask_size)
        proc.set_input_tuple(8, row_move)
        proc.set_input_tuple(9, col_move)
        proc.set_input_tuple(10, row_tolerance)
        proc.set_input_tuple(11, col_tolerance)
        proc.set_input_tuple(12, rotation)
        proc.set_input_tuple(13, match_threshold)
        proc.set_input_tuple(14, estimation_method)
        proc.set_input_tuple(15, distance_threshold)
        proc.set_input_tuple(16, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rel_pose
            proc.get_output_tuple_m(1),  # cov_rel_pose
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def max_diameter_object_model_3d(
    object_model_3d: MaybeSequence[HHandle]
) -> Sequence[float]:
    """
    Calculate the maximal diameter of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    diameter : Sequence[float]
               Calculated diameter.

    See Also
    --------
    volume_object_model_3d_relative_to_plane, area_object_model_3d,
    moments_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, connection_object_model_3d

    Successors
    ----------
    select_object_model_3d
    """
    with HalconOperator(1081) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        diameter = proc.get_output_tuple_m(0)
        return diameter  # type: ignore


def max_diameter_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle]
) -> float:
    """
    Calculate the maximal diameter of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    diameter : float
               Calculated diameter.

    See Also
    --------
    volume_object_model_3d_relative_to_plane, area_object_model_3d,
    moments_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, connection_object_model_3d

    Successors
    ----------
    select_object_model_3d
    """
    with HalconOperator(1081) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        diameter = proc.get_output_tuple_s(0)
        return diameter  # type: ignore


def max_image(image_1: HObject, image_2: HObject) -> HObject:
    """
    Calculate the maximum of two images pixel by pixel.

    Parameters
    ----------

    image_1 : HObject
              Image(s) 1.

    image_2 : HObject
              Image(s) 2.

    Returns
    -------

    image_max : HObject
                Result image(s) by the maximization.

    See Also
    --------
    min_image

    Notes
    -----
    The two input images must be of the same type and size.
    """
    with HalconOperator(1613) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.execute()
        image_max = HObject(proc.get_output_object_key(1))
        return image_max  # type: ignore


def max_matrix(matrix_id: HHandle, max_type: str) -> HHandle:
    """
    Returns the elementwise maximum of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    max_type : str
               Type of maximum determination.
               Value Suggestion: columns

    Returns
    -------

    matrix_max_id : HHandle
                    Matrix handle with the maximum values of the input
                    matrix.

    See Also
    --------
    min_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(857) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, max_type)
        proc.init_oct(0)
        proc.execute()
        matrix_max_id = proc.get_output_tuple_s(0)
        return matrix_max_id  # type: ignore


def max_parallels_xld(ext_parallels: HObject) -> HObject:
    """
    Join modified XLD parallels lying on the same polygon.

    Parameters
    ----------

    ext_parallels : HObject
                    Extended XLD parallels.

    Returns
    -------

    max_polygons : HObject
                   Maximally extended parallels.

    Predecessors
    ------------
    mod_parallels_xld

    Successors
    ----------
    get_polygon_xld, get_lines_xld
    """
    with HalconOperator(38) as proc:
        proc.set_input_object(1, ext_parallels)
        proc.execute()
        max_polygons = HObject(proc.get_output_object_key(1))
        return max_polygons  # type: ignore


def mean_curvature_flow(
    image: HObject,
    sigma: float,
    theta: float,
    iterations: int
) -> HObject:
    """
    Apply the mean curvature flow to an image.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma : float
            Smoothing parameter for derivative operator.
            Value Suggestion: 0.5
            Assertion: Sigma >= 0

    theta : float
            Time step.
            Value Suggestion: 0.5
            Assertion: 0 < Theta <= 0.5

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    Returns
    -------

    image_mcf : HObject
                Output image.

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1546) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma)
        proc.set_input_tuple(1, theta)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        image_mcf = HObject(proc.get_output_object_key(1))
        return image_mcf  # type: ignore


def mean_image(
    image: HObject,
    mask_width: int,
    mask_height: int
) -> HObject:
    """
    Smooth by averaging.

    Parameters
    ----------

    image : HObject
            Image to be smoothed.

    mask_width : int
                 Width of filter mask.
                 Value Suggestion: 9
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    mask_height : int
                  Height of filter mask.
                  Value Suggestion: 9
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    Returns
    -------

    image_mean : HObject
                 Smoothed image.

    See Also
    --------
    anisotropic_diffusion, sigma_image, convol_image, gen_lowpass

    Alternatives
    ------------
    binomial_filter, gauss_filter, smooth_image

    Predecessors
    ------------
    reduce_domain, rectangle1_domain

    Successors
    ----------
    dyn_threshold, regiongrowing

    Notes
    -----
    If even values instead of odd values are given for MaskHeight or
    MaskWidth, the routine uses the next larger odd values instead (this
    way the center of the filter mask is always explicitly determined).
    mean_image can be executed on OpenCL devices for byte, int2, uint2,
    int4 and real images if MaskHeight is less than twice the height of
    Image. For OpenCL, the mean filter value is calculated internally
    using either 32 bit signed integers (for all integer image types) or
    single precision floating point (for real images). This can lead to
    overflows (and thus incorrect results) if Image is either an int4 or
    real image and the full dynamic range is used. Additionally, to
    improve performance a full scan of each row of Image is calculated
    (again using either 32 bit integer or single precision floating point
    arithmetic) if MaskWidth is bigger than 9. This can also lead to
    overflows with very wide images even for byte, int2, or uint2 images.
    In these cases, the CPU version of mean_image should be used.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1418) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.execute()
        image_mean = HObject(proc.get_output_object_key(1))
        return image_mean  # type: ignore


def mean_matrix(matrix_id: HHandle, mean_type: str) -> HHandle:
    """
    Returns the elementwise mean of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    mean_type : str
                Type of mean determination.
                Value Suggestion: columns

    Returns
    -------

    matrix_mean_id : HHandle
                     Matrix handle with the mean values of the input
                     matrix.

    See Also
    --------
    norm_matrix, sum_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(870) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, mean_type)
        proc.init_oct(0)
        proc.execute()
        matrix_mean_id = proc.get_output_tuple_s(0)
        return matrix_mean_id  # type: ignore


def mean_n(image: HObject) -> HObject:
    """
    Average gray values over several channels.

    Parameters
    ----------

    image : HObject
            Multichannel gray image.

    Returns
    -------

    image_mean : HObject
                 Result of averaging.

    See Also
    --------
    count_channels, mean_image

    Alternatives
    ------------
    rank_n

    Predecessors
    ------------
    compose2, compose3, compose4, compose5, add_channels

    Notes
    -----
    This operator may return unexpected results if an image with a
    reduced domain is used as input. Please refer to the chapter  Filters.
    """
    with HalconOperator(1426) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_mean = HObject(proc.get_output_object_key(1))
        return image_mean  # type: ignore


def mean_sp(
    image: HObject,
    mask_width: int,
    mask_height: int,
    min_thresh: int,
    max_thresh: int
) -> HObject:
    """
    Suppress salt and pepper noise.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_width : int
                 Width of filter mask.
                 Value Suggestion: 3
                 Assertion: odd(MaskWidth) && MaskWidth < width(Image) * 2

    mask_height : int
                  Height of filter mask.
                  Value Suggestion: 3
                  Assertion: odd(MaskHeight) && MaskHeight < height(Image) * 2

    min_thresh : int
                 Minimum gray value.
                 Value Suggestion: 1

    max_thresh : int
                 Maximum gray value.
                 Value Suggestion: 254
                 Assertion: MinThresh <= MaxThresh

    Returns
    -------

    image_spmean : HObject
                   Smoothed image.

    See Also
    --------
    anisotropic_diffusion, sigma_image, binomial_filter, gauss_filter,
    smooth_image, eliminate_min_max

    Alternatives
    ------------
    mean_image, median_image, median_separate, eliminate_min_max

    Successors
    ----------
    disp_image

    Notes
    -----
    If even values instead of odd values are given for MaskHeight or
    MaskWidth, the routine uses the next larger odd values instead (this
    way the center of the filter mask is always explicitly determined).
    This operator may return unexpected results if an image with a
    reduced domain is used as input. Please refer to the chapter  Filters.
    """
    with HalconOperator(1428) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, min_thresh)
        proc.set_input_tuple(3, max_thresh)
        proc.execute()
        image_spmean = HObject(proc.get_output_object_key(1))
        return image_spmean  # type: ignore


def measure_pairs(
    image: HObject,
    measure_handle: HHandle,
    sigma: float,
    threshold: float,
    transition: str,
    select: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Extract straight edge pairs perpendicular to a rectangle or annular
    arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    sigma : float
            Sigma of gaussian smoothing.
            Value Suggestion: 1.0
            Assertion: Sigma >= 0.4

    threshold : float
                Minimum edge amplitude.
                Value Suggestion: 30.0

    transition : str
                 Type of gray value transition that determines how edges
                 are grouped to edge pairs.
                 Value Suggestion: all

    select : str
             Selection of edge pairs.
             Value Suggestion: all

    Returns
    -------

    row_edge_first : Sequence[float]
                     Row coordinate of the center of the first edge.

    column_edge_first : Sequence[float]
                        Column coordinate of the center of the first edge.

    amplitude_first : Sequence[float]
                      Edge amplitude of the first edge (with sign).

    row_edge_second : Sequence[float]
                      Row coordinate of the center of the second edge.

    column_edge_second : Sequence[float]
                         Column coordinate of the center of the second
                         edge.

    amplitude_second : Sequence[float]
                       Edge amplitude of the second edge (with sign).

    intra_distance : Sequence[float]
                     Distance between edges of an edge pair.

    inter_distance : Sequence[float]
                     Distance between consecutive edge pairs.

    See Also
    --------
    measure_pos, fuzzy_measure_pos

    Alternatives
    ------------
    edges_sub_pix, fuzzy_measure_pairs, fuzzy_measure_pairing

    Predecessors
    ------------
    gen_measure_rectangle2

    Successors
    ----------
    close_measure

    Notes
    -----
    measure_pairs only returns meaningful results if the assumptions that
    the edges are straight and perpendicular to the major axis of the
    rectangle are fulfilled.  Thus, it should not be used to extract edges
    from curved objects, for example. Furthermore, the user should ensure
    that the rectangle is as close to perpendicular as possible to the
    edges in the image. Additionally, Sigma must not become larger than
    approx. 0.5 * Length1 (for Length1 see gen_measure_rectangle2).
    It should be kept in mind that measure_pairs ignores the domain of
    Image for efficiency reasons.  If certain regions in the image should
    be excluded from the measurement a new measure object with
    appropriately modified parameters should be generated.
    """
    with HalconOperator(835) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.set_input_tuple(3, transition)
        proc.set_input_tuple(4, select)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_edge_first
            proc.get_output_tuple_m(1),  # column_edge_first
            proc.get_output_tuple_m(2),  # amplitude_first
            proc.get_output_tuple_m(3),  # row_edge_second
            proc.get_output_tuple_m(4),  # column_edge_second
            proc.get_output_tuple_m(5),  # amplitude_second
            proc.get_output_tuple_m(6),  # intra_distance
            proc.get_output_tuple_m(7)   # inter_distance
        )  # type: ignore


def measure_pos(
    image: HObject,
    measure_handle: HHandle,
    sigma: float,
    threshold: float,
    transition: str,
    select: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Extract straight edges perpendicular to a rectangle or annular arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    sigma : float
            Sigma of gaussian smoothing.
            Value Suggestion: 1.0
            Assertion: Sigma >= 0.4

    threshold : float
                Minimum edge amplitude.
                Value Suggestion: 30.0

    transition : str
                 Light/dark or dark/light edge.
                 Value Suggestion: all

    select : str
             Selection of end points.
             Value Suggestion: all

    Returns
    -------

    row_edge : Sequence[float]
               Row coordinate of the center of the edge.

    column_edge : Sequence[float]
                  Column coordinate of the center of the edge.

    amplitude : Sequence[float]
                Edge amplitude of the edge (with sign).

    distance : Sequence[float]
               Distance between consecutive edges.

    See Also
    --------
    measure_pairs, fuzzy_measure_pairs, fuzzy_measure_pairing

    Alternatives
    ------------
    edges_sub_pix, fuzzy_measure_pos

    Predecessors
    ------------
    gen_measure_rectangle2

    Successors
    ----------
    close_measure

    Notes
    -----
    measure_pos only returns meaningful results if the assumptions that
    the edges are straight and perpendicular to the major axis of the
    rectangle or arc are fulfilled.  Thus, it should not be used to
    extract edges from curved objects, for example. Furthermore, the user
    should ensure that the rectangle or arc is as close to perpendicular
    as possible to the edges in the image. Additionally, Sigma must not
    become larger than approx. 0.5 * Length1 (for Length1 see
    gen_measure_rectangle2).
    It should be kept in mind that measure_pos ignores the domain of Image
    for efficiency reasons.  If certain regions in the image should be
    excluded from the measurement a new measure object with appropriately
    modified parameters should be generated.
    """
    with HalconOperator(836) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.set_input_tuple(3, transition)
        proc.set_input_tuple(4, select)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_edge
            proc.get_output_tuple_m(1),  # column_edge
            proc.get_output_tuple_m(2),  # amplitude
            proc.get_output_tuple_m(3)   # distance
        )  # type: ignore


def measure_profile_sheet_of_light(
    profile_image: HObject,
    sheet_of_light_model_id: HHandle,
    movement_pose: Sequence[Union[int, float]]
) -> None:
    """
    Process the profile image provided as input and store the resulting
    disparity to the sheet-of-light model.

    Parameters
    ----------

    profile_image : HObject
                    Input image.

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    movement_pose : Sequence[Union[int, float]]
                    Pose describing the movement of the scene under
                    measurement between the previously processed profile
                    image and the current profile image.

    See Also
    --------
    query_sheet_of_light_params, get_sheet_of_light_param,
    get_sheet_of_light_result, apply_sheet_of_light_calibration

    Successors
    ----------
    apply_sheet_of_light_calibration, get_sheet_of_light_result
    """
    with HalconOperator(384) as proc:
        proc.set_input_object(1, profile_image)
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, movement_pose)
        proc.execute()


def measure_projection(
    image: HObject,
    measure_handle: HHandle
) -> Sequence[float]:
    """
    Extract a gray value profile perpendicular to a rectangle or annular
    arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    Returns
    -------

    gray_values : Sequence[float]
                  Gray value profile.

    Alternatives
    ------------
    gray_projections

    Predecessors
    ------------
    gen_measure_rectangle2

    Successors
    ----------
    close_measure

    Notes
    -----
    It should be kept in mind that measure_projection ignores the domain
    of Image for efficiency reasons.  If certain regions in the image
    should be excluded from the measurement a new measure object with
    appropriately modified parameters should be generated.
    """
    with HalconOperator(828) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.init_oct(0)
        proc.execute()
        gray_values = proc.get_output_tuple_m(0)
        return gray_values  # type: ignore


def measure_thresh(
    image: HObject,
    measure_handle: HHandle,
    sigma: float,
    threshold: float,
    select: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Extracting points with a particular gray value along a rectangle or an
    annular arc.

    Parameters
    ----------

    image : HObject
            Input image.

    measure_handle : HHandle
                     Measure object handle.

    sigma : float
            Sigma of gaussian smoothing.
            Value Suggestion: 1.0
            Assertion: Sigma >= 0.0

    threshold : float
                Threshold.
                Value Suggestion: 128.0

    select : str
             Selection of points.
             Value Suggestion: all

    Returns
    -------

    row_thresh : Sequence[float]
                 Row coordinates of points with threshold value.

    column_thresh : Sequence[float]
                    Column coordinates of points with threshold value.

    distance : Sequence[float]
               Distance between consecutive points.

    Alternatives
    ------------
    measure_pos, edges_sub_pix, measure_pairs

    Predecessors
    ------------
    gen_measure_rectangle2

    Successors
    ----------
    close_measure

    Notes
    -----
    measure_thresh only returns meaningful results if the assumptions that
    the edges are straight and perpendicular to the major axis of the
    rectangle are fulfilled.  Thus, it should not be used to extract edges
    from curved objects, for example. Furthermore, the user should ensure
    that the rectangle is as close to perpendicular as possible to the
    edges in the image. Additionally, Sigma must not become larger than
    approx. 0.5 * Length1 (for Length1 see gen_measure_rectangle2).
    It should be kept in mind that measure_thresh ignores the domain of
    Image for efficiency reasons.  If certain regions in the image should
    be excluded from the measurement a new measure object with
    appropriately modified parameters should be generated.
    """
    with HalconOperator(825) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.set_input_tuple(3, select)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_thresh
            proc.get_output_tuple_m(1),  # column_thresh
            proc.get_output_tuple_m(2)   # distance
        )  # type: ignore


def median_image(
    image: HObject,
    mask_type: str,
    radius: int,
    margin: Union[int, float, str]
) -> HObject:
    """
    Compute a median filter with various masks.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask_type : str
                Filter mask type.
                Value Suggestion: circle

    radius : int
             Radius of the filter mask.
             Value Suggestion: 1

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_median : HObject
                   Filtered image.

    See Also
    --------
    gray_erosion_rect, gray_dilation_rect, gray_erosion_shape,
    gray_dilation_shape, gray_erosion, gray_dilation

    Alternatives
    ------------
    median_rect, rank_image, rank_rect

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    median_image uses an algorithm with a runtime per pixel that depends
    on the mask height $2 - Radius + 1$2 * Radius + 1.  Therefore,
    median_image is slower than median_rect for square masks with a large
    mask height. The precise mask height for which median_rect will become
    faster than median_image depends on the computer architecture
    (processor type, availability of SIMD instructions like SSE2 or MMX,
    cache size and throughput, memory throughput). Typically, this is the
    case for mask heights $>$ 15, but can also be the case only for larger
    mask sizes, e.g., if SIMD instructions are unavailable and memory
    throughput is low.
    Furthermore, it should be noted that median_rect uses a recursive
    implementation, which internally computes the filter response on the
    smallest enclosing rectangle of the domain of the input image.
    Therefore, if the domain of the input image only covers a small
    fraction of the smallest enclosing rectangle, it can happen that
    median_image is faster than median_rect even for larger mask heights.
    Due to performance reasons, the input Image is not checked whether it
    contains NaNs. Using an input image with NaNs crashes -
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1413) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_type)
        proc.set_input_tuple(1, radius)
        proc.set_input_tuple(2, margin)
        proc.execute()
        image_median = HObject(proc.get_output_object_key(1))
        return image_median  # type: ignore


def median_rect(
    image: HObject,
    mask_width: int,
    mask_height: int
) -> HObject:
    """
    Compute a median filter with rectangular masks.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 15

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 15

    Returns
    -------

    image_median : HObject
                   Filtered image.

    See Also
    --------
    gray_erosion_rect, gray_dilation_rect, gray_erosion_shape,
    gray_dilation_shape, gray_erosion, gray_dilation

    Alternatives
    ------------
    median_image, rank_rect, rank_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    If even values instead of odd values are passed in MaskHeight or
    MaskWidth, median_rect uses the next larger odd values instead.
    median_rect uses an algorithm with constant runtime per pixel, i.e.,
    the runtime only depends on the size of the input image and not on the
    mask size.  Therefore, for large mask sizes median_rect is the fastest
    implementation of the median filter in HALCON.  Depending on the
    computer architecture (processor type, availability of SIMD
    instructions like SSE2 or MMX, cache size and throughput, memory
    throughput), for small mask sizes the implementation used in
    median_image and rank_image is faster than median_rect.  Typically,
    this is the case for MaskHeight $- 15, but can also happen for larger
    mask sizes, e.g., if SIMD instructions are unavailable and memory
    throughput is low.
    Furthermore, it should be noted that median_rect uses a recursive
    implementation, which internally computes the filter response on the
    smallest enclosing rectangle of the domain of the input image.
    Therefore, if the domain of the input image only covers a small
    fraction of the smallest enclosing rectangle, it can happen that
    median_image and rank_image are faster than median_rect even for
    larger values of MaskHeight.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1412) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.execute()
        image_median = HObject(proc.get_output_object_key(1))
        return image_median  # type: ignore


def median_separate(
    image: HObject,
    mask_width: int,
    mask_height: int,
    margin: Union[int, float, str]
) -> HObject:
    """
    Separated median filtering with rectangle masks.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask_width : int
                 Width of rank mask.
                 Value Suggestion: 25

    mask_height : int
                  Height of rank mask.
                  Value Suggestion: 25

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_smedian : HObject
                    Median filtered image.

    See Also
    --------
    rank_image

    Alternatives
    ------------
    median_image

    Predecessors
    ------------
    texture_laws, sobel_amp, deviation_image

    Successors
    ----------
    learn_ndim_norm, regiongrowing, auto_threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    Due to performance reasons, the input Image is not checked whether it
    contains NaNs. Using an input image with NaNs crashes
    """
    with HalconOperator(1411) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, margin)
        proc.execute()
        image_smedian = HObject(proc.get_output_object_key(1))
        return image_smedian  # type: ignore


def median_weighted(
    image: HObject,
    mask_type: str,
    mask_size: int
) -> HObject:
    """
    Weighted median filtering with different rank masks.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask_type : str
                Type of median mask.
                Value Suggestion: inner

    mask_size : int
                mask size.
                Value Suggestion: 3

    Returns
    -------

    image_wmedian : HObject
                    Median filtered image.

    Alternatives
    ------------
    median_image, trimmed_mean, sigma_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1414) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_type)
        proc.set_input_tuple(1, mask_size)
        proc.execute()
        image_wmedian = HObject(proc.get_output_object_key(1))
        return image_wmedian  # type: ignore


def merge_cont_line_scan_xld(
    curr_conts: HObject,
    prev_conts: HObject,
    image_height: int,
    margin: Union[float, int],
    merge_border: str,
    max_images_cont: int
) -> Tuple[HObject, HObject]:
    """
    Merge XLD contours from successive line scan images.

    Parameters
    ----------

    curr_conts : HObject
                 Current input contours.

    prev_conts : HObject
                 Merged contours from the previous iteration.

    image_height : int
                   Height of the line scan images.
                   Value Suggestion: 512

    margin : Union[float, int]
             Maximum distance of contours from the image border.
             Value Suggestion: 0.0

    merge_border : str
                   Image line of the current image, which touches the
                   previous image.
                   Value Suggestion: 'top'

    max_images_cont : int
                      Maximum number of images covered by one contour.
                      Value Suggestion: 3

    Returns
    -------

    curr_merged_conts : HObject
                        Current contours, merged with old ones where
                        applicable.

    prev_merged_conts : HObject
                        Contours from the previous iteration which could
                        not be merged with the current ones.
    """
    with HalconOperator(17) as proc:
        proc.set_input_object(1, curr_conts)
        proc.set_input_object(2, prev_conts)
        proc.set_input_tuple(0, image_height)
        proc.set_input_tuple(1, margin)
        proc.set_input_tuple(2, merge_border)
        proc.set_input_tuple(3, max_images_cont)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # curr_merged_conts
            HObject(proc.get_output_object_key(2))   # prev_merged_conts
        )  # type: ignore


def merge_regions_line_scan(
    curr_regions: HObject,
    prev_regions: HObject,
    image_height: int,
    merge_border: str,
    max_images_region: int
) -> Tuple[HObject, HObject]:
    """
    Merge regions from line scan images.

    Parameters
    ----------

    curr_regions : HObject
                   Current input regions.

    prev_regions : HObject
                   Merged regions from the previous iteration.

    image_height : int
                   Height of the line scan images.
                   Value Suggestion: 512

    merge_border : str
                   Image line of the current image, which touches the
                   previous image.
                   Value Suggestion: 'top'

    max_images_region : int
                        Maximum number of images for a single region.
                        Value Suggestion: 3

    Returns
    -------

    curr_merged_regions : HObject
                          Current regions, merged with old ones where
                          applicable.

    prev_merged_regions : HObject
                          Regions from the previous iteration which could
                          not be merged with the current ones.
    """
    with HalconOperator(477) as proc:
        proc.set_input_object(1, curr_regions)
        proc.set_input_object(2, prev_regions)
        proc.set_input_tuple(0, image_height)
        proc.set_input_tuple(1, merge_border)
        proc.set_input_tuple(2, max_images_region)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # curr_merged_regions
            HObject(proc.get_output_object_key(2))   # prev_merged_regions
        )  # type: ignore


def midrange_image(
    image: HObject,
    mask: HObject,
    margin: Union[int, float, str]
) -> HObject:
    """
    Calculate the average of maximum and minimum inside any mask.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask : HObject
           Filter mask.

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_midrange : HObject
                     Filtered image.

    See Also
    --------
    gen_circle, gen_rectangle1, gray_erosion_rect, gray_dilation_rect,
    gray_range_rect

    Alternatives
    ------------
    sigma_image

    Predecessors
    ------------
    read_image, draw_region, gen_circle, gen_rectangle1

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1409) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, mask)
        proc.set_input_tuple(0, margin)
        proc.execute()
        image_midrange = HObject(proc.get_output_object_key(1))
        return image_midrange  # type: ignore


def min_image(image_1: HObject, image_2: HObject) -> HObject:
    """
    Calculate the minimum of two images pixel by pixel.

    Parameters
    ----------

    image_1 : HObject
              Image(s) 1.

    image_2 : HObject
              Image(s) 2.

    Returns
    -------

    image_min : HObject
                Result image(s) by the minimization.

    See Also
    --------
    max_image

    Alternatives
    ------------
    gray_erosion
    """
    with HalconOperator(1612) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.execute()
        image_min = HObject(proc.get_output_object_key(1))
        return image_min  # type: ignore


def min_matrix(matrix_id: HHandle, min_type: str) -> HHandle:
    """
    Returns the elementwise minimum of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    min_type : str
               Type of minimum determination.
               Value Suggestion: columns

    Returns
    -------

    matrix_min_id : HHandle
                    Matrix handle with the minimum values of the input
                    matrix.

    See Also
    --------
    max_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(858) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, min_type)
        proc.init_oct(0)
        proc.execute()
        matrix_min_id = proc.get_output_tuple_s(0)
        return matrix_min_id  # type: ignore


def min_max_gray(
    regions: HObject,
    image: HObject,
    percent: Union[int, float]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Determine the minimum and maximum gray values within regions.

    Parameters
    ----------

    regions : HObject
              Regions, the features of which are to be calculated.

    image : HObject
            Gray value image.

    percent : Union[int, float]
              Percentage below (above) the absolute maximum (minimum).
              Value Suggestion: 0
              Assertion: 0 <= Percent && Percent <= 50

    Returns
    -------

    min : Sequence[float]
          ``Minimum'' gray value.

    max : Sequence[float]
          ``Maximum'' gray value.
          Assertion: Max >= Min

    range : Sequence[float]
            Difference between Max and Min.
            Assertion: Range >= 0

    See Also
    --------
    gray_histo, scale_image, scale_image_max, learn_ndim_norm

    Alternatives
    ------------
    select_gray, intensity

    Predecessors
    ------------
    draw_region, gen_circle, gen_ellipse, gen_rectangle1, threshold,
    regiongrowing

    Successors
    ----------
    threshold

    Notes
    -----
    Note that the operator min_max_gray only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1751) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, percent)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # min
            proc.get_output_tuple_m(1),  # max
            proc.get_output_tuple_m(2)   # range
        )  # type: ignore


def min_max_gray_s(
    regions: HObject,
    image: HObject,
    percent: Union[int, float]
) -> Tuple[float, float, float]:
    """
    Determine the minimum and maximum gray values within regions.

    Parameters
    ----------

    regions : HObject
              Regions, the features of which are to be calculated.

    image : HObject
            Gray value image.

    percent : Union[int, float]
              Percentage below (above) the absolute maximum (minimum).
              Value Suggestion: 0
              Assertion: 0 <= Percent && Percent <= 50

    Returns
    -------

    min : float
          ``Minimum'' gray value.

    max : float
          ``Maximum'' gray value.
          Assertion: Max >= Min

    range : float
            Difference between Max and Min.
            Assertion: Range >= 0

    See Also
    --------
    gray_histo, scale_image, scale_image_max, learn_ndim_norm

    Alternatives
    ------------
    select_gray, intensity

    Predecessors
    ------------
    draw_region, gen_circle, gen_ellipse, gen_rectangle1, threshold,
    regiongrowing

    Successors
    ----------
    threshold

    Notes
    -----
    Note that the operator min_max_gray only considers  the given Regions
    and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1751) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, percent)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # min
            proc.get_output_tuple_s(1),  # max
            proc.get_output_tuple_s(2)   # range
        )  # type: ignore


def minkowski_add1(
    region: HObject,
    struct_element: HObject,
    iterations: int
) -> HObject:
    """
    Perform a Minkowski addition on a region.

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    struct_element : HObject
                     Structuring element.

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_mink_add : HObject
                      Dilated regions.

    See Also
    --------
    transpose_region, minkowski_sub1

    Alternatives
    ------------
    minkowski_add2, dilation1

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    A Minkowski addition always results in enlarged regions. Closely
    spaced regions which may touch or overlap as a result of the dilation
    are still treated as two separate regions.  If the desired behavior is
    to merge them into one region, the operator union1 has to be called
    first.
    """
    with HalconOperator(758) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, iterations)
        proc.execute()
        region_mink_add = HObject(proc.get_output_object_key(1))
        return region_mink_add  # type: ignore


def minkowski_add2(
    region: HObject,
    struct_element: HObject,
    row: int,
    column: int,
    iterations: int
) -> HObject:
    """
    Dilate a region (using a reference point).

    Parameters
    ----------

    region : HObject
             Regions to be dilated.

    struct_element : HObject
                     Structuring element.

    row : int
          Row coordinate of the reference point.

    column : int
             Column coordinate of the reference point.

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_mink_add : HObject
                      Dilated regions.

    See Also
    --------
    transpose_region

    Alternatives
    ------------
    minkowski_add1, dilation1

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Notes
    -----
    A Minkowski addition always results in enlarged regions. Closely
    spaced regions which may touch or overlap as a result of the dilation
    are still treated as two separate regions.  If the desired behavior is
    to merge them into one region, the operator union1 has to be called
    first.
    """
    with HalconOperator(757) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        region_mink_add = HObject(proc.get_output_object_key(1))
        return region_mink_add  # type: ignore


def minkowski_sub1(
    region: HObject,
    struct_element: HObject,
    iterations: int
) -> HObject:
    """
    Erode a region.

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    struct_element : HObject
                     Structuring element.

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_mink_sub : HObject
                      Eroded regions.

    See Also
    --------
    transpose_region

    Alternatives
    ------------
    minkowski_sub2, erosion1

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(756) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, iterations)
        proc.execute()
        region_mink_sub = HObject(proc.get_output_object_key(1))
        return region_mink_sub  # type: ignore


def minkowski_sub2(
    region: HObject,
    struct_element: HObject,
    row: int,
    column: int,
    iterations: int
) -> HObject:
    """
    Erode a region (using a reference point).

    Parameters
    ----------

    region : HObject
             Regions to be eroded.

    struct_element : HObject
                     Structuring element.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 0

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_mink_sub : HObject
                      Eroded regions.

    See Also
    --------
    gen_circle, gen_rectangle2, gen_region_polygon

    Alternatives
    ------------
    minkowski_sub1, erosion1, erosion2

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm, gen_circle,
    gen_ellipse, gen_rectangle1, gen_rectangle2, draw_region,
    gen_region_points, gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(755) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        region_mink_sub = HObject(proc.get_output_object_key(1))
        return region_mink_sub  # type: ignore


def mirror_image(image: HObject, mode: str) -> HObject:
    """
    Mirror an image.

    Parameters
    ----------

    image : HObject
            Input image.

    mode : str
           Axis of reflection.
           Value Suggestion: row

    Returns
    -------

    image_mirror : HObject
                   Reflected image.

    See Also
    --------
    rotate_image, hom_mat2d_rotate

    Alternatives
    ------------
    hom_mat2d_rotate, hom_mat2d_reflect, affine_trans_image, rotate_image

    Notes
    -----
    mirror_image can be executed on OpenCL devices if the input image does
    not exceed the maximum size of image objects of the selected device.
    However, execution might be faster on the CPU, especially for the mode
    'row'.
    """
    with HalconOperator(1626) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mode)
        proc.execute()
        image_mirror = HObject(proc.get_output_object_key(1))
        return image_mirror  # type: ignore


def mirror_region(
    region: HObject,
    mode: str,
    width_height: int
) -> HObject:
    """
    Reflect a region about an axis.

    Parameters
    ----------

    region : HObject
             Region(s) to be reflected.

    mode : str
           Axis of symmetry.
           Value Suggestion: row

    width_height : int
                   Twice the coordinate of the axis of symmetry.
                   Value Suggestion: 512
                   Assertion: WidthHeight > 0

    Returns
    -------

    region_mirror : HObject
                    Reflected region(s).

    See Also
    --------
    zoom_region

    Alternatives
    ------------
    hom_mat2d_reflect, affine_trans_region

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(489) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, width_height)
        proc.execute()
        region_mirror = HObject(proc.get_output_object_key(1))
        return region_mirror  # type: ignore


def mod_parallels_xld(
    parallels: HObject,
    image: HObject,
    quality: Union[float, int],
    min_gray: int,
    max_gray: int,
    max_standard: Union[float, int]
) -> Tuple[HObject, HObject]:
    """
    Extract parallel XLD polygons enclosing a homogeneous area.

    Parameters
    ----------

    parallels : HObject
                Input XLD parallels.

    image : HObject
            Corresponding gray value image.

    quality : Union[float, int]
              Minimum quality factor (measure of parallelism).
              Value Suggestion: 0.4
              Assertion: 0.0 <= Quality && Quality <= 1.0

    min_gray : int
               Minimum mean gray value.
               Value Suggestion: 160
               Assertion: 0 <= MinGray && MinGray <= 255

    max_gray : int
               Maximum mean gray value.
               Value Suggestion: 220
               Assertion: 0 <= MaxGray && MaxGray <= 255 && MaxGray >= MinGray

    max_standard : Union[float, int]
                   Maximum allowed standard deviation.
                   Value Suggestion: 10.0
                   Assertion: MaxStandard >= 0.0

    Returns
    -------

    mod_parallels : HObject
                    Modified XLD parallels.

    ext_parallels : HObject
                    Extended XLD parallels.

    See Also
    --------
    info_parallels_xld

    Predecessors
    ------------
    gen_parallels_xld

    Successors
    ----------
    max_parallels_xld
    """
    with HalconOperator(39) as proc:
        proc.set_input_object(1, parallels)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, quality)
        proc.set_input_tuple(1, min_gray)
        proc.set_input_tuple(2, max_gray)
        proc.set_input_tuple(3, max_standard)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # mod_parallels
            HObject(proc.get_output_object_key(2))   # ext_parallels
        )  # type: ignore


def modify_component_relations(
    component_training_id: HHandle,
    reference_component: MaybeSequence[Union[int, str]],
    tolerance_component: MaybeSequence[Union[int, str]],
    position_tolerance: MaybeSequence[float],
    angle_tolerance: MaybeSequence[float]
) -> None:
    """
    Modify the relations within a training result.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    reference_component : MaybeSequence[Union[int, str]]
                          Model component(s) relative to which the
                          movement(s) should be modified.
                          Value Suggestion: all

    tolerance_component : MaybeSequence[Union[int, str]]
                          Model component(s) of which the relative
                          movement(s) should be modified.
                          Value Suggestion: all

    position_tolerance : MaybeSequence[float]
                         Change of the position relation in pixels.

    angle_tolerance : MaybeSequence[float]
                      Change of the orientation relation in radians.

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    create_trained_component_model
    """
    with HalconOperator(1010) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, reference_component)
        proc.set_input_tuple(2, tolerance_component)
        proc.set_input_tuple(3, position_tolerance)
        proc.set_input_tuple(4, angle_tolerance)
        proc.execute()


def moments_any_points_xld(
    xld: HObject,
    mode: str,
    area: MaybeSequence[float],
    center_row: MaybeSequence[float],
    center_col: MaybeSequence[float],
    p: MaybeSequence[int],
    q: MaybeSequence[int]
) -> Sequence[float]:
    """
    Arbitrary geometric moments of contours or polygons treated as point
    clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    mode : str
           Computation mode.
           Value Suggestion: unnormalized

    area : MaybeSequence[float]
           Area enclosed by the contour or polygon.

    center_row : MaybeSequence[float]
                 Row coordinate of the centroid.

    center_col : MaybeSequence[float]
                 Column coordinate of the centroid.

    p : MaybeSequence[int]
        First index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    q : MaybeSequence[int]
        Second index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    Returns
    -------

    m : Sequence[float]
        The computed moments.

    See Also
    --------
    moments_points_xld, area_center_points_xld, moments_region_2nd,
    area_center

    Alternatives
    ------------
    moments_points_xld, moments_any_xld

    Predecessors
    ------------
    area_center_points_xld, gen_contours_skeleton_xld,
    smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1669) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, area)
        proc.set_input_tuple(2, center_row)
        proc.set_input_tuple(3, center_col)
        proc.set_input_tuple(4, p)
        proc.set_input_tuple(5, q)
        proc.init_oct(0)
        proc.execute()
        m = proc.get_output_tuple_m(0)
        return m  # type: ignore


def moments_any_points_xld_s(
    xld: HObject,
    mode: str,
    area: MaybeSequence[float],
    center_row: MaybeSequence[float],
    center_col: MaybeSequence[float],
    p: MaybeSequence[int],
    q: MaybeSequence[int]
) -> float:
    """
    Arbitrary geometric moments of contours or polygons treated as point
    clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    mode : str
           Computation mode.
           Value Suggestion: unnormalized

    area : MaybeSequence[float]
           Area enclosed by the contour or polygon.

    center_row : MaybeSequence[float]
                 Row coordinate of the centroid.

    center_col : MaybeSequence[float]
                 Column coordinate of the centroid.

    p : MaybeSequence[int]
        First index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    q : MaybeSequence[int]
        Second index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    Returns
    -------

    m : float
        The computed moments.

    See Also
    --------
    moments_points_xld, area_center_points_xld, moments_region_2nd,
    area_center

    Alternatives
    ------------
    moments_points_xld, moments_any_xld

    Predecessors
    ------------
    area_center_points_xld, gen_contours_skeleton_xld,
    smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1669) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, area)
        proc.set_input_tuple(2, center_row)
        proc.set_input_tuple(3, center_col)
        proc.set_input_tuple(4, p)
        proc.set_input_tuple(5, q)
        proc.init_oct(0)
        proc.execute()
        m = proc.get_output_tuple_s(0)
        return m  # type: ignore


def moments_any_xld(
    xld: HObject,
    mode: str,
    point_order: MaybeSequence[str],
    area: MaybeSequence[float],
    center_row: MaybeSequence[float],
    center_col: MaybeSequence[float],
    p: MaybeSequence[int],
    q: MaybeSequence[int]
) -> Sequence[float]:
    """
    Arbitrary geometric moments of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    mode : str
           Computation mode.
           Value Suggestion: unnormalized

    point_order : MaybeSequence[str]
                  Point order along the boundary.
                  Value Suggestion: positive

    area : MaybeSequence[float]
           Area enclosed by the contour or polygon.

    center_row : MaybeSequence[float]
                 Row coordinate of the centroid.

    center_col : MaybeSequence[float]
                 Column coordinate of the centroid.

    p : MaybeSequence[int]
        First index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    q : MaybeSequence[int]
        Second index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    Returns
    -------

    m : Sequence[float]
        The computed moments.

    See Also
    --------
    moments_xld, area_center_xld, moments_region_2nd, area_center

    Alternatives
    ------------
    moments_xld, moments_any_points_xld

    Predecessors
    ------------
    area_center_xld, gen_contours_skeleton_xld, smooth_contours_xld,
    gen_polygons_xld
    """
    with HalconOperator(1691) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, point_order)
        proc.set_input_tuple(2, area)
        proc.set_input_tuple(3, center_row)
        proc.set_input_tuple(4, center_col)
        proc.set_input_tuple(5, p)
        proc.set_input_tuple(6, q)
        proc.init_oct(0)
        proc.execute()
        m = proc.get_output_tuple_m(0)
        return m  # type: ignore


def moments_any_xld_s(
    xld: HObject,
    mode: str,
    point_order: MaybeSequence[str],
    area: MaybeSequence[float],
    center_row: MaybeSequence[float],
    center_col: MaybeSequence[float],
    p: MaybeSequence[int],
    q: MaybeSequence[int]
) -> float:
    """
    Arbitrary geometric moments of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    mode : str
           Computation mode.
           Value Suggestion: unnormalized

    point_order : MaybeSequence[str]
                  Point order along the boundary.
                  Value Suggestion: positive

    area : MaybeSequence[float]
           Area enclosed by the contour or polygon.

    center_row : MaybeSequence[float]
                 Row coordinate of the centroid.

    center_col : MaybeSequence[float]
                 Column coordinate of the centroid.

    p : MaybeSequence[int]
        First index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    q : MaybeSequence[int]
        Second index of the desired moments M[P,Q]$M_{p,q}$.
        Value Suggestion: 1

    Returns
    -------

    m : float
        The computed moments.

    See Also
    --------
    moments_xld, area_center_xld, moments_region_2nd, area_center

    Alternatives
    ------------
    moments_xld, moments_any_points_xld

    Predecessors
    ------------
    area_center_xld, gen_contours_skeleton_xld, smooth_contours_xld,
    gen_polygons_xld
    """
    with HalconOperator(1691) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, point_order)
        proc.set_input_tuple(2, area)
        proc.set_input_tuple(3, center_row)
        proc.set_input_tuple(4, center_col)
        proc.set_input_tuple(5, p)
        proc.set_input_tuple(6, q)
        proc.init_oct(0)
        proc.execute()
        m = proc.get_output_tuple_s(0)
        return m  # type: ignore


def moments_gray_plane(
    regions: HObject,
    image: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate gray value moments and approximation by a plane.

    Parameters
    ----------

    regions : HObject
              Regions to be checked.

    image : HObject
            Corresponding gray values.

    Returns
    -------

    mrow : Sequence[float]
           Mixed moments along a line.

    mcol : Sequence[float]
           Mixed moments along a column.

    alpha : Sequence[float]
            Parameter Alpha of the approximating plane.

    beta : Sequence[float]
           Parameter Beta of the approximating plane.

    mean : Sequence[float]
           Mean gray value.

    See Also
    --------
    intensity, moments_region_2nd

    Predecessors
    ------------
    draw_region, gen_circle, gen_ellipse, gen_rectangle1, gen_rectangle2,
    threshold, regiongrowing

    Notes
    -----
    Note that the operator moments_gray_plane only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1761) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # mrow
            proc.get_output_tuple_m(1),  # mcol
            proc.get_output_tuple_m(2),  # alpha
            proc.get_output_tuple_m(3),  # beta
            proc.get_output_tuple_m(4)   # mean
        )  # type: ignore


def moments_gray_plane_s(
    regions: HObject,
    image: HObject
) -> Tuple[float, float, float, float, float]:
    """
    Calculate gray value moments and approximation by a plane.

    Parameters
    ----------

    regions : HObject
              Regions to be checked.

    image : HObject
            Corresponding gray values.

    Returns
    -------

    mrow : float
           Mixed moments along a line.

    mcol : float
           Mixed moments along a column.

    alpha : float
            Parameter Alpha of the approximating plane.

    beta : float
           Parameter Beta of the approximating plane.

    mean : float
           Mean gray value.

    See Also
    --------
    intensity, moments_region_2nd

    Predecessors
    ------------
    draw_region, gen_circle, gen_ellipse, gen_rectangle1, gen_rectangle2,
    threshold, regiongrowing

    Notes
    -----
    Note that the operator moments_gray_plane only considers  the given
    Regions and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1761) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # mrow
            proc.get_output_tuple_s(1),  # mcol
            proc.get_output_tuple_s(2),  # alpha
            proc.get_output_tuple_s(3),  # beta
            proc.get_output_tuple_s(4)   # mean
        )  # type: ignore


def moments_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    moments_to_calculate: MaybeSequence[str]
) -> Sequence[float]:
    """
    Calculates the mean or the central moment of second order for a 3D
    object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    moments_to_calculate : MaybeSequence[str]
                           Moment to calculate.
                           Value Suggestion: 'mean_points'

    Returns
    -------

    moments : Sequence[float]
              Calculated moment.

    See Also
    --------
    volume_object_model_3d_relative_to_plane

    Predecessors
    ------------
    read_object_model_3d, connection_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz
    """
    with HalconOperator(1082) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, moments_to_calculate)
        proc.init_oct(0)
        proc.execute()
        moments = proc.get_output_tuple_m(0)
        return moments  # type: ignore


def moments_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    moments_to_calculate: MaybeSequence[str]
) -> float:
    """
    Calculates the mean or the central moment of second order for a 3D
    object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    moments_to_calculate : MaybeSequence[str]
                           Moment to calculate.
                           Value Suggestion: 'mean_points'

    Returns
    -------

    moments : float
              Calculated moment.

    See Also
    --------
    volume_object_model_3d_relative_to_plane

    Predecessors
    ------------
    read_object_model_3d, connection_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz
    """
    with HalconOperator(1082) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, moments_to_calculate)
        proc.init_oct(0)
        proc.execute()
        moments = proc.get_output_tuple_s(0)
        return moments  # type: ignore


def moments_points_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments M20$M_{20}$, M02$M_{02}$, and M11$M_{11}$ of
    contours or polygons treated as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    m11 : Sequence[float]
          Mixed second order moment.

    m20 : Sequence[float]
          Second order moment along the row axis.

    m02 : Sequence[float]
          Second order moment along the column axis.

    See Also
    --------
    moments_any_points_xld, area_center_points_xld, moments_region_2nd,
    area_center

    Alternatives
    ------------
    moments_xld, moments_any_xld, moments_any_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1673) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # m11
            proc.get_output_tuple_m(1),  # m20
            proc.get_output_tuple_m(2)   # m02
        )  # type: ignore


def moments_points_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Geometric moments M20$M_{20}$, M02$M_{02}$, and M11$M_{11}$ of
    contours or polygons treated as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    m11 : float
          Mixed second order moment.

    m20 : float
          Second order moment along the row axis.

    m02 : float
          Second order moment along the column axis.

    See Also
    --------
    moments_any_points_xld, area_center_points_xld, moments_region_2nd,
    area_center

    Alternatives
    ------------
    moments_xld, moments_any_xld, moments_any_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1673) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # m11
            proc.get_output_tuple_s(1),  # m20
            proc.get_output_tuple_s(2)   # m02
        )  # type: ignore


def moments_region_2nd(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Input regions.

    Returns
    -------

    m11 : Sequence[float]
          Product of inertia of the axes through the center parallel to
          the coordinate axes.

    m20 : Sequence[float]
          Moment of 2nd order (row-dependent).

    m02 : Sequence[float]
          Moment of 2nd order (column-dependent).

    ia : Sequence[float]
         Length of the major axis of the input region.

    ib : Sequence[float]
         Length of the minor axis of the input region.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd_invar

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1708) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # m11
            proc.get_output_tuple_m(1),  # m20
            proc.get_output_tuple_m(2),  # m02
            proc.get_output_tuple_m(3),  # ia
            proc.get_output_tuple_m(4)   # ib
        )  # type: ignore


def moments_region_2nd_invar(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    m11 : Sequence[float]
          Product of inertia of the axes through the center parallel to
          the coordinate axes.

    m20 : Sequence[float]
          Moment of 2nd order (line-dependent).

    m02 : Sequence[float]
          Moment of 2nd order (column-dependent).

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1707) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # m11
            proc.get_output_tuple_m(1),  # m20
            proc.get_output_tuple_m(2)   # m02
        )  # type: ignore


def moments_region_2nd_invar_s(
    regions: HObject
) -> Tuple[float, float, float]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    m11 : float
          Product of inertia of the axes through the center parallel to
          the coordinate axes.

    m20 : float
          Moment of 2nd order (line-dependent).

    m02 : float
          Moment of 2nd order (column-dependent).

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1707) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # m11
            proc.get_output_tuple_s(1),  # m20
            proc.get_output_tuple_s(2)   # m02
        )  # type: ignore


def moments_region_2nd_rel_invar(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    phi1 : Sequence[float]
           Moment of 2nd order.

    phi2 : Sequence[float]
           Moment of 2nd order.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1706) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # phi1
            proc.get_output_tuple_m(1)   # phi2
        )  # type: ignore


def moments_region_2nd_rel_invar_s(
    regions: HObject
) -> Tuple[float, float]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    phi1 : float
           Moment of 2nd order.

    phi2 : float
           Moment of 2nd order.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1706) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # phi1
            proc.get_output_tuple_s(1)   # phi2
        )  # type: ignore


def moments_region_2nd_s(
    regions: HObject
) -> Tuple[float, float, float, float, float]:
    """
    Calculate the geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Input regions.

    Returns
    -------

    m11 : float
          Product of inertia of the axes through the center parallel to
          the coordinate axes.

    m20 : float
          Moment of 2nd order (row-dependent).

    m02 : float
          Moment of 2nd order (column-dependent).

    ia : float
         Length of the major axis of the input region.

    ib : float
         Length of the minor axis of the input region.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd_invar

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1708) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # m11
            proc.get_output_tuple_s(1),  # m20
            proc.get_output_tuple_s(2),  # m02
            proc.get_output_tuple_s(3),  # ia
            proc.get_output_tuple_s(4)   # ib
        )  # type: ignore


def moments_region_3rd(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    m21 : Sequence[float]
          Moment of 3rd order (line-dependent).

    m12 : Sequence[float]
          Moment of 3rd order (column-dependent).

    m03 : Sequence[float]
          Moment of 3rd order (column-dependent).

    m30 : Sequence[float]
          Moment of 3rd order (line-dependent).

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1697) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # m21
            proc.get_output_tuple_m(1),  # m12
            proc.get_output_tuple_m(2),  # m03
            proc.get_output_tuple_m(3)   # m30
        )  # type: ignore


def moments_region_3rd_invar(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    m21 : Sequence[float]
          Moment of 3rd order (line-dependent).

    m12 : Sequence[float]
          Moment of 3rd order (column-dependent).

    m03 : Sequence[float]
          Moment of 3rd order (column-dependent).

    m30 : Sequence[float]
          Moment of 3rd order (line-dependent).

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1696) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # m21
            proc.get_output_tuple_m(1),  # m12
            proc.get_output_tuple_m(2),  # m03
            proc.get_output_tuple_m(3)   # m30
        )  # type: ignore


def moments_region_3rd_invar_s(
    regions: HObject
) -> Tuple[float, float, float, float]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    m21 : float
          Moment of 3rd order (line-dependent).

    m12 : float
          Moment of 3rd order (column-dependent).

    m03 : float
          Moment of 3rd order (column-dependent).

    m30 : float
          Moment of 3rd order (line-dependent).

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1696) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # m21
            proc.get_output_tuple_s(1),  # m12
            proc.get_output_tuple_s(2),  # m03
            proc.get_output_tuple_s(3)   # m30
        )  # type: ignore


def moments_region_3rd_s(
    regions: HObject
) -> Tuple[float, float, float, float]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    m21 : float
          Moment of 3rd order (line-dependent).

    m12 : float
          Moment of 3rd order (column-dependent).

    m03 : float
          Moment of 3rd order (column-dependent).

    m30 : float
          Moment of 3rd order (line-dependent).

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1697) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # m21
            proc.get_output_tuple_s(1),  # m12
            proc.get_output_tuple_s(2),  # m03
            proc.get_output_tuple_s(3)   # m30
        )  # type: ignore


def moments_region_central(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    i1 : Sequence[float]
         Moment of 2nd order.

    i2 : Sequence[float]
         Moment of 2nd order.

    i3 : Sequence[float]
         Moment of 2nd order.

    i4 : Sequence[float]
         Moment of 3rd order.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1695) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # i1
            proc.get_output_tuple_m(1),  # i2
            proc.get_output_tuple_m(2),  # i3
            proc.get_output_tuple_m(3)   # i4
        )  # type: ignore


def moments_region_central_invar(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    psi1 : Sequence[float]
           Moment of 2nd order.

    psi2 : Sequence[float]
           Moment of 2nd order.

    psi3 : Sequence[float]
           Moment of 2nd order.

    psi4 : Sequence[float]
           Moment of 2nd order.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1694) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # psi1
            proc.get_output_tuple_m(1),  # psi2
            proc.get_output_tuple_m(2),  # psi3
            proc.get_output_tuple_m(3)   # psi4
        )  # type: ignore


def moments_region_central_invar_s(
    regions: HObject
) -> Tuple[float, float, float, float]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    psi1 : float
           Moment of 2nd order.

    psi2 : float
           Moment of 2nd order.

    psi3 : float
           Moment of 2nd order.

    psi4 : float
           Moment of 2nd order.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1694) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # psi1
            proc.get_output_tuple_s(1),  # psi2
            proc.get_output_tuple_s(2),  # psi3
            proc.get_output_tuple_s(3)   # psi4
        )  # type: ignore


def moments_region_central_s(
    regions: HObject
) -> Tuple[float, float, float, float]:
    """
    Geometric moments of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    i1 : float
         Moment of 2nd order.

    i2 : float
         Moment of 2nd order.

    i3 : float
         Moment of 2nd order.

    i4 : float
         Moment of 3rd order.

    See Also
    --------
    elliptic_axis

    Alternatives
    ------------
    moments_region_2nd

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1695) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # i1
            proc.get_output_tuple_s(1),  # i2
            proc.get_output_tuple_s(2),  # i3
            proc.get_output_tuple_s(3)   # i4
        )  # type: ignore


def moments_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Geometric moments M20$M_{20}$, M02$M_{02}$, and M11$M_{11}$ of
    contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    m11 : Sequence[float]
          Mixed second order moment.

    m20 : Sequence[float]
          Second order moment along the row axis.

    m02 : Sequence[float]
          Second order moment along the column axis.

    See Also
    --------
    moments_any_xld, area_center_xld, moments_region_2nd, area_center

    Alternatives
    ------------
    moments_any_xld, moments_points_xld, moments_any_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1692) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # m11
            proc.get_output_tuple_m(1),  # m20
            proc.get_output_tuple_m(2)   # m02
        )  # type: ignore


def moments_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Geometric moments M20$M_{20}$, M02$M_{02}$, and M11$M_{11}$ of
    contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    m11 : float
          Mixed second order moment.

    m20 : float
          Second order moment along the row axis.

    m02 : float
          Second order moment along the column axis.

    See Also
    --------
    moments_any_xld, area_center_xld, moments_region_2nd, area_center

    Alternatives
    ------------
    moments_any_xld, moments_points_xld, moments_any_points_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, smooth_contours_xld, gen_polygons_xld
    """
    with HalconOperator(1692) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # m11
            proc.get_output_tuple_s(1),  # m20
            proc.get_output_tuple_s(2)   # m02
        )  # type: ignore


def monotony(image: HObject) -> HObject:
    """
    Calculating the monotony operation.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_monotony : HObject
                     Result of the monotony operator.

    Alternatives
    ------------
    local_max, topographic_sketch, corner_response

    Predecessors
    ------------
    binomial_filter, gauss_filter, median_image, mean_image, smooth_image,
    invert_image

    Successors
    ----------
    threshold, exhaustive_match, disp_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1509) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_monotony = HObject(proc.get_output_object_key(1))
        return image_monotony  # type: ignore


def morph_hat(region: HObject, struct_element: HObject) -> HObject:
    """
    Compute the union of bottom_hat and top_hat.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_element : HObject
                     Structuring element (position-invariant).

    Returns
    -------

    region_morph_hat : HObject
                       Union of top hat and bottom hat.

    See Also
    --------
    opening, closing

    Alternatives
    ------------
    top_hat, bottom_hat, union2

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    morph_hat is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    The individual regions are processed separately.
    """
    with HalconOperator(752) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.execute()
        region_morph_hat = HObject(proc.get_output_object_key(1))
        return region_morph_hat  # type: ignore


def morph_skeleton(region: HObject) -> HObject:
    """
    Compute the morphological skeleton of a region.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    Returns
    -------

    region_skeleton : HObject
                      Resulting morphological skeleton.

    Alternatives
    ------------
    skeleton

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    skeleton, reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    morph_skeleton is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(751) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        region_skeleton = HObject(proc.get_output_object_key(1))
        return region_skeleton  # type: ignore


def morph_skiz(
    region: HObject,
    iterations_1: Union[int, str],
    iterations_2: Union[int, str]
) -> HObject:
    """
    Thinning of a region.

    Parameters
    ----------

    region : HObject
             Regions to be thinned.

    iterations_1 : Union[int, str]
                   Number of iterations for the sequential thinning with
                   the element 'l' of the Golay alphabet.
                   Value Suggestion: 100

    iterations_2 : Union[int, str]
                   Number of iterations for the sequential thinning with
                   the element 'e' of the Golay alphabet.
                   Value Suggestion: 1

    Returns
    -------

    region_skiz : HObject
                  Result of the skiz operator.

    See Also
    --------
    thinning, hit_or_miss_seq, difference

    Alternatives
    ------------
    skeleton, thinning_seq, morph_skeleton, interjacent

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    pruning, reduce_domain, select_shape, area_center, connection,
    background_seg, complement

    Warnings
    --------
    morph_skiz is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(750) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, iterations_1)
        proc.set_input_tuple(1, iterations_2)
        proc.execute()
        region_skiz = HObject(proc.get_output_object_key(1))
        return region_skiz  # type: ignore


def move_rectangle(
    window_handle: HHandle,
    row_1: MaybeSequence[int],
    column_1: MaybeSequence[int],
    row_2: MaybeSequence[int],
    column_2: MaybeSequence[int],
    dest_row: MaybeSequence[int],
    dest_column: MaybeSequence[int]
) -> None:
    """
    Copy inside an output window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1 : MaybeSequence[int]
            Row index of upper left corner of the source rectangle.
            Value Suggestion: 0

    column_1 : MaybeSequence[int]
               Column index of upper left corner of the source rectangle.
               Value Suggestion: 0

    row_2 : MaybeSequence[int]
            Row index of lower right corner of the source rectangle.
            Value Suggestion: 64

    column_2 : MaybeSequence[int]
               Column index of lower right corner of the source rectangle.
               Value Suggestion: 64

    dest_row : MaybeSequence[int]
               Row index of upper left corner of the target position.
               Value Suggestion: 64

    dest_column : MaybeSequence[int]
                  Column index of upper left corner of the target position.
                  Value Suggestion: 64

    See Also
    --------
    open_window

    Alternatives
    ------------
    copy_rectangle

    Predecessors
    ------------
    open_window

    Warnings
    --------
    move_rectangle is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1180) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1)
        proc.set_input_tuple(2, column_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.set_input_tuple(5, dest_row)
        proc.set_input_tuple(6, dest_column)
        proc.execute()


def move_region(region: HObject, row: int, column: int) -> HObject:
    """
    Translate a region.

    Parameters
    ----------

    region : HObject
             Region(s) to be moved.

    row : int
          Row coordinate of the vector by which the region is to be moved.
          Value Suggestion: 30

    column : int
             Row coordinate of the vector by which the region is to be
             moved.
             Value Suggestion: 30

    Returns
    -------

    region_moved : HObject
                   Translated region(s).

    See Also
    --------
    affine_trans_image, mirror_region, zoom_region

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(491) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.execute()
        region_moved = HObject(proc.get_output_object_key(1))
        return region_moved  # type: ignore


def mult_element_matrix(
    matrix_aid: HHandle,
    matrix_bid: HHandle
) -> HHandle:
    """
    Multiply matrices element-by-element.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    Returns
    -------

    matrix_mult_id : HHandle
                     Matrix handle with the multiplied values of the input
                     matrices.

    See Also
    --------
    div_element_matrix, div_element_matrix_mod, scale_matrix,
    scale_matrix_mod

    Alternatives
    ------------
    mult_element_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(875) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.init_oct(0)
        proc.execute()
        matrix_mult_id = proc.get_output_tuple_s(0)
        return matrix_mult_id  # type: ignore


def mult_element_matrix_mod(
    matrix_aid: HHandle,
    matrix_bid: HHandle
) -> None:
    """
    Multiply matrices element-by-element.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    See Also
    --------
    div_element_matrix, div_element_matrix_mod, scale_matrix,
    scale_matrix_mod

    Alternatives
    ------------
    mult_element_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(874) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.execute()


def mult_image(
    image_1: HObject,
    image_2: HObject,
    mult: Union[int, float],
    add: Union[int, float]
) -> HObject:
    """
    Multiply two images.

    Parameters
    ----------

    image_1 : HObject
              Image(s) 1.

    image_2 : HObject
              Image(s) 2.

    mult : Union[int, float]
           Factor for gray range adaption.
           Value Suggestion: 0.005

    add : Union[int, float]
          Value for gray range adaption.
          Value Suggestion: 0

    Returns
    -------

    image_result : HObject
                   Result image(s) by the product.

    See Also
    --------
    add_image, sub_image, div_image

    Alternatives
    ------------
    add_image, sub_image, div_image
    """
    with HalconOperator(1609) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, mult)
        proc.set_input_tuple(1, add)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def mult_matrix(
    matrix_aid: HHandle,
    matrix_bid: HHandle,
    mult_type: str
) -> HHandle:
    """
    Multiply two matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    mult_type : str
                Type of the input matrices.
                Value Suggestion: AB

    Returns
    -------

    matrix_mult_id : HHandle
                     Matrix handle of the multiplied matrices.

    See Also
    --------
    mult_element_matrix, mult_element_matrix_mod, div_element_matrix,
    div_element_matrix_mod, transpose_matrix, transpose_matrix_mod

    Alternatives
    ------------
    mult_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(883) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.set_input_tuple(2, mult_type)
        proc.init_oct(0)
        proc.execute()
        matrix_mult_id = proc.get_output_tuple_s(0)
        return matrix_mult_id  # type: ignore


def mult_matrix_mod(
    matrix_aid: HHandle,
    matrix_bid: HHandle,
    mult_type: str
) -> None:
    """
    Multiply two matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    mult_type : str
                Type of the input matrices.
                Value Suggestion: AB

    See Also
    --------
    mult_element_matrix, mult_element_matrix_mod, div_element_matrix,
    div_element_matrix_mod, transpose_matrix, transpose_matrix_mod

    Alternatives
    ------------
    mult_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(882) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.set_input_tuple(2, mult_type)
        proc.execute()


def negate_funct_1d(
    function: Sequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Negation of the y values.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    function_inverted : Sequence[Union[float, int]]
                        Function with the negated y values.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1383) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.execute()
        function_inverted = proc.get_output_tuple_m(0)
        return function_inverted  # type: ignore


def new_extern_window(
    winhwnd: int,
    row: int,
    column: int,
    width: int,
    height: int
) -> HHandle:
    """
    Create a virtual graphics window under Windows.

    Parameters
    ----------

    winhwnd : int
              Windows window handle of a previously created window.
              Assertion: WINHWnd != 0

    row : int
          Row coordinate of upper left corner.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : int
             Column coordinate of upper left corner.
             Value Suggestion: 0
             Assertion: Column >= 0

    width : int
            Width of the window.
            Value Suggestion: 512
            Assertion: Width > 0 || Width == -1

    height : int
             Height of the window.
             Value Suggestion: 512
             Assertion: Height > 0 || Height == -1

    Returns
    -------

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    open_window, disp_region, disp_image, disp_color, set_lut,
    query_color, set_color, set_rgb, set_hsi, set_pixel, set_gray,
    set_part, set_part_style, query_window_type, get_window_type,
    set_window_type, get_mposition, set_tposition, set_window_extents,
    get_window_extents, set_window_attr, set_check, set_system

    Alternatives
    ------------
    open_window

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    set_color, query_window_type, get_window_type, set_window_type,
    get_mposition, set_tposition, set_tshape, set_window_extents,
    get_window_extents, query_color, set_check, set_system

    Notes
    -----
    Note that parameters as Row, Column, Width and Height are constrained
    through the output device, i.e., the size of the Windows NT desktop.
    Furthermore, be aware that all operators that allow the user to define
    graphical primitives through mouse interactions, like for example
    draw_rectangle1, do not work on external windows.
    """
    with HalconOperator(1171) as proc:
        proc.set_input_tuple(0, winhwnd)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.init_oct(0)
        proc.execute()
        window_handle = proc.get_output_tuple_s(0)
        return window_handle  # type: ignore


def new_line(window_handle: HHandle) -> None:
    """
    Set the position of the text cursor to the beginning of the next line.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    write_string, set_font

    Alternatives
    ------------
    get_tposition, get_string_extents, set_tposition

    Predecessors
    ------------
    open_window, set_font, write_string
    """
    with HalconOperator(1195) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def noise_distribution_mean(
    const_region: HObject,
    image: HObject,
    filter_size: int
) -> Sequence[float]:
    """
    Determine the noise distribution of an image.

    Parameters
    ----------

    const_region : HObject
                   Region from which the noise distribution is to be
                   estimated.

    image : HObject
            Corresponding image.

    filter_size : int
                  Size of the mean filter.
                  Value Suggestion: 21

    Returns
    -------

    distribution : Sequence[float]
                   Noise distribution of all input regions.

    See Also
    --------
    mean_image, gauss_distribution

    Predecessors
    ------------
    draw_region, gen_circle, gen_ellipse, gen_rectangle1, gen_rectangle2,
    threshold, erosion_circle, binomial_filter, gauss_filter,
    smooth_image, sub_image

    Successors
    ----------
    add_noise_distribution

    Notes
    -----
    It is important to ensure that the region ConstRegion is not too close
    to a large gradient in the image, because the gradient values are then
    used for calculating the mean.  This means the distance of ConstRegion
    must be at least as large as the filter size FilterSize used for
    calculating the mean.
    """
    with HalconOperator(1440) as proc:
        proc.set_input_object(1, const_region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, filter_size)
        proc.init_oct(0)
        proc.execute()
        distribution = proc.get_output_tuple_m(0)
        return distribution  # type: ignore


def nonmax_suppression_amp(img_amp: HObject, mode: str) -> HObject:
    """
    Suppress non-maximum points on an edge.

    Parameters
    ----------

    img_amp : HObject
              Amplitude (gradient magnitude) image.

    mode : str
           Select horizontal/vertical or undirected NMS.
           Value Suggestion: hvnms

    Returns
    -------

    image_result : HObject
                   Image with thinned edge regions.

    See Also
    --------
    skeleton

    Alternatives
    ------------
    local_max, nonmax_suppression_dir

    Predecessors
    ------------
    sobel_amp

    Successors
    ----------
    threshold, hysteresis_threshold
    """
    with HalconOperator(446) as proc:
        proc.set_input_object(1, img_amp)
        proc.set_input_tuple(0, mode)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def nonmax_suppression_dir(
    img_amp: HObject,
    img_dir: HObject,
    mode: str
) -> HObject:
    """
    Suppress non-maximum points on an edge using a direction image.

    Parameters
    ----------

    img_amp : HObject
              Amplitude (gradient magnitude) image.

    img_dir : HObject
              Direction image.

    mode : str
           Select non-maximum-suppression or interpolating NMS.
           Value Suggestion: nms

    Returns
    -------

    image_result : HObject
                   Image with thinned edge regions.

    See Also
    --------
    skeleton

    Alternatives
    ------------
    nonmax_suppression_amp

    Predecessors
    ------------
    edges_image, sobel_dir, frei_dir

    Successors
    ----------
    threshold, hysteresis_threshold
    """
    with HalconOperator(447) as proc:
        proc.set_input_object(1, img_amp)
        proc.set_input_object(2, img_dir)
        proc.set_input_tuple(0, mode)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def norm_matrix(matrix_id: HHandle, norm_type: str) -> float:
    """
    Norm of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    norm_type : str
                Type of norm.
                Value Suggestion: 2-norm

    Returns
    -------

    value : float
            Norm of the input matrix.

    See Also
    --------
    sum_matrix, mean_matrix

    Predecessors
    ------------
    create_matrix
    """
    with HalconOperator(869) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, norm_type)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def num_points_funct_1d(function: Sequence[Union[float, int]]) -> int:
    """
    Number of control points of the function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    length : int
             Number of control points.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1387) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_s(0)
        return length  # type: ignore


def obj_diff(objects: HObject, objects_sub: HObject) -> HObject:
    """
    Calculate the difference of two object tuples.

    Parameters
    ----------

    objects : HObject
              Object tuple 1.

    objects_sub : HObject
                  Object tuple 2.

    Returns
    -------

    objects_diff : HObject
                   Objects from Objects that are not part of ObjectsSub.

    See Also
    --------
    test_equal_obj, count_obj, copy_obj, select_obj

    Notes
    -----
    Image matrices and XLDs are not compared regarding their contents.
    Thus, two images or XLDs, respectively, are ``equal'' if they are
    located at the same place in the storage. By contrast, regions that
    are not located at the same place in the storage are compared
    regarding their actual contents.
    """
    with HalconOperator(573) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_object(2, objects_sub)
        proc.execute()
        objects_diff = HObject(proc.get_output_object_key(1))
        return objects_diff  # type: ignore


def obj_to_integer(
    objects: HObject,
    index: int,
    number: int
) -> Sequence[int]:
    """
    Convert an iconic object into an ``integer number.''

    Parameters
    ----------

    objects : HObject
              Objects for which the surrogates are to be returned.

    index : int
            Starting index of the surrogates to be returned.
            Value Suggestion: 1

    number : int
             Number of surrogates to be returned.
             Value Suggestion: -1
             Assertion: Number == -1 || Number + Index <= number(Objects)

    Returns
    -------

    surrogate_tuple : Sequence[int]
                      Tuple containing the surrogates.

    See Also
    --------
    integer_to_obj, count_obj

    Alternatives
    ------------
    copy_obj, select_obj, copy_image, gen_image_proto

    Notes
    -----
    The objects' data is not duplicated.
    """
    with HalconOperator(582) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_tuple(0, index)
        proc.set_input_tuple(1, number)
        proc.init_oct(0)
        proc.execute()
        surrogate_tuple = proc.get_output_tuple_m(0)
        return surrogate_tuple  # type: ignore


def obj_to_integer_s(objects: HObject, index: int, number: int) -> int:
    """
    Convert an iconic object into an ``integer number.''

    Parameters
    ----------

    objects : HObject
              Objects for which the surrogates are to be returned.

    index : int
            Starting index of the surrogates to be returned.
            Value Suggestion: 1

    number : int
             Number of surrogates to be returned.
             Value Suggestion: -1
             Assertion: Number == -1 || Number + Index <= number(Objects)

    Returns
    -------

    surrogate_tuple : int
                      Tuple containing the surrogates.

    See Also
    --------
    integer_to_obj, count_obj

    Alternatives
    ------------
    copy_obj, select_obj, copy_image, gen_image_proto

    Notes
    -----
    The objects' data is not duplicated.
    """
    with HalconOperator(582) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_tuple(0, index)
        proc.set_input_tuple(1, number)
        proc.init_oct(0)
        proc.execute()
        surrogate_tuple = proc.get_output_tuple_s(0)
        return surrogate_tuple  # type: ignore


def object_model_3d_to_xyz(
    object_model_3d: MaybeSequence[HHandle],
    type: str,
    cam_param: Sequence[Union[float, int, str]],
    pose: Sequence[Union[int, float]]
) -> Tuple[HObject, HObject, HObject]:
    """
    Transform 3D points from a 3D object model to images.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    type : str
           Type of the conversion.
           Value Suggestion: cartesian

    cam_param : Sequence[Union[float, int, str]]
                Camera parameters.

    pose : Sequence[Union[int, float]]
           Pose of the 3D object model.

    Returns
    -------

    x : HObject
        Image with the X-Coordinates of the 3D points.

    y : HObject
        Image with the Y-Coordinates of the 3D points.

    z : HObject
        Image with the Z-Coordinates of the 3D points.

    See Also
    --------
    xyz_to_object_model_3d, get_object_model_3d_params

    Alternatives
    ------------
    project_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    triangulate_object_model_3d

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1092) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, type)
        proc.set_input_tuple(2, cam_param)
        proc.set_input_tuple(3, pose)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # x
            HObject(proc.get_output_object_key(2)),  # y
            HObject(proc.get_output_object_key(3))   # z
        )  # type: ignore


def ocr_change_char(ocr_handle: HHandle, character: Sequence[str]) -> None:
    """
    Define a new conversion table for the characters.

    Parameters
    ----------

    ocr_handle : HHandle
                 ID of the OCR-network to be changed.

    character : Sequence[str]
                New assign of characters.
                Value Suggestion: ['a','b','c']

    Predecessors
    ------------
    read_ocr

    Successors
    ----------
    do_ocr_multi_class_mlp, do_ocr_single_class_mlp

    Warnings
    --------
    ocr_change_char is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(721) as proc:
        proc.set_input_tuple(0, ocr_handle)
        proc.set_input_tuple(1, character)
        proc.execute()


def ocr_get_features(
    character: HObject,
    ocr_handle: HHandle
) -> Sequence[float]:
    """
    Access the features which correspond to a character.

    Parameters
    ----------

    character : HObject
                Characters to be trained.

    ocr_handle : HHandle
                 ID of the desired OCR-classifier.

    Returns
    -------

    feature_vector : Sequence[float]
                     Feature vector.

    See Also
    --------
    trainf_ocr_class_box, traind_ocr_class_box

    Predecessors
    ------------
    read_ocr, reduce_domain, threshold, connection

    Warnings
    --------
    ocr_get_features is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(727) as proc:
        proc.set_input_object(1, character)
        proc.set_input_tuple(0, ocr_handle)
        proc.init_oct(0)
        proc.execute()
        feature_vector = proc.get_output_tuple_m(0)
        return feature_vector  # type: ignore


def open_compute_device(device_identifier: int) -> HHandle:
    """
    Open a compute device.

    Parameters
    ----------

    device_identifier : int
                        Compute device Identifier.

    Returns
    -------

    device_handle : HHandle
                    Compute device handle.

    Predecessors
    ------------
    query_available_compute_devices

    Successors
    ----------
    activate_compute_device, init_compute_device
    """
    with HalconOperator(304) as proc:
        proc.set_input_tuple(0, device_identifier)
        proc.init_oct(0)
        proc.execute()
        device_handle = proc.get_output_tuple_s(0)
        return device_handle  # type: ignore


def open_file(file_name: str, file_type: MaybeSequence[str]) -> HHandle:
    """
    Open a file in text or binary format.

    Parameters
    ----------

    file_name : str
                Name of file to be opened.
                Value Suggestion: standard

    file_type : MaybeSequence[str]
                Type of file access and optional the string encoding.
                Value Suggestion: output

    Returns
    -------

    file_handle : HHandle
                  File handle.

    See Also
    --------
    close_file

    Successors
    ----------
    fwrite_string, fread_char, fread_string, fread_line,
    fread_serialized_item, fwrite_serialized_item, fread_bytes,
    fwrite_bytes, close_file
    """
    with HalconOperator(1659) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, file_type)
        proc.init_oct(0)
        proc.execute()
        file_handle = proc.get_output_tuple_s(0)
        return file_handle  # type: ignore


def open_framegrabber(
    name: str,
    horizontal_resolution: int,
    vertical_resolution: int,
    image_width: int,
    image_height: int,
    start_row: int,
    start_column: int,
    field: str,
    bits_per_channel: MaybeSequence[int],
    color_space: MaybeSequence[str],
    generic: MaybeSequence[Union[str, float, int]],
    external_trigger: str,
    camera_type: MaybeSequence[str],
    device: MaybeSequence[str],
    port: MaybeSequence[int],
    line_in: MaybeSequence[int]
) -> HHandle:
    """
    Open and configure an image acquisition device.

    Parameters
    ----------

    name : str
           HALCON image acquisition interface name, i.e., name of the
           corresponding DLL (Windows) or shared library (Linux/macOS).
           Value Suggestion: File

    horizontal_resolution : int
                            Desired horizontal resolution of image
                            acquisition interface (absolute value or 1 for
                            full resolution, 2 for half resolution, or 4
                            for quarter resolution).
                            Value Suggestion: 1

    vertical_resolution : int
                          Desired vertical resolution of image acquisition
                          interface (absolute value or 1 for full
                          resolution, 2 for half resolution, or 4 for
                          quarter resolution).
                          Value Suggestion: 1

    image_width : int
                  Width of desired image part (absolute value or 0 for
                  HorizontalResolution - 2*StartColumn).
                  Value Suggestion: 0

    image_height : int
                   Height of desired image part (absolute value or 0 for
                   VerticalResolution - 2*StartRow).
                   Value Suggestion: 0

    start_row : int
                Line number of upper left corner of desired image part (or
                border height if ImageHeight = 0).
                Value Suggestion: 0

    start_column : int
                   Column number of upper left corner of desired image
                   part (or border width if ImageWidth = 0).
                   Value Suggestion: 0

    field : str
            Desired half image or full image.
            Value Suggestion: default

    bits_per_channel : MaybeSequence[int]
                       Number of transferred bits per pixel and image
                       channel (-1: device-specific default value).
                       Value Suggestion: -1

    color_space : MaybeSequence[str]
                  Output color format of the grabbed images, typically
                  'gray' or 'raw' for single-channel or 'rgb' or 'yuv' for
                  three-channel images ('default': device-specific default
                  value).
                  Value Suggestion: default

    generic : MaybeSequence[Union[str, float, int]]
              Generic parameter with device-specific meaning.
              Value Suggestion: -1

    external_trigger : str
                       External triggering.
                       Value Suggestion: default

    camera_type : MaybeSequence[str]
                  Type of used camera ('default': device-specific default
                  value).
                  Value Suggestion: default

    device : MaybeSequence[str]
             Device the image acquisition device is connected to
             ('default': device-specific default value).
             Value Suggestion: default

    port : MaybeSequence[int]
           Port the image acquisition device is connected to (-1:
           device-specific default value).
           Value Suggestion: -1

    line_in : MaybeSequence[int]
              Camera input line of multiplexer (-1: device-specific
              default value).
              Value Suggestion: -1

    Returns
    -------

    acq_handle : HHandle
                 Handle of the opened image acquisition device.

    See Also
    --------
    info_framegrabber, close_framegrabber, grab_image

    Predecessors
    ------------
    info_framegrabber

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async, set_framegrabber_param, set_framegrabber_callback

    Notes
    -----
    Due to the multitude of supported image acquisition devices,
    open_framegrabber contains a large number of parameters.  However, not
    all parameters are needed for a specific image acquisition device.
    For a multithreaded application all image acquisition operators, i.e.,
    info_framegrabber, open_framegrabber, get_framegrabber_param,
    set_framegrabber_param, get_framegrabber_callback,
    set_framegrabber_callback, get_framegrabber_lut, set_framegrabber_lut,
    grab_image_start, grab_image, grab_image_async, grab_data,
    grab_data_async, close_framegrabber and close_all_framegrabbers are an
    own group in which info_framegrabber, open_framegrabber,
    close_framegrabber and close_all_framegrabbers are executed
    exclusively.
    Thus, info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers block the concurrent execution of all other
    operators within this group, but run in parallel with all
    non-exclusive operators outside of this group.
    On Windows Systems, error dialog boxes from the operating system can
    occur  when dependency modules of the interface are not found, e.g.,
    the according  SDK was not installed. The occurrence of the error
    boxes can be controlled  by setting Windows' Error Mode. Please refer
    to the description of  SetErrorMode within the Windows MSDN
    documentation.
    """
    with HalconOperator(2037) as proc:
        proc.set_input_tuple(0, name)
        proc.set_input_tuple(1, horizontal_resolution)
        proc.set_input_tuple(2, vertical_resolution)
        proc.set_input_tuple(3, image_width)
        proc.set_input_tuple(4, image_height)
        proc.set_input_tuple(5, start_row)
        proc.set_input_tuple(6, start_column)
        proc.set_input_tuple(7, field)
        proc.set_input_tuple(8, bits_per_channel)
        proc.set_input_tuple(9, color_space)
        proc.set_input_tuple(10, generic)
        proc.set_input_tuple(11, external_trigger)
        proc.set_input_tuple(12, camera_type)
        proc.set_input_tuple(13, device)
        proc.set_input_tuple(14, port)
        proc.set_input_tuple(15, line_in)
        proc.init_oct(0)
        proc.execute()
        acq_handle = proc.get_output_tuple_s(0)
        return acq_handle  # type: ignore


def open_io_channel(
    iodevice_handle: HHandle,
    iochannel_name: MaybeSequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> Sequence[HHandle]:
    """
    Open and configure I/O channels.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    iochannel_name : MaybeSequence[str]
                     HALCON I/O channel names of the specified device.

    gen_param_name : Sequence[str]
                     Parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Parameter values.
                      Value Suggestion: []

    Returns
    -------

    iochannel_handle : Sequence[HHandle]
                       Handles of the opened I/O channel.

    Predecessors
    ------------
    open_io_device, query_io_device

    Successors
    ----------
    set_io_channel_param, read_io_channel, write_io_channel
    """
    with HalconOperator(2016) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, iochannel_name)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        iochannel_handle = proc.get_output_tuple_m(0)
        return iochannel_handle  # type: ignore


def open_io_channel_s(
    iodevice_handle: HHandle,
    iochannel_name: MaybeSequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Open and configure I/O channels.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    iochannel_name : MaybeSequence[str]
                     HALCON I/O channel names of the specified device.

    gen_param_name : Sequence[str]
                     Parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Parameter values.
                      Value Suggestion: []

    Returns
    -------

    iochannel_handle : HHandle
                       Handles of the opened I/O channel.

    Predecessors
    ------------
    open_io_device, query_io_device

    Successors
    ----------
    set_io_channel_param, read_io_channel, write_io_channel
    """
    with HalconOperator(2016) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, iochannel_name)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        iochannel_handle = proc.get_output_tuple_s(0)
        return iochannel_handle  # type: ignore


def open_io_device(
    iointerface_name: str,
    iodevice_name: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Open and configure an I/O device.

    Parameters
    ----------

    iointerface_name : str
                       HALCON I/O interface name.
                       Value Suggestion: []

    iodevice_name : str
                    I/O device name.
                    Value Suggestion: []

    gen_param_name : Sequence[str]
                     Dynamic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Dynamic parameter values.
                      Value Suggestion: []

    Returns
    -------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    Predecessors
    ------------
    query_io_interface

    Successors
    ----------
    set_io_device_param, get_io_device_param, open_io_channel

    Notes
    -----
    On Windows Systems, error dialog boxes from the operating system can
    occur when dependency modules of the interface are not found, e.g.,
    the according SDK was not installed. The occurrence of the error boxes
    can be controlled by setting Windows' Error Mode. Please refer to the
    description of SetErrorMode within the Windows MSDN documentation.
    """
    with HalconOperator(2022) as proc:
        proc.set_input_tuple(0, iointerface_name)
        proc.set_input_tuple(1, iodevice_name)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        iodevice_handle = proc.get_output_tuple_s(0)
        return iodevice_handle  # type: ignore


def open_serial(port_name: str) -> HHandle:
    """
    Open a serial device.

    Parameters
    ----------

    port_name : str
                Name of the serial port.
                Value Suggestion: 'COM1'

    Returns
    -------

    serial_handle : HHandle
                    Serial interface handle.

    See Also
    --------
    set_serial_param, get_serial_param, open_file

    Successors
    ----------
    set_serial_param, read_serial, write_serial, close_serial
    """
    with HalconOperator(314) as proc:
        proc.set_input_tuple(0, port_name)
        proc.init_oct(0)
        proc.execute()
        serial_handle = proc.get_output_tuple_s(0)
        return serial_handle  # type: ignore


def open_socket_accept(
    port: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> HHandle:
    """
    Open a socket that accepts connection requests.

    Parameters
    ----------

    port : int
           Port number.
           Value Suggestion: 3000

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the socket.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Values of the generic parameters that can be
                      adjusted for the socket.
                      Value Suggestion: []

    Returns
    -------

    accepting_socket : HHandle
                       Socket number.

    See Also
    --------
    open_socket_connect, close_socket, get_socket_param, set_socket_param,
    send_image, receive_image, send_region, receive_region, send_tuple,
    receive_tuple, send_data, receive_data

    Successors
    ----------
    socket_accept_connect
    """
    with HalconOperator(343) as proc:
        proc.set_input_tuple(0, port)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        accepting_socket = proc.get_output_tuple_s(0)
        return accepting_socket  # type: ignore


def open_socket_connect(
    host_name: str,
    port: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> HHandle:
    """
    Open a socket and connect it to an accepting socket.

    Parameters
    ----------

    host_name : str
                Hostname of the computer to connect to.
                Value Suggestion: localhost

    port : int
           Port number.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the socket.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Values of the generic parameters that can be
                      adjusted for the socket.
                      Value Suggestion: []

    Returns
    -------

    socket : HHandle
             Socket number.

    See Also
    --------
    open_socket_accept, socket_accept_connect, get_socket_param,
    set_socket_param, close_socket

    Successors
    ----------
    send_image, receive_image, send_region, receive_region, send_tuple,
    receive_tuple, send_data, receive_data
    """
    with HalconOperator(342) as proc:
        proc.set_input_tuple(0, host_name)
        proc.set_input_tuple(1, port)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        socket = proc.get_output_tuple_s(0)
        return socket  # type: ignore


def open_textwindow(
    row: int,
    column: int,
    width: int,
    height: int,
    border_width: int,
    border_color: str,
    background_color: str,
    father_window: Union[int, str],
    mode: str,
    machine: str
) -> HHandle:
    """
    Open a textual window.

    Parameters
    ----------

    row : int
          Row index of upper left corner.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : int
             Column index of upper left corner.
             Value Suggestion: 0
             Assertion: Column >= 0

    width : int
            Window's width.
            Value Suggestion: 256
            Assertion: Width > 0

    height : int
             Window's height.
             Value Suggestion: 256
             Assertion: Height > 0

    border_width : int
                   Window border's width.
                   Value Suggestion: 2
                   Assertion: BorderWidth >= 0

    border_color : str
                   Window border's color.
                   Value Suggestion: white

    background_color : str
                       Background color.
                       Value Suggestion: black

    father_window : Union[int, str]
                    Logical number of the father window. For the display
                    as father you may specify 'root' or 0.
                    Value Suggestion: 0
                    Assertion: FatherWindow >= 0

    mode : str
           Window mode.
           Value Suggestion: visible

    machine : str
              Computer name, where the window has to be opened or empty
              string.
              Value Suggestion: ''

    Returns
    -------

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    write_string, read_string, new_line, get_string_extents,
    get_tposition, set_color, query_window_type, get_window_type,
    set_window_type, get_mposition, set_tposition, set_tshape,
    set_window_extents, get_window_extents, query_color, set_check,
    set_system

    Alternatives
    ------------
    open_window

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    set_color, query_window_type, get_window_type, set_window_type,
    get_mposition, set_tposition, set_tshape, set_window_extents,
    get_window_extents, query_color, set_check, set_system

    Warnings
    --------
    open_textwindow is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  operator
    open_window instead.

    Notes
    -----
    You have to keep in mind that parameters like Row, Column, Width and
    Height are restricted by the output device. Is a father window
    (FatherWindow $ <> $ 'root') specified, then the coordinates are
    relative to this window.
    """
    with HalconOperator(1179) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.set_input_tuple(4, border_width)
        proc.set_input_tuple(5, border_color)
        proc.set_input_tuple(6, background_color)
        proc.set_input_tuple(7, father_window)
        proc.set_input_tuple(8, mode)
        proc.set_input_tuple(9, machine)
        proc.init_oct(0)
        proc.execute()
        window_handle = proc.get_output_tuple_s(0)
        return window_handle  # type: ignore


def open_window(
    row: int,
    column: int,
    width: int,
    height: int,
    father_window: Union[int, str],
    mode: str,
    machine: str
) -> HHandle:
    """
    Open a graphics window.

    Parameters
    ----------

    row : int
          Row index of upper left corner.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : int
             Column index of upper left corner.
             Value Suggestion: 0
             Assertion: Column >= 0

    width : int
            Width of the window.
            Value Suggestion: 256
            Assertion: 0 < Width <= 32768 || Width == -1

    height : int
             Height of the window.
             Value Suggestion: 256
             Assertion: 0 < Height <= 32768 || Height == -1

    father_window : Union[int, str]
                    Logical number of the father window. To specify the
                    display as father you may enter 'root' or 0.
                    Value Suggestion: 0
                    Assertion: FatherWindow >= 0

    mode : str
           Window mode.
           Value Suggestion: visible

    machine : str
              Name of the computer on which you want to open the window.
              Otherwise the empty string.
              Value Suggestion: ''

    Returns
    -------

    window_handle : HHandle
                    Window handle.

    See Also
    --------
    disp_region, disp_image, disp_color, set_lut, query_color, set_color,
    set_rgb, set_hsi, set_pixel, set_gray, set_part, set_part_style,
    query_window_type, get_window_type, set_window_type, get_mposition,
    set_tposition, set_window_extents, get_window_extents,
    set_window_attr, set_check, set_system

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    set_color, query_window_type, get_window_type, set_window_type,
    get_mposition, set_tposition, set_tshape, set_window_extents,
    get_window_extents, query_color, set_check, set_system

    Notes
    -----
    You may keep in mind that parameters as Row, Column, Width and Height
    are constrained by the output device. If you specify a father window
    (FatherWindow $ < > $ 'root') the coordinates are relative to this
    window.
    """
    with HalconOperator(1178) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.set_input_tuple(4, father_window)
        proc.set_input_tuple(5, mode)
        proc.set_input_tuple(6, machine)
        proc.init_oct(0)
        proc.execute()
        window_handle = proc.get_output_tuple_s(0)
        return window_handle  # type: ignore


def opening(region: HObject, struct_element: HObject) -> HObject:
    """
    Open a region.

    Parameters
    ----------

    region : HObject
             Regions to be opened.

    struct_element : HObject
                     Structuring element (position-invariant).

    Returns
    -------

    region_opening : HObject
                     Opened regions.

    See Also
    --------
    gen_circle, gen_rectangle2, gen_region_polygon

    Alternatives
    ------------
    minkowski_add1, erosion1, opening_circle

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(767) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.execute()
        region_opening = HObject(proc.get_output_object_key(1))
        return region_opening  # type: ignore


def opening_circle(
    region: HObject,
    radius: Union[float, int]
) -> HObject:
    """
    Open a region with a circular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be opened.

    radius : Union[float, int]
             Radius of the circular structuring element.
             Value Suggestion: 3.5

    Returns
    -------

    region_opening : HObject
                     Opened regions.

    See Also
    --------
    transpose_region

    Alternatives
    ------------
    opening, dilation1, minkowski_add1, gen_circle

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(766) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, radius)
        proc.execute()
        region_opening = HObject(proc.get_output_object_key(1))
        return region_opening  # type: ignore


def opening_golay(
    region: HObject,
    golay_element: str,
    rotation: int
) -> HObject:
    """
    Open a region with an element from the Golay alphabet.

    Parameters
    ----------

    region : HObject
             Regions to be opened.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_opening : HObject
                     Opened regions.

    See Also
    --------
    erosion_golay, dilation_golay, closing_golay, hit_or_miss_golay,
    thinning_golay, thickening_golay, golay_elements

    Alternatives
    ------------
    opening_seg, opening

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    opening_golay is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.  For some
    of the values of Rotation, the resulting regions are identical to the
    input regions.
    """
    with HalconOperator(764) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, rotation)
        proc.execute()
        region_opening = HObject(proc.get_output_object_key(1))
        return region_opening  # type: ignore


def opening_rectangle1(
    region: HObject,
    width: int,
    height: int
) -> HObject:
    """
    Open a region with a rectangular structuring element.

    Parameters
    ----------

    region : HObject
             Regions to be opened.

    width : int
            Width of the structuring rectangle.
            Value Suggestion: 10

    height : int
             Height of the structuring rectangle.
             Value Suggestion: 10

    Returns
    -------

    region_opening : HObject
                     Opened regions.

    Alternatives
    ------------
    opening, gen_rectangle1, dilation_rectangle1, erosion_rectangle1

    Predecessors
    ------------
    threshold, regiongrowing, watersheds, class_ndim_norm

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(765) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        region_opening = HObject(proc.get_output_object_key(1))
        return region_opening  # type: ignore


def opening_seg(region: HObject, struct_element: HObject) -> HObject:
    """
    Separate overlapping regions.

    Parameters
    ----------

    region : HObject
             Regions to be opened.

    struct_element : HObject
                     Structuring element (position-invariant).

    Returns
    -------

    region_opening : HObject
                     Opened regions.

    Alternatives
    ------------
    erosion1, connection, dilation1

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    expand_region, reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    opening_seg is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(763) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.execute()
        region_opening = HObject(proc.get_output_object_key(1))
        return region_opening  # type: ignore


def optical_flow_mg(
    image_t1: HObject,
    image_t2: HObject,
    algorithm: str,
    smoothing_sigma: float,
    integration_sigma: float,
    flow_smoothness: float,
    gradient_constancy: float,
    mgparam_name: MaybeSequence[str],
    mgparam_value: MaybeSequence[Union[str, float, int]]
) -> HObject:
    """
    Compute the optical flow between two images.

    Parameters
    ----------

    image_t1 : HObject
               Input image 1.

    image_t2 : HObject
               Input image 2.

    algorithm : str
                Algorithm for computing the optical flow.
                Value Suggestion: fdrig

    smoothing_sigma : float
                      Standard deviation for initial Gaussian smoothing.
                      Value Suggestion: 0.8
                      Assertion: SmoothingSigma >= 0.0

    integration_sigma : float
                        Standard deviation of the integration filter.
                        Value Suggestion: 1.0
                        Assertion: IntegrationSigma >= 0.0

    flow_smoothness : float
                      Weight of the smoothing term relative to the data
                      term.
                      Value Suggestion: 20.0
                      Assertion: FlowSmoothness >= 0.0

    gradient_constancy : float
                         Weight of the gradient constancy relative to the
                         gray value constancy.
                         Value Suggestion: 5.0
                         Assertion: GradientConstancy >= 0.0

    mgparam_name : MaybeSequence[str]
                   Parameter name(s) for the multigrid algorithm.
                   Value Suggestion: default_parameters

    mgparam_value : MaybeSequence[Union[str, float, int]]
                    Parameter value(s) for the multigrid algorithm.
                    Value Suggestion: accurate

    Returns
    -------

    vector_field : HObject
                   Optical flow.

    See Also
    --------
    unwarp_image_vector_field

    Successors
    ----------
    threshold, vector_field_length
    """
    with HalconOperator(1486) as proc:
        proc.set_input_object(1, image_t1)
        proc.set_input_object(2, image_t2)
        proc.set_input_tuple(0, algorithm)
        proc.set_input_tuple(1, smoothing_sigma)
        proc.set_input_tuple(2, integration_sigma)
        proc.set_input_tuple(3, flow_smoothness)
        proc.set_input_tuple(4, gradient_constancy)
        proc.set_input_tuple(5, mgparam_name)
        proc.set_input_tuple(6, mgparam_value)
        proc.execute()
        vector_field = HObject(proc.get_output_object_key(1))
        return vector_field  # type: ignore


def optimize_aop(
    operator_name: MaybeSequence[str],
    iconic_type: MaybeSequence[str],
    file_name: Union[str, int],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> None:
    """
    Check hardware regarding its potential for automatic operator
    parallelization.

    Parameters
    ----------

    operator_name : MaybeSequence[str]
                    Operators to check
                    Value Suggestion: ''

    iconic_type : MaybeSequence[str]
                  Iconic object types to check
                  Value Suggestion: ''

    file_name : Union[str, int]
                Knowledge file name
                Value Suggestion: ''

    gen_param_name : Sequence[str]
                     Parameter name
                     Value Suggestion: none

    gen_param_value : Sequence[Union[str, float, int]]
                      Parameter value
                      Value Suggestion: none

    Notes
    -----
    During its test loops optimize_aop has to start every examined
    operator several times. Thus, the processing time of optimize_aop can
    be rather  long depending on the operator's parameter settings. It is
    essential for a correct  optimization not run any other
    computation-intensive application  simultaneously on the machine, as
    this would strongly influence the time  measurements of the hardware
    check and thus would lead to wrong results. Note that according to the
    file location  optimize_aop must be called by users with the
    appropriate  privileges for storing the  parallelization information.
    See the operator's description above for more details about these
    subjects.
    """
    with HalconOperator(569) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, iconic_type)
        proc.set_input_tuple(2, file_name)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.execute()


def optimize_fft_speed(width: int, height: int, mode: str) -> None:
    """
    Optimize the runtime of the FFT.

    Parameters
    ----------

    width : int
            Width of the image for which the runtime should be optimized.
            Value Suggestion: 512

    height : int
             Height of the image for which the runtime should be optimized.
             Value Suggestion: 512

    mode : str
           Thoroughness of the search for the optimum runtime.
           Value Suggestion: standard

    See Also
    --------
    optimize_rft_speed

    Alternatives
    ------------
    read_fft_optimization_data

    Successors
    ----------
    fft_generic, fft_image, fft_image_inv, wiener_filter,
    wiener_filter_ni, photometric_stereo, sfs_pentland, sfs_mod_lr,
    sfs_orig_lr, write_fft_optimization_data
    """
    with HalconOperator(1540) as proc:
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, mode)
        proc.execute()


def optimize_rft_speed(width: int, height: int, mode: str) -> None:
    """
    Optimize the runtime of the real-valued FFT.

    Parameters
    ----------

    width : int
            Width of the image for which the runtime should be optimized.
            Value Suggestion: 512

    height : int
             Height of the image for which the runtime should be optimized.
             Value Suggestion: 512

    mode : str
           Thoroughness of the search for the optimum runtime.
           Value Suggestion: standard

    See Also
    --------
    optimize_fft_speed

    Alternatives
    ------------
    read_fft_optimization_data

    Successors
    ----------
    rft_generic, write_fft_optimization_data
    """
    with HalconOperator(1539) as proc:
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, mode)
        proc.execute()


def orientation_points_xld(xld: HObject) -> Sequence[float]:
    """
    Orientation of contours or polygons treated as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    phi : Sequence[float]
          Orientation of the contours or polygons (radians).
          Assertion: - pi < Phi && Phi <= pi

    See Also
    --------
    moments_region_2nd

    Alternatives
    ------------
    orientation_xld, elliptic_axis_points_xld, smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld
    """
    with HalconOperator(1672) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_m(0)
        return phi  # type: ignore


def orientation_points_xld_s(xld: HObject) -> float:
    """
    Orientation of contours or polygons treated as point clouds.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    phi : float
          Orientation of the contours or polygons (radians).
          Assertion: - pi < Phi && Phi <= pi

    See Also
    --------
    moments_region_2nd

    Alternatives
    ------------
    orientation_xld, elliptic_axis_points_xld, smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld
    """
    with HalconOperator(1672) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_s(0)
        return phi  # type: ignore


def orientation_region(regions: HObject) -> Sequence[float]:
    """
    Orientation of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    phi : Sequence[float]
          Orientation of region (arc measure).
          Assertion: - pi <= Phi && Phi < pi

    See Also
    --------
    moments_region_2nd, line_orientation

    Alternatives
    ------------
    elliptic_axis, smallest_rectangle2

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    disp_arrow
    """
    with HalconOperator(1720) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_m(0)
        return phi  # type: ignore


def orientation_region_s(regions: HObject) -> float:
    """
    Orientation of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    phi : float
          Orientation of region (arc measure).
          Assertion: - pi <= Phi && Phi < pi

    See Also
    --------
    moments_region_2nd, line_orientation

    Alternatives
    ------------
    elliptic_axis, smallest_rectangle2

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Successors
    ----------
    disp_arrow
    """
    with HalconOperator(1720) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_s(0)
        return phi  # type: ignore


def orientation_xld(xld: HObject) -> Sequence[float]:
    """
    Orientation of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    phi : Sequence[float]
          Orientation of the contours or polygons (radians).
          Assertion: - pi < Phi && Phi <= pi

    See Also
    --------
    moments_region_2nd

    Alternatives
    ------------
    elliptic_axis_xld, smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1679) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_m(0)
        return phi  # type: ignore


def orientation_xld_s(xld: HObject) -> float:
    """
    Orientation of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    phi : float
          Orientation of the contours or polygons (radians).
          Assertion: - pi < Phi && Phi <= pi

    See Also
    --------
    moments_region_2nd

    Alternatives
    ------------
    elliptic_axis_xld, smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1679) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        phi = proc.get_output_tuple_s(0)
        return phi  # type: ignore


def orthogonal_decompose_matrix(
    matrix_id: HHandle,
    decomposition_type: str,
    output_matrices_type: str,
    compute_orthogonal: str
) -> Tuple[HHandle, HHandle]:
    """
    Perform an orthogonal decomposition of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    decomposition_type : str
                         Method of decomposition.
                         Value Suggestion: qr

    output_matrices_type : str
                           Type of output matrices.
                           Value Suggestion: full

    compute_orthogonal : str
                         Computation of the orthogonal matrix.
                         Value Suggestion: true

    Returns
    -------

    matrix_orthogonal_id : HHandle
                           Matrix handle with the orthogonal part of the
                           decomposed input matrix.

    matrix_triangular_id : HHandle
                           Matrix handle with the triangular part of the
                           decomposed input matrix.

    See Also
    --------
    decompose_matrix, solve_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(844) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, decomposition_type)
        proc.set_input_tuple(2, output_matrices_type)
        proc.set_input_tuple(3, compute_orthogonal)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # matrix_orthogonal_id
            proc.get_output_tuple_s(1)   # matrix_triangular_id
        )  # type: ignore


def overpaint_gray(
    image_destination: HObject,
    image_source: HObject
) -> None:
    """
    Overpaint the gray values of an image.

    Parameters
    ----------

    image_destination : HObject
                        Input image to be painted over.

    image_source : HObject
                   Input image containing the desired gray values.

    See Also
    --------
    paint_region, overpaint_region

    Alternatives
    ------------
    get_image_pointer1, paint_gray, set_grayval, copy_image

    Predecessors
    ------------
    read_image, gen_image_const, gen_image_proto

    Notes
    -----
    overpaint_gray modifies the content of an already existing image
    (ImageDestination). Besides, even other image objects may be affected:
    For example, if you created ImageDestination via copy_obj from another
    image object (or vice versa), overpaint_gray will also modify the
    image matrix of this other image object. Therefore, overpaint_gray
    should only be used to overpaint newly created image objects. Typical
    operators for this task are, e.g., gen_image_const (creates a new
    image with a specified size), gen_image_proto (creates an image with
    the size of a specified prototype image) or copy_image (creates an
    image as the copy of a specified image).
    """
    with HalconOperator(580) as proc:
        proc.set_input_object(1, image_destination)
        proc.set_input_object(2, image_source)
        proc.execute()


def overpaint_region(
    image: HObject,
    region: HObject,
    grayval: MaybeSequence[Union[int, float]],
    type: str
) -> None:
    """
    Overpaint regions in an image.

    Parameters
    ----------

    image : HObject
            Image in which the regions are to be painted.

    region : HObject
             Regions to be painted into the input image.

    grayval : MaybeSequence[Union[int, float]]
              Desired gray values of the regions.
              Value Suggestion: 255.0

    type : str
           Paint regions filled or as boundaries.
           Value Suggestion: fill

    See Also
    --------
    reduce_domain, set_draw, paint_gray, overpaint_gray, gen_image_const

    Alternatives
    ------------
    set_grayval, paint_region, paint_xld

    Predecessors
    ------------
    read_image, gen_image_const, gen_image_proto, reduce_domain

    Notes
    -----
    overpaint_region modifies the content of an already existing image
    (Image). Besides, even other image objects may be affected: For
    example, if you created Image via copy_obj from another image object
    (or vice versa), overpaint_region will also modify the image matrix of
    this other image object. Therefore, overpaint_region should only be
    used to overpaint newly created image objects. Typical operators for
    this task are, e.g., gen_image_const (creates a new image with a
    specified size), gen_image_proto (creates an image with the size of a
    specified prototype image) or copy_image (creates an image as the copy
    of a specified image).
    """
    with HalconOperator(577) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.set_input_tuple(0, grayval)
        proc.set_input_tuple(1, type)
        proc.execute()


def paint_gray(
    image_source: HObject,
    image_destination: HObject
) -> HObject:
    """
    Paint the gray values of an image into another image.

    Parameters
    ----------

    image_source : HObject
                   Input image containing the desired gray values.

    image_destination : HObject
                        Input image to be painted over.

    Returns
    -------

    mixed_image : HObject
                  Result image.

    See Also
    --------
    paint_region, overpaint_region

    Alternatives
    ------------
    get_image_pointer1, set_grayval, copy_image, overpaint_gray

    Predecessors
    ------------
    read_image, gen_image_const, gen_image_proto
    """
    with HalconOperator(579) as proc:
        proc.set_input_object(1, image_source)
        proc.set_input_object(2, image_destination)
        proc.execute()
        mixed_image = HObject(proc.get_output_object_key(1))
        return mixed_image  # type: ignore


def paint_region(
    region: HObject,
    image: HObject,
    grayval: MaybeSequence[Union[int, float]],
    type: str
) -> HObject:
    """
    Paint regions into an image.

    Parameters
    ----------

    region : HObject
             Regions to be painted into the input image.

    image : HObject
            Image in which the regions are to be painted.

    grayval : MaybeSequence[Union[int, float]]
              Desired gray values of the regions.
              Value Suggestion: 255.0

    type : str
           Paint regions filled or as boundaries.
           Value Suggestion: fill

    Returns
    -------

    image_result : HObject
                   Image containing the result.

    See Also
    --------
    reduce_domain, paint_gray, overpaint_gray, set_draw, gen_image_const

    Alternatives
    ------------
    set_grayval, overpaint_region, paint_xld

    Predecessors
    ------------
    read_image, gen_image_const, gen_image_proto, reduce_domain
    """
    with HalconOperator(576) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, grayval)
        proc.set_input_tuple(1, type)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def paint_xld(
    xld: HObject,
    image: HObject,
    grayval: MaybeSequence[Union[int, float]]
) -> HObject:
    """
    Paint XLD objects into an image.

    Parameters
    ----------

    xld : HObject
          XLD objects to be painted into the input image.

    image : HObject
            Image in which the xld objects are to be painted.

    grayval : MaybeSequence[Union[int, float]]
              Desired gray value of the xld object.
              Value Suggestion: 255.0

    Returns
    -------

    image_result : HObject
                   Image containing the result.

    See Also
    --------
    gen_image_const

    Alternatives
    ------------
    set_grayval, paint_gray, paint_region

    Predecessors
    ------------
    read_image, gen_image_const, gen_image_proto, gen_contour_polygon_xld,
    threshold_sub_pix
    """
    with HalconOperator(575) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, grayval)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def partition_dynamic(
    region: HObject,
    distance: float,
    percent: float
) -> HObject:
    """
    Partition a region horizontally at positions of small vertical extent.

    Parameters
    ----------

    region : HObject
             Region to be partitioned.

    distance : float
               Approximate width of the resulting region parts.

    percent : float
              Maximum percental shift of the split position.
              Value Suggestion: 20

    Returns
    -------

    partitioned : HObject
                  Partitioned region.

    See Also
    --------
    intersection, smallest_rectangle1, shape_trans, clip_region

    Alternatives
    ------------
    partition_rectangle

    Predecessors
    ------------
    threshold, connection
    """
    with HalconOperator(479) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, distance)
        proc.set_input_tuple(1, percent)
        proc.execute()
        partitioned = HObject(proc.get_output_object_key(1))
        return partitioned  # type: ignore


def partition_lines(
    row_begin_in: Sequence[int],
    col_begin_in: Sequence[int],
    row_end_in: Sequence[int],
    col_end_in: Sequence[int],
    feature: MaybeSequence[str],
    operation: str,
    min: MaybeSequence[Union[int, float, str]],
    max: MaybeSequence[Union[int, float, str]]
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Partition lines according to various criteria.

    Parameters
    ----------

    row_begin_in : Sequence[int]
                   Row coordinates of the starting points of the input
                   lines.

    col_begin_in : Sequence[int]
                   Column coordinates of the starting points of the input
                   lines.

    row_end_in : Sequence[int]
                 Row coordinates of the ending points of the input lines.

    col_end_in : Sequence[int]
                 Column coordinates  of the ending points of the input
                 lines.

    feature : MaybeSequence[str]
              Features to be used for selection.

    operation : str
                Desired combination of the features.

    min : MaybeSequence[Union[int, float, str]]
          Lower limits of the features or 'min'.
          Value Suggestion: min

    max : MaybeSequence[Union[int, float, str]]
          Upper limits of the features or 'max'.
          Value Suggestion: max

    Returns
    -------

    row_begin_out : Sequence[int]
                    Row coordinates of the starting points of the lines
                    fulfilling the conditions.

    col_begin_out : Sequence[int]
                    Column coordinates of the starting points of the lines
                    fulfilling the conditions.

    row_end_out : Sequence[int]
                  Row coordinates of the ending points of the lines
                  fulfilling the conditions.

    col_end_out : Sequence[int]
                  Column coordinates of the ending points of the lines
                  fulfilling the conditions.

    fail_row_bout : Sequence[int]
                    Row coordinates of the starting points of the lines
                    not fulfilling the conditions.

    fail_col_bout : Sequence[int]
                    Column coordinates of the starting points of the lines
                    not fulfilling the conditions.

    fail_row_eout : Sequence[int]
                    Row coordinates of the ending points of the lines not
                    fulfilling the conditions.

    fail_col_eout : Sequence[int]
                    Column coordinates of the ending points of the lines
                    not fulfilling the conditions.

    See Also
    --------
    select_lines, select_lines_longest, detect_edge_segments, select_shape

    Alternatives
    ------------
    line_orientation, line_position, select_lines, select_lines_longest

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line

    Warnings
    --------
    partition_lines is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    If only one feature is used the value of Operation is meaningless.
    Several features are processed according to the sequence in which they
    are passed.
    """
    with HalconOperator(1737) as proc:
        proc.set_input_tuple(0, row_begin_in)
        proc.set_input_tuple(1, col_begin_in)
        proc.set_input_tuple(2, row_end_in)
        proc.set_input_tuple(3, col_end_in)
        proc.set_input_tuple(4, feature)
        proc.set_input_tuple(5, operation)
        proc.set_input_tuple(6, min)
        proc.set_input_tuple(7, max)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_begin_out
            proc.get_output_tuple_m(1),  # col_begin_out
            proc.get_output_tuple_m(2),  # row_end_out
            proc.get_output_tuple_m(3),  # col_end_out
            proc.get_output_tuple_m(4),  # fail_row_bout
            proc.get_output_tuple_m(5),  # fail_col_bout
            proc.get_output_tuple_m(6),  # fail_row_eout
            proc.get_output_tuple_m(7)   # fail_col_eout
        )  # type: ignore


def partition_rectangle(
    region: HObject,
    width: float,
    height: float
) -> HObject:
    """
    Partition a region into rectangles of approximately equal size.

    Parameters
    ----------

    region : HObject
             Region to be partitioned.

    width : float
            Width of the individual rectangles.

    height : float
             Height of the individual rectangles.

    Returns
    -------

    partitioned : HObject
                  Partitioned region.

    See Also
    --------
    intersection, smallest_rectangle1, shape_trans, clip_region

    Alternatives
    ------------
    partition_dynamic

    Predecessors
    ------------
    threshold, connection
    """
    with HalconOperator(478) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.execute()
        partitioned = HObject(proc.get_output_object_key(1))
        return partitioned  # type: ignore


def phase_correlation_fft(
    image_fft1: HObject,
    image_fft2: HObject
) -> HObject:
    """
    Compute the phase correlation of two images in the frequency domain.

    Parameters
    ----------

    image_fft1 : HObject
                 Fourier-transformed input image 1.

    image_fft2 : HObject
                 Fourier-transformed input image 2.

    Returns
    -------

    image_phase_correlation : HObject
                              Phase correlation of the input images in the
                              frequency domain.

    Alternatives
    ------------
    correlation_fft

    Predecessors
    ------------
    fft_generic, fft_image, rft_generic

    Successors
    ----------
    fft_generic, fft_image_inv, rft_generic

    Notes
    -----
    The filtering is always performed on the entire image, i.e., the
    domain of the image is ignored.
    """
    with HalconOperator(1532) as proc:
        proc.set_input_object(1, image_fft1)
        proc.set_input_object(2, image_fft2)
        proc.execute()
        image_phase_correlation = HObject(proc.get_output_object_key(1))
        return image_phase_correlation  # type: ignore


def phase_deg(image_complex: HObject) -> HObject:
    """
    Return the phase of a complex image in degrees.

    Parameters
    ----------

    image_complex : HObject
                    Input image in frequency domain.

    Returns
    -------

    image_phase : HObject
                  Phase of the image in degrees.

    See Also
    --------
    fft_image_inv

    Alternatives
    ------------
    phase_rad

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1527) as proc:
        proc.set_input_object(1, image_complex)
        proc.execute()
        image_phase = HObject(proc.get_output_object_key(1))
        return image_phase  # type: ignore


def phase_rad(image_complex: HObject) -> HObject:
    """
    Return the phase of a complex image in radians.

    Parameters
    ----------

    image_complex : HObject
                    Input image in frequency domain.

    Returns
    -------

    image_phase : HObject
                  Phase of the image in radians.

    See Also
    --------
    fft_image_inv, fft_generic, rft_generic

    Alternatives
    ------------
    phase_deg

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1528) as proc:
        proc.set_input_object(1, image_complex)
        proc.execute()
        image_phase = HObject(proc.get_output_object_key(1))
        return image_phase  # type: ignore


def photometric_stereo(
    images: HObject,
    slants: Sequence[Union[float, int]],
    tilts: Sequence[Union[float, int]],
    result_type: Sequence[str],
    reconstruction_method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> Tuple[HObject, HObject, HObject]:
    """
    Reconstruct a surface according to the photometric stereo technique.

    Parameters
    ----------

    images : HObject
             Array with at least three input images with different
             directions of illumination.

    slants : Sequence[Union[float, int]]
             Angle between the camera and the direction of  illumination
             (in degrees).
             Value Suggestion: 45.0

    tilts : Sequence[Union[float, int]]
            Angle of the direction of illumination within the object plane
            (in degrees).
            Value Suggestion: 45.0

    result_type : Sequence[str]
                  Types of the requested results.
                  Value Suggestion: all

    reconstruction_method : str
                            Type of the reconstruction method.
                            Value Suggestion: poisson

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    height_field : HObject
                   Reconstructed height field.

    gradient : HObject
               The gradient field of the surface.

    albedo : HObject
             The albedo of the surface.

    Predecessors
    ------------
    optimize_fft_speed

    Notes
    -----
    Note that photometric_stereo assumes square pixels. Additionally, it
    assumes that the heights are computed on a lattice with step width 1
    in object space. If this is not the case, i.e., if the pixel size of
    the camera projected into the object space differs from 1, the
    returned height values must be multiplied by the actual step width
    (value of the pixel size projected into the object space). The size of
    the pixel in object space is computed by dividing the size of the
    pixel in the camera by the magnification of the (telecentric) lens.
    """
    with HalconOperator(399) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, slants)
        proc.set_input_tuple(1, tilts)
        proc.set_input_tuple(2, result_type)
        proc.set_input_tuple(3, reconstruction_method)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # height_field
            HObject(proc.get_output_object_key(2)),  # gradient
            HObject(proc.get_output_object_key(3))   # albedo
        )  # type: ignore


def plane_deviation(
    regions: HObject,
    image: HObject
) -> Sequence[float]:
    """
    Calculate the deviation of the gray values from the approximating
    image plane.

    Parameters
    ----------

    regions : HObject
              Regions, of which the plane deviation is to be calculated.

    image : HObject
            Gray value image.

    Returns
    -------

    deviation : Sequence[float]
                Deviation of the gray values within a region.

    See Also
    --------
    moments_gray_plane

    Alternatives
    ------------
    intensity, gen_image_gray_ramp, sub_image

    Notes
    -----
    Note that the operator plane_deviation only considers  the given
    Regions and ignores any previously set domain of the input image
    Image.  It should be noted that the calculation of Deviation does not
    follow the usual definition.  It is defined to return the value 0.0
    for an image with only one pixel.
    """
    with HalconOperator(1762) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.execute()
        deviation = proc.get_output_tuple_m(0)
        return deviation  # type: ignore


def plane_deviation_s(regions: HObject, image: HObject) -> float:
    """
    Calculate the deviation of the gray values from the approximating
    image plane.

    Parameters
    ----------

    regions : HObject
              Regions, of which the plane deviation is to be calculated.

    image : HObject
            Gray value image.

    Returns
    -------

    deviation : float
                Deviation of the gray values within a region.

    See Also
    --------
    moments_gray_plane

    Alternatives
    ------------
    intensity, gen_image_gray_ramp, sub_image

    Notes
    -----
    Note that the operator plane_deviation only considers  the given
    Regions and ignores any previously set domain of the input image
    Image.  It should be noted that the calculation of Deviation does not
    follow the usual definition.  It is defined to return the value 0.0
    for an image with only one pixel.
    """
    with HalconOperator(1762) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.init_oct(0)
        proc.execute()
        deviation = proc.get_output_tuple_s(0)
        return deviation  # type: ignore


def plateaus(image: HObject) -> HObject:
    """
    Detect all gray value plateaus.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    plateaus : HObject
               Extracted plateaus as regions (one region for each plateau).

    See Also
    --------
    monotony, topographic_sketch, corner_response, texture_laws

    Alternatives
    ------------
    plateaus_center, nonmax_suppression_amp, local_max

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image

    Successors
    ----------
    area_center, get_region_points, select_shape
    """
    with HalconOperator(469) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        plateaus = HObject(proc.get_output_object_key(1))
        return plateaus  # type: ignore


def plateaus_center(image: HObject) -> HObject:
    """
    Detect the centers of all gray value plateaus.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    plateaus : HObject
               Centers of gravity of the extracted plateaus as regions
               (one region for each plateau).

    See Also
    --------
    monotony, topographic_sketch, corner_response, texture_laws

    Alternatives
    ------------
    plateaus, nonmax_suppression_amp, local_max

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image

    Successors
    ----------
    area_center, get_region_points, select_shape
    """
    with HalconOperator(470) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        plateaus = HObject(proc.get_output_object_key(1))
        return plateaus  # type: ignore


def point_line_to_hom_mat2d(
    transformation_type: str,
    px: Sequence[float],
    py: Sequence[float],
    l1x: Sequence[float],
    l1y: Sequence[float],
    l2x: Sequence[float],
    l2y: Sequence[float]
) -> Sequence[float]:
    """
    Approximate an affine transformation from point-to-line
    correspondences.

    Parameters
    ----------

    transformation_type : str
                          Type of the transformation to compute.
                          Value Suggestion: rigid

    px : Sequence[float]
         X coordinates of the original points.

    py : Sequence[float]
         Y coordinates of the original points.

    l1x : Sequence[float]
          X coordinates of the first point on the corresponding line.

    l1y : Sequence[float]
          Y coordinates of the first point on the corresponding line.

    l2x : Sequence[float]
          X coordinates of the second point on the corresponding line.

    l2y : Sequence[float]
          Y coordinates of the second point on the corresponding line.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    See Also
    --------
    vector_to_hom_mat2d, vector_to_aniso, vector_to_similarity,
    vector_to_rigid

    Successors
    ----------
    affine_trans_image, affine_trans_image_size, affine_trans_region,
    affine_trans_contour_xld, affine_trans_polygon_xld,
    affine_trans_point_2d

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(265) as proc:
        proc.set_input_tuple(0, transformation_type)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, l1x)
        proc.set_input_tuple(4, l1y)
        proc.set_input_tuple(5, l2x)
        proc.set_input_tuple(6, l2y)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def points_foerstner(
    image: HObject,
    sigma_grad: Union[float, int],
    sigma_int: Union[float, int],
    sigma_points: Union[float, int],
    thresh_inhom: Union[float, int],
    thresh_shape: float,
    smoothing: str,
    eliminate_doublets: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Detect points of interest using the Frstner operator.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma_grad : Union[float, int]
                 Amount of smoothing used for the calculation of the
                 gradient. If Smoothing is 'mean', SigmaGrad is ignored.
                 Value Suggestion: 1.0
                 Assertion: SigmaGrad > 0.0

    sigma_int : Union[float, int]
                Amount of smoothing used for the integration of the
                gradients.
                Value Suggestion: 2.0
                Assertion: SigmaInt > 0.0

    sigma_points : Union[float, int]
                   Amount of smoothing used in the optimization functions.
                   Value Suggestion: 3.0
                   Assertion: SigmaPoints >= SigmaInt && SigmaPoints > 0.6

    thresh_inhom : Union[float, int]
                   Threshold for the segmentation of inhomogeneous image
                   areas.
                   Value Suggestion: 200
                   Assertion: ThreshInhom >= 0.0

    thresh_shape : float
                   Threshold for the segmentation of point areas.
                   Value Suggestion: 0.3
                   Assertion: 0.0 <= ThreshShape && ThreshShape <= 1.0

    smoothing : str
                Used smoothing method.
                Value Suggestion: gauss

    eliminate_doublets : str
                         Elimination of multiply detected points.
                         Value Suggestion: false

    Returns
    -------

    row_junctions : Sequence[float]
                    Row coordinates of the detected junction points.

    column_junctions : Sequence[float]
                       Column coordinates of the detected junction points.

    co_rrjunctions : Sequence[float]
                     Row part of the covariance matrix of the detected
                     junction points.

    co_rcjunctions : Sequence[float]
                     Mixed part of the covariance matrix of the detected
                     junction points.

    co_ccjunctions : Sequence[float]
                     Column part of the covariance matrix of the detected
                     junction points.

    row_area : Sequence[float]
               Row coordinates of the detected area points.

    column_area : Sequence[float]
                  Column coordinates of the detected area points.

    co_rrarea : Sequence[float]
                Row part of the covariance matrix of the detected area
                points.

    co_rcarea : Sequence[float]
                Mixed part of the covariance matrix of the detected area
                points.

    co_ccarea : Sequence[float]
                Column part of the covariance matrix of the detected area
                points.

    Alternatives
    ------------
    points_harris, points_lepetit, points_harris_binomial

    Successors
    ----------
    gen_cross_contour_xld, disp_cross

    Notes
    -----
    Note that only odd values for SigmaInt and SigmaPoints are allowed, if
    Smoothing is 'mean'. Even values automatically will be replaced by the
    next larger odd value.
    points_foerstner with Smoothing = 'gauss' uses a special
    implementation that is optimized using SSE2 instructions if the system
    parameter 'sse2_enable' is set to 'true' (which is default if SSE2 is
    available on your machine). This implementation is slightly inaccurate
    compared to the pure C version due to numerical issues (for 'byte'
    images the difference in RowJunctions and ColumnJunctions is in order
    of magnitude of $1.0e-5$). If you prefer accuracy over performance you
    can set 'sse2_enable' to 'false' (using set_system) before you call
    points_foerstner. This way points_foerstner does not use SSE2
    accelerations. Don't forget to set 'sse2_enable' back to 'true'
    afterwards.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1438) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma_grad)
        proc.set_input_tuple(1, sigma_int)
        proc.set_input_tuple(2, sigma_points)
        proc.set_input_tuple(3, thresh_inhom)
        proc.set_input_tuple(4, thresh_shape)
        proc.set_input_tuple(5, smoothing)
        proc.set_input_tuple(6, eliminate_doublets)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.init_oct(8)
        proc.init_oct(9)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_junctions
            proc.get_output_tuple_m(1),  # column_junctions
            proc.get_output_tuple_m(2),  # co_rrjunctions
            proc.get_output_tuple_m(3),  # co_rcjunctions
            proc.get_output_tuple_m(4),  # co_ccjunctions
            proc.get_output_tuple_m(5),  # row_area
            proc.get_output_tuple_m(6),  # column_area
            proc.get_output_tuple_m(7),  # co_rrarea
            proc.get_output_tuple_m(8),  # co_rcarea
            proc.get_output_tuple_m(9)   # co_ccarea
        )  # type: ignore


def points_harris(
    image: HObject,
    sigma_grad: float,
    sigma_smooth: float,
    alpha: float,
    threshold: Union[float, int]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Detect points of interest using the Harris operator.

    Parameters
    ----------

    image : HObject
            Input image.

    sigma_grad : float
                 Amount of smoothing used for the calculation of the
                 gradient.
                 Value Suggestion: 0.7
                 Assertion: SigmaGrad > 0.0

    sigma_smooth : float
                   Amount of smoothing used for the integration of the
                   gradients.
                   Value Suggestion: 2.0
                   Assertion: SigmaSmooth > 0.0

    alpha : float
            Weight of the squared trace of the squared gradient matrix.
            Value Suggestion: 0.08
            Assertion: Alpha > 0.0

    threshold : Union[float, int]
                Minimum filter response for the points.
                Value Suggestion: 1000.0
                Assertion: Threshold >= 0.0

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the detected points.

    column : Sequence[float]
             Column coordinates of the detected points.

    Alternatives
    ------------
    points_foerstner, points_lepetit, points_harris_binomial

    Successors
    ----------
    gen_cross_contour_xld

    Notes
    -----
    points_harris uses a special implementation that is optimized using
    SSE2 instructions if the system parameter 'sse2_enable' is set to
    'true' (which is default if SSE2 is available on your machine). This
    implementation is slightly inaccurate compared to the pure C version
    due to numerical issues (for 'byte' images the difference in Row and
    Column is in order of magnitude of $1.0e-5$). If you prefer accuracy
    over performance you can set 'sse2_enable' to  'false' (using
    set_system) before you call points_harris. This way points_harris does
    not use SSE2 accelerations. Don't forget to set 'sse2_enable' back to
    'true' afterwards.
    points_harris can be executed on an OpenCL device if both SigmaGrad
    and SigmaSmooth induce a filter size of no more than 129 pixels. This
    corresponds to a value of less than $20.7$ for both parameters. As
    with the SSE2 version, the results of the OpenCL implementation may
    diverge slightly from that of pure C version due to numerical issues.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1435) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, sigma_grad)
        proc.set_input_tuple(1, sigma_smooth)
        proc.set_input_tuple(2, alpha)
        proc.set_input_tuple(3, threshold)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def points_harris_binomial(
    image: HObject,
    mask_size_grad: int,
    mask_size_smooth: int,
    alpha: float,
    threshold: Union[float, int],
    subpix: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Detect points of interest using the binomial approximation of the
    Harris operator.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_size_grad : int
                     Amount of binomial smoothing used for the calculation
                     of the gradient.
                     Value Suggestion: 5
                     Assertion: MaskSizeGrad > 0

    mask_size_smooth : int
                       Amount of smoothing used for the integration of the
                       gradients.
                       Value Suggestion: 15
                       Assertion: MaskSizeSmooth > 0

    alpha : float
            Weight of the squared trace of the squared gradient matrix.
            Value Suggestion: 0.08
            Assertion: Alpha > 0.0

    threshold : Union[float, int]
                Minimum filter response for the points.
                Value Suggestion: 1000.0
                Assertion: Threshold >= 0.0

    subpix : str
             Turn on or off subpixel refinement.
             Value Suggestion: on

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the detected points.

    column : Sequence[float]
             Column coordinates of the detected points.

    Alternatives
    ------------
    points_foerstner, points_harris, points_lepetit, points_sojka

    Successors
    ----------
    gen_cross_contour_xld

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1436) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_size_grad)
        proc.set_input_tuple(1, mask_size_smooth)
        proc.set_input_tuple(2, alpha)
        proc.set_input_tuple(3, threshold)
        proc.set_input_tuple(4, subpix)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def points_lepetit(
    image: HObject,
    radius: int,
    check_neighbor: int,
    min_check_neighbor_diff: int,
    min_score: int,
    subpix: str
) -> Tuple[Sequence[Union[int, float]], Sequence[Union[int, float]]]:
    """
    Detect points of interest using the Lepetit operator.

    Parameters
    ----------

    image : HObject
            Input image.

    radius : int
             Radius of the circle.
             Value Suggestion: 3

    check_neighbor : int
                     Number of checked neighbors on the circle.
                     Value Suggestion: 1

    min_check_neighbor_diff : int
                              Threshold of gray value difference to each
                              circle point.
                              Value Suggestion: 15

    min_score : int
                Threshold of gray value difference to all circle points.
                Value Suggestion: 30

    subpix : str
             Subpixel accuracy of point coordinates.
             Value Suggestion: interpolation

    Returns
    -------

    row : Sequence[Union[int, float]]
          Row-coordinates of the detected points.

    column : Sequence[Union[int, float]]
             Column-coordinates of the detected points.

    Alternatives
    ------------
    points_foerstner, points_harris, points_harris_binomial, points_sojka

    Predecessors
    ------------
    gauss_filter

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1437) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, radius)
        proc.set_input_tuple(1, check_neighbor)
        proc.set_input_tuple(2, min_check_neighbor_diff)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, subpix)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def points_sojka(
    image: HObject,
    mask_size: int,
    sigma_w: Union[float, int],
    sigma_d: Union[float, int],
    min_grad: Union[int, float],
    min_apparentness: Union[int, float],
    min_angle: float,
    subpix: str
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Find corners using the Sojka operator.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_size : int
                Required filter size.
                Value Suggestion: 9

    sigma_w : Union[float, int]
              Sigma of the weight function according to the distance to
              the corner candidate.
              Value Suggestion: 2.5
              Assertion: 2.0 <= SigmaW && SigmaW <= 3.0

    sigma_d : Union[float, int]
              Sigma of the weight function for the distance to the ideal
              gray value edge.
              Value Suggestion: 0.75
              Assertion: 0.6 <= SigmaD && SigmaD <= 1.0

    min_grad : Union[int, float]
               Threshold for the magnitude of the gradient.
               Value Suggestion: 30.0

    min_apparentness : Union[int, float]
                       Threshold for $Apparentness$Apparentness.
                       Value Suggestion: 90.0

    min_angle : float
                Threshold for the direction change in a corner point
                (radians).
                Value Suggestion: 0.5
                Assertion: 0.0 <= MinAngle && MinAngle <= pi

    subpix : str
             Subpixel precise calculation of the corner points.
             Value Suggestion: false

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the detected corner points.

    column : Sequence[float]
             Column coordinates of the detected corner points.

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1429) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_size)
        proc.set_input_tuple(1, sigma_w)
        proc.set_input_tuple(2, sigma_d)
        proc.set_input_tuple(3, min_grad)
        proc.set_input_tuple(4, min_apparentness)
        proc.set_input_tuple(5, min_angle)
        proc.set_input_tuple(6, subpix)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def polar_trans_contour_xld(
    contour: HObject,
    row: Union[int, float],
    column: Union[int, float],
    angle_start: float,
    angle_end: float,
    radius_start: Union[int, float],
    radius_end: Union[int, float],
    width: int,
    height: int
) -> HObject:
    """
    Transform a contour in an annular arc to polar coordinates.

    Parameters
    ----------

    contour : HObject
              Input contour.

    row : Union[int, float]
          Row coordinate of the center of the arc.
          Value Suggestion: 256
          Assertion: Row >= -131068 && Row <= 131068

    column : Union[int, float]
             Column coordinate of the center of the arc.
             Value Suggestion: 256
             Assertion: Column >= -131068 && Column <= 131068

    angle_start : float
                  Angle of the ray to be mapped to the column coordinate 0
                  of PolarTransContour.
                  Value Suggestion: 0.0

    angle_end : float
                Angle of the ray to be mapped to the column coordinate
                $Width-1$ of PolarTransContour to.
                Value Suggestion: 6.2831853

    radius_start : Union[int, float]
                   Radius of the circle to be mapped to the row coordinate
                   0 of PolarTransContour.
                   Value Suggestion: 0

    radius_end : Union[int, float]
                 Radius of the circle to be mapped to the row coordinate
                 $Height-1$ of PolarTransContour.
                 Value Suggestion: 100

    width : int
            Width of the virtual output image.
            Value Suggestion: 512

    height : int
             Height of the virtual output image.
             Value Suggestion: 512

    Returns
    -------

    polar_trans_contour : HObject
                          Output contour.

    See Also
    --------
    polar_trans_image_ext, polar_trans_image_inv, polar_trans_region,
    polar_trans_region_inv, polar_trans_contour_xld_inv

    Notes
    -----
    Only the contour points are transformed. As the polar transformation
    is not affine, polar_trans_contour_xld only produces reliable results
    if the spacing of the contour points is small. Existing attributes are
    not transformed.
    """
    with HalconOperator(2) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, angle_start)
        proc.set_input_tuple(3, angle_end)
        proc.set_input_tuple(4, radius_start)
        proc.set_input_tuple(5, radius_end)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.execute()
        polar_trans_contour = HObject(proc.get_output_object_key(1))
        return polar_trans_contour  # type: ignore


def polar_trans_contour_xld_inv(
    polar_contour: HObject,
    row: Union[int, float],
    column: Union[int, float],
    angle_start: float,
    angle_end: float,
    radius_start: Union[int, float],
    radius_end: Union[int, float],
    width_in: int,
    height_in: int,
    width: int,
    height: int
) -> HObject:
    """
    Transform a contour in polar coordinates back to Cartesian coordinates

    Parameters
    ----------

    polar_contour : HObject
                    Input contour.

    row : Union[int, float]
          Row coordinate of the center of the arc.
          Value Suggestion: 256
          Assertion: Row >= -131068 && Row <= 131068

    column : Union[int, float]
             Column coordinate of the center of the arc.
             Value Suggestion: 256
             Assertion: Column >= -131068 && Column <= 131068

    angle_start : float
                  Angle of the ray to map the column coordinate 0 of
                  PolarContour to.
                  Value Suggestion: 0.0

    angle_end : float
                Angle of the ray to map the column coordinate $WidthIn-1$
                of PolarContour to.
                Value Suggestion: 6.2831853

    radius_start : Union[int, float]
                   Radius of the circle to map the row coordinate 0 of
                   PolarContour to.
                   Value Suggestion: 0

    radius_end : Union[int, float]
                 Radius of the circle to map the row coordinate
                 $HeightIn-1$ of PolarContour to.
                 Value Suggestion: 100

    width_in : int
               Width of the virtual input image.
               Value Suggestion: 512

    height_in : int
                Height of the virtual input image.
                Value Suggestion: 512

    width : int
            Width of the virtual output image.
            Value Suggestion: 512

    height : int
             Height of the virtual output image.
             Value Suggestion: 512

    Returns
    -------

    xytrans_contour : HObject
                      Output contour.

    See Also
    --------
    polar_trans_image_ext, polar_trans_image_inv, polar_trans_region,
    polar_trans_region_inv, polar_trans_contour_xld

    Notes
    -----
    Only the contour points are transformed. As the polar transformation
    is not affine, polar_trans_contour_xld_inv only produces reliable
    results if the spacing of the contour points is small. Existing
    attributes are not transformed.
    """
    with HalconOperator(1) as proc:
        proc.set_input_object(1, polar_contour)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, angle_start)
        proc.set_input_tuple(3, angle_end)
        proc.set_input_tuple(4, radius_start)
        proc.set_input_tuple(5, radius_end)
        proc.set_input_tuple(6, width_in)
        proc.set_input_tuple(7, height_in)
        proc.set_input_tuple(8, width)
        proc.set_input_tuple(9, height)
        proc.execute()
        xytrans_contour = HObject(proc.get_output_object_key(1))
        return xytrans_contour  # type: ignore


def polar_trans_image(
    image_xy: HObject,
    row: int,
    column: int,
    width: int,
    height: int
) -> HObject:
    """
    Transform an image to polar coordinates

    Parameters
    ----------

    image_xy : HObject
               Input image in Cartesian coordinates.

    row : int
          Row coordinate of the center of the coordinate system.
          Value Suggestion: 100

    column : int
             Column coordinate of the center of the coordinate system.
             Value Suggestion: 100

    width : int
            Width of the result image.
            Value Suggestion: 314

    height : int
             Height of the result image.
             Value Suggestion: 200

    Returns
    -------

    image_polar : HObject
                  Result image in polar coordinates.

    Warnings
    --------
    polar_trans_image is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the operator
    polar_trans_image_ext instead.
    """
    with HalconOperator(1630) as proc:
        proc.set_input_object(1, image_xy)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.execute()
        image_polar = HObject(proc.get_output_object_key(1))
        return image_polar  # type: ignore


def polar_trans_image_ext(
    image: HObject,
    row: Union[int, float],
    column: Union[int, float],
    angle_start: float,
    angle_end: float,
    radius_start: Union[int, float],
    radius_end: Union[int, float],
    width: int,
    height: int,
    interpolation: str
) -> HObject:
    """
    Transform an annular arc in an image to polar coordinates.

    Parameters
    ----------

    image : HObject
            Input image.

    row : Union[int, float]
          Row coordinate of the center of the arc.
          Value Suggestion: 256

    column : Union[int, float]
             Column coordinate of the center of the arc.
             Value Suggestion: 256

    angle_start : float
                  Angle of the ray to be mapped to the first column of the
                  output image.
                  Value Suggestion: 0.0

    angle_end : float
                Angle of the ray to be mapped to the last column of the
                output image.
                Value Suggestion: 6.2831853

    radius_start : Union[int, float]
                   Radius of the circle to be mapped to the first row of
                   the output image.
                   Value Suggestion: 0

    radius_end : Union[int, float]
                 Radius of the circle to be mapped to the last row of the
                 output image.
                 Value Suggestion: 100

    width : int
            Width of the output image.
            Value Suggestion: 512

    height : int
             Height of the output image.
             Value Suggestion: 512

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    polar_trans_image : HObject
                        Output image.

    See Also
    --------
    polar_trans_image_inv, polar_trans_region, polar_trans_region_inv,
    polar_trans_contour_xld, polar_trans_contour_xld_inv

    Notes
    -----
    For speed reasons, the domain of the input image is ignored.  The
    output image always has a complete rectangle as its domain.
    """
    with HalconOperator(1629) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, angle_start)
        proc.set_input_tuple(3, angle_end)
        proc.set_input_tuple(4, radius_start)
        proc.set_input_tuple(5, radius_end)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.set_input_tuple(8, interpolation)
        proc.execute()
        polar_trans_image = HObject(proc.get_output_object_key(1))
        return polar_trans_image  # type: ignore


def polar_trans_image_inv(
    polar_image: HObject,
    row: Union[int, float],
    column: Union[int, float],
    angle_start: float,
    angle_end: float,
    radius_start: Union[int, float],
    radius_end: Union[int, float],
    width: int,
    height: int,
    interpolation: str
) -> HObject:
    """
    Transform an image in polar coordinates back to Cartesian coordinates

    Parameters
    ----------

    polar_image : HObject
                  Input image.

    row : Union[int, float]
          Row coordinate of the center of the arc.
          Value Suggestion: 256

    column : Union[int, float]
             Column coordinate of the center of the arc.
             Value Suggestion: 256

    angle_start : float
                  Angle of the ray to map the first column of the input
                  image to.
                  Value Suggestion: 0.0

    angle_end : float
                Angle of the ray to map the last column of the input image
                to.
                Value Suggestion: 6.2831853

    radius_start : Union[int, float]
                   Radius of the circle to map the first row of the input
                   image to.
                   Value Suggestion: 0

    radius_end : Union[int, float]
                 Radius of the circle to map the last row of the input
                 image to.
                 Value Suggestion: 100

    width : int
            Width of the output image.
            Value Suggestion: 512

    height : int
             Height of the output image.
             Value Suggestion: 512

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    xytrans_image : HObject
                    Output image.

    See Also
    --------
    polar_trans_image_ext, polar_trans_region, polar_trans_region_inv,
    polar_trans_contour_xld, polar_trans_contour_xld_inv
    """
    with HalconOperator(1628) as proc:
        proc.set_input_object(1, polar_image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, angle_start)
        proc.set_input_tuple(3, angle_end)
        proc.set_input_tuple(4, radius_start)
        proc.set_input_tuple(5, radius_end)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.set_input_tuple(8, interpolation)
        proc.execute()
        xytrans_image = HObject(proc.get_output_object_key(1))
        return xytrans_image  # type: ignore


def polar_trans_region(
    region: HObject,
    row: Union[int, float],
    column: Union[int, float],
    angle_start: float,
    angle_end: float,
    radius_start: Union[int, float],
    radius_end: Union[int, float],
    width: int,
    height: int,
    interpolation: str
) -> HObject:
    """
    Transform a region within an annular arc to polar coordinates.

    Parameters
    ----------

    region : HObject
             Input region.

    row : Union[int, float]
          Row coordinate of the center of the arc.
          Value Suggestion: 256
          Assertion: Row >= -131068 && Row <= 131068

    column : Union[int, float]
             Column coordinate of the center of the arc.
             Value Suggestion: 256
             Assertion: Column >= -131068 && Column <= 131068

    angle_start : float
                  Angle of the ray to be mapped to column coordinate 0 of
                  PolarTransRegion.
                  Value Suggestion: 0.0

    angle_end : float
                Angle of the ray to be mapped to column coordinate
                $Width-1$ of PolarTransRegion.
                Value Suggestion: 6.2831853

    radius_start : Union[int, float]
                   Radius of the circle to be mapped to row coordinate 0
                   of PolarTransRegion.
                   Value Suggestion: 0

    radius_end : Union[int, float]
                 Radius of the circle to be mapped to row coordinate
                 $Height-1$ of PolarTransRegion.
                 Value Suggestion: 100

    width : int
            Width of the virtual output image.
            Value Suggestion: 512

    height : int
             Height of the virtual output image.
             Value Suggestion: 512

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    polar_trans_region : HObject
                         Output region.

    See Also
    --------
    polar_trans_image_ext, polar_trans_image_inv, polar_trans_region_inv,
    polar_trans_contour_xld, polar_trans_contour_xld_inv

    Notes
    -----
    If Width or Height are chosen greater than the dimensions of the
    current image, the system variable 'clip_region' should be set to
    'false' (see set_system). Otherwise, an output region that does not
    lie within the dimensions of the current image can produce an error
    message.
    """
    with HalconOperator(476) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, angle_start)
        proc.set_input_tuple(3, angle_end)
        proc.set_input_tuple(4, radius_start)
        proc.set_input_tuple(5, radius_end)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.set_input_tuple(8, interpolation)
        proc.execute()
        polar_trans_region = HObject(proc.get_output_object_key(1))
        return polar_trans_region  # type: ignore


def polar_trans_region_inv(
    polar_region: HObject,
    row: Union[int, float],
    column: Union[int, float],
    angle_start: float,
    angle_end: float,
    radius_start: Union[int, float],
    radius_end: Union[int, float],
    width_in: int,
    height_in: int,
    width: int,
    height: int,
    interpolation: str
) -> HObject:
    """
    Transform a region in polar coordinates back to Cartesian coordinates.

    Parameters
    ----------

    polar_region : HObject
                   Input region.

    row : Union[int, float]
          Row coordinate of the center of the arc.
          Value Suggestion: 256
          Assertion: Row >= -131068 && Row <= 131068

    column : Union[int, float]
             Column coordinate of the center of the arc.
             Value Suggestion: 256
             Assertion: Column >= -131068 && Column <= 131068

    angle_start : float
                  Angle of the ray to map the column coordinate 0 of
                  PolarRegion to.
                  Value Suggestion: 0.0

    angle_end : float
                Angle of the ray to map the column coordinate $WidthIn-1$
                of PolarRegion to.
                Value Suggestion: 6.2831853

    radius_start : Union[int, float]
                   Radius of the circle to map the row coordinate 0 of
                   PolarRegion to.
                   Value Suggestion: 0

    radius_end : Union[int, float]
                 Radius of the circle to map the row coordinate
                 $HeightIn-1$ of PolarRegion to.
                 Value Suggestion: 100

    width_in : int
               Width of the virtual input image.
               Value Suggestion: 512

    height_in : int
                Height of the virtual input image.
                Value Suggestion: 512

    width : int
            Width of the virtual output image.
            Value Suggestion: 512

    height : int
             Height of the virtual output image.
             Value Suggestion: 512

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: nearest_neighbor

    Returns
    -------

    xytrans_region : HObject
                     Output region.

    See Also
    --------
    polar_trans_image_ext, polar_trans_image_inv, polar_trans_region,
    polar_trans_contour_xld, polar_trans_contour_xld_inv

    Notes
    -----
    If Width or Height are chosen greater than the dimensions of the
    current image, the system variable 'clip_region' should be set to
    'false' (see set_system). Otherwise, an output region that does not
    lie within the dimensions of the current image can produce an error
    message.
    """
    with HalconOperator(475) as proc:
        proc.set_input_object(1, polar_region)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, angle_start)
        proc.set_input_tuple(3, angle_end)
        proc.set_input_tuple(4, radius_start)
        proc.set_input_tuple(5, radius_end)
        proc.set_input_tuple(6, width_in)
        proc.set_input_tuple(7, height_in)
        proc.set_input_tuple(8, width)
        proc.set_input_tuple(9, height)
        proc.set_input_tuple(10, interpolation)
        proc.execute()
        xytrans_region = HObject(proc.get_output_object_key(1))
        return xytrans_region  # type: ignore


def pose_average(
    poses: Sequence[int],
    weights: Sequence[Union[float, int]],
    mode: str,
    sigma_t: Union[float, int, str],
    sigma_r: Union[float, int, str]
) -> Tuple[Sequence[Union[float, int]], Sequence[float]]:
    """
    Compute the average of a set of poses.

    Parameters
    ----------

    poses : Sequence[int]
            Set of poses of which the average if computed.

    weights : Sequence[Union[float, int]]
              Empty tuple, or one weight per pose.
              Value Suggestion: []
              Assertion: Weights > 0 && length(Weights) == 0 || length(Weights) == length(Poses) / 7

    mode : str
           Averaging mode.
           Value Suggestion: iterative

    sigma_t : Union[float, int, str]
              Weight of the translation.
              Value Suggestion: auto

    sigma_r : Union[float, int, str]
              Weight of the rotation.
              Value Suggestion: auto

    Returns
    -------

    average_pose : Sequence[Union[float, int]]
                   Weighted mean of the poses.

    quality : Sequence[float]
              Deviation of the mean from the input poses.
              Assertion: length(Quality) == 4

    See Also
    --------
    read_pose, hom_mat3d_to_pose, pose_to_hom_mat3d

    Predecessors
    ------------
    read_pose, hom_mat3d_to_pose
    """
    with HalconOperator(221) as proc:
        proc.set_input_tuple(0, poses)
        proc.set_input_tuple(1, weights)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, sigma_t)
        proc.set_input_tuple(4, sigma_r)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # average_pose
            proc.get_output_tuple_m(1)   # quality
        )  # type: ignore


def pose_compose(
    pose_left: Sequence[Union[float, int]],
    pose_right: Sequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Combine 3D poses given in two tuples.

    Parameters
    ----------

    pose_left : Sequence[Union[float, int]]
                Tuple containing the left poses.

    pose_right : Sequence[Union[float, int]]
                 Tuple containing the right poses.

    Returns
    -------

    pose_compose : Sequence[Union[float, int]]
                   Tuple containing the returned poses.

    See Also
    --------
    pose_to_hom_mat3d, hom_mat3d_to_pose, hom_mat3d_compose

    Alternatives
    ------------
    hom_mat3d_compose, dual_quat_compose

    Predecessors
    ------------
    read_pose, hom_mat3d_to_pose, create_pose, convert_pose_type,
    pose_invert

    Successors
    ----------
    convert_pose_type
    """
    with HalconOperator(228) as proc:
        proc.set_input_tuple(0, pose_left)
        proc.set_input_tuple(1, pose_right)
        proc.init_oct(0)
        proc.execute()
        pose_compose = proc.get_output_tuple_m(0)
        return pose_compose  # type: ignore


def pose_invert(
    pose: Sequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Invert each pose in a tuple of 3D poses.

    Parameters
    ----------

    pose : Sequence[Union[float, int]]
           Tuple of 3D poses.

    Returns
    -------

    pose_invert : Sequence[Union[float, int]]
                  Tuple of inverted 3D poses.

    See Also
    --------
    pose_to_hom_mat3d, hom_mat3d_to_pose

    Alternatives
    ------------
    hom_mat3d_invert, dual_quat_conjugate

    Predecessors
    ------------
    read_pose, hom_mat3d_to_pose, create_pose, convert_pose_type,
    pose_compose

    Successors
    ----------
    convert_pose_type
    """
    with HalconOperator(227) as proc:
        proc.set_input_tuple(0, pose)
        proc.init_oct(0)
        proc.execute()
        pose_invert = proc.get_output_tuple_m(0)
        return pose_invert  # type: ignore


def pose_to_dual_quat(pose: Sequence[Union[float, int]]) -> Sequence[float]:
    """
    Convert a 3D pose to a unit dual quaternion.

    Parameters
    ----------

    pose : Sequence[Union[float, int]]
           3D pose.

    Returns
    -------

    dual_quaternion : Sequence[float]
                      Unit dual quaternion.

    See Also
    --------
    dual_quat_to_hom_mat3d, dual_quat_to_pose, dual_quat_normalize,
    serialize_dual_quat, deserialize_dual_quat, dual_quat_trans_line_3d,
    pose_to_quat

    Alternatives
    ------------
    pose_to_hom_mat3d, screw_to_dual_quat

    Predecessors
    ------------
    create_pose, read_pose

    Successors
    ----------
    dual_quat_compose, dual_quat_interpolate, dual_quat_to_screw,
    dual_quat_conjugate
    """
    with HalconOperator(2080) as proc:
        proc.set_input_tuple(0, pose)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion = proc.get_output_tuple_m(0)
        return dual_quaternion  # type: ignore


def pose_to_hom_mat3d(pose: Sequence[Union[int, float]]) -> Sequence[float]:
    """
    Convert a 3D pose into a homogeneous transformation matrix.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           3D pose.

    Returns
    -------

    hom_mat_3d : Sequence[float]
                 Equivalent homogeneous transformation matrix.

    See Also
    --------
    create_pose, camera_calibration, write_pose, read_pose,
    hom_mat3d_to_pose, project_3d_point, get_line_of_sight,
    hom_mat3d_rotate, hom_mat3d_translate, hom_mat3d_invert,
    affine_trans_point_3d

    Alternatives
    ------------
    pose_to_dual_quat

    Predecessors
    ------------
    camera_calibration, read_pose

    Successors
    ----------
    affine_trans_point_3d, hom_mat3d_invert, hom_mat3d_translate,
    hom_mat3d_rotate, hom_mat3d_to_pose
    """
    with HalconOperator(1935) as proc:
        proc.set_input_tuple(0, pose)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3d = proc.get_output_tuple_m(0)
        return hom_mat_3d  # type: ignore


def pose_to_quat(pose: Sequence[Union[float, int]]) -> Sequence[float]:
    """
    Convert the rotational part of a 3D pose to a quaternion.

    Parameters
    ----------

    pose : Sequence[Union[float, int]]
           3D Pose.

    Returns
    -------

    quaternion : Sequence[float]
                 Rotation quaternion.

    See Also
    --------
    quat_to_pose, quat_to_hom_mat3d, quat_compose, quat_rotate_point_3d,
    pose_to_dual_quat

    Alternatives
    ------------
    axis_angle_to_quat

    Predecessors
    ------------
    create_pose, read_pose

    Successors
    ----------
    quat_compose, quat_rotate_point_3d, quat_interpolate
    """
    with HalconOperator(230) as proc:
        proc.set_input_tuple(0, pose)
        proc.init_oct(0)
        proc.execute()
        quaternion = proc.get_output_tuple_m(0)
        return quaternion  # type: ignore


def pouring(
    image: HObject,
    mode: str,
    min_gray: int,
    max_gray: int
) -> HObject:
    """
    Segment an image by ``pouring water'' over it.

    Parameters
    ----------

    image : HObject
            Input image.

    mode : str
           Mode of operation.
           Value Suggestion: all

    min_gray : int
               All gray values smaller than this threshold are disregarded.
               Value Suggestion: 0
               Assertion: MinGray >= 0

    max_gray : int
               All gray values larger than this threshold are disregarded.
               Value Suggestion: 255
               Assertion: MaxGray <= 255 && MaxGray > MinGray

    Returns
    -------

    regions : HObject
              Segmented regions.

    See Also
    --------
    histo_2dim, expand_region, expand_gray, expand_gray_ref

    Alternatives
    ------------
    watersheds, local_max, watersheds_threshold, watersheds_marker

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image, mean_image
    """
    with HalconOperator(458) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, min_gray)
        proc.set_input_tuple(2, max_gray)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def pow_element_matrix(
    matrix_id: HHandle,
    matrix_exp_id: HHandle
) -> HHandle:
    """
    Compute the power functions of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix of the base.

    matrix_exp_id : HHandle
                    Matrix handle of the input matrix with exponents.

    Returns
    -------

    matrix_pow_id : HHandle
                    Matrix handle with the raised power of the input
                    matrix.

    See Also
    --------
    sqrt_matrix, sqrt_matrix_mod

    Alternatives
    ------------
    pow_element_matrix_mod, pow_scalar_element_matrix,
    pow_scalar_element_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(862) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_exp_id)
        proc.init_oct(0)
        proc.execute()
        matrix_pow_id = proc.get_output_tuple_s(0)
        return matrix_pow_id  # type: ignore


def pow_element_matrix_mod(
    matrix_id: HHandle,
    matrix_exp_id: HHandle
) -> None:
    """
    Compute the power functions of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix of the base.

    matrix_exp_id : HHandle
                    Matrix handle of the input matrix with exponents.

    See Also
    --------
    sqrt_matrix, sqrt_matrix_mod

    Alternatives
    ------------
    pow_element_matrix, pow_scalar_element_matrix,
    pow_scalar_element_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(861) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_exp_id)
        proc.execute()


def pow_image(image: HObject, exponent: Union[int, float]) -> HObject:
    """
    Raise an image to a power.

    Parameters
    ----------

    image : HObject
            Input image.

    exponent : Union[int, float]
               Power to which the gray values are raised.
               Value Suggestion: 2

    Returns
    -------

    pow_image : HObject
                Output image.

    See Also
    --------
    sqrt_image, exp_image, log_image

    Alternatives
    ------------
    gamma_image

    Notes
    -----
    pow_image can be executed on an OpenCL device for byte, int1, int2,
    uint2, int4, and real images. Note that the results of the OpenCL code
    may vary from the results produced by the CPU.
    """
    with HalconOperator(1594) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, exponent)
        proc.execute()
        pow_image = HObject(proc.get_output_object_key(1))
        return pow_image  # type: ignore


def pow_matrix(
    matrix_id: HHandle,
    matrix_type: str,
    power: Union[int, float]
) -> HHandle:
    """
    Compute the power functions of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_type : str
                  The type of the input matrix.
                  Value Suggestion: general

    power : Union[int, float]
            The power.
            Value Suggestion: 2.0

    Returns
    -------

    matrix_pow_id : HHandle
                    Matrix handle with the raised powered matrix.

    See Also
    --------
    sqrt_matrix, sqrt_matrix_mod

    Alternatives
    ------------
    pow_matrix_mod, eigenvalues_symmetric_matrix,
    eigenvalues_general_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    For MatrixType = 'symmetric', 'positive_definite', or
    'upper_triangular' the upper triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly lower
    triangular part of the matrix is not referenced.  For MatrixType =
    'lower_triangular' the lower triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly upper
    triangular part of the matrix is not referenced.  If the referenced
    part of the input Matrix is not of the specified type, an exception is
    raised.
    """
    with HalconOperator(860) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_type)
        proc.set_input_tuple(2, power)
        proc.init_oct(0)
        proc.execute()
        matrix_pow_id = proc.get_output_tuple_s(0)
        return matrix_pow_id  # type: ignore


def pow_matrix_mod(
    matrix_id: HHandle,
    matrix_type: str,
    power: Union[int, float]
) -> None:
    """
    Compute the power functions of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_type : str
                  The type of the input matrix.
                  Value Suggestion: general

    power : Union[int, float]
            The power.
            Value Suggestion: 2.0

    See Also
    --------
    sqrt_matrix, sqrt_matrix_mod

    Alternatives
    ------------
    pow_matrix, eigenvalues_symmetric_matrix, eigenvalues_general_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    For MatrixType = 'symmetric', 'positive_definite', or
    'upper_triangular' the upper triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly lower
    triangular part of the matrix is not referenced.  For MatrixType =
    'lower_triangular' the lower triangular part of the input Matrix must
    contain the relevant information of the matrix.  The strictly upper
    triangular part of the matrix is not referenced.  If the referenced
    part of the input Matrix is not of the specified type, an exception is
    raised.
    pow_matrix_mod modifies the content of an already existing matrix.
    """
    with HalconOperator(859) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_type)
        proc.set_input_tuple(2, power)
        proc.execute()


def pow_scalar_element_matrix(
    matrix_id: HHandle,
    power: Union[int, float]
) -> HHandle:
    """
    Compute the power functions of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    power : Union[int, float]
            The power.
            Value Suggestion: 2.0

    Returns
    -------

    matrix_pow_id : HHandle
                    Matrix handle with the raised power of the input
                    matrix.

    See Also
    --------
    sqrt_matrix, sqrt_matrix_mod

    Alternatives
    ------------
    pow_scalar_element_matrix_mod, pow_element_matrix,
    pow_element_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(864) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, power)
        proc.init_oct(0)
        proc.execute()
        matrix_pow_id = proc.get_output_tuple_s(0)
        return matrix_pow_id  # type: ignore


def pow_scalar_element_matrix_mod(
    matrix_id: HHandle,
    power: Union[int, float]
) -> None:
    """
    Compute the power functions of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    power : Union[int, float]
            The power.
            Value Suggestion: 2.0

    See Also
    --------
    sqrt_matrix, sqrt_matrix_mod

    Alternatives
    ------------
    pow_scalar_element_matrix, pow_element_matrix, pow_element_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(863) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, power)
        proc.execute()


def power_byte(image: HObject) -> HObject:
    """
    Return the power spectrum of a complex image.

    Parameters
    ----------

    image : HObject
            Input image in frequency domain.

    Returns
    -------

    power_byte : HObject
                 Power spectrum of the input image.

    See Also
    --------
    fft_image, fft_generic, rft_generic

    Alternatives
    ------------
    abs_image, convert_image_type, power_real, power_ln

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic, convol_fft, convol_gabor

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1526) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        power_byte = HObject(proc.get_output_object_key(1))
        return power_byte  # type: ignore


def power_ln(image: HObject) -> HObject:
    """
    Return the power spectrum of a complex image.

    Parameters
    ----------

    image : HObject
            Input image in frequency domain.

    Returns
    -------

    image_result : HObject
                   Power spectrum of the input image.

    See Also
    --------
    fft_image, fft_generic, rft_generic

    Alternatives
    ------------
    abs_image, convert_image_type, power_real, power_byte

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic, convol_fft, convol_gabor

    Successors
    ----------
    disp_image, convert_image_type, scale_image
    """
    with HalconOperator(1524) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def power_real(image: HObject) -> HObject:
    """
    Return the power spectrum of a complex image.

    Parameters
    ----------

    image : HObject
            Input image in frequency domain.

    Returns
    -------

    image_result : HObject
                   Power spectrum of the input image.

    See Also
    --------
    fft_image, fft_generic, rft_generic

    Alternatives
    ------------
    abs_image, convert_image_type, power_byte, power_ln

    Predecessors
    ------------
    fft_image, fft_generic, rft_generic, convol_fft, convol_gabor

    Successors
    ----------
    disp_image, convert_image_type, scale_image
    """
    with HalconOperator(1525) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_result = HObject(proc.get_output_object_key(1))
        return image_result  # type: ignore


def prepare_direct_variation_model(
    ref_image: HObject,
    var_image: HObject,
    model_id: HHandle,
    abs_threshold: MaybeSequence[Union[float, int]],
    var_threshold: MaybeSequence[Union[float, int]]
) -> None:
    """
    Prepare a variation model for comparison with an image.

    Parameters
    ----------

    ref_image : HObject
                Reference image of the object.

    var_image : HObject
                Variation image of the object.

    model_id : HHandle
               ID of the variation model.

    abs_threshold : MaybeSequence[Union[float, int]]
                    Absolute minimum threshold for the differences between
                    the image and the variation model.
                    Value Suggestion: 10
                    Assertion: AbsThreshold >= 0

    var_threshold : MaybeSequence[Union[float, int]]
                    Threshold for the differences based on the variation
                    of the variation model.
                    Value Suggestion: 2
                    Assertion: VarThreshold >= 0

    See Also
    --------
    create_variation_model

    Alternatives
    ------------
    prepare_variation_model

    Predecessors
    ------------
    sobel_amp, edges_image, gray_range_rect

    Successors
    ----------
    compare_variation_model, compare_ext_variation_model,
    get_thresh_images_variation_model, write_variation_model
    """
    with HalconOperator(89) as proc:
        proc.set_input_object(1, ref_image)
        proc.set_input_object(2, var_image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, abs_threshold)
        proc.set_input_tuple(2, var_threshold)
        proc.execute()


def prepare_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    purpose: str,
    overwrite_data: str,
    gen_param_name: Sequence[Union[str, float, int]],
    gen_param_value: Sequence[Union[str, float, int]]
) -> None:
    """
    Prepare a 3D object model for a certain operation.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    purpose : str
              Purpose of the 3D object model.
              Value Suggestion: shape_based_matching_3d

    overwrite_data : str
                     Specify if already existing data should be
                     overwritten.
                     Value Suggestion: true

    gen_param_name : Sequence[Union[str, float, int]]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    create_shape_model_3d, create_surface_model, distance_object_model_3d,
    find_surface_model, fit_primitives_object_model_3d,
    refine_surface_model_pose, segment_object_model_3d,
    simplify_object_model_3d, sample_object_model_3d,
    surface_normals_object_model_3d
    """
    with HalconOperator(1091) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, purpose)
        proc.set_input_tuple(2, overwrite_data)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.execute()


def prepare_sample_identifier(
    sample_identifier: HHandle,
    remove_preparation_data: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> None:
    """
    Adapt the internal data structure of a sample identifier to the
    objects to be identified.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    remove_preparation_data : str
                              Indicates if the preparation data should be
                              removed.
                              Value Suggestion: true

    gen_param_name : Sequence[str]
                     Generic parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Generic parameter value.
                      Value Suggestion: []

    See Also
    --------
    create_sample_identifier, apply_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_preparation_data

    Successors
    ----------
    write_sample_identifier, add_sample_identifier_training_data,
    train_sample_identifier
    """
    with HalconOperator(913) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, remove_preparation_data)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def prepare_variation_model(
    model_id: HHandle,
    abs_threshold: MaybeSequence[Union[float, int]],
    var_threshold: MaybeSequence[Union[float, int]]
) -> None:
    """
    Prepare a variation model for comparison with an image.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    abs_threshold : MaybeSequence[Union[float, int]]
                    Absolute minimum threshold for the differences between
                    the image and the variation model.
                    Value Suggestion: 10
                    Assertion: AbsThreshold >= 0

    var_threshold : MaybeSequence[Union[float, int]]
                    Threshold for the differences based on the variation
                    of the variation model.
                    Value Suggestion: 2
                    Assertion: VarThreshold >= 0

    See Also
    --------
    create_variation_model

    Alternatives
    ------------
    prepare_direct_variation_model

    Predecessors
    ------------
    train_variation_model

    Successors
    ----------
    compare_variation_model, compare_ext_variation_model,
    get_thresh_images_variation_model, clear_train_data_variation_model,
    write_variation_model
    """
    with HalconOperator(90) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, abs_threshold)
        proc.set_input_tuple(2, var_threshold)
        proc.execute()


def prewitt_amp(image: HObject) -> HObject:
    """
    Detect edges (amplitude) using the Prewitt operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    sobel_amp, kirsch_amp, frei_amp, robinson_amp, roberts

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Successors
    ----------
    threshold, gray_skeleton, nonmax_suppression_amp, close_edges,
    close_edges_length

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1559) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_edge_amp = HObject(proc.get_output_object_key(1))
        return image_edge_amp  # type: ignore


def prewitt_dir(image: HObject) -> Tuple[HObject, HObject]:
    """
    Detect edges (amplitude and direction) using the Prewitt operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    image_edge_dir : HObject
                     Edge direction image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    edges_image, sobel_dir, robinson_dir, frei_dir, kirsch_dir

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Successors
    ----------
    hysteresis_threshold, threshold, gray_skeleton,
    nonmax_suppression_dir, close_edges, close_edges_length

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1558) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_edge_amp
            HObject(proc.get_output_object_key(2))   # image_edge_dir
        )  # type: ignore


def principal_comp(
    multichannel_image: HObject
) -> Tuple[HObject, Sequence[float]]:
    """
    Compute the principal components of multichannel images.

    Parameters
    ----------

    multichannel_image : HObject
                         Multichannel input image.

    Returns
    -------

    pcaimage : HObject
               Multichannel output image.

    info_per_comp : Sequence[float]
                    Information content of each output channel.

    See Also
    --------
    linear_trans_color

    Alternatives
    ------------
    gen_principal_comp_trans

    Notes
    -----
    principal_comp can be executed on OpenCL devices if image consists of
    eight channels or less. Since the calculations are done in single
    precision floating point, the results may differ from those calculated
    by the CPU.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1456) as proc:
        proc.set_input_object(1, multichannel_image)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # pcaimage
            proc.get_output_tuple_m(0)   # info_per_comp
        )  # type: ignore


def proj_hom_mat2d_to_pose(
    homography: Sequence[float],
    camera_matrix: Sequence[float],
    method: str
) -> Sequence[Union[float, int]]:
    """
    Compute a pose out of a homography describing the relation between
    world and image coordinates.

    Parameters
    ----------

    homography : Sequence[float]
                 The homography from world- to image coordinates.

    camera_matrix : Sequence[float]
                    The camera calibration matrix K.

    method : str
             Type of pose computation.
             Value Suggestion: decomposition

    Returns
    -------

    pose : Sequence[Union[float, int]]
           Pose of the 2D object.

    See Also
    --------
    vector_to_proj_hom_mat2d, image_points_to_world_plane, vector_to_pose,
    camera_calibration

    Predecessors
    ------------
    image_points_to_world_plane, vector_to_proj_hom_mat2d
    """
    with HalconOperator(1903) as proc:
        proc.set_input_tuple(0, homography)
        proc.set_input_tuple(1, camera_matrix)
        proc.set_input_tuple(2, method)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def proj_match_points_distortion_ransac(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[Union[float, int]],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[float], float, float, Sequence[int], Sequence[int]]:
    """
    Compute a projective transformation matrix between two images and the
    radial distortion coefficient by automatically finding correspondences
    between points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 5

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) >= 5

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows2)

    gray_match_method : str
                        Gray value match metric.
                        Value Suggestion: ncc

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    row_move : int
               Average row coordinate offset of corresponding points.
               Value Suggestion: 0

    col_move : int
               Average column coordinate offset of corresponding points.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 200
                    Assertion: RowTolerance >= 1

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 200
                    Assertion: ColTolerance >= 1

    rotation : MaybeSequence[Union[float, int]]
               Estimate of the relative rotation of the second image with
               respect to the first image.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 0.7

    estimation_method : str
                        Algorithm for the computation of the projective
                        transformation matrix.
                        Value Suggestion: gold_standard

    distance_threshold : Union[float, int]
                         Threshold for the transformation consistency
                         check.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Computed homogeneous projective transformation matrix.

    kappa : float
            Computed radial distortion coefficient.

    error : float
            Root-Mean-Square transformation error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_vector_to_proj_hom_mat2d, vector_to_proj_hom_mat2d

    Alternatives
    ------------
    proj_match_points_distortion_ransac_guided

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_proj_hom_mat2d_distortion, change_radial_distortion_cam_par,
    change_radial_distortion_image, change_radial_distortion_points,
    gen_binocular_proj_rectification, projective_trans_image,
    projective_trans_image_size, projective_trans_region,
    projective_trans_contour_xld, projective_trans_point_2d,
    projective_trans_pixel
    """
    with HalconOperator(257) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, gray_match_method)
        proc.set_input_tuple(5, mask_size)
        proc.set_input_tuple(6, row_move)
        proc.set_input_tuple(7, col_move)
        proc.set_input_tuple(8, row_tolerance)
        proc.set_input_tuple(9, col_tolerance)
        proc.set_input_tuple(10, rotation)
        proc.set_input_tuple(11, match_threshold)
        proc.set_input_tuple(12, estimation_method)
        proc.set_input_tuple(13, distance_threshold)
        proc.set_input_tuple(14, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_s(1),  # kappa
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def proj_match_points_distortion_ransac_guided(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    hom_mat_2dguide: Sequence[float],
    kappa_guide: float,
    distance_tolerance: float,
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: Union[float, int],
    rand_seed: int
) -> Tuple[Sequence[float], float, float, Sequence[int], Sequence[int]]:
    """
    Compute a projective transformation matrix and the radial distortion
    coefficient between two images by finding correspondences between
    points based on known approximations of the projective transformation
    matrix and the radial distortion coefficient.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 5

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) >= 5

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows2)

    gray_match_method : str
                        Gray value match metric.
                        Value Suggestion: ncc

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10
                Assertion: MaskSize >= 1

    hom_mat_2dguide : Sequence[float]
                      Approximation of the homogeneous projective
                      transformation matrix between the two images.

    kappa_guide : float
                  Approximation of the radial distortion coefficient in
                  the two images.

    distance_tolerance : float
                         Tolerance for the matching search window.
                         Value Suggestion: 20.0
                         Assertion: DistanceTolerance > 0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 0.7

    estimation_method : str
                        Algorithm for the computation of the projective
                        transformation matrix.
                        Value Suggestion: gold_standard

    distance_threshold : Union[float, int]
                         Threshold for transformation consistency check.
                         Value Suggestion: 1
                         Assertion: DistanceThreshold > 0

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Computed homogeneous projective transformation matrix.

    kappa : float
            Computed radial distortion coefficient.

    error : float
            Root-Mean-Square transformation error.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_vector_to_proj_hom_mat2d, vector_to_proj_hom_mat2d

    Alternatives
    ------------
    proj_match_points_distortion_ransac

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    vector_to_proj_hom_mat2d_distortion, change_radial_distortion_cam_par,
    change_radial_distortion_image, change_radial_distortion_points,
    gen_binocular_proj_rectification, projective_trans_image,
    projective_trans_image_size, projective_trans_region,
    projective_trans_contour_xld, projective_trans_point_2d,
    projective_trans_pixel
    """
    with HalconOperator(256) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, gray_match_method)
        proc.set_input_tuple(5, mask_size)
        proc.set_input_tuple(6, hom_mat_2dguide)
        proc.set_input_tuple(7, kappa_guide)
        proc.set_input_tuple(8, distance_tolerance)
        proc.set_input_tuple(9, match_threshold)
        proc.set_input_tuple(10, estimation_method)
        proc.set_input_tuple(11, distance_threshold)
        proc.set_input_tuple(12, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_s(1),  # kappa
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # points_1
            proc.get_output_tuple_m(4)   # points_2
        )  # type: ignore


def proj_match_points_ransac(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    row_move: int,
    col_move: int,
    row_tolerance: int,
    col_tolerance: int,
    rotation: MaybeSequence[float],
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: float,
    rand_seed: int
) -> Tuple[Sequence[float], Sequence[int], Sequence[int]]:
    """
    Compute a projective transformation matrix between two images by
    finding correspondences between points.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10

    row_move : int
               Average row coordinate shift.
               Value Suggestion: 0

    col_move : int
               Average column coordinate shift.
               Value Suggestion: 0

    row_tolerance : int
                    Half height of matching search window.
                    Value Suggestion: 256

    col_tolerance : int
                    Half width of matching search window.
                    Value Suggestion: 256

    rotation : MaybeSequence[float]
               Range of rotation angles.
               Value Suggestion: 0.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Transformation matrix estimation algorithm.
                        Value Suggestion: normalized_dlt

    distance_threshold : float
                         Threshold for transformation consistency check.
                         Value Suggestion: 0.2

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    proj_match_points_ransac_guided

    Alternatives
    ------------
    hom_vector_to_proj_hom_mat2d, vector_to_proj_hom_mat2d

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d, projective_trans_pixel
    """
    with HalconOperator(259) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, gray_match_method)
        proc.set_input_tuple(5, mask_size)
        proc.set_input_tuple(6, row_move)
        proc.set_input_tuple(7, col_move)
        proc.set_input_tuple(8, row_tolerance)
        proc.set_input_tuple(9, col_tolerance)
        proc.set_input_tuple(10, rotation)
        proc.set_input_tuple(11, match_threshold)
        proc.set_input_tuple(12, estimation_method)
        proc.set_input_tuple(13, distance_threshold)
        proc.set_input_tuple(14, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_m(1),  # points_1
            proc.get_output_tuple_m(2)   # points_2
        )  # type: ignore


def proj_match_points_ransac_guided(
    image_1: HObject,
    image_2: HObject,
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    gray_match_method: str,
    mask_size: int,
    hom_mat_2dguide: Sequence[float],
    distance_tolerance: float,
    match_threshold: Union[int, float],
    estimation_method: str,
    distance_threshold: float,
    rand_seed: int
) -> Tuple[Sequence[float], Sequence[int], Sequence[int]]:
    """
    Compute a projective transformation matrix between two images by
    finding correspondences between points based on a known approximation
    of the projective transformation matrix.

    Parameters
    ----------

    image_1 : HObject
              Input image 1.

    image_2 : HObject
              Input image 2.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 1.

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 1.

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of characteristic points in image 2.

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of characteristic points in image 2.

    gray_match_method : str
                        Gray value comparison metric.
                        Value Suggestion: ssd

    mask_size : int
                Size of gray value masks.
                Value Suggestion: 10

    hom_mat_2dguide : Sequence[float]
                      Approximation of the Homogeneous projective
                      transformation matrix between the two images.

    distance_tolerance : float
                         Tolerance for the matching search window.
                         Value Suggestion: 20.0

    match_threshold : Union[int, float]
                      Threshold for gray value matching.
                      Value Suggestion: 10

    estimation_method : str
                        Transformation matrix estimation algorithm.
                        Value Suggestion: normalized_dlt

    distance_threshold : float
                         Threshold for transformation consistency check.
                         Value Suggestion: 0.2

    rand_seed : int
                Seed for the random number generator.
                Value Suggestion: 0

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    points_1 : Sequence[int]
               Indices of matched input points in image 1.

    points_2 : Sequence[int]
               Indices of matched input points in image 2.

    See Also
    --------
    proj_match_points_ransac

    Alternatives
    ------------
    hom_vector_to_proj_hom_mat2d, vector_to_proj_hom_mat2d

    Predecessors
    ------------
    points_foerstner, points_harris

    Successors
    ----------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d, projective_trans_pixel
    """
    with HalconOperator(258) as proc:
        proc.set_input_object(1, image_1)
        proc.set_input_object(2, image_2)
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, gray_match_method)
        proc.set_input_tuple(5, mask_size)
        proc.set_input_tuple(6, hom_mat_2dguide)
        proc.set_input_tuple(7, distance_tolerance)
        proc.set_input_tuple(8, match_threshold)
        proc.set_input_tuple(9, estimation_method)
        proc.set_input_tuple(10, distance_threshold)
        proc.set_input_tuple(11, rand_seed)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_m(1),  # points_1
            proc.get_output_tuple_m(2)   # points_2
        )  # type: ignore


def project_3d_point(
    x: Sequence[float],
    y: Sequence[float],
    z: Sequence[float],
    camera_param: Sequence[Union[int, float, str]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Project 3D points into (sub-)pixel image coordinates.

    Parameters
    ----------

    x : Sequence[float]
        X coordinates of the 3D points to be projected in the camera
        coordinate system.

    y : Sequence[float]
        Y coordinates of the 3D points to be projected in the camera
        coordinate system.

    z : Sequence[float]
        Z coordinates of the 3D points to be projected in the camera
        coordinate system.

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the projected points (in pixels).

    column : Sequence[float]
             Column coordinates of the projected points (in pixels).

    See Also
    --------
    camera_calibration, disp_caltab, read_cam_par, get_line_of_sight,
    affine_trans_point_3d, image_points_to_world_plane

    Predecessors
    ------------
    read_cam_par, affine_trans_point_3d

    Successors
    ----------
    gen_region_points, gen_region_polygon, disp_polygon
    """
    with HalconOperator(1932) as proc:
        proc.set_input_tuple(0, x)
        proc.set_input_tuple(1, y)
        proc.set_input_tuple(2, z)
        proc.set_input_tuple(3, camera_param)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def project_hom_point_hom_mat3d(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]],
    pw: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Project a homogeneous 3D point using a 34 projection matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 34 projection matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    pw : MaybeSequence[Union[float, int]]
         Input point (w coordinate).

    Returns
    -------

    qx : Sequence[float]
         Output point (x coordinate).

    qy : Sequence[float]
         Output point (y coordinate).

    qw : Sequence[float]
         Output point (w coordinate).

    Alternatives
    ------------
    project_point_hom_mat3d, project_3d_point

    Predecessors
    ------------
    cam_par_pose_to_hom_mat3d
    """
    with HalconOperator(1930) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.set_input_tuple(4, pw)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1),  # qy
            proc.get_output_tuple_m(2)   # qw
        )  # type: ignore


def project_hom_point_hom_mat3d_s(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]],
    pw: MaybeSequence[Union[float, int]]
) -> Tuple[float, float, float]:
    """
    Project a homogeneous 3D point using a 34 projection matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 34 projection matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    pw : MaybeSequence[Union[float, int]]
         Input point (w coordinate).

    Returns
    -------

    qx : float
         Output point (x coordinate).

    qy : float
         Output point (y coordinate).

    qw : float
         Output point (w coordinate).

    Alternatives
    ------------
    project_point_hom_mat3d, project_3d_point

    Predecessors
    ------------
    cam_par_pose_to_hom_mat3d
    """
    with HalconOperator(1930) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.set_input_tuple(4, pw)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1),  # qy
            proc.get_output_tuple_s(2)   # qw
        )  # type: ignore


def project_object_model_3d(
    object_model_3d: HHandle,
    cam_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, int, float]]
) -> HObject:
    """
    Project a 3D object model into image coordinates.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    cam_param : Sequence[Union[int, float, str]]
                Internal camera parameters.

    pose : Sequence[Union[int, float]]
           3D pose of the world coordinate system in camera coordinates.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, int, float]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    model_contours : HObject
                     Projected model contours.

    See Also
    --------
    project_shape_model_3d, object_model_3d_to_xyz

    Predecessors
    ------------
    read_object_model_3d, affine_trans_object_model_3d,
    prepare_object_model_3d

    Successors
    ----------
    clear_object_model_3d

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1095) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, cam_param)
        proc.set_input_tuple(2, pose)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.execute()
        model_contours = HObject(proc.get_output_object_key(1))
        return model_contours  # type: ignore


def project_point_hom_mat3d(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Project a 3D point using a 34 projection matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 34 projection matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    Returns
    -------

    qx : Sequence[float]
         Output point (x coordinate).

    qy : Sequence[float]
         Output point (y coordinate).

    Alternatives
    ------------
    project_hom_point_hom_mat3d, project_3d_point

    Predecessors
    ------------
    cam_par_pose_to_hom_mat3d
    """
    with HalconOperator(1931) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1)   # qy
        )  # type: ignore


def project_point_hom_mat3d_s(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Project a 3D point using a 34 projection matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 34 projection matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    Returns
    -------

    qx : float
         Output point (x coordinate).

    qy : float
         Output point (y coordinate).

    Alternatives
    ------------
    project_hom_point_hom_mat3d, project_3d_point

    Predecessors
    ------------
    cam_par_pose_to_hom_mat3d
    """
    with HalconOperator(1931) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1)   # qy
        )  # type: ignore


def project_shape_model_3d(
    shape_model_3did: HHandle,
    cam_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]],
    hidden_surface_removal: str,
    min_face_angle: Union[int, float]
) -> HObject:
    """
    Project the edges of a 3D shape model into image coordinates.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    cam_param : Sequence[Union[int, float, str]]
                Internal camera parameters.

    pose : Sequence[Union[int, float]]
           3D pose of the 3D shape model in the world coordinate system.

    hidden_surface_removal : str
                             Remove hidden surfaces?
                             Value Suggestion: true

    min_face_angle : Union[int, float]
                     Smallest face angle for which the edge is displayed
                     Value Suggestion: 0.523599

    Returns
    -------

    model_contours : HObject
                     Contour representation of the model view.

    See Also
    --------
    convert_point_3d_cart_to_spher, convert_point_3d_spher_to_cart,
    create_cam_pose_look_at_point, trans_pose_shape_model_3d

    Alternatives
    ------------
    project_object_model_3d

    Predecessors
    ------------
    create_shape_model_3d, read_shape_model_3d, get_shape_model_3d_params,
    find_shape_model_3d
    """
    with HalconOperator(1055) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, cam_param)
        proc.set_input_tuple(2, pose)
        proc.set_input_tuple(3, hidden_surface_removal)
        proc.set_input_tuple(4, min_face_angle)
        proc.execute()
        model_contours = HObject(proc.get_output_object_key(1))
        return model_contours  # type: ignore


def projection_pl(
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the projection of a point onto a line.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the point.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point on the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point on the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point on the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point on the line.

    Returns
    -------

    row_proj : Sequence[float]
               Row coordinate of the projected point.

    col_proj : Sequence[float]
               Column coordinate of the projected point
    """
    with HalconOperator(1338) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_proj
            proc.get_output_tuple_m(1)   # col_proj
        )  # type: ignore


def projection_pl_s(
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    row_1: MaybeSequence[Union[float, int]],
    column_1: MaybeSequence[Union[float, int]],
    row_2: MaybeSequence[Union[float, int]],
    column_2: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Calculate the projection of a point onto a line.

    Parameters
    ----------

    row : MaybeSequence[Union[float, int]]
          Row coordinate of the point.

    column : MaybeSequence[Union[float, int]]
             Column coordinate of the point.

    row_1 : MaybeSequence[Union[float, int]]
            Row coordinate of the first point on the line.

    column_1 : MaybeSequence[Union[float, int]]
               Column coordinate of the first point on the line.

    row_2 : MaybeSequence[Union[float, int]]
            Row coordinate of the second point on the line.

    column_2 : MaybeSequence[Union[float, int]]
               Column coordinate of the second point on the line.

    Returns
    -------

    row_proj : float
               Row coordinate of the projected point.

    col_proj : float
               Column coordinate of the projected point
    """
    with HalconOperator(1338) as proc:
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, column_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, column_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_proj
            proc.get_output_tuple_s(1)   # col_proj
        )  # type: ignore


def projective_trans_contour_xld(
    contours: HObject,
    hom_mat_2d: Sequence[float]
) -> HObject:
    """
    Apply a projective transformation to an XLD contour.

    Parameters
    ----------

    contours : HObject
               Input contours.

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    Returns
    -------

    contours_proj_trans : HObject
                          Output contours.

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_point_2d,
    projective_trans_pixel

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project

    Notes
    -----
    The used coordinate system is the same as in affine_trans_pixel. This
    means that in fact not HomMat2D is applied but a modified version.
    Therefore, applying projective_trans_contour_xld corresponds to the
    following chain of transformations, which is applied to each point
    (Row_i, Col_i)  ($Row_i$, $Col_i$)  of the contour (input and output
    pixels as homogeneous vectors):
    / RowTrans_i -   / 1 0 -0.5 -              / 1 0 +0.5 -   / Row_i -  |
    ColTrans_i | = | 0 1 -0.5 | * HomMat2D * | 0 1 +0.5 | * | Col_i | -
    1       /   - 0 0   1  /              - 0 0   1  /   -  1    /
    displaymath RowTrans_i{ColTrans_i} = 1 & 0 & - 0.5
    0 & 1 & - 0.5 -    HomMat2D -    1 & 0 & + 0.5
    0 & 1 & + 0.5 -    Row_i{Col_i} displaymath
    As an effect, you might get unexpected results when creating
    projective transformations based on coordinates that are derived from
    the contour, e.g., by operators like area_center_xld. For example, if
    you use this operator to calculate the center of gravity of a
    rotationally symmetric XLD contour and then rotate the contour around
    this point using hom_mat2d_rotate, the resulting contour will not lie
    on the original one. In such a case, you can compensate this effect by
    applying the following translations to HomMat2D before using it in
    projective_trans_contour_xld:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_contour_xld(Contours, ContoursAffineTrans,
    HomMat2DAdapted)
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_contour_xld(Contours, ContoursAffineTrans,
    HomMat2DAdapted)
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(47) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.execute()
        contours_proj_trans = HObject(proc.get_output_object_key(1))
        return contours_proj_trans  # type: ignore


def projective_trans_hom_point_3d(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]],
    pw: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Project a homogeneous 3D point using a projective transformation
    matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Homogeneous projective transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    pw : MaybeSequence[Union[float, int]]
         Input point (w coordinate).

    Returns
    -------

    qx : Sequence[float]
         Output point (x coordinate).

    qy : Sequence[float]
         Output point (y coordinate).

    qz : Sequence[float]
         Output point (z coordinate).

    qw : Sequence[float]
         Output point (w coordinate).

    Alternatives
    ------------
    projective_trans_point_3d

    Predecessors
    ------------
    vector_to_hom_mat3d
    """
    with HalconOperator(239) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.set_input_tuple(4, pw)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1),  # qy
            proc.get_output_tuple_m(2),  # qz
            proc.get_output_tuple_m(3)   # qw
        )  # type: ignore


def projective_trans_hom_point_3d_s(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]],
    pw: MaybeSequence[Union[float, int]]
) -> Tuple[float, float, float, float]:
    """
    Project a homogeneous 3D point using a projective transformation
    matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Homogeneous projective transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    pw : MaybeSequence[Union[float, int]]
         Input point (w coordinate).

    Returns
    -------

    qx : float
         Output point (x coordinate).

    qy : float
         Output point (y coordinate).

    qz : float
         Output point (z coordinate).

    qw : float
         Output point (w coordinate).

    Alternatives
    ------------
    projective_trans_point_3d

    Predecessors
    ------------
    vector_to_hom_mat3d
    """
    with HalconOperator(239) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.set_input_tuple(4, pw)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1),  # qy
            proc.get_output_tuple_s(2),  # qz
            proc.get_output_tuple_s(3)   # qw
        )  # type: ignore


def projective_trans_image(
    image: HObject,
    hom_mat_2d: Sequence[float],
    interpolation: str,
    adapt_image_size: str,
    transform_domain: str
) -> HObject:
    """
    Apply a projective transformation to an image.

    Parameters
    ----------

    image : HObject
            Input image.

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: bilinear

    adapt_image_size : str
                       Adapt the size of the output image automatically?
                       Value Suggestion: false

    transform_domain : str
                       Should the domain of the input image also be
                       transformed?
                       Value Suggestion: false

    Returns
    -------

    trans_image : HObject
                  Output image.

    See Also
    --------
    projective_trans_image_size, projective_trans_contour_xld,
    projective_trans_region, projective_trans_point_2d,
    projective_trans_pixel

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project

    Notes
    -----
    The used coordinate system is the same as in affine_trans_pixel. This
    means that in fact not HomMat2D is applied but a modified version.
    Therefore, applying projective_trans_image corresponds to the
    following chain of transformations, which is applied to each point
    (Row_i, Col_i)  ($Row_i$, $Col_i$)  of the image (input and output
    pixels as homogeneous vectors):
    / RowTrans_i -   / 1 0 -0.5 -              / 1 0 +0.5 -   / Row_i -  |
    ColTrans_i | = | 0 1 -0.5 | * HomMat2D * | 0 1 +0.5 | * | Col_i | -
    1       /   - 0 0   1  /              - 0 0   1  /   -  1    /
    displaymath RowTrans_i{ColTrans_i} = 1 & 0 & - 0.5
    0 & 1 & - 0.5 -    HomMat2D -    1 & 0 & + 0.5
    0 & 1 & + 0.5 -    Row_i{Col_i} displaymath
    As an effect, you might get unexpected results when creating
    projective transformations based on coordinates that are derived from
    the image, e.g., by operators like area_center_gray. For example, if
    you use this operator to calculate the center of gravity of a
    rotationally symmetric image and then rotate the image around this
    point using hom_mat2d_rotate, the resulting image will not lie on the
    original one. In such a case, you can compensate this effect by
    applying the following translations to HomMat2D before using it in
    projective_trans_image:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_image(Image, TransImage, HomMat2DAdapted, 'bilinear',
    'false', 'false')
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_image(Image, TransImage, HomMat2DAdapted, 'bilinear',
    'false', 'false')
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    projective_trans_image can be executed on OpenCL devices if the input
    image does not exceed the maximum size of image objects of the
    selected device and the parameter TransformDomain is set to 'false'.
    The result can diverge slightly from that calculated on the CPU.
    """
    with HalconOperator(1621) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, interpolation)
        proc.set_input_tuple(2, adapt_image_size)
        proc.set_input_tuple(3, transform_domain)
        proc.execute()
        trans_image = HObject(proc.get_output_object_key(1))
        return trans_image  # type: ignore


def projective_trans_image_size(
    image: HObject,
    hom_mat_2d: Sequence[float],
    interpolation: str,
    width: int,
    height: int,
    transform_domain: str
) -> HObject:
    """
    Apply a projective transformation to an image and specify the output
    image size.

    Parameters
    ----------

    image : HObject
            Input image.

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: bilinear

    width : int
            Output image width.

    height : int
             Output image height.

    transform_domain : str
                       Should the domain of the input image also be
                       transformed?
                       Value Suggestion: false

    Returns
    -------

    trans_image : HObject
                  Output image.

    See Also
    --------
    projective_trans_image, projective_trans_contour_xld,
    projective_trans_region, projective_trans_point_2d,
    projective_trans_pixel

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project

    Notes
    -----
    The used coordinate system is the same as in affine_trans_pixel. This
    means that in fact not HomMat2D is applied but a modified version.
    Therefore, applying projective_trans_image_size corresponds to the
    following chain of transformations, which is applied to each point
    (Row_i, Col_i)  ($Row_i$, $Col_i$)  of the image (input and output
    pixels as homogeneous vectors):
    / RowTrans_i -   / 1 0 -0.5 -              / 1 0 +0.5 -   / Row_i -  |
    ColTrans_i | = | 0 1 -0.5 | * HomMat2D * | 0 1 +0.5 | * | Col_i | -
    1       /   - 0 0   1  /              - 0 0   1  /   -  1    /
    displaymath RowTrans_i{ColTrans_i} = 1 & 0 & - 0.5
    0 & 1 & - 0.5 -    HomMat2D -    1 & 0 & + 0.5
    0 & 1 & + 0.5 -    Row_i{Col_i} displaymath
    As an effect, you might get unexpected results when creating
    projective transformations based on coordinates that are derived from
    the image, e.g., by operators like area_center_gray. For example, if
    you use this operator to calculate the center of gravity of a
    rotationally symmetric image and then rotate the image around this
    point using hom_mat2d_rotate, the resulting image will not lie on the
    original one. In such a case, you can compensate this effect by
    applying the following translations to HomMat2D before using it in
    projective_trans_image_size:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_image_size(Image, TransImage, HomMat2DAdapted,
    'bilinear', Width, Height, 'false')
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_image_size(Image, TransImage, HomMat2DAdapted,
    'bilinear', Width, Height, 'false')
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    projective_trans_image_size can be executed on OpenCL devices if the
    input image does not exceed the maximum size of image objects of the
    selected device and the parameter TransformDomain is set to 'false'.
    The result can diverge slightly from that calculated on the CPU.
    """
    with HalconOperator(1620) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, interpolation)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.set_input_tuple(4, transform_domain)
        proc.execute()
        trans_image = HObject(proc.get_output_object_key(1))
        return trans_image  # type: ignore


def projective_trans_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    hom_mat_3d: Sequence[float]
) -> Sequence[HHandle]:
    """
    Apply an arbitrary projective 3D transformation to 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    hom_mat_3d : Sequence[float]
                 Homogeneous projective transformation matrix.

    Returns
    -------

    object_model_3dprojective_trans : Sequence[HHandle]
                                      Handles of the transformed 3D object
                                      models.

    See Also
    --------
    affine_trans_point_3d, rigid_trans_object_model_3d,
    affine_trans_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    projective_trans_object_model_3d transforms the attributes of type 3D
    points.  Attributes of type shape model for shape-based 3D matching,
    of type 3D primitive, and of type normals are not transformed.
    Therefore, these attributes do not exist in the transformed 3D object
    model.  All other attributes are copied without modification.  To
    transform 3D primitives, the operator rigid_trans_object_model_3d must
    be used.
    """
    with HalconOperator(1097) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        object_model_3dprojective_trans = proc.get_output_tuple_m(0)
        return object_model_3dprojective_trans  # type: ignore


def projective_trans_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    hom_mat_3d: Sequence[float]
) -> HHandle:
    """
    Apply an arbitrary projective 3D transformation to 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    hom_mat_3d : Sequence[float]
                 Homogeneous projective transformation matrix.

    Returns
    -------

    object_model_3dprojective_trans : HHandle
                                      Handles of the transformed 3D object
                                      models.

    See Also
    --------
    affine_trans_point_3d, rigid_trans_object_model_3d,
    affine_trans_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    projective_trans_object_model_3d transforms the attributes of type 3D
    points.  Attributes of type shape model for shape-based 3D matching,
    of type 3D primitive, and of type normals are not transformed.
    Therefore, these attributes do not exist in the transformed 3D object
    model.  All other attributes are copied without modification.  To
    transform 3D primitives, the operator rigid_trans_object_model_3d must
    be used.
    """
    with HalconOperator(1097) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        object_model_3dprojective_trans = proc.get_output_tuple_s(0)
        return object_model_3dprojective_trans  # type: ignore


def projective_trans_pixel(
    hom_mat_2d: Sequence[float],
    row: MaybeSequence[Union[float, int]],
    col: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Project pixel coordinates using a homogeneous projective
    transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    row : MaybeSequence[Union[float, int]]
          Input pixel(s) (row coordinate).
          Value Suggestion: 64

    col : MaybeSequence[Union[float, int]]
          Input pixel(s) (column coordinate).
          Value Suggestion: 64

    Returns
    -------

    row_trans : Sequence[float]
                Output pixel(s) (row coordinate).

    col_trans : Sequence[float]
                Output pixel(s) (column coordinate).

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project
    """
    with HalconOperator(270) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, col)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_trans
            proc.get_output_tuple_m(1)   # col_trans
        )  # type: ignore


def projective_trans_pixel_s(
    hom_mat_2d: Sequence[float],
    row: MaybeSequence[Union[float, int]],
    col: MaybeSequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Project pixel coordinates using a homogeneous projective
    transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    row : MaybeSequence[Union[float, int]]
          Input pixel(s) (row coordinate).
          Value Suggestion: 64

    col : MaybeSequence[Union[float, int]]
          Input pixel(s) (column coordinate).
          Value Suggestion: 64

    Returns
    -------

    row_trans : float
                Output pixel(s) (row coordinate).

    col_trans : float
                Output pixel(s) (column coordinate).

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project
    """
    with HalconOperator(270) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, col)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_trans
            proc.get_output_tuple_s(1)   # col_trans
        )  # type: ignore


def projective_trans_point_2d(
    hom_mat_2d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pw: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Project a homogeneous 2D point using a projective transformation
    matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pw : MaybeSequence[Union[float, int]]
         Input point (w coordinate).

    Returns
    -------

    qx : Sequence[float]
         Output point (x coordinate).

    qy : Sequence[float]
         Output point (y coordinate).

    qw : Sequence[float]
         Output point (w coordinate).

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_pixel

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project
    """
    with HalconOperator(271) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pw)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1),  # qy
            proc.get_output_tuple_m(2)   # qw
        )  # type: ignore


def projective_trans_point_2d_s(
    hom_mat_2d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pw: MaybeSequence[Union[float, int]]
) -> Tuple[float, float, float]:
    """
    Project a homogeneous 2D point using a projective transformation
    matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pw : MaybeSequence[Union[float, int]]
         Input point (w coordinate).

    Returns
    -------

    qx : float
         Output point (x coordinate).

    qy : float
         Output point (y coordinate).

    qw : float
         Output point (w coordinate).

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_pixel

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project
    """
    with HalconOperator(271) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pw)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1),  # qy
            proc.get_output_tuple_s(2)   # qw
        )  # type: ignore


def projective_trans_point_3d(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Project a 3D point using a projective transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Homogeneous projective transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    Returns
    -------

    qx : Sequence[float]
         Output point (x coordinate).

    qy : Sequence[float]
         Output point (y coordinate).

    qz : Sequence[float]
         Output point (z coordinate).

    Alternatives
    ------------
    projective_trans_hom_point_3d

    Predecessors
    ------------
    vector_to_hom_mat3d
    """
    with HalconOperator(240) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # qx
            proc.get_output_tuple_m(1),  # qy
            proc.get_output_tuple_m(2)   # qz
        )  # type: ignore


def projective_trans_point_3d_s(
    hom_mat_3d: Sequence[float],
    px: MaybeSequence[Union[float, int]],
    py: MaybeSequence[Union[float, int]],
    pz: MaybeSequence[Union[float, int]]
) -> Tuple[float, float, float]:
    """
    Project a 3D point using a projective transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Homogeneous projective transformation matrix.

    px : MaybeSequence[Union[float, int]]
         Input point (x coordinate).

    py : MaybeSequence[Union[float, int]]
         Input point (y coordinate).

    pz : MaybeSequence[Union[float, int]]
         Input point (z coordinate).

    Returns
    -------

    qx : float
         Output point (x coordinate).

    qy : float
         Output point (y coordinate).

    qz : float
         Output point (z coordinate).

    Alternatives
    ------------
    projective_trans_hom_point_3d

    Predecessors
    ------------
    vector_to_hom_mat3d
    """
    with HalconOperator(240) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1),  # qy
            proc.get_output_tuple_s(2)   # qz
        )  # type: ignore


def projective_trans_region(
    regions: HObject,
    hom_mat_2d: Sequence[float],
    interpolation: str
) -> HObject:
    """
    Apply a projective transformation to a region.

    Parameters
    ----------

    regions : HObject
              Input regions.

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    interpolation : str
                    Interpolation method for the transformation.
                    Value Suggestion: bilinear

    Returns
    -------

    trans_regions : HObject
                    Output regions.

    See Also
    --------
    projective_trans_image, projective_trans_image_size,
    projective_trans_contour_xld, projective_trans_point_2d,
    projective_trans_pixel

    Predecessors
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d,
    proj_match_points_ransac, proj_match_points_ransac_guided,
    hom_mat3d_project

    Notes
    -----
    The used coordinate system is the same as in affine_trans_pixel. This
    means that in fact not HomMat2D is applied but a modified version.
    Therefore, applying projective_trans_region corresponds to the
    following chain of transformations, which is applied to each point
    (Row_i, Col_i)  ($Row_i$, $Col_i$)  of the region (input and output
    pixels as homogeneous vectors):
    / RowTrans_i -   / 1 0 -0.5 -              / 1 0 +0.5 -   / Row_i -  |
    ColTrans_i | = | 0 1 -0.5 | * HomMat2D * | 0 1 +0.5 | * | Col_i | -
    1       /   - 0 0   1  /              - 0 0   1  /   -  1    /
    displaymath RowTrans_i{ColTrans_i} = 1 & 0 & - 0.5
    0 & 1 & - 0.5 -    HomMat2D -    1 & 0 & + 0.5
    0 & 1 & + 0.5 -    Row_i{Col_i} displaymath
    As an effect, you might get unexpected results when creating
    projective transformations based on coordinates that are derived from
    the region, e.g., by operators like area_center. For example, if you
    use this operator to calculate the center of gravity of a rotationally
    symmetric region and then rotate the region around this point using
    hom_mat2d_rotate, the resulting region will not lie on the original
    one. In such a case, you can compensate this effect by applying the
    following translations to HomMat2D before using it in
    projective_trans_region:
    tt hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_region(Region, TransRegion, HomMat2DAdapted,
    'bilinear')
    tt  hom_mat2d_translate(HomMat2D, 0.5, 0.5, HomMat2DTmp)
    hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, HomMat2DAdapted)
    projective_trans_region(Region, TransRegion, HomMat2DAdapted,
    'bilinear')
    For an explanation of the different 2D coordinate systems  used in -
    see the introduction of chapter  Transformations, 2DTransformations.
    """
    with HalconOperator(487) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, hom_mat_2d)
        proc.set_input_tuple(1, interpolation)
        proc.execute()
        trans_regions = HObject(proc.get_output_object_key(1))
        return trans_regions  # type: ignore


def protect_ocr_trainf(
    training_file: str,
    password: MaybeSequence[str],
    training_file_protected: str
) -> None:
    """
    Protection of training data.

    Parameters
    ----------

    training_file : str
                    Names of the training files.
                    Value Suggestion: ''

    password : MaybeSequence[str]
               Passwords for protecting the training files.

    training_file_protected : str
                              Names of the protected training files.

    See Also
    --------
    select_feature_set_trainf_mlp

    Predecessors
    ------------
    write_ocr_trainf, append_ocr_trainf, concat_ocr_trainf

    Successors
    ----------
    read_ocr_trainf_names_protected, trainf_ocr_class_mlp_protected,
    trainf_ocr_class_svm_protected,
    select_feature_set_trainf_mlp_protected,
    select_feature_set_trainf_svm_protected
    """
    with HalconOperator(719) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, password)
        proc.set_input_tuple(2, training_file_protected)
        proc.execute()


def pruning(region: HObject, length: int) -> HObject:
    """
    Prune the branches of a region.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    length : int
             Length of the branches to be removed.
             Value Suggestion: 2

    Returns
    -------

    region_prune : HObject
                   Result of the pruning operation.

    See Also
    --------
    junctions_skeleton

    Predecessors
    ------------
    skeleton

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(735) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, length)
        proc.execute()
        region_prune = HObject(proc.get_output_object_key(1))
        return region_prune  # type: ignore


def quat_compose(
    quaternion_left: Sequence[float],
    quaternion_right: Sequence[float]
) -> Sequence[float]:
    """
    Multiply two quaternions.

    Parameters
    ----------

    quaternion_left : Sequence[float]
                      Left quaternion.

    quaternion_right : Sequence[float]
                       Right quaternion.

    Returns
    -------

    quaternion_composed : Sequence[float]
                          Product of the input quaternions.

    See Also
    --------
    axis_angle_to_quat, quat_to_hom_mat3d, quat_rotate_point_3d,
    quat_normalize, quat_conjugate, dual_quat_compose

    Predecessors
    ------------
    axis_angle_to_quat

    Successors
    ----------
    quat_to_hom_mat3d, quat_to_pose, quat_rotate_point_3d
    """
    with HalconOperator(232) as proc:
        proc.set_input_tuple(0, quaternion_left)
        proc.set_input_tuple(1, quaternion_right)
        proc.init_oct(0)
        proc.execute()
        quaternion_composed = proc.get_output_tuple_m(0)
        return quaternion_composed  # type: ignore


def quat_conjugate(quaternion: Sequence[float]) -> Sequence[float]:
    """
    Generate the conjugation of a quaternion.

    Parameters
    ----------

    quaternion : Sequence[float]
                 Input quaternion.

    Returns
    -------

    conjugated_quaternion : Sequence[float]
                            Conjugated quaternion.

    See Also
    --------
    axis_angle_to_quat, quat_to_hom_mat3d, quat_rotate_point_3d,
    quat_normalize, quat_compose, quat_interpolate, dual_quat_conjugate

    Predecessors
    ------------
    axis_angle_to_quat

    Successors
    ----------
    quat_to_hom_mat3d, quat_rotate_point_3d
    """
    with HalconOperator(223) as proc:
        proc.set_input_tuple(0, quaternion)
        proc.init_oct(0)
        proc.execute()
        conjugated_quaternion = proc.get_output_tuple_m(0)
        return conjugated_quaternion  # type: ignore


def quat_interpolate(
    quaternion_start: Sequence[float],
    quaternion_end: Sequence[float],
    interp_pos: Sequence[float]
) -> Sequence[float]:
    """
    Interpolation of two quaternions.

    Parameters
    ----------

    quaternion_start : Sequence[float]
                       Start quaternion.

    quaternion_end : Sequence[float]
                     End quaternion.

    interp_pos : Sequence[float]
                 Interpolation parameter.
                 Value Suggestion: 0.5

    Returns
    -------

    quaternion_interpolated : Sequence[float]
                              Interpolated quaternion.

    See Also
    --------
    quat_rotate_point_3d, quat_conjugate, quat_compose,
    dual_quat_interpolate

    Predecessors
    ------------
    axis_angle_to_quat, quat_normalize

    Successors
    ----------
    quat_to_hom_mat3d, quat_rotate_point_3d, quat_to_pose
    """
    with HalconOperator(231) as proc:
        proc.set_input_tuple(0, quaternion_start)
        proc.set_input_tuple(1, quaternion_end)
        proc.set_input_tuple(2, interp_pos)
        proc.init_oct(0)
        proc.execute()
        quaternion_interpolated = proc.get_output_tuple_m(0)
        return quaternion_interpolated  # type: ignore


def quat_normalize(quaternion: Sequence[float]) -> Sequence[float]:
    """
    Normalize a quaternion.

    Parameters
    ----------

    quaternion : Sequence[float]
                 Input quaternion.

    Returns
    -------

    normalized_quaternion : Sequence[float]
                            Normalized quaternion.

    See Also
    --------
    axis_angle_to_quat, quat_interpolate, quat_compose, quat_conjugate,
    dual_quat_to_hom_mat3d

    Predecessors
    ------------
    axis_angle_to_quat

    Successors
    ----------
    quat_to_hom_mat3d, quat_rotate_point_3d
    """
    with HalconOperator(224) as proc:
        proc.set_input_tuple(0, quaternion)
        proc.init_oct(0)
        proc.execute()
        normalized_quaternion = proc.get_output_tuple_m(0)
        return normalized_quaternion  # type: ignore


def quat_rotate_point_3d(
    quaternion: Sequence[float],
    px: float,
    py: float,
    pz: float
) -> Tuple[float, float, float]:
    """
    Perform a rotation by a unit quaternion.

    Parameters
    ----------

    quaternion : Sequence[float]
                 Rotation quaternion.

    px : float
         X coordinate of the point to be rotated.

    py : float
         Y coordinate of the point to be rotated.

    pz : float
         Z coordinate of the point to be rotated.

    Returns
    -------

    qx : float
         X coordinate of the rotated point.

    qy : float
         Y coordinate of the rotated point.

    qz : float
         Z coordinate of the rotated point.

    See Also
    --------
    axis_angle_to_quat, quat_to_hom_mat3d, quat_compose, quat_normalize,
    quat_conjugate, quat_interpolate, dual_quat_trans_line_3d

    Predecessors
    ------------
    axis_angle_to_quat

    Notes
    -----
    The operator quat_rotate_point_3d does not check whether Quaternion is
    a unit quaternion. If Quaternion is not a unit quaternion, the result
    of this operator is not defined.
    """
    with HalconOperator(222) as proc:
        proc.set_input_tuple(0, quaternion)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # qx
            proc.get_output_tuple_s(1),  # qy
            proc.get_output_tuple_s(2)   # qz
        )  # type: ignore


def quat_to_hom_mat3d(quaternion: Sequence[float]) -> Sequence[float]:
    """
    Convert a quaternion into the corresponding rotation matrix.

    Parameters
    ----------

    quaternion : Sequence[float]
                 Rotation quaternion.

    Returns
    -------

    rotation_matrix : Sequence[float]
                      Rotation matrix.

    See Also
    --------
    axis_angle_to_quat, quat_rotate_point_3d, quat_to_pose,
    quat_normalize, quat_conjugate, quat_interpolate

    Predecessors
    ------------
    axis_angle_to_quat, quat_compose

    Successors
    ----------
    affine_trans_point_3d

    Notes
    -----
    RotationMatrix will only be a valid rotation matrix if Quaternion is a
    unit quaternion.
    """
    with HalconOperator(229) as proc:
        proc.set_input_tuple(0, quaternion)
        proc.init_oct(0)
        proc.execute()
        rotation_matrix = proc.get_output_tuple_m(0)
        return rotation_matrix  # type: ignore


def quat_to_pose(
    quaternion: Sequence[float]
) -> Sequence[Union[float, int]]:
    """
    Convert a quaternion into the corresponding 3D pose.

    Parameters
    ----------

    quaternion : Sequence[float]
                 Rotation quaternion.

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D Pose.

    See Also
    --------
    pose_to_quat, axis_angle_to_quat, quat_compose, quat_rotate_point_3d,
    quat_to_hom_mat3d, quat_normalize, dual_quat_to_pose

    Predecessors
    ------------
    axis_angle_to_quat, quat_compose, quat_conjugate

    Successors
    ----------
    camera_calibration, write_pose, disp_caltab, sim_caltab
    """
    with HalconOperator(226) as proc:
        proc.set_input_tuple(0, quaternion)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def query_all_colors(window_handle: HHandle) -> Sequence[str]:
    """
    Query all color names.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    colors : Sequence[str]
             Color names.

    See Also
    --------
    query_color, set_system, set_color, disp_region, open_window

    Successors
    ----------
    set_system, set_color, disp_region
    """
    with HalconOperator(1258) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        colors = proc.get_output_tuple_m(0)
        return colors  # type: ignore


def query_aop_info(
    operator_name: Union[str, int],
    index_name: MaybeSequence[Union[str, int]],
    index_value: MaybeSequence[Union[str, int]]
) -> Tuple[Sequence[str], Sequence[str]]:
    """
    Query indexing structure of AOP information for operators.

    Parameters
    ----------

    operator_name : Union[str, int]
                    Operator to get information for
                    Value Suggestion: ''

    index_name : MaybeSequence[Union[str, int]]
                 Further specific index
                 Value Suggestion: ''

    index_value : MaybeSequence[Union[str, int]]
                  Further specific address
                  Value Suggestion: ''

    Returns
    -------

    name : Sequence[str]
           Name of next index stage

    value : Sequence[str]
            Values of next index stage
    """
    with HalconOperator(568) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, index_name)
        proc.set_input_tuple(2, index_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # name
            proc.get_output_tuple_m(1)   # value
        )  # type: ignore


def query_available_compute_devices() -> Sequence[int]:
    """
    Get the list of available compute devices.

    Returns
    -------

    device_identifier : Sequence[int]
                        List of available compute devices.

    Successors
    ----------
    get_compute_device_info, open_compute_device
    """
    with HalconOperator(306) as proc:
        proc.init_oct(0)
        proc.execute()
        device_identifier = proc.get_output_tuple_m(0)
        return device_identifier  # type: ignore


def query_available_dl_devices(
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> Sequence[HHandle]:
    """
    Get list of deep-learning-capable hardware devices.

    Parameters
    ----------

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    dldevice_handles : Sequence[HHandle]
                       Tuple of DLDevice handles

    Successors
    ----------
    get_dl_device_param
    """
    with HalconOperator(2214) as proc:
        proc.set_input_tuple(0, gen_param_name)
        proc.set_input_tuple(1, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        dldevice_handles = proc.get_output_tuple_m(0)
        return dldevice_handles  # type: ignore


def query_available_dl_devices_s(
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Get list of deep-learning-capable hardware devices.

    Parameters
    ----------

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    dldevice_handles : HHandle
                       Tuple of DLDevice handles

    Successors
    ----------
    get_dl_device_param
    """
    with HalconOperator(2214) as proc:
        proc.set_input_tuple(0, gen_param_name)
        proc.set_input_tuple(1, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        dldevice_handles = proc.get_output_tuple_s(0)
        return dldevice_handles  # type: ignore


def query_bar_code_params(
    bar_code_handle: HHandle,
    properties: str
) -> Sequence[str]:
    """
    Get the names of the parameters that can be used in set_bar_code* and
    get_bar_code* operators for a given bar code model

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    properties : str
                 Properties of the parameters.
                 Value Suggestion: 'trained_general'

    Returns
    -------

    gen_param_name : Sequence[str]
                     Names of the generic parameters.

    Predecessors
    ------------
    find_bar_code, decode_bar_code_rectangle2

    Successors
    ----------
    get_bar_code_param, get_bar_code_param_specific
    """
    with HalconOperator(1994) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, properties)
        proc.init_oct(0)
        proc.execute()
        gen_param_name = proc.get_output_tuple_m(0)
        return gen_param_name  # type: ignore


def query_bar_code_params_s(
    bar_code_handle: HHandle,
    properties: str
) -> str:
    """
    Get the names of the parameters that can be used in set_bar_code* and
    get_bar_code* operators for a given bar code model

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    properties : str
                 Properties of the parameters.
                 Value Suggestion: 'trained_general'

    Returns
    -------

    gen_param_name : str
                     Names of the generic parameters.

    Predecessors
    ------------
    find_bar_code, decode_bar_code_rectangle2

    Successors
    ----------
    get_bar_code_param, get_bar_code_param_specific
    """
    with HalconOperator(1994) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, properties)
        proc.init_oct(0)
        proc.execute()
        gen_param_name = proc.get_output_tuple_s(0)
        return gen_param_name  # type: ignore


def query_calib_data_observ_indices(
    calib_data_id: HHandle,
    item_type: str,
    item_idx: int
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Query information about the relations between cameras, calibration
    objects, and calibration object poses.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    item_type : str
                Kind of referred object.
                Value Suggestion: camera

    item_idx : int
               Camera index or calibration object index (depending on the
               selected ItemType).
               Value Suggestion: 0

    Returns
    -------

    index_1 : Sequence[int]
              List of calibration object indices or list of camera indices
              (depending on ItemType).

    index_2 : Sequence[int]
              Calibration object numbers.
    """
    with HalconOperator(1976) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, item_type)
        proc.set_input_tuple(2, item_idx)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # index_1
            proc.get_output_tuple_m(1)   # index_2
        )  # type: ignore


def query_color(window_handle: HHandle) -> Sequence[str]:
    """
    Query all color names displayable in the window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    colors : Sequence[str]
             Color names.

    See Also
    --------
    query_all_colors, set_color, disp_region, open_window

    Successors
    ----------
    set_color, disp_region
    """
    with HalconOperator(1259) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        colors = proc.get_output_tuple_m(0)
        return colors  # type: ignore


def query_colored() -> Sequence[int]:
    """
    Query the number of colors for color output.

    Returns
    -------

    possible_number_of_colors : Sequence[int]
                                Tuple of the possible numbers of colors.

    See Also
    --------
    set_colored, set_color

    Alternatives
    ------------
    query_color

    Successors
    ----------
    set_colored, set_color, disp_region
    """
    with HalconOperator(1257) as proc:
        proc.init_oct(0)
        proc.execute()
        possible_number_of_colors = proc.get_output_tuple_m(0)
        return possible_number_of_colors  # type: ignore


def query_contour_attribs_xld(contour: HObject) -> Sequence[str]:
    """
    Return the names of the defined attributes of an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    Returns
    -------

    attribs : Sequence[str]
              List of the defined contour attributes.

    See Also
    --------
    get_contour_attrib_xld, get_contour_global_attrib_xld,
    query_contour_global_attribs_xld

    Predecessors
    ------------
    lines_gauss, lines_facet, edges_sub_pix
    """
    with HalconOperator(67) as proc:
        proc.set_input_object(1, contour)
        proc.init_oct(0)
        proc.execute()
        attribs = proc.get_output_tuple_m(0)
        return attribs  # type: ignore


def query_contour_global_attribs_xld(contour: HObject) -> Sequence[str]:
    """
    Return the names of the defined global attributes of an XLD contour.

    Parameters
    ----------

    contour : HObject
              Input contour.

    Returns
    -------

    attribs : Sequence[str]
              List of the defined global contour attributes.

    See Also
    --------
    get_contour_global_attrib_xld, get_contour_attrib_xld,
    query_contour_attribs_xld

    Predecessors
    ------------
    lines_gauss, lines_facet, edges_sub_pix
    """
    with HalconOperator(65) as proc:
        proc.set_input_object(1, contour)
        proc.init_oct(0)
        proc.execute()
        attribs = proc.get_output_tuple_m(0)
        return attribs  # type: ignore


def query_data_code_2d_params(
    data_code_handle: HHandle,
    query_name: str
) -> Sequence[str]:
    """
    Get for a given 2D data code model the names of the generic parameters
    or objects that can be used in the other 2D data code operators.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    query_name : str
                 Name of the parameter group.
                 Value Suggestion: get_result_params

    Returns
    -------

    gen_param_name : Sequence[str]
                     List containing the names of the supported generic
                     parameters.

    Predecessors
    ------------
    create_data_code_2d_model

    Successors
    ----------
    get_data_code_2d_param, get_data_code_2d_results,
    get_data_code_2d_objects
    """
    with HalconOperator(1771) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, query_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_name = proc.get_output_tuple_m(0)
        return gen_param_name  # type: ignore


def query_font(window_handle: HHandle) -> Sequence[str]:
    """
    Query the available fonts.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    font : Sequence[str]
           Tuple with available font names.

    See Also
    --------
    set_font, write_string, read_string, read_char, new_line

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_font, write_string, read_string, read_char

    Notes
    -----
    For different machines the available fonts may differ a lot. Therefore
    query_font will return different fonts on different machines.
    """
    with HalconOperator(1200) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        font = proc.get_output_tuple_m(0)
        return font  # type: ignore


def query_gray(window_handle: HHandle) -> Sequence[int]:
    """
    Query the displayable gray values.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    grayval : Sequence[int]
              Tuple of all displayable gray values.

    See Also
    --------
    set_gray, disp_image

    Successors
    ----------
    set_gray, disp_region
    """
    with HalconOperator(1256) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        grayval = proc.get_output_tuple_m(0)
        return grayval  # type: ignore


def query_insert(window_handle: HHandle) -> Sequence[str]:
    """
    Query the possible graphic modes.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : Sequence[str]
           Display function name.

    See Also
    --------
    set_insert, get_insert

    Successors
    ----------
    set_insert, disp_region

    Warnings
    --------
    query_insert is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1255) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_m(0)
        return mode  # type: ignore


def query_io_device(
    iodevice_handle: HHandle,
    iochannel_name: MaybeSequence[str],
    query: Sequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Query information about channels of the specified I/O device.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    iochannel_name : MaybeSequence[str]
                     Channel names to query.

    query : Sequence[str]
            Name of the query.
            Value Suggestion: param_name

    Returns
    -------

    result : Sequence[Union[int, float, str]]
             List of values (according to Query).

    Successors
    ----------
    open_io_device
    """
    with HalconOperator(2017) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, iochannel_name)
        proc.set_input_tuple(2, query)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def query_io_interface(
    iointerface_name: str,
    query: MaybeSequence[str]
) -> Sequence[Union[int, float, str]]:
    """
    Query information about the specified I/O device interface.

    Parameters
    ----------

    iointerface_name : str
                       HALCON I/O interface name.
                       Value Suggestion: []

    query : MaybeSequence[str]
            Parameter name of the query.
            Value Suggestion: io_device_names

    Returns
    -------

    result : Sequence[Union[int, float, str]]
             List of result values (according to Query).

    Successors
    ----------
    open_io_device

    Notes
    -----
    On Windows Systems, error dialog boxes from the operating system can
    occur when dependency modules of the interface are not found, e.g.,
    the according SDK was not installed. The occurrence of the error boxes
    can be controlled by setting Windows' Error Mode. Please refer to the
    description of SetErrorMode within the Windows MSDN documentation.
    """
    with HalconOperator(2024) as proc:
        proc.set_input_tuple(0, iointerface_name)
        proc.set_input_tuple(1, query)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def query_line_width() -> Tuple[int, int]:
    """
    Query the possible line widths.

    Returns
    -------

    min : int
          Displayable minimum width.

    max : int
          Displayable maximum width.

    See Also
    --------
    disp_circle, disp_line, disp_rectangle1, disp_rectangle2, disp_region,
    set_line_width, get_line_width, set_line_style

    Successors
    ----------
    get_line_width, set_line_width, set_line_style, disp_line
    """
    with HalconOperator(1254) as proc:
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # min
            proc.get_output_tuple_s(1)   # max
        )  # type: ignore


def query_lut(window_handle: HHandle) -> Sequence[str]:
    """
    Query all available look-up-tables (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    look_up_table : Sequence[str]
                    Names of look-up-tables.

    See Also
    --------
    set_lut

    Successors
    ----------
    set_lut, disp_lut
    """
    with HalconOperator(1286) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        look_up_table = proc.get_output_tuple_m(0)
        return look_up_table  # type: ignore


def query_mshape(window_handle: HHandle) -> Sequence[str]:
    """
    Query all available mouse pointer shapes.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    shape_names : Sequence[str]
                  Available mouse pointer names.

    See Also
    --------
    set_mshape, get_mshape

    Predecessors
    ------------
    open_window, get_mshape

    Successors
    ----------
    set_mshape

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1279) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        shape_names = proc.get_output_tuple_m(0)
        return shape_names  # type: ignore


def query_operator_info() -> Sequence[str]:
    """
    Query slots concerning information with relation to the operator
    get_operator_info.

    Returns
    -------

    slots : Sequence[str]
            Slot names of the operator get_operator_info.

    See Also
    --------
    get_operator_info

    Successors
    ----------
    get_operator_info
    """
    with HalconOperator(1108) as proc:
        proc.init_oct(0)
        proc.execute()
        slots = proc.get_output_tuple_m(0)
        return slots  # type: ignore


def query_paint(window_handle: HHandle) -> Sequence[str]:
    """
    Query the gray value display modes.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    mode : Sequence[str]
           Gray value display mode names.

    See Also
    --------
    set_paint, get_paint, disp_image

    Successors
    ----------
    get_paint, set_paint, disp_image
    """
    with HalconOperator(1253) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        mode = proc.get_output_tuple_m(0)
        return mode  # type: ignore


def query_param_info() -> Sequence[str]:
    """
    Query slots of the online-information concerning the operator
    get_param_info.

    Returns
    -------

    slots : Sequence[str]
            Slot names for the operator get_param_info.

    See Also
    --------
    get_param_info

    Successors
    ----------
    get_param_info
    """
    with HalconOperator(1109) as proc:
        proc.init_oct(0)
        proc.execute()
        slots = proc.get_output_tuple_m(0)
        return slots  # type: ignore


def query_params_ocr_class_cnn(ocrhandle: HHandle) -> Sequence[str]:
    """
    Get the names of the parameters that can be used in
    get_params_ocr_class_cnn for a given CNN-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of OCR classifier.

    Returns
    -------

    gen_param_name : Sequence[str]
                     Names of the generic parameters.

    Successors
    ----------
    get_params_ocr_class_cnn
    """
    with HalconOperator(2081) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        gen_param_name = proc.get_output_tuple_m(0)
        return gen_param_name  # type: ignore


def query_params_ocr_class_cnn_s(ocrhandle: HHandle) -> str:
    """
    Get the names of the parameters that can be used in
    get_params_ocr_class_cnn for a given CNN-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of OCR classifier.

    Returns
    -------

    gen_param_name : str
                     Names of the generic parameters.

    Successors
    ----------
    get_params_ocr_class_cnn
    """
    with HalconOperator(2081) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        gen_param_name = proc.get_output_tuple_s(0)
        return gen_param_name  # type: ignore


def query_shape() -> Sequence[str]:
    """
    Query the region display modes.

    Returns
    -------

    display_shape : Sequence[str]
                    region display mode names.

    See Also
    --------
    set_shape, get_shape, disp_region

    Successors
    ----------
    get_shape, set_shape, disp_region
    """
    with HalconOperator(1252) as proc:
        proc.init_oct(0)
        proc.execute()
        display_shape = proc.get_output_tuple_m(0)
        return display_shape  # type: ignore


def query_sheet_of_light_params(
    sheet_of_light_model_id: HHandle,
    query_name: str
) -> Sequence[str]:
    """
    For a given sheet-of-light model get the names of the generic iconic
    or control parameters that can be used in the different sheet-of-light
    operators.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    query_name : str
                 Name of the parameter group.
                 Value Suggestion: create_model_params

    Returns
    -------

    gen_param_name : Sequence[str]
                     List containing the names of the supported generic
                     parameters.

    Successors
    ----------
    create_sheet_of_light_model, set_sheet_of_light_param,
    get_sheet_of_light_param, get_sheet_of_light_result
    """
    with HalconOperator(387) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, query_name)
        proc.init_oct(0)
        proc.execute()
        gen_param_name = proc.get_output_tuple_m(0)
        return gen_param_name  # type: ignore


def query_spy() -> Tuple[Sequence[str], Sequence[str]]:
    """
    Inquiring for possible settings of the HALCON debugging tool.

    Returns
    -------

    classes : Sequence[str]
              Available control modes (see also set_spy).

    values : Sequence[str]
             Corresponding state of the control modes.

    See Also
    --------
    set_spy, get_spy

    Predecessors
    ------------
    reset_obj_db

    Notes
    -----
    The values of Values cannot be used as direct input for set_spy, as
    they are transmitted as a symbolic constant.
    """
    with HalconOperator(371) as proc:
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # classes
            proc.get_output_tuple_m(1)   # values
        )  # type: ignore


def query_tshape(window_handle: HHandle) -> Sequence[str]:
    """
    Query all shapes available for text cursors.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    text_cursor : Sequence[str]
                  Names of the available text cursors.

    See Also
    --------
    set_tshape, get_shape, set_tposition, write_string, read_string

    Predecessors
    ------------
    open_window

    Successors
    ----------
    set_tshape, write_string, read_string

    Warnings
    --------
    query_tshape is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1201) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.execute()
        text_cursor = proc.get_output_tuple_m(0)
        return text_cursor  # type: ignore


def query_window_type() -> Sequence[str]:
    """
    Query all available window types.

    Returns
    -------

    window_types : Sequence[str]
                   Names of available window types.

    Predecessors
    ------------
    reset_obj_db
    """
    with HalconOperator(1177) as proc:
        proc.init_oct(0)
        proc.execute()
        window_types = proc.get_output_tuple_m(0)
        return window_types  # type: ignore


def radial_distortion_self_calibration(
    contours: HObject,
    width: int,
    height: int,
    inlier_threshold: float,
    rand_seed: int,
    distortion_model: str,
    distortion_center: str,
    principal_point_var: float
) -> Tuple[HObject, Sequence[Union[int, float, str]]]:
    """
    Calibrate the radial distortion.

    Parameters
    ----------

    contours : HObject
               Contours that are available for the calibration.

    width : int
            Width of the images from which the contours were extracted.
            Value Suggestion: 640
            Assertion: Width > 0

    height : int
             Height of the images from which the contours were extracted.
             Value Suggestion: 480
             Assertion: Height > 0

    inlier_threshold : float
                       Threshold for the classification of outliers.
                       Value Suggestion: 0.05
                       Assertion: InlierThreshold >= 0

    rand_seed : int
                Seed value for the random number generator.
                Value Suggestion: 42

    distortion_model : str
                       Determines the distortion model.
                       Value Suggestion: division

    distortion_center : str
                        Determines how the distortion center will be
                        estimated.
                        Value Suggestion: variable

    principal_point_var : float
                          Controls the deviation of the distortion center
                          from the image center; larger values allow
                          larger deviations from the image center; 0
                          switches the penalty term off.
                          Value Suggestion: 0.0
                          Assertion: PrincipalPointVar >= 0.0 && PrincipalPointVar <= 100.0

    Returns
    -------

    selected_contours : HObject
                        Contours that were used for the calibration

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    See Also
    --------
    camera_calibration

    Predecessors
    ------------
    edges_sub_pix, segment_contours_xld

    Successors
    ----------
    change_radial_distortion_cam_par, change_radial_distortion_image

    Notes
    -----
    Since the polynomial model (DistortionModel $=$ 'polynomial') uses
    more parameters than the division model (DistortionModel $=$
    'division') the calibration using the polynomial model can be slightly
    less stable than the calibration using the division model, which
    becomes noticeable in the accuracy of the decentering distortion
    parameters $P_{1}, P_{2}$P1, P2. To improve the stability, contours of
    multiple images can be used. Additional stability can be achieved by
    setting $DistortionCenter = 'fixed'$, $DistortionCenter = 'adaptive'$,
    or $PrincipalPointVar > 0$, which was already mentioned above.
    """
    with HalconOperator(1904) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, inlier_threshold)
        proc.set_input_tuple(3, rand_seed)
        proc.set_input_tuple(4, distortion_model)
        proc.set_input_tuple(5, distortion_center)
        proc.set_input_tuple(6, principal_point_var)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # selected_contours
            proc.get_output_tuple_m(0)   # camera_param
        )  # type: ignore


def radiometric_self_calibration(
    images: HObject,
    exposure_ratios: MaybeSequence[float],
    features: str,
    function_type: str,
    smoothness: float,
    polynomial_degree: int
) -> Sequence[Union[int, float]]:
    """
    Perform a radiometric self-calibration of a camera.

    Parameters
    ----------

    images : HObject
             Input images.

    exposure_ratios : MaybeSequence[float]
                      Ratio of the exposure energies of successive image
                      pairs.
                      Value Suggestion: 0.5
                      Assertion: ExposureRatios > 0 && ExposureRatios < 1

    features : str
               Features that are used to compute the inverse response
               function of the camera.
               Value Suggestion: 2d_histogram

    function_type : str
                    Type of the inverse response function of the camera.
                    Value Suggestion: discrete

    smoothness : float
                 Smoothness of the inverse response function of the camera.
                 Value Suggestion: 1.0
                 Assertion: Smoothness > 0

    polynomial_degree : int
                        Degree of the polynomial if FunctionType =
                        'polynomial'.
                        Value Suggestion: 5
                        Assertion: PolynomialDegree >= 1 && PolynomialDegree <= 20

    Returns
    -------

    inverse_response : Sequence[Union[int, float]]
                       Inverse response function of the camera.

    See Also
    --------
    histo_2dim, gray_histo, gray_histo_abs, reduce_domain

    Predecessors
    ------------
    read_image, grab_image, grab_image_async, set_framegrabber_param,
    concat_obj, proj_match_points_ransac, proj_match_points_ransac_guided,
    projective_trans_image

    Successors
    ----------
    lut_trans
    """
    with HalconOperator(1910) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, exposure_ratios)
        proc.set_input_tuple(1, features)
        proc.set_input_tuple(2, function_type)
        proc.set_input_tuple(3, smoothness)
        proc.set_input_tuple(4, polynomial_degree)
        proc.init_oct(0)
        proc.execute()
        inverse_response = proc.get_output_tuple_m(0)
        return inverse_response  # type: ignore


def rank_image(
    image: HObject,
    mask: HObject,
    rank: int,
    margin: Union[int, float, str]
) -> HObject:
    """
    Compute a rank filter with arbitrary masks.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask : HObject
           Filter mask.

    rank : int
           Rank of the output gray value.
           Value Suggestion: 5

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_rank : HObject
                 Filtered image.

    See Also
    --------
    gray_erosion_rect, gray_dilation_rect, gray_erosion_shape,
    gray_dilation_shape, gray_erosion, gray_dilation

    Alternatives
    ------------
    rank_rect, median_image, median_rect

    Predecessors
    ------------
    read_image, draw_region, gen_circle, gen_rectangle1, gen_rectangle2

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    rank_image uses an algorithm with a runtime per pixel that depends on
    the number of runs in the mask Mask.  Therefore, rank_image is slower
    than rank_rect for rectangular masks with a large mask height.  The
    precise mask height for which rank_rect will become faster than
    rank_image depends on the computer architecture (processor type,
    availability of SIMD instructions like SSE2 or MMX, cache size and
    throughput, memory throughput).  Typically, this is the case for mask
    heights $>$ 15, but can also be the case only for larger mask sizes,
    e.g., if SIMD instructions are unavailable and memory throughput is
    low.
    Furthermore, it should be noted that rank_rect uses a recursive
    implementation, which internally computes the filter response on the
    smallest enclosing rectangle of the domain of the input image.
    Therefore, if the domain of the input image only covers a small
    fraction of the smallest enclosing rectangle, it can happen that
    rank_image is faster than rank_rect even for larger mask heights.
    rank_image should neither be used with $Rank = 1$ to perform a gray
    value erosion nor with $Rank = A$ to perform a gray value dilation.
    In these cases, the operators gray_erosion_rect, gray_erosion_shape,
    or gray_erosion and gray_dilation_rect, gray_dilation_shape, or
    gray_dilation, respectively, are typically faster than rank_image.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1416) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, mask)
        proc.set_input_tuple(0, rank)
        proc.set_input_tuple(1, margin)
        proc.execute()
        image_rank = HObject(proc.get_output_object_key(1))
        return image_rank  # type: ignore


def rank_n(image: HObject, rank_index: int) -> HObject:
    """
    Return gray values with given rank from multiple channels.

    Parameters
    ----------

    image : HObject
            Multichannel gray image.

    rank_index : int
                 Rank of the gray value images to return.
                 Value Suggestion: 2

    Returns
    -------

    rank_image : HObject
                 Result of the rank function.

    See Also
    --------
    count_channels, rank_image

    Alternatives
    ------------
    mean_n

    Predecessors
    ------------
    compose2, compose3, compose4, compose5, add_channels

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1425) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, rank_index)
        proc.execute()
        rank_image = HObject(proc.get_output_object_key(1))
        return rank_image  # type: ignore


def rank_rect(
    image: HObject,
    mask_width: int,
    mask_height: int,
    rank: int
) -> HObject:
    """
    Compute a rank filter with rectangular masks.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask_width : int
                 Width of the filter mask.
                 Value Suggestion: 15

    mask_height : int
                  Height of the filter mask.
                  Value Suggestion: 15

    rank : int
           Rank of the output gray value.
           Value Suggestion: 5
           Assertion: 1 <= Rank && Rank <= MaskWidth * MaskHeight

    Returns
    -------

    image_rank : HObject
                 Filtered image.

    See Also
    --------
    gray_erosion_rect, gray_dilation_rect, gray_erosion_shape,
    gray_dilation_shape, gray_erosion, gray_dilation

    Alternatives
    ------------
    rank_image, median_rect, median_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    If even values instead of odd values are passed in MaskHeight or
    MaskWidth, rank_rect uses the next larger odd values instead.
    rank_rect uses an algorithm with constant runtime per pixel, i.e., the
    runtime only depends on the size of the input image and not on the
    mask size.  Therefore, for large mask sizes rank_rect is the fastest
    implementation of the rank filter in HALCON.  Depending on the
    computer architecture (processor type, availability of SIMD
    instructions like SSE2 or MMX, cache size and throughput, memory
    throughput), for small mask sizes the implementation used in
    rank_image is faster than rank_rect.  Typically, this is the case for
    MaskHeight $- 15, but can also happen for larger mask sizes, e.g., if
    SIMD instructions are unavailable and memory throughput is low.
    Furthermore, it should be noted that rank_rect uses a recursive
    implementation, which internally computes the filter response on the
    smallest enclosing rectangle of the domain of the input image.
    Therefore, if the domain of the input image only covers a small
    fraction of the smallest enclosing rectangle, it can happen that
    rank_image is faster than rank_rect even for larger values of
    MaskHeight.
    rank_rect should neither be used with $Rank = 1$Rank = 1 to perform a
    gray value erosion nor with $Rank = MaskWidth
    arRef{MaskHeight}$Rank = MaskWidth * MaskHeight to perform a gray
    value dilation.  In these cases, the operators gray_erosion_rect or
    gray_erosion_shape and gray_dilation_rect or gray_dilation_shape,
    respectively, are faster than rank_rect for almost all mask sizes.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1415) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, rank)
        proc.execute()
        image_rank = HObject(proc.get_output_object_key(1))
        return image_rank  # type: ignore


def rank_region(
    region: HObject,
    width: int,
    height: int,
    number: int
) -> HObject:
    """
    Rank operator for regions.

    Parameters
    ----------

    region : HObject
             Region(s) to be transformed.

    width : int
            Width of the filter mask.
            Value Suggestion: 15
            Assertion: Width >= 3 && odd(Width)

    height : int
             Height of the filter mask.
             Value Suggestion: 15
             Assertion: Height >= 3 && odd(Height)

    number : int
             Minimum number of points lying within the filter mask.
             Value Suggestion: 70
             Assertion: Number > 0

    Returns
    -------

    region_count : HObject
                   Resulting region(s).

    See Also
    --------
    rank_image, mean_image

    Alternatives
    ------------
    closing_rectangle1, expand_region

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape, disp_region

    Notes
    -----
    For Height and Width only odd values $>$ 3 are valid.  If invalid
    parameters are chosen they are converted automatically (without
    raising an exception) to the next larger odd values.
    """
    with HalconOperator(500) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, number)
        proc.execute()
        region_count = HObject(proc.get_output_object_key(1))
        return region_count  # type: ignore


def read_aop_knowledge(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, int, float]]
) -> Tuple[Sequence[str], Sequence[str]]:
    """
    Load knowledge about hardware dependent behavior of automatic operator
    parallelization.

    Parameters
    ----------

    file_name : str
                Name of knowledge file
                Value Suggestion: ''

    gen_param_name : MaybeSequence[str]
                     Parameter name
                     Value Suggestion: none

    gen_param_value : MaybeSequence[Union[str, int, float]]
                      Parameter value
                      Value Suggestion: none

    Returns
    -------

    attributes : Sequence[str]
                 Knowledge attributes

    operator_names : Sequence[str]
                     Updated Operators
    """
    with HalconOperator(571) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # attributes
            proc.get_output_tuple_m(1)   # operator_names
        )  # type: ignore


def read_aop_knowledge_s(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, int, float]]
) -> Tuple[Sequence[str], str]:
    """
    Load knowledge about hardware dependent behavior of automatic operator
    parallelization.

    Parameters
    ----------

    file_name : str
                Name of knowledge file
                Value Suggestion: ''

    gen_param_name : MaybeSequence[str]
                     Parameter name
                     Value Suggestion: none

    gen_param_value : MaybeSequence[Union[str, int, float]]
                      Parameter value
                      Value Suggestion: none

    Returns
    -------

    attributes : Sequence[str]
                 Knowledge attributes

    operator_names : str
                     Updated Operators
    """
    with HalconOperator(571) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # attributes
            proc.get_output_tuple_s(1)   # operator_names
        )  # type: ignore


def read_bar_code_model(file_name: str) -> HHandle:
    """
    Read a bar code model from a file and create a new model.

    Parameters
    ----------

    file_name : str
                Name of the bar code model file.
                Value Suggestion: bar_code_model.bcm

    Returns
    -------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    See Also
    --------
    write_bar_code_model, clear_bar_code_model

    Alternatives
    ------------
    create_bar_code_model

    Successors
    ----------
    find_bar_code
    """
    with HalconOperator(1988) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        bar_code_handle = proc.get_output_tuple_s(0)
        return bar_code_handle  # type: ignore


def read_calib_data(file_name: str) -> HHandle:
    """
    Restore a calibration data model from a file.

    Parameters
    ----------

    file_name : str
                The path and file name of the model file.

    Returns
    -------

    calib_data_id : HHandle
                    Handle of a calibration data model.
    """
    with HalconOperator(1963) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        calib_data_id = proc.get_output_tuple_s(0)
        return calib_data_id  # type: ignore


def read_cam_par(cam_par_file: str) -> Sequence[Union[int, float, str]]:
    """
    Read internal camera parameters from a file.

    Parameters
    ----------

    cam_par_file : str
                   File name of internal camera parameters.
                   Value Suggestion: campar.dat

    Returns
    -------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    See Also
    --------
    find_caltab, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab, write_cam_par, write_pose, read_pose, project_3d_point,
    get_line_of_sight

    Successors
    ----------
    find_marks_and_pose, sim_caltab, gen_caltab, disp_caltab,
    camera_calibration
    """
    with HalconOperator(1942) as proc:
        proc.set_input_tuple(0, cam_par_file)
        proc.init_oct(0)
        proc.execute()
        camera_param = proc.get_output_tuple_m(0)
        return camera_param  # type: ignore


def read_camera_setup_model(file_name: str) -> HHandle:
    """
    Restore a camera setup model from a file.

    Parameters
    ----------

    file_name : str
                The path and file name of the model file.

    Returns
    -------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.
    """
    with HalconOperator(1954) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        camera_setup_model_id = proc.get_output_tuple_s(0)
        return camera_setup_model_id  # type: ignore


def read_char(window_handle: HHandle) -> Tuple[str, str]:
    """
    Read a character from a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    Returns
    -------

    char : str
           Input character (if it is not a control character).

    code : str
           Code for input character.

    See Also
    --------
    write_string, set_font

    Alternatives
    ------------
    read_string, fread_char, fread_string

    Predecessors
    ------------
    open_window, set_font
    """
    with HalconOperator(1194) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # char
            proc.get_output_tuple_s(1)   # code
        )  # type: ignore


def read_class_box(classif_handle: HHandle, file_name: str) -> None:
    """
    Read a classifier from a file.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    file_name : str
                Filename of the classifier.

    See Also
    --------
    create_class_box, write_class_box

    Predecessors
    ------------
    create_class_box

    Successors
    ----------
    test_sampset_box, enquire_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    read_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.

    Notes
    -----
    All values of the classifier are going to be overwritten.
    """
    with HalconOperator(1889) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def read_class_gmm(file_name: str) -> HHandle:
    """
    Read a Gaussian Mixture Model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    gmmhandle : HHandle
                GMM handle.

    See Also
    --------
    create_class_gmm, write_class_gmm

    Successors
    ----------
    classify_class_gmm, evaluate_class_gmm, create_class_lut_gmm
    """
    with HalconOperator(1828) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        gmmhandle = proc.get_output_tuple_s(0)
        return gmmhandle  # type: ignore


def read_class_knn(file_name: str) -> HHandle:
    """
    Read the k-NN classifier from a file.

    Parameters
    ----------

    file_name : str
                File name of the classifier.

    Returns
    -------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    See Also
    --------
    create_class_knn

    Successors
    ----------
    classify_class_knn
    """
    with HalconOperator(1809) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        knnhandle = proc.get_output_tuple_s(0)
        return knnhandle  # type: ignore


def read_class_mlp(file_name: str) -> HHandle:
    """
    Read a multilayer perceptron from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    mlphandle : HHandle
                MLP handle.

    See Also
    --------
    create_class_mlp, write_class_mlp

    Alternatives
    ------------
    read_dl_classifier

    Successors
    ----------
    classify_class_mlp, evaluate_class_mlp, create_class_lut_mlp
    """
    with HalconOperator(1867) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        mlphandle = proc.get_output_tuple_s(0)
        return mlphandle  # type: ignore


def read_class_svm(file_name: str) -> HHandle:
    """
    Read a support vector machine from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    svmhandle : HHandle
                SVM handle.

    See Also
    --------
    create_class_svm, write_class_svm

    Alternatives
    ------------
    read_dl_classifier

    Successors
    ----------
    classify_class_svm, create_class_lut_svm
    """
    with HalconOperator(1846) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        svmhandle = proc.get_output_tuple_s(0)
        return svmhandle  # type: ignore


def read_class_train_data(file_name: str) -> HHandle:
    """
    Read the training data for classifiers from a file.

    Parameters
    ----------

    file_name : str
                File name of the training data.

    Returns
    -------

    class_train_data_handle : HHandle
                              Handle of the training data.

    See Also
    --------
    create_class_train_data, write_class_train_data
    """
    with HalconOperator(1781) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        class_train_data_handle = proc.get_output_tuple_s(0)
        return class_train_data_handle  # type: ignore


def read_component_model(file_name: str) -> HHandle:
    """
    Read a component model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    component_model_id : HHandle
                         Handle of the component model.

    Successors
    ----------
    find_component_model
    """
    with HalconOperator(1002) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        component_model_id = proc.get_output_tuple_s(0)
        return component_model_id  # type: ignore


def read_contour_xld_arc_info(file_name: str) -> HObject:
    """
    Read XLD contours to a file in ARC/INFO generate format.

    Parameters
    ----------

    file_name : str
                Name of the ARC/INFO file.

    Returns
    -------

    contours : HObject
               Read XLD contours.

    See Also
    --------
    read_world_file, write_contour_xld_arc_info, read_polygon_xld_arc_info

    Successors
    ----------
    hom_mat2d_invert, affine_trans_contour_xld
    """
    with HalconOperator(20) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()
        contours = HObject(proc.get_output_object_key(1))
        return contours  # type: ignore


def read_contour_xld_dxf(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HObject, Sequence[str]]:
    """
    Read XLD contours from a DXF file.

    Parameters
    ----------

    file_name : str
                Name of the DXF file.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the DXF input.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the DXF input.
                      Value Suggestion: []

    Returns
    -------

    contours : HObject
               Read XLD contours.

    dxf_status : Sequence[str]
                 Status information.

    See Also
    --------
    write_contour_xld_dxf, read_polygon_xld_dxf,
    query_contour_attribs_xld, query_contour_global_attribs_xld,
    get_contour_attrib_xld, get_contour_global_attrib_xld

    Predecessors
    ------------
    write_contour_xld_dxf
    """
    with HalconOperator(1636) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # contours
            proc.get_output_tuple_m(0)   # dxf_status
        )  # type: ignore


def read_contour_xld_dxf_s(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HObject, str]:
    """
    Read XLD contours from a DXF file.

    Parameters
    ----------

    file_name : str
                Name of the DXF file.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the DXF input.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the DXF input.
                      Value Suggestion: []

    Returns
    -------

    contours : HObject
               Read XLD contours.

    dxf_status : str
                 Status information.

    See Also
    --------
    write_contour_xld_dxf, read_polygon_xld_dxf,
    query_contour_attribs_xld, query_contour_global_attribs_xld,
    get_contour_attrib_xld, get_contour_global_attrib_xld

    Predecessors
    ------------
    write_contour_xld_dxf
    """
    with HalconOperator(1636) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # contours
            proc.get_output_tuple_s(0)   # dxf_status
        )  # type: ignore


def read_data_code_2d_model(file_name: str) -> HHandle:
    """
    Read a 2D data code model from a file and create a new model.

    Parameters
    ----------

    file_name : str
                Name of the 2D data code model file.
                Value Suggestion: data_code_model.dcm

    Returns
    -------

    data_code_handle : HHandle
                       Handle of the created 2D data code model.

    See Also
    --------
    write_data_code_2d_model, clear_data_code_2d_model

    Alternatives
    ------------
    create_data_code_2d_model

    Successors
    ----------
    find_data_code_2d
    """
    with HalconOperator(1774) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        data_code_handle = proc.get_output_tuple_s(0)
        return data_code_handle  # type: ignore


def read_deep_ocr(file_name: str) -> HHandle:
    """
    Read a Deep OCR model from a file.

    Parameters
    ----------

    file_name : str
                Filename

    Returns
    -------

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    Alternatives
    ------------
    create_deep_ocr

    Successors
    ----------
    set_deep_ocr_param, get_deep_ocr_param, apply_deep_ocr
    """
    with HalconOperator(2215) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        deep_ocr_handle = proc.get_output_tuple_s(0)
        return deep_ocr_handle  # type: ignore


def read_deformable_model(file_name: str) -> HHandle:
    """
    Read a deformable model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model, find_local_deformable_model
    """
    with HalconOperator(965) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def read_deformable_surface_model(file_name: str) -> HHandle:
    """
    Read a deformable surface model from a file.

    Parameters
    ----------

    file_name : str
                Name of the file to read.

    Returns
    -------

    deformable_surface_model : HHandle
                               Handle of the read deformable surface model.

    See Also
    --------
    create_deformable_surface_model, write_deformable_surface_model

    Alternatives
    ------------
    create_deformable_surface_model

    Predecessors
    ------------
    write_deformable_surface_model

    Successors
    ----------
    find_deformable_surface_model, refine_deformable_surface_model,
    get_deformable_surface_model_param, clear_deformable_surface_model
    """
    with HalconOperator(1024) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        deformable_surface_model = proc.get_output_tuple_s(0)
        return deformable_surface_model  # type: ignore


def read_descriptor_model(file_name: str) -> HHandle:
    """
    Read a descriptor model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_calib_descriptor_model, create_uncalib_descriptor_model

    Successors
    ----------
    find_uncalib_descriptor_model, find_calib_descriptor_model
    """
    with HalconOperator(946) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def read_dict(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Read a dictionary from a file.

    Parameters
    ----------

    file_name : str
                File name.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    dict_handle : HHandle
                  Dictionary handle.

    See Also
    --------
    write_dict, serialize_handle, deserialize_handle

    Predecessors
    ------------
    write_dict
    """
    with HalconOperator(2162) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        dict_handle = proc.get_output_tuple_s(0)
        return dict_handle  # type: ignore


def read_distance_transform_xld(file_name: str) -> HHandle:
    """
    Read an XLD distance transform from a file.

    Parameters
    ----------

    file_name : str
                Name of the file.

    Returns
    -------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    See Also
    --------
    write_distance_transform_xld, serialize_distance_transform_xld,
    deserialize_distance_transform_xld, create_distance_transform_xld,
    set_distance_transform_xld_param, clear_distance_transform_xld

    Successors
    ----------
    apply_distance_transform_xld, get_distance_transform_xld_contour,
    get_distance_transform_xld_param
    """
    with HalconOperator(1353) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        distance_transform_id = proc.get_output_tuple_s(0)
        return distance_transform_id  # type: ignore


def read_dl_classifier(file_name: str) -> HHandle:
    """
    Read a deep-learning-based classifier from a file.

    Parameters
    ----------

    file_name : str
                File name.
                Value Suggestion: pretrained_dl_classifier_compact.hdl

    Returns
    -------

    dlclassifier_handle : HHandle
                          Handle of the deep learning classifier.

    Alternatives
    ------------
    read_dl_model, read_class_mlp, read_class_svm

    Successors
    ----------
    set_dl_classifier_param, get_dl_classifier_param, apply_dl_classifier,
    train_dl_classifier_batch

    Warnings
    --------
    read_dl_classifier is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the common
    CNN-based operator read_dl_model.
    """
    with HalconOperator(2122) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        dlclassifier_handle = proc.get_output_tuple_s(0)
        return dlclassifier_handle  # type: ignore


def read_dl_model(file_name: str) -> HHandle:
    """
    Read a deep learning model from a file.

    Parameters
    ----------

    file_name : str
                Filename
                Value Suggestion: pretrained_dl_classifier_compact.hdl

    Returns
    -------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    Alternatives
    ------------
    create_dl_model_detection

    Successors
    ----------
    set_dl_model_param, get_dl_model_param, apply_dl_model,
    train_dl_model_batch, train_dl_model_anomaly_dataset
    """
    with HalconOperator(2163) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        dlmodel_handle = proc.get_output_tuple_s(0)
        return dlmodel_handle  # type: ignore


def read_fft_optimization_data(file_name: str) -> None:
    """
    Load FFT speed optimization data from a file.

    Parameters
    ----------

    file_name : str
                File name of the optimization data.
                Value Suggestion: 'fft_opt.dat'

    See Also
    --------
    write_fft_optimization_data

    Alternatives
    ------------
    optimize_fft_speed, optimize_rft_speed

    Successors
    ----------
    fft_generic, fft_image, fft_image_inv, rft_generic, wiener_filter,
    wiener_filter_ni, photometric_stereo, sfs_pentland, sfs_mod_lr,
    sfs_orig_lr
    """
    with HalconOperator(1537) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()


def read_funct_1d(file_name: str) -> Sequence[Union[float, int]]:
    """
    Read a function from a file.

    Parameters
    ----------

    file_name : str
                Name of the file to be read.

    Returns
    -------

    function : Sequence[Union[float, int]]
               Function from the file.

    See Also
    --------
    write_funct_1d, write_image, write_region, open_file

    Alternatives
    ------------
    fread_string, read_tuple
    """
    with HalconOperator(1397) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        function = proc.get_output_tuple_m(0)
        return function  # type: ignore


def read_funct_1d_s(file_name: str) -> Union[float, int]:
    """
    Read a function from a file.

    Parameters
    ----------

    file_name : str
                Name of the file to be read.

    Returns
    -------

    function : Union[float, int]
               Function from the file.

    See Also
    --------
    write_funct_1d, write_image, write_region, open_file

    Alternatives
    ------------
    fread_string, read_tuple
    """
    with HalconOperator(1397) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        function = proc.get_output_tuple_s(0)
        return function  # type: ignore


def read_gray_se(file_name: str) -> HObject:
    """
    Load a structuring element for gray morphology.

    Parameters
    ----------

    file_name : str
                Name of the file containing the structuring element.

    Returns
    -------

    se : HObject
         Generated structuring element.

    See Also
    --------
    paint_region, paint_gray, crop_part

    Alternatives
    ------------
    gen_disc_se, read_image, change_domain

    Successors
    ----------
    gray_erosion, gray_dilation, gray_opening, gray_closing, gray_tophat,
    gray_bothat, write_image
    """
    with HalconOperator(786) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()
        se = HObject(proc.get_output_object_key(1))
        return se  # type: ignore


def read_image(file_name: MaybeSequence[str]) -> HObject:
    """
    Read an image with different file formats.

    Parameters
    ----------

    file_name : MaybeSequence[str]
                Name of the image to be read.
                Value Suggestion: printer_chip/printer_chip_01

    Returns
    -------

    image : HObject
            Read image.

    See Also
    --------
    set_system, write_image

    Alternatives
    ------------
    read_sequence

    Successors
    ----------
    disp_image, threshold, regiongrowing, count_channels, decompose3,
    class_ndim_norm, gauss_filter, fill_interlace, zoom_image_size,
    zoom_image_factor, crop_part, write_image, rgb1_to_gray

    Notes
    -----
    If CMYK or YCCK JPEG/JPEG-XR files are read, HALCON assumes that these
    files follow the Adobe Photoshop convention that the CMYK channels are
    stored inverted, i.e., 0 represents 100- ink coverage, rather than 0-
    ink as one would expect.  The images are converted to RGB images using
    this convention.  If the JPEG file does not follow this convention,
    but stores the CMYK channels in the usual fashion, invert_image must
    be called after reading the image.
    If PNG images that contain an alpha channel are read, the alpha
    channel is returned as the second or fourth channel of the output
    image, unless the alpha channel contains exactly two different gray
    values, in which case a one or three channel image with a reduced
    domain is returned, in which the points in the domain correspond to
    the points with the higher gray value in the alpha channel.
    """
    with HalconOperator(1658) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def read_image_metadata(
    format: str,
    tag_name: str,
    file_name: str
) -> Union[int, float, str]:
    """
    Read metadata from image files.

    Parameters
    ----------

    format : str
             Graphic format.
             Value Suggestion: 'tiff'

    tag_name : str
               Name of the tag to be written in the image file.
               Value Suggestion: 'tiff_image_description'

    file_name : str
                Name of image file.

    Returns
    -------

    tag_value : Union[int, float, str]
                Output tag value read from the image file.

    Predecessors
    ------------
    write_image_metadata

    Successors
    ----------
    read_image
    """
    with HalconOperator(2185) as proc:
        proc.set_input_tuple(0, format)
        proc.set_input_tuple(1, tag_name)
        proc.set_input_tuple(2, file_name)
        proc.init_oct(0)
        proc.execute()
        tag_value = proc.get_output_tuple_s(0)
        return tag_value  # type: ignore


def read_io_channel(
    iochannel_handle: MaybeSequence[HHandle]
) -> Tuple[Sequence[Union[int, float, str]], Sequence[int]]:
    """
    Read a value from the specified I/O channels.

    Parameters
    ----------

    iochannel_handle : MaybeSequence[HHandle]
                       Handles of the opened I/O channels.

    Returns
    -------

    value : Sequence[Union[int, float, str]]
            Read value.

    status : Sequence[int]
             Status of read value.

    See Also
    --------
    write_io_channel, query_io_device, set_io_channel_param

    Predecessors
    ------------
    open_io_channel, set_io_channel_param

    Successors
    ----------
    close_io_channel
    """
    with HalconOperator(2012) as proc:
        proc.set_input_tuple(0, iochannel_handle)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # value
            proc.get_output_tuple_m(1)   # status
        )  # type: ignore


def read_kalman(
    file_name: str
) -> Tuple[Sequence[int], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Read the description file of a Kalman filter.

    Parameters
    ----------

    file_name : str
                Description file for a Kalman filter.
                Value Suggestion: 'kalman.init'

    Returns
    -------

    dimension : Sequence[int]
                The dimensions of the state vector, the measurement vector
                and the controller vector.

    model : Sequence[float]
            The lined up matrices A, C, Q$A, C, Q$, possibly G$G$ and
            u$u$, and if necessary L$L$ stored in row-major order.

    measurement : Sequence[float]
                  The matrix R$R$ stored in row-major order.

    prediction : Sequence[float]
                 The matrix P0$P_{0}$ (error covariance matrix of the
                 initial state estimate) stored in row-major order and the
                 initial state estimate x0$x_{0}$ lined up.

    See Also
    --------
    update_kalman, filter_kalman

    Successors
    ----------
    filter_kalman

    Warnings
    --------
    read_kalman is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1105) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # dimension
            proc.get_output_tuple_m(1),  # model
            proc.get_output_tuple_m(2),  # measurement
            proc.get_output_tuple_m(3)   # prediction
        )  # type: ignore


def read_matrix(file_name: str) -> HHandle:
    """
    Read a matrix from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    matrix_id : HHandle
                Matrix handle.

    Successors
    ----------
    get_full_matrix
    """
    with HalconOperator(842) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        matrix_id = proc.get_output_tuple_s(0)
        return matrix_id  # type: ignore


def read_measure(file_name: str) -> HHandle:
    """
    Read a measure object from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    measure_handle : HHandle
                     Measure object handle.

    See Also
    --------
    write_measure

    Successors
    ----------
    measure_pos, measure_pairs
    """
    with HalconOperator(824) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        measure_handle = proc.get_output_tuple_s(0)
        return measure_handle  # type: ignore


def read_message(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Read a message from a file.

    Parameters
    ----------

    file_name : str
                File name.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    Returns
    -------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    See Also
    --------
    write_message, serialize_handle, deserialize_handle

    Predecessors
    ------------
    write_message
    """
    with HalconOperator(2164) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        message_handle = proc.get_output_tuple_s(0)
        return message_handle  # type: ignore


def read_metrology_model(file_name: str) -> HHandle:
    """
    Read a metrology model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    metrology_handle : HHandle
                       Handle of the metrology model.

    See Also
    --------
    write_metrology_model

    Successors
    ----------
    get_metrology_object_indices, apply_metrology_model
    """
    with HalconOperator(798) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        metrology_handle = proc.get_output_tuple_s(0)
        return metrology_handle  # type: ignore


def read_ncc_model(file_name: str) -> HHandle:
    """
    Read an NCC model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_ncc_model, clear_ncc_model

    Successors
    ----------
    find_ncc_model, find_ncc_models
    """
    with HalconOperator(985) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def read_object(file_name: str) -> HObject:
    """
    Read an iconic object.

    Parameters
    ----------

    file_name : str
                Name of file.

    Returns
    -------

    object : HObject
             Iconic object.

    See Also
    --------
    write_object, write_image, read_image

    Predecessors
    ------------
    write_image, write_object
    """
    with HalconOperator(1646) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()
        object = HObject(proc.get_output_object_key(1))
        return object  # type: ignore


def read_object_model_3d(
    file_name: str,
    scale: Union[str, float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> Tuple[HHandle, Sequence[str]]:
    """
    Read a 3D object model from a file.

    Parameters
    ----------

    file_name : str
                Filename of the file to be read.
                Value Suggestion: mvtec_bunny_normals

    scale : Union[str, float, int]
            Scale of the data in the file.
            Value Suggestion: m

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    status : Sequence[str]
             Status information.

    See Also
    --------
    write_object_model_3d, clear_object_model_3d

    Alternatives
    ------------
    xyz_to_object_model_3d

    Predecessors
    ------------
    write_object_model_3d

    Successors
    ----------
    affine_trans_object_model_3d, object_model_3d_to_xyz,
    prepare_object_model_3d
    """
    with HalconOperator(1104) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, scale)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # object_model_3d
            proc.get_output_tuple_m(1)   # status
        )  # type: ignore


def read_object_model_3d_s(
    file_name: str,
    scale: Union[str, float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> Tuple[HHandle, str]:
    """
    Read a 3D object model from a file.

    Parameters
    ----------

    file_name : str
                Filename of the file to be read.
                Value Suggestion: mvtec_bunny_normals

    scale : Union[str, float, int]
            Scale of the data in the file.
            Value Suggestion: m

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    status : str
             Status information.

    See Also
    --------
    write_object_model_3d, clear_object_model_3d

    Alternatives
    ------------
    xyz_to_object_model_3d

    Predecessors
    ------------
    write_object_model_3d

    Successors
    ----------
    affine_trans_object_model_3d, object_model_3d_to_xyz,
    prepare_object_model_3d
    """
    with HalconOperator(1104) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, scale)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # object_model_3d
            proc.get_output_tuple_s(1)   # status
        )  # type: ignore


def read_ocr(file_name: str) -> HHandle:
    """
    Read an OCR classifier from a file.

    Parameters
    ----------

    file_name : str
                Name of the OCR classifier file.
                Value Suggestion: testnet

    Returns
    -------

    ocr_handle : HHandle
                 ID of the read OCR classifier.

    See Also
    --------
    write_ocr, do_ocr_multi, traind_ocr_class_box, trainf_ocr_class_box

    Predecessors
    ------------
    reset_obj_db

    Successors
    ----------
    do_ocr_multi, do_ocr_single, traind_ocr_class_box, trainf_ocr_class_box

    Warnings
    --------
    read_ocr is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.
    """
    with HalconOperator(712) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        ocr_handle = proc.get_output_tuple_s(0)
        return ocr_handle  # type: ignore


def read_ocr_class_cnn(file_name: str) -> HHandle:
    """
    Read an CNN-based OCR classifier from a file.

    Parameters
    ----------

    file_name : str
                File name.
                Value Suggestion: Universal_Rej.occ

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    get_params_ocr_class_cnn

    Successors
    ----------
    do_ocr_single_class_cnn, do_ocr_multi_class_cnn, do_ocr_word_cnn
    """
    with HalconOperator(2082) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def read_ocr_class_knn(file_name: str) -> HHandle:
    """
    Read an OCR classifier from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_knn

    Successors
    ----------
    classify_class_knn
    """
    with HalconOperator(650) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def read_ocr_class_mlp(file_name: str) -> HHandle:
    """
    Read an OCR classifier from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_mlp, write_ocr_class_mlp, read_class_mlp,
    write_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(694) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def read_ocr_class_svm(file_name: str) -> HHandle:
    """
    Read a SVM-based OCR classifier from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    See Also
    --------
    create_ocr_class_svm, write_ocr_class_svm, read_class_svm,
    write_class_svm

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm
    """
    with HalconOperator(676) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        ocrhandle = proc.get_output_tuple_s(0)
        return ocrhandle  # type: ignore


def read_ocr_trainf(
    training_file: MaybeSequence[str]
) -> Tuple[HObject, Sequence[str]]:
    """
    Read training characters from files and convert to images.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    Returns
    -------

    characters : HObject
                 Images read from file.

    character_names : Sequence[str]
                      Names of the read characters.

    Alternatives
    ------------
    read_ocr_trainf_select

    Predecessors
    ------------
    write_ocr_trainf

    Successors
    ----------
    disp_image, select_obj, zoom_image_size
    """
    with HalconOperator(734) as proc:
        proc.set_input_tuple(0, training_file)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # characters
            proc.get_output_tuple_m(0)   # character_names
        )  # type: ignore


def read_ocr_trainf_names(
    training_file: MaybeSequence[str]
) -> Tuple[Sequence[str], Sequence[int]]:
    """
    Query which characters are stored in a training file.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    Returns
    -------

    character_names : Sequence[str]
                      Names of the read characters.

    character_count : Sequence[int]
                      Number of characters.

    See Also
    --------
    trainf_ocr_class_svm, trainf_ocr_class_mlp

    Predecessors
    ------------
    write_ocr_trainf
    """
    with HalconOperator(732) as proc:
        proc.set_input_tuple(0, training_file)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # character_names
            proc.get_output_tuple_m(1)   # character_count
        )  # type: ignore


def read_ocr_trainf_names_protected(
    training_file: MaybeSequence[str],
    password: MaybeSequence[str]
) -> Tuple[Sequence[str], Sequence[int]]:
    """
    Query which characters are stored in a (protected) training file.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    password : MaybeSequence[str]
               Passwords for protected training files.

    Returns
    -------

    character_names : Sequence[str]
                      Names of the read characters.

    character_count : Sequence[int]
                      Number of characters.

    See Also
    --------
    read_ocr_trainf_names

    Predecessors
    ------------
    protect_ocr_trainf
    """
    with HalconOperator(731) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, password)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # character_names
            proc.get_output_tuple_m(1)   # character_count
        )  # type: ignore


def read_ocr_trainf_names_protected_s(
    training_file: MaybeSequence[str],
    password: MaybeSequence[str]
) -> Tuple[str, int]:
    """
    Query which characters are stored in a (protected) training file.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    password : MaybeSequence[str]
               Passwords for protected training files.

    Returns
    -------

    character_names : str
                      Names of the read characters.

    character_count : int
                      Number of characters.

    See Also
    --------
    read_ocr_trainf_names

    Predecessors
    ------------
    protect_ocr_trainf
    """
    with HalconOperator(731) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, password)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # character_names
            proc.get_output_tuple_s(1)   # character_count
        )  # type: ignore


def read_ocr_trainf_names_s(
    training_file: MaybeSequence[str]
) -> Tuple[str, int]:
    """
    Query which characters are stored in a training file.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    Returns
    -------

    character_names : str
                      Names of the read characters.

    character_count : int
                      Number of characters.

    See Also
    --------
    trainf_ocr_class_svm, trainf_ocr_class_mlp

    Predecessors
    ------------
    write_ocr_trainf
    """
    with HalconOperator(732) as proc:
        proc.set_input_tuple(0, training_file)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # character_names
            proc.get_output_tuple_s(1)   # character_count
        )  # type: ignore


def read_ocr_trainf_select(
    training_file: MaybeSequence[str],
    search_names: MaybeSequence[str]
) -> Tuple[HObject, Sequence[str]]:
    """
    Read training specific characters from files and convert to images.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    search_names : MaybeSequence[str]
                   Names of the characters to be extracted.
                   Value Suggestion: '0'

    Returns
    -------

    characters : HObject
                 Images read from file.

    found_names : Sequence[str]
                  Names of the read characters.

    Alternatives
    ------------
    read_ocr_trainf

    Predecessors
    ------------
    write_ocr_trainf

    Successors
    ----------
    disp_image, select_obj, zoom_image_size
    """
    with HalconOperator(733) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, search_names)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # characters
            proc.get_output_tuple_m(0)   # found_names
        )  # type: ignore


def read_ocr_trainf_select_s(
    training_file: MaybeSequence[str],
    search_names: MaybeSequence[str]
) -> Tuple[HObject, str]:
    """
    Read training specific characters from files and convert to images.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    search_names : MaybeSequence[str]
                   Names of the characters to be extracted.
                   Value Suggestion: '0'

    Returns
    -------

    characters : HObject
                 Images read from file.

    found_names : str
                  Names of the read characters.

    Alternatives
    ------------
    read_ocr_trainf

    Predecessors
    ------------
    write_ocr_trainf

    Successors
    ----------
    disp_image, select_obj, zoom_image_size
    """
    with HalconOperator(733) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, search_names)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # characters
            proc.get_output_tuple_s(0)   # found_names
        )  # type: ignore


def read_ocv(file_name: str) -> HHandle:
    """
    Reading an OCV tool from file.

    Parameters
    ----------

    file_name : str
                Name of the file which has to be read.
                Value Suggestion: test_ocv

    Returns
    -------

    ocvhandle : HHandle
                Handle of read OCV tool.

    See Also
    --------
    read_ocr

    Predecessors
    ------------
    write_ocv

    Successors
    ----------
    do_ocv_simple, close_ocv
    """
    with HalconOperator(642) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        ocvhandle = proc.get_output_tuple_s(0)
        return ocvhandle  # type: ignore


def read_polygon_xld_arc_info(file_name: str) -> HObject:
    """
    Read XLD polygons from a file in ARC/INFO generate format.

    Parameters
    ----------

    file_name : str
                Name of the ARC/INFO file.

    Returns
    -------

    polygons : HObject
               Read XLD polygons.

    See Also
    --------
    read_world_file, write_polygon_xld_arc_info, read_contour_xld_arc_info

    Successors
    ----------
    hom_mat2d_invert, affine_trans_polygon_xld
    """
    with HalconOperator(18) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()
        polygons = HObject(proc.get_output_object_key(1))
        return polygons  # type: ignore


def read_polygon_xld_dxf(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HObject, Sequence[str]]:
    """
    Read XLD polygons from a DXF file.

    Parameters
    ----------

    file_name : str
                Name of the DXF file.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the DXF input.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the DXF input.
                      Value Suggestion: []

    Returns
    -------

    polygons : HObject
               Read XLD polygons.

    dxf_status : Sequence[str]
                 Status information.

    See Also
    --------
    write_polygon_xld_dxf, read_contour_xld_dxf

    Predecessors
    ------------
    write_polygon_xld_dxf
    """
    with HalconOperator(1634) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # polygons
            proc.get_output_tuple_m(0)   # dxf_status
        )  # type: ignore


def read_polygon_xld_dxf_s(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HObject, str]:
    """
    Read XLD polygons from a DXF file.

    Parameters
    ----------

    file_name : str
                Name of the DXF file.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that can be adjusted
                     for the DXF input.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the DXF input.
                      Value Suggestion: []

    Returns
    -------

    polygons : HObject
               Read XLD polygons.

    dxf_status : str
                 Status information.

    See Also
    --------
    write_polygon_xld_dxf, read_contour_xld_dxf

    Predecessors
    ------------
    write_polygon_xld_dxf
    """
    with HalconOperator(1634) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # polygons
            proc.get_output_tuple_s(0)   # dxf_status
        )  # type: ignore


def read_pose(pose_file: str) -> Sequence[Union[int, float]]:
    """
    Read a 3D pose from a text file.

    Parameters
    ----------

    pose_file : str
                File name of the external camera parameters.
                Value Suggestion: campose.dat

    Returns
    -------

    pose : Sequence[Union[int, float]]
           3D pose.

    See Also
    --------
    create_pose, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab, write_pose, pose_to_hom_mat3d, hom_mat3d_to_pose

    Predecessors
    ------------
    read_cam_par

    Successors
    ----------
    pose_to_hom_mat3d, camera_calibration, disp_caltab, sim_caltab
    """
    with HalconOperator(1940) as proc:
        proc.set_input_tuple(0, pose_file)
        proc.init_oct(0)
        proc.execute()
        pose = proc.get_output_tuple_m(0)
        return pose  # type: ignore


def read_region(file_name: str) -> HObject:
    """
    Read binary images or HALCON regions.

    Parameters
    ----------

    file_name : str
                Name of the region to be read.

    Returns
    -------

    region : HObject
             Read region.

    See Also
    --------
    write_region, read_image, write_object

    Predecessors
    ------------
    read_image

    Successors
    ----------
    reduce_domain, disp_region

    Notes
    -----
    The clipping based on the current image format is set via the operator
    set_system('clip_region',<'true'/'false'>). Consequently, if no image
    of sufficient size has been created before the call to read_region,
    set_system('clip_region','false') should be called before calling
    read_region to ensure that the region is not being clipped.
    """
    with HalconOperator(1657) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def read_sample_identifier(file_name: str) -> HHandle:
    """
    Read a sample identifier from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, train_sample_identifier,
    apply_sample_identifier, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, clear_sample_identifier,
    set_sample_identifier_object_info

    Alternatives
    ------------
    deserialize_sample_identifier

    Successors
    ----------
    apply_sample_identifier, add_sample_identifier_training_data
    """
    with HalconOperator(901) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        sample_identifier = proc.get_output_tuple_s(0)
        return sample_identifier  # type: ignore


def read_samples_class_gmm(gmmhandle: HHandle, file_name: str) -> None:
    """
    Read the training data of a Gaussian Mixture Model from a file.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    file_name : str
                File name.

    See Also
    --------
    write_samples_class_gmm, write_samples_class_mlp,
    clear_samples_class_gmm

    Alternatives
    ------------
    add_sample_class_gmm

    Predecessors
    ------------
    create_class_gmm

    Successors
    ----------
    train_class_gmm
    """
    with HalconOperator(1830) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def read_samples_class_mlp(mlphandle: HHandle, file_name: str) -> None:
    """
    Read the training data of a multilayer perceptron from a file.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    file_name : str
                File name.

    See Also
    --------
    write_samples_class_mlp, clear_samples_class_mlp

    Alternatives
    ------------
    add_sample_class_mlp

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    train_class_mlp
    """
    with HalconOperator(1869) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def read_samples_class_svm(svmhandle: HHandle, file_name: str) -> None:
    """
    Read the training data of a support vector machine from a file.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    file_name : str
                File name.

    See Also
    --------
    write_samples_class_svm, clear_samples_class_svm

    Alternatives
    ------------
    add_sample_class_svm

    Predecessors
    ------------
    create_class_svm

    Successors
    ----------
    train_class_svm
    """
    with HalconOperator(1848) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def read_sampset(file_name: str) -> HHandle:
    """
    Read a training data set from a file.

    Parameters
    ----------

    file_name : str
                Filename of the data set to train.
                Value Suggestion: sampset1

    Returns
    -------

    samp_key : HHandle
               Identification of the data set to train.

    See Also
    --------
    test_sampset_box, clear_sampset, learn_sampset_box

    Predecessors
    ------------
    create_class_box

    Successors
    ----------
    test_sampset_box, enquire_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    read_sampset is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  MLP, SVM, KNN or GMM
    operators instead.
    """
    with HalconOperator(1888) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        samp_key = proc.get_output_tuple_s(0)
        return samp_key  # type: ignore


def read_sequence(
    header_size: int,
    source_width: int,
    source_height: int,
    start_row: int,
    start_column: int,
    dest_width: int,
    dest_height: int,
    pixel_type: str,
    bit_order: str,
    byte_order: str,
    pad: str,
    index: int,
    file_name: str
) -> HObject:
    """
    Read images.

    Parameters
    ----------

    header_size : int
                  Number of bytes for file header.
                  Value Suggestion: 0

    source_width : int
                   Number of image columns of the filed image.
                   Value Suggestion: 512

    source_height : int
                    Number of image lines of the filed image.
                    Value Suggestion: 512

    start_row : int
                Starting point of image area (line).
                Value Suggestion: 0
                Assertion: StartRow < SourceHeight

    start_column : int
                   Starting point of image area (column).
                   Value Suggestion: 0
                   Assertion: StartColumn < SourceWidth

    dest_width : int
                 Number of image columns of output image.
                 Value Suggestion: 512
                 Assertion: DestWidth <= SourceWidth

    dest_height : int
                  Number of image lines of output image.
                  Value Suggestion: 512
                  Assertion: DestHeight <= SourceHeight

    pixel_type : str
                 Type of pixel values.
                 Value Suggestion: byte

    bit_order : str
                Sequence of bits within one byte.
                Value Suggestion: MSBFirst

    byte_order : str
                 Sequence of bytes within one 'short' unit.
                 Value Suggestion: MSBFirst

    pad : str
          Data units within one image line (alignment).
          Value Suggestion: byte

    index : int
            Number of images in the file.
            Value Suggestion: 1

    file_name : str
                Name of input file.

    Returns
    -------

    image : HObject
            Image read.

    See Also
    --------
    read_image

    Alternatives
    ------------
    read_image

    Successors
    ----------
    disp_image, count_channels, decompose3, write_image, rgb1_to_gray

    Notes
    -----
    If files of pixel type 'real' are read and the byte order is chosen
    incorrectly (i.e., differently from the byte order in which the data
    is stored in the file) program error and even crashes because of
    floating point exceptions may result.
    """
    with HalconOperator(1656) as proc:
        proc.set_input_tuple(0, header_size)
        proc.set_input_tuple(1, source_width)
        proc.set_input_tuple(2, source_height)
        proc.set_input_tuple(3, start_row)
        proc.set_input_tuple(4, start_column)
        proc.set_input_tuple(5, dest_width)
        proc.set_input_tuple(6, dest_height)
        proc.set_input_tuple(7, pixel_type)
        proc.set_input_tuple(8, bit_order)
        proc.set_input_tuple(9, byte_order)
        proc.set_input_tuple(10, pad)
        proc.set_input_tuple(11, index)
        proc.set_input_tuple(12, file_name)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def read_serial(
    serial_handle: HHandle,
    num_characters: int
) -> Sequence[int]:
    """
    Read from a serial device.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    num_characters : int
                     Number of characters to read.
                     Value Suggestion: 1

    Returns
    -------

    data : Sequence[int]
           Read characters (as tuple of integers).

    See Also
    --------
    write_serial

    Predecessors
    ------------
    open_serial
    """
    with HalconOperator(309) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.set_input_tuple(1, num_characters)
        proc.init_oct(0)
        proc.execute()
        data = proc.get_output_tuple_m(0)
        return data  # type: ignore


def read_serial_s(serial_handle: HHandle, num_characters: int) -> int:
    """
    Read from a serial device.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    num_characters : int
                     Number of characters to read.
                     Value Suggestion: 1

    Returns
    -------

    data : int
           Read characters (as tuple of integers).

    See Also
    --------
    write_serial

    Predecessors
    ------------
    open_serial
    """
    with HalconOperator(309) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.set_input_tuple(1, num_characters)
        proc.init_oct(0)
        proc.execute()
        data = proc.get_output_tuple_s(0)
        return data  # type: ignore


def read_shape_model(file_name: str) -> HHandle:
    """
    Read a shape model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    model_id : HHandle
               Handle of the model.

    See Also
    --------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, clear_shape_model

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models,
    get_shape_model_clutter
    """
    with HalconOperator(917) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def read_shape_model_3d(file_name: str) -> HHandle:
    """
    Read a 3D shape model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    See Also
    --------
    create_shape_model_3d, clear_shape_model_3d

    Successors
    ----------
    find_shape_model_3d, get_shape_model_3d_params
    """
    with HalconOperator(1052) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        shape_model_3did = proc.get_output_tuple_s(0)
        return shape_model_3did  # type: ignore


def read_sheet_of_light_model(file_name: str) -> HHandle:
    """
    Read a sheet-of-light model from a file and create a new model.

    Parameters
    ----------

    file_name : str
                Name of the sheet-of-light model file.
                Value Suggestion: sheet_of_light_model.solm

    Returns
    -------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    See Also
    --------
    write_sheet_of_light_model

    Alternatives
    ------------
    create_sheet_of_light_model

    Successors
    ----------
    measure_profile_sheet_of_light
    """
    with HalconOperator(374) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        sheet_of_light_model_id = proc.get_output_tuple_s(0)
        return sheet_of_light_model_id  # type: ignore


def read_string(
    window_handle: HHandle,
    in_string: str,
    length: int
) -> str:
    """
    Read a string in a text window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    in_string : str
                Default string (visible before input).
                Value Suggestion: ''

    length : int
             Maximum number of characters.
             Value Suggestion: 32
             Assertion: Length > 0 && Length <= 1024

    Returns
    -------

    out_string : str
                 Read string.

    See Also
    --------
    set_tposition, new_line, open_window, set_font, set_color

    Alternatives
    ------------
    read_char, fread_string, fread_char

    Predecessors
    ------------
    open_window, set_font

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1193) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, in_string)
        proc.set_input_tuple(2, length)
        proc.init_oct(0)
        proc.execute()
        out_string = proc.get_output_tuple_s(0)
        return out_string  # type: ignore


def read_structured_light_model(file_name: str) -> HHandle:
    """
    Read a structured light model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    structured_light_model : HHandle
                             Handle of the structured light model.

    See Also
    --------
    create_structured_light_model, clear_structured_light_model

    Predecessors
    ------------
    write_structured_light_model
    """
    with HalconOperator(2123) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        structured_light_model = proc.get_output_tuple_s(0)
        return structured_light_model  # type: ignore


def read_surface_model(file_name: str) -> HHandle:
    """
    Read a surface model from a file.

    Parameters
    ----------

    file_name : str
                Name of the SFM file.

    Returns
    -------

    surface_model_id : HHandle
                       Handle of the read surface model.

    See Also
    --------
    create_surface_model, write_surface_model

    Alternatives
    ------------
    create_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    find_surface_model, refine_surface_model_pose,
    get_surface_model_param, clear_surface_model,
    find_surface_model_image, refine_surface_model_pose_image
    """
    with HalconOperator(1039) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        surface_model_id = proc.get_output_tuple_s(0)
        return surface_model_id  # type: ignore


def read_template(file_name: str) -> HHandle:
    """
    Reading a template from file.

    Parameters
    ----------

    file_name : str
                file name.

    Returns
    -------

    template_id : HHandle
                  Template number.

    Successors
    ----------
    adapt_template, set_reference_template, set_offset_template,
    best_match, fast_match, best_match_rot

    Warnings
    --------
    read_template is obsolete and is only provided for reasons of backward
    compatibility. New applications should use the  shape-based or
    NCC-based operators instead.
    """
    with HalconOperator(1493) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        template_id = proc.get_output_tuple_s(0)
        return template_id  # type: ignore


def read_texture_inspection_model(file_name: str) -> HHandle:
    """
    Read a texture inspection model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    See Also
    --------
    create_texture_inspection_model, clear_texture_inspection_model,
    set_texture_inspection_model_param,
    get_texture_inspection_model_param, add_texture_inspection_model_image

    Predecessors
    ------------
    write_texture_inspection_model

    Successors
    ----------
    apply_texture_inspection_model
    """
    with HalconOperator(2083) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        texture_inspection_model = proc.get_output_tuple_s(0)
        return texture_inspection_model  # type: ignore


def read_training_components(file_name: str) -> HHandle:
    """
    Read a component training result from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    component_training_id : HHandle
                            Handle of the training result.

    See Also
    --------
    train_model_components, clear_training_components

    Successors
    ----------
    create_trained_component_model
    """
    with HalconOperator(1013) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        component_training_id = proc.get_output_tuple_s(0)
        return component_training_id  # type: ignore


def read_tuple(file_name: str) -> Sequence[Union[float, int, str]]:
    """
    Read a tuple from a file.

    Parameters
    ----------

    file_name : str
                Name of the file to be read.

    Returns
    -------

    tuple : Sequence[Union[float, int, str]]
            Tuple with any kind of data.

    See Also
    --------
    write_tuple, write_image, write_region, open_file

    Alternatives
    ------------
    fwrite_string
    """
    with HalconOperator(220) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_m(0)
        return tuple  # type: ignore


def read_tuple_s(file_name: str) -> Union[float, int, str]:
    """
    Read a tuple from a file.

    Parameters
    ----------

    file_name : str
                Name of the file to be read.

    Returns
    -------

    tuple : Union[float, int, str]
            Tuple with any kind of data.

    See Also
    --------
    write_tuple, write_image, write_region, open_file

    Alternatives
    ------------
    fwrite_string
    """
    with HalconOperator(220) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_s(0)
        return tuple  # type: ignore


def read_variation_model(file_name: str) -> HHandle:
    """
    Read a variation model from a file.

    Parameters
    ----------

    file_name : str
                File name.

    Returns
    -------

    model_id : HHandle
               ID of the variation model.

    See Also
    --------
    write_variation_model

    Successors
    ----------
    compare_variation_model, compare_ext_variation_model
    """
    with HalconOperator(83) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        model_id = proc.get_output_tuple_s(0)
        return model_id  # type: ignore


def read_world_file(file_name: str) -> Sequence[float]:
    """
    Read the geo coding from an ARC/INFO world file.

    Parameters
    ----------

    file_name : str
                Name of the ARC/INFO world file.

    Returns
    -------

    world_transformation : Sequence[float]
                           Transformation matrix from image to world
                           coordinates.

    See Also
    --------
    write_contour_xld_arc_info, read_contour_xld_arc_info,
    write_polygon_xld_arc_info, read_polygon_xld_arc_info

    Successors
    ----------
    hom_mat2d_invert, affine_trans_contour_xld, affine_trans_polygon_xld
    """
    with HalconOperator(22) as proc:
        proc.set_input_tuple(0, file_name)
        proc.init_oct(0)
        proc.execute()
        world_transformation = proc.get_output_tuple_m(0)
        return world_transformation  # type: ignore


def real_to_complex(
    image_real: HObject,
    image_imaginary: HObject
) -> HObject:
    """
    Convert two real images into a complex image.

    Parameters
    ----------

    image_real : HObject
                 Real part.

    image_imaginary : HObject
                      Imaginary part.

    Returns
    -------

    image_complex : HObject
                    Complex image.

    See Also
    --------
    complex_to_real
    """
    with HalconOperator(1474) as proc:
        proc.set_input_object(1, image_real)
        proc.set_input_object(2, image_imaginary)
        proc.execute()
        image_complex = HObject(proc.get_output_object_key(1))
        return image_complex  # type: ignore


def real_to_vector_field(
    row: HObject,
    col: HObject,
    type: str
) -> HObject:
    """
    Convert two real-valued images into a vector field image.

    Parameters
    ----------

    row : HObject
          Vector component in the row direction.

    col : HObject
          Vector component in the column direction.

    type : str
           Semantic kind of the vector field.
           Value Suggestion: vector_field_relative

    Returns
    -------

    vector_field : HObject
                   Displacement vector field.

    Predecessors
    ------------
    vector_field_to_real
    """
    with HalconOperator(1472) as proc:
        proc.set_input_object(1, row)
        proc.set_input_object(2, col)
        proc.set_input_tuple(0, type)
        proc.execute()
        vector_field = HObject(proc.get_output_object_key(1))
        return vector_field  # type: ignore


def receive_data(
    socket: HHandle,
    format: MaybeSequence[str]
) -> Tuple[Union[float, int, str], Union[int, str]]:
    """
    Receive arbitrary data from external devices or applications using a
    generic socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    format : MaybeSequence[str]
             Specification how to convert the data to tuples.
             Value Suggestion: z

    Returns
    -------

    data : Union[float, int, str]
           Value (or tuple of values) holding the received and converted
           data.

    from_val : Union[int, str]
               IP address or hostname and network port of the
               communication partner.

    See Also
    --------
    send_data

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect, get_socket_param,
    set_socket_param

    Successors
    ----------
    close_socket
    """
    with HalconOperator(333) as proc:
        proc.set_input_tuple(0, socket)
        proc.set_input_tuple(1, format)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # data
            proc.get_output_tuple_s(1)   # from_val
        )  # type: ignore


def receive_image(socket: HHandle) -> HObject:
    """
    Receive an image over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    image : HObject
            Received image.

    See Also
    --------
    send_image, send_region, receive_region, send_tuple, receive_tuple,
    get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect, get_socket_param,
    set_socket_param

    Notes
    -----
    'int8' images can be received by 64 bit systems only!
    """
    with HalconOperator(325) as proc:
        proc.set_input_tuple(0, socket)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def receive_region(socket: HHandle) -> HObject:
    """
    Receive regions over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    region : HObject
             Received regions.

    See Also
    --------
    send_region, send_image, receive_image, send_tuple, receive_tuple,
    get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect, get_socket_param,
    set_socket_param
    """
    with HalconOperator(327) as proc:
        proc.set_input_tuple(0, socket)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def receive_serialized_item(socket: HHandle) -> HHandle:
    """
    Receive a serialized item over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    send_serialized_item

    Successors
    ----------
    get_serialized_item_ptr, deserialize_matrix,
    deserialize_metrology_model
    """
    with HalconOperator(403) as proc:
        proc.set_input_tuple(0, socket)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def receive_tuple(socket: HHandle) -> Union[float, int, str]:
    """
    Receive a tuple over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    tuple : Union[float, int, str]
            Received tuple.

    See Also
    --------
    send_tuple, send_image, receive_image, send_region, receive_region,
    get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect, get_socket_param,
    set_socket_param
    """
    with HalconOperator(331) as proc:
        proc.set_input_tuple(0, socket)
        proc.init_oct(0)
        proc.execute()
        tuple = proc.get_output_tuple_s(0)
        return tuple  # type: ignore


def receive_xld(socket: HHandle) -> HObject:
    """
    Receive an XLD object over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    Returns
    -------

    xld : HObject
          Received XLD object.

    See Also
    --------
    send_xld, send_image, receive_image, send_region, receive_region,
    send_tuple, receive_tuple, get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect, get_socket_param,
    set_socket_param
    """
    with HalconOperator(329) as proc:
        proc.set_input_tuple(0, socket)
        proc.execute()
        xld = HObject(proc.get_output_object_key(1))
        return xld  # type: ignore


def reconst3d_from_fundamental_matrix(
    rows_1: MaybeSequence[Union[float, int]],
    cols_1: MaybeSequence[Union[float, int]],
    rows_2: MaybeSequence[Union[float, int]],
    cols_2: MaybeSequence[Union[float, int]],
    cov_rr1: MaybeSequence[Union[float, int]],
    cov_rc1: MaybeSequence[Union[float, int]],
    cov_cc1: MaybeSequence[Union[float, int]],
    cov_rr2: MaybeSequence[Union[float, int]],
    cov_rc2: MaybeSequence[Union[float, int]],
    cov_cc2: MaybeSequence[Union[float, int]],
    fmatrix: Sequence[float],
    cov_fmat: Sequence[float]
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the projective 3d reconstruction of points based on the
    fundamental matrix.

    Parameters
    ----------

    rows_1 : MaybeSequence[Union[float, int]]
             Input points in image 1 (row coordinate).

    cols_1 : MaybeSequence[Union[float, int]]
             Input points in image 1 (column coordinate).

    rows_2 : MaybeSequence[Union[float, int]]
             Input points in image 2 (row coordinate).

    cols_2 : MaybeSequence[Union[float, int]]
             Input points in image 2 (column coordinate).

    cov_rr1 : MaybeSequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : MaybeSequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : MaybeSequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : MaybeSequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : MaybeSequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : MaybeSequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    fmatrix : Sequence[float]
              Fundamental matrix.

    cov_fmat : Sequence[float]
               $9- covariance matrix of the fundamental matrix.
               Value Suggestion: []

    Returns
    -------

    x : Sequence[float]
        X coordinates of the reconstructed points in projective 3D space.

    y : Sequence[float]
        Y coordinates of the reconstructed points in projective 3D space.

    z : Sequence[float]
        Z coordinates of the reconstructed points in projective 3D space.

    w : Sequence[float]
        W coordinates of the reconstructed points in projective 3D space.

    cov_xyzw : Sequence[float]
               Covariance matrices of the reconstructed points.

    Alternatives
    ------------
    vector_to_fundamental_matrix, intersect_lines_of_sight

    Predecessors
    ------------
    match_fundamental_matrix_ransac
    """
    with HalconOperator(350) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, fmatrix)
        proc.set_input_tuple(11, cov_fmat)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1),  # y
            proc.get_output_tuple_m(2),  # z
            proc.get_output_tuple_m(3),  # w
            proc.get_output_tuple_m(4)   # cov_xyzw
        )  # type: ignore


def reconst3d_from_fundamental_matrix_s(
    rows_1: MaybeSequence[Union[float, int]],
    cols_1: MaybeSequence[Union[float, int]],
    rows_2: MaybeSequence[Union[float, int]],
    cols_2: MaybeSequence[Union[float, int]],
    cov_rr1: MaybeSequence[Union[float, int]],
    cov_rc1: MaybeSequence[Union[float, int]],
    cov_cc1: MaybeSequence[Union[float, int]],
    cov_rr2: MaybeSequence[Union[float, int]],
    cov_rc2: MaybeSequence[Union[float, int]],
    cov_cc2: MaybeSequence[Union[float, int]],
    fmatrix: Sequence[float],
    cov_fmat: Sequence[float]
) -> Tuple[float, float, float, float, float]:
    """
    Compute the projective 3d reconstruction of points based on the
    fundamental matrix.

    Parameters
    ----------

    rows_1 : MaybeSequence[Union[float, int]]
             Input points in image 1 (row coordinate).

    cols_1 : MaybeSequence[Union[float, int]]
             Input points in image 1 (column coordinate).

    rows_2 : MaybeSequence[Union[float, int]]
             Input points in image 2 (row coordinate).

    cols_2 : MaybeSequence[Union[float, int]]
             Input points in image 2 (column coordinate).

    cov_rr1 : MaybeSequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : MaybeSequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : MaybeSequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : MaybeSequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : MaybeSequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : MaybeSequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    fmatrix : Sequence[float]
              Fundamental matrix.

    cov_fmat : Sequence[float]
               $9- covariance matrix of the fundamental matrix.
               Value Suggestion: []

    Returns
    -------

    x : float
        X coordinates of the reconstructed points in projective 3D space.

    y : float
        Y coordinates of the reconstructed points in projective 3D space.

    z : float
        Z coordinates of the reconstructed points in projective 3D space.

    w : float
        W coordinates of the reconstructed points in projective 3D space.

    cov_xyzw : float
               Covariance matrices of the reconstructed points.

    Alternatives
    ------------
    vector_to_fundamental_matrix, intersect_lines_of_sight

    Predecessors
    ------------
    match_fundamental_matrix_ransac
    """
    with HalconOperator(350) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, fmatrix)
        proc.set_input_tuple(11, cov_fmat)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # x
            proc.get_output_tuple_s(1),  # y
            proc.get_output_tuple_s(2),  # z
            proc.get_output_tuple_s(3),  # w
            proc.get_output_tuple_s(4)   # cov_xyzw
        )  # type: ignore


def reconstruct_height_field_from_gradient(
    gradient: HObject,
    reconstruction_method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> HObject:
    """
    Reconstruct a surface from surface gradients.

    Parameters
    ----------

    gradient : HObject
               The gradient field of the image.

    reconstruction_method : str
                            Type of the reconstruction method.
                            Value Suggestion: poisson

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    height_field : HObject
                   Reconstructed height field.

    Notes
    -----
    reconstruct_height_field_from_gradient takes into account the values
    of all pixels in Gradient, not only the values within its domain.  If
    Gradient does not have a full domain, one could cut out the relevant
    square part of the gradient field and generate a smaller image with
    full domain.
    """
    with HalconOperator(398) as proc:
        proc.set_input_object(1, gradient)
        proc.set_input_tuple(0, reconstruction_method)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()
        height_field = HObject(proc.get_output_object_key(1))
        return height_field  # type: ignore


def reconstruct_points_stereo(
    stereo_model_id: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    cov_ip: Sequence[Union[float, int]],
    camera_idx: int,
    point_idx: int
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Reconstruct 3D points from calibrated multi-view stereo images.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    row : MaybeSequence[Union[float, int]]
          Row coordinates of the detected points.

    column : MaybeSequence[Union[float, int]]
             Column coordinates of the detected points.

    cov_ip : Sequence[Union[float, int]]
             Covariance matrices of the detected points.
             Value Suggestion: []

    camera_idx : int
                 Indices of the observing cameras.

    point_idx : int
                Indices of the observed world points.

    Returns
    -------

    x : Sequence[float]
        X coordinates of the reconstructed 3D points.

    y : Sequence[float]
        Y coordinates of the reconstructed 3D points.

    z : Sequence[float]
        Z coordinates of the reconstructed 3D points.

    cov_wp : Sequence[float]
             Covariance matrices of the reconstructed 3D points.

    point_idx_out : Sequence[int]
                    Indices of the reconstructed 3D points.

    Alternatives
    ------------
    reconstruct_surface_stereo, intersect_lines_of_sight
    """
    with HalconOperator(520) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, cov_ip)
        proc.set_input_tuple(4, camera_idx)
        proc.set_input_tuple(5, point_idx)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # x
            proc.get_output_tuple_m(1),  # y
            proc.get_output_tuple_m(2),  # z
            proc.get_output_tuple_m(3),  # cov_wp
            proc.get_output_tuple_m(4)   # point_idx_out
        )  # type: ignore


def reconstruct_points_stereo_s(
    stereo_model_id: HHandle,
    row: MaybeSequence[Union[float, int]],
    column: MaybeSequence[Union[float, int]],
    cov_ip: Sequence[Union[float, int]],
    camera_idx: int,
    point_idx: int
) -> Tuple[float, float, float, float, int]:
    """
    Reconstruct 3D points from calibrated multi-view stereo images.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    row : MaybeSequence[Union[float, int]]
          Row coordinates of the detected points.

    column : MaybeSequence[Union[float, int]]
             Column coordinates of the detected points.

    cov_ip : Sequence[Union[float, int]]
             Covariance matrices of the detected points.
             Value Suggestion: []

    camera_idx : int
                 Indices of the observing cameras.

    point_idx : int
                Indices of the observed world points.

    Returns
    -------

    x : float
        X coordinates of the reconstructed 3D points.

    y : float
        Y coordinates of the reconstructed 3D points.

    z : float
        Z coordinates of the reconstructed 3D points.

    cov_wp : float
             Covariance matrices of the reconstructed 3D points.

    point_idx_out : int
                    Indices of the reconstructed 3D points.

    Alternatives
    ------------
    reconstruct_surface_stereo, intersect_lines_of_sight
    """
    with HalconOperator(520) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, cov_ip)
        proc.set_input_tuple(4, camera_idx)
        proc.set_input_tuple(5, point_idx)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # x
            proc.get_output_tuple_s(1),  # y
            proc.get_output_tuple_s(2),  # z
            proc.get_output_tuple_s(3),  # cov_wp
            proc.get_output_tuple_s(4)   # point_idx_out
        )  # type: ignore


def reconstruct_surface_stereo(
    images: HObject,
    stereo_model_id: HHandle
) -> HHandle:
    """
    Reconstruct surface from calibrated multi-view stereo images.

    Parameters
    ----------

    images : HObject
             An image array acquired by the camera setup associated with
             the stereo model.

    stereo_model_id : HHandle
                      Handle of the stereo model.

    Returns
    -------

    object_model_3d : HHandle
                      Handle to the resulting surface.

    Alternatives
    ------------
    reconstruct_points_stereo

    Predecessors
    ------------
    create_stereo_model, get_calib_data, set_stereo_model_image_pairs

    Successors
    ----------
    get_stereo_model_object_model_3d
    """
    with HalconOperator(521) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, stereo_model_id)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def rectangle1_domain(
    image: HObject,
    row_1: int,
    column_1: int,
    row_2: int,
    column_2: int
) -> HObject:
    """
    Reduce the domain of an image to a rectangle.

    Parameters
    ----------

    image : HObject
            Input image.

    row_1 : int
            Line index of upper left corner of image area.
            Value Suggestion: 100

    column_1 : int
               Column index of upper left corner of image area.
               Value Suggestion: 100

    row_2 : int
            Line index of lower right corner of image area.
            Value Suggestion: 200

    column_2 : int
               Column index of lower right corner of image area.
               Value Suggestion: 200

    Returns
    -------

    image_reduced : HObject
                    Image with reduced definition domain.

    See Also
    --------
    full_domain, get_domain, intersection

    Alternatives
    ------------
    change_domain, reduce_domain, add_channels

    Predecessors
    ------------
    get_domain
    """
    with HalconOperator(1145) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, row_2)
        proc.set_input_tuple(3, column_2)
        proc.execute()
        image_reduced = HObject(proc.get_output_object_key(1))
        return image_reduced  # type: ignore


def rectangularity(regions: HObject) -> Sequence[float]:
    """
    Shape factor for the rectangularity of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    rectangularity : Sequence[float]
                     Rectangularity of the input region(s).
                     Assertion: 0 <= Rectangularity && Rectangularity <= 1.0

    See Also
    --------
    contlength, area_center, select_shape

    Alternatives
    ------------
    circularity, compactness, convexity, eccentricity

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    For input regions which orientation cannot be computed by using second
    order moments (as it is the case for square regions, for example), the
    returned Rectangularity is underestimated by up to 10- on the
    orientation of the input region.
    """
    with HalconOperator(1727) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        rectangularity = proc.get_output_tuple_m(0)
        return rectangularity  # type: ignore


def rectangularity_s(regions: HObject) -> float:
    """
    Shape factor for the rectangularity of a region.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    rectangularity : float
                     Rectangularity of the input region(s).
                     Assertion: 0 <= Rectangularity && Rectangularity <= 1.0

    See Also
    --------
    contlength, area_center, select_shape

    Alternatives
    ------------
    circularity, compactness, convexity, eccentricity

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    For input regions which orientation cannot be computed by using second
    order moments (as it is the case for square regions, for example), the
    returned Rectangularity is underestimated by up to 10- on the
    orientation of the input region.
    """
    with HalconOperator(1727) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.execute()
        rectangularity = proc.get_output_tuple_s(0)
        return rectangularity  # type: ignore


def rectangularity_xld(xld: HObject) -> Sequence[float]:
    """
    Shape factor for the rectangularity of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    rectangularity : Sequence[float]
                     Rectangularity of the input contours or polygons.
                     Assertion: 0 <= Rectangularity && Rectangularity <= 1.0

    See Also
    --------
    area_center_xld, select_shape_xld

    Alternatives
    ------------
    circularity_xld, convexity_xld, compactness_xld, eccentricity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Notes
    -----
    For input contours or polygons which orientation cannot be computed by
    using second order moments (as it is the case for squares, for
    example), the returned Rectangularity is underestimated by up to 10-
    depending on the orientation of the input contour or polygon.
    """
    with HalconOperator(2186) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        rectangularity = proc.get_output_tuple_m(0)
        return rectangularity  # type: ignore


def rectangularity_xld_s(xld: HObject) -> float:
    """
    Shape factor for the rectangularity of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    rectangularity : float
                     Rectangularity of the input contours or polygons.
                     Assertion: 0 <= Rectangularity && Rectangularity <= 1.0

    See Also
    --------
    area_center_xld, select_shape_xld

    Alternatives
    ------------
    circularity_xld, convexity_xld, compactness_xld, eccentricity_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Notes
    -----
    For input contours or polygons which orientation cannot be computed by
    using second order moments (as it is the case for squares, for
    example), the returned Rectangularity is underestimated by up to 10-
    depending on the orientation of the input contour or polygon.
    """
    with HalconOperator(2186) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        rectangularity = proc.get_output_tuple_s(0)
        return rectangularity  # type: ignore


def reduce_class_svm(
    svmhandle: HHandle,
    method: str,
    min_remaining_sv: int,
    max_error: float
) -> HHandle:
    """
    Approximate a trained support vector machine by a reduced support
    vector machine for faster classification.

    Parameters
    ----------

    svmhandle : HHandle
                Original SVM handle.

    method : str
             Type of postprocessing to reduce number of SV.
             Value Suggestion: bottom_up

    min_remaining_sv : int
                       Minimum number of remaining SVs.
                       Value Suggestion: 2
                       Assertion: MinRemainingSV >= 2

    max_error : float
                Maximum allowed error of reduction.
                Value Suggestion: 0.001
                Assertion: MaxError > 0.0

    Returns
    -------

    svmhandle_reduced : HHandle
                        SVMHandle of reduced SVM.

    See Also
    --------
    train_class_svm

    Predecessors
    ------------
    train_class_svm, get_support_vector_num_class_svm

    Successors
    ----------
    classify_class_svm, write_class_svm, get_support_vector_num_class_svm
    """
    with HalconOperator(1852) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, min_remaining_sv)
        proc.set_input_tuple(3, max_error)
        proc.init_oct(0)
        proc.execute()
        svmhandle_reduced = proc.get_output_tuple_s(0)
        return svmhandle_reduced  # type: ignore


def reduce_domain(image: HObject, region: HObject) -> HObject:
    """
    Reduce the domain of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    region : HObject
             New definition domain.

    Returns
    -------

    image_reduced : HObject
                    Image with reduced definition domain.

    See Also
    --------
    full_domain, get_domain, intersection

    Alternatives
    ------------
    change_domain, rectangle1_domain, add_channels

    Predecessors
    ------------
    get_domain
    """
    with HalconOperator(1146) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, region)
        proc.execute()
        image_reduced = HObject(proc.get_output_object_key(1))
        return image_reduced  # type: ignore


def reduce_object_model_3d_by_view(
    region: HObject,
    object_model_3d: MaybeSequence[HHandle],
    cam_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]]
) -> Sequence[HHandle]:
    """
    Remove points from a 3D object model by projecting it to a virtual
    view and removing all points outside of a given region.

    Parameters
    ----------

    region : HObject
             Region in the image plane.

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    cam_param : Sequence[Union[int, float, str]]
                Internal camera parameters.

    pose : Sequence[Union[int, float]]
           3D pose of the world coordinate system in camera coordinates.

    Returns
    -------

    object_model_3dreduced : Sequence[HHandle]
                             Handle of the reduced 3D object model.

    See Also
    --------
    select_points_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1084) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, cam_param)
        proc.set_input_tuple(2, pose)
        proc.init_oct(0)
        proc.execute()
        object_model_3dreduced = proc.get_output_tuple_m(0)
        return object_model_3dreduced  # type: ignore


def reduce_object_model_3d_by_view_s(
    region: HObject,
    object_model_3d: MaybeSequence[HHandle],
    cam_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]]
) -> HHandle:
    """
    Remove points from a 3D object model by projecting it to a virtual
    view and removing all points outside of a given region.

    Parameters
    ----------

    region : HObject
             Region in the image plane.

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    cam_param : Sequence[Union[int, float, str]]
                Internal camera parameters.

    pose : Sequence[Union[int, float]]
           3D pose of the world coordinate system in camera coordinates.

    Returns
    -------

    object_model_3dreduced : HHandle
                             Handle of the reduced 3D object model.

    See Also
    --------
    select_points_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1084) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, cam_param)
        proc.set_input_tuple(2, pose)
        proc.init_oct(0)
        proc.execute()
        object_model_3dreduced = proc.get_output_tuple_s(0)
        return object_model_3dreduced  # type: ignore


def reduce_ocr_class_svm(
    ocrhandle: HHandle,
    method: str,
    min_remaining_sv: int,
    max_error: float
) -> HHandle:
    """
    Approximate a trained SVM-based OCR classifier by a reduced SVM.

    Parameters
    ----------

    ocrhandle : HHandle
                Original handle of SVM-based OCR-classifier.

    method : str
             Type of postprocessing to reduce number of SVs.
             Value Suggestion: bottom_up

    min_remaining_sv : int
                       Minimum number of remaining SVs.
                       Value Suggestion: 2
                       Assertion: MinRemainingSV >= 2

    max_error : float
                Maximum allowed error of reduction.
                Value Suggestion: 0.001
                Assertion: MaxError > 0.0

    Returns
    -------

    ocrhandle_reduced : HHandle
                        SVMHandle of reduced OCR classifier.

    See Also
    --------
    create_ocr_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm, get_support_vector_num_ocr_class_svm

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm,
    get_support_vector_ocr_class_svm, get_support_vector_num_ocr_class_svm
    """
    with HalconOperator(682) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, min_remaining_sv)
        proc.set_input_tuple(3, max_error)
        proc.init_oct(0)
        proc.execute()
        ocrhandle_reduced = proc.get_output_tuple_s(0)
        return ocrhandle_reduced  # type: ignore


def refine_deformable_surface_model(
    deformable_surface_model: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    initial_deformation_object_model_3d: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> Tuple[Sequence[float], Sequence[HHandle]]:
    """
    Refine the position and deformation of a deformable surface model in a
    3D scene.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Relative sampling distance of the scene.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    initial_deformation_object_model_3d : HHandle
                                          Initial deformation of the 3D
                                          object model

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    score : Sequence[float]
            Score of the refined model.

    deformable_surface_matching_result : Sequence[HHandle]
                                         Handle of the matching result.

    See Also
    --------
    create_deformable_surface_model, find_deformable_surface_model

    Alternatives
    ------------
    find_deformable_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_deformable_surface_model,
    create_deformable_surface_model, get_deformable_surface_model_param,
    find_deformable_surface_model

    Successors
    ----------
    get_deformable_surface_matching_result,
    clear_deformable_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(1026) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, initial_deformation_object_model_3d)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # score
            proc.get_output_tuple_m(1)   # deformable_surface_matching_result
        )  # type: ignore


def refine_deformable_surface_model_s(
    deformable_surface_model: HHandle,
    object_model_3d: HHandle,
    rel_sampling_distance: float,
    initial_deformation_object_model_3d: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> Tuple[float, HHandle]:
    """
    Refine the position and deformation of a deformable surface model in a
    3D scene.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    rel_sampling_distance : float
                            Relative sampling distance of the scene.
                            Value Suggestion: 0.05
                            Assertion: 0 < RelSamplingDistance < 1

    initial_deformation_object_model_3d : HHandle
                                          Initial deformation of the 3D
                                          object model

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    score : float
            Score of the refined model.

    deformable_surface_matching_result : HHandle
                                         Handle of the matching result.

    See Also
    --------
    create_deformable_surface_model, find_deformable_surface_model

    Alternatives
    ------------
    find_deformable_surface_model

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_deformable_surface_model,
    create_deformable_surface_model, get_deformable_surface_model_param,
    find_deformable_surface_model

    Successors
    ----------
    get_deformable_surface_matching_result,
    clear_deformable_surface_matching_result, clear_object_model_3d
    """
    with HalconOperator(1026) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, rel_sampling_distance)
        proc.set_input_tuple(3, initial_deformation_object_model_3d)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # score
            proc.get_output_tuple_s(1)   # deformable_surface_matching_result
        )  # type: ignore


def refine_surface_model_pose(
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    initial_pose: Sequence[Union[float, int]],
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], Sequence[HHandle]]:
    """
    Refine the pose of a surface model in a 3D scene.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    initial_pose : Sequence[Union[float, int]]
                   Initial pose of the surface model in the scene.

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the model.

    surface_matching_result_id : Sequence[HHandle]
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    create_surface_model, find_surface_model,
    refine_surface_model_pose_image

    Alternatives
    ------------
    find_surface_model, refine_surface_model_pose_image,
    find_surface_model_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, find_surface_model, edges_object_model_3d

    Successors
    ----------
    get_surface_matching_result, clear_surface_matching_result,
    clear_object_model_3d
    """
    with HalconOperator(1041) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, initial_pose)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, return_result_handle)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_m(2)   # surface_matching_result_id
        )  # type: ignore


def refine_surface_model_pose_image(
    image: HObject,
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    initial_pose: Sequence[Union[float, int]],
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], Sequence[HHandle]]:
    """
    Refine the pose of a surface model in a 3D scene and in images.

    Parameters
    ----------

    image : HObject
            Images of the scene.

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    initial_pose : Sequence[Union[float, int]]
                   Initial pose of the surface model in the scene.

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the model.

    surface_matching_result_id : Sequence[HHandle]
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    create_surface_model, find_surface_model, refine_surface_model_pose

    Alternatives
    ------------
    find_surface_model, refine_surface_model_pose, find_surface_model_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, find_surface_model, edges_object_model_3d

    Successors
    ----------
    get_surface_matching_result, clear_surface_matching_result,
    clear_object_model_3d
    """
    with HalconOperator(2084) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, initial_pose)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, return_result_handle)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_m(2)   # surface_matching_result_id
        )  # type: ignore


def refine_surface_model_pose_image_s(
    image: HObject,
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    initial_pose: Sequence[Union[float, int]],
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], HHandle]:
    """
    Refine the pose of a surface model in a 3D scene and in images.

    Parameters
    ----------

    image : HObject
            Images of the scene.

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    initial_pose : Sequence[Union[float, int]]
                   Initial pose of the surface model in the scene.

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the model.

    surface_matching_result_id : HHandle
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    create_surface_model, find_surface_model, refine_surface_model_pose

    Alternatives
    ------------
    find_surface_model, refine_surface_model_pose, find_surface_model_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, find_surface_model, edges_object_model_3d

    Successors
    ----------
    get_surface_matching_result, clear_surface_matching_result,
    clear_object_model_3d
    """
    with HalconOperator(2084) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, initial_pose)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, return_result_handle)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_s(2)   # surface_matching_result_id
        )  # type: ignore


def refine_surface_model_pose_s(
    surface_model_id: HHandle,
    object_model_3d: HHandle,
    initial_pose: Sequence[Union[float, int]],
    min_score: MaybeSequence[Union[float, int]],
    return_result_handle: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[Sequence[Union[float, int]], Sequence[float], HHandle]:
    """
    Refine the pose of a surface model in a 3D scene.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    object_model_3d : HHandle
                      Handle of the 3D object model containing the scene.

    initial_pose : Sequence[Union[float, int]]
                   Initial pose of the surface model in the scene.

    min_score : MaybeSequence[Union[float, int]]
                Minimum score of the returned poses.
                Value Suggestion: 0
                Assertion: MinScore >= 0

    return_result_handle : str
                           Enable returning a result handle in
                           SurfaceMatchingResultID.
                           Value Suggestion: false

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[float, int]]
           3D pose of the surface model in the scene.

    score : Sequence[float]
            Score of the found instances of the model.

    surface_matching_result_id : HHandle
                                 Handle of the matching result, if enabled
                                 in ReturnResultHandle.

    See Also
    --------
    create_surface_model, find_surface_model,
    refine_surface_model_pose_image

    Alternatives
    ------------
    find_surface_model, refine_surface_model_pose_image,
    find_surface_model_image

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    get_object_model_3d_params, read_surface_model, create_surface_model,
    get_surface_model_param, find_surface_model, edges_object_model_3d

    Successors
    ----------
    get_surface_matching_result, clear_surface_matching_result,
    clear_object_model_3d
    """
    with HalconOperator(1041) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, object_model_3d)
        proc.set_input_tuple(2, initial_pose)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, return_result_handle)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # score
            proc.get_output_tuple_s(2)   # surface_matching_result_id
        )  # type: ignore


def region_features(
    regions: HObject,
    features: MaybeSequence[str]
) -> Sequence[float]:
    """
    Calculate shape features of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    features : MaybeSequence[str]
               Shape features to be calculated.
               Value Suggestion: area

    Returns
    -------

    value : Sequence[float]
            The calculated features.

    See Also
    --------
    area_center, circularity, compactness, contlength, convexity,
    rectangularity, elliptic_axis, eccentricity, inner_circle,
    smallest_circle, smallest_rectangle1, smallest_rectangle2,
    inner_rectangle1, roundness, connect_and_holes, area_holes,
    diameter_region, orientation_region, moments_region_2nd,
    moments_region_2nd_invar, moments_region_2nd_rel_invar,
    moments_region_3rd, moments_region_3rd_invar, moments_region_central,
    moments_region_central_invar, select_obj, select_shape

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    select_shape, select_gray, shape_trans, reduce_domain, count_obj
    """
    with HalconOperator(1702) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, features)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_m(0)
        return value  # type: ignore


def region_features_s(
    regions: HObject,
    features: MaybeSequence[str]
) -> float:
    """
    Calculate shape features of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    features : MaybeSequence[str]
               Shape features to be calculated.
               Value Suggestion: area

    Returns
    -------

    value : float
            The calculated features.

    See Also
    --------
    area_center, circularity, compactness, contlength, convexity,
    rectangularity, elliptic_axis, eccentricity, inner_circle,
    smallest_circle, smallest_rectangle1, smallest_rectangle2,
    inner_rectangle1, roundness, connect_and_holes, area_holes,
    diameter_region, orientation_region, moments_region_2nd,
    moments_region_2nd_invar, moments_region_2nd_rel_invar,
    moments_region_3rd, moments_region_3rd_invar, moments_region_central,
    moments_region_central_invar, select_obj, select_shape

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    select_shape, select_gray, shape_trans, reduce_domain, count_obj
    """
    with HalconOperator(1702) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, features)
        proc.init_oct(0)
        proc.execute()
        value = proc.get_output_tuple_s(0)
        return value  # type: ignore


def region_to_bin(
    region: HObject,
    foreground_gray: int,
    background_gray: int,
    width: int,
    height: int
) -> HObject:
    """
    Convert a region into a binary byte-image.

    Parameters
    ----------

    region : HObject
             Regions to be converted.

    foreground_gray : int
                      Gray value in which the regions are displayed.
                      Value Suggestion: 255

    background_gray : int
                      Gray value in which the background is displayed.
                      Value Suggestion: 0

    width : int
            Width of the image to be generated.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of the image to be generated.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    bin_image : HObject
                Result image of dimension Width $- Height containing the
                converted regions.

    See Also
    --------
    gen_image_proto, paint_gray

    Alternatives
    ------------
    region_to_label, paint_region, set_grayval

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    get_grayval
    """
    with HalconOperator(481) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, foreground_gray)
        proc.set_input_tuple(1, background_gray)
        proc.set_input_tuple(2, width)
        proc.set_input_tuple(3, height)
        proc.execute()
        bin_image = HObject(proc.get_output_object_key(1))
        return bin_image  # type: ignore


def region_to_label(
    region: HObject,
    type: str,
    width: int,
    height: int
) -> HObject:
    """
    Convert regions to a label image.

    Parameters
    ----------

    region : HObject
             Regions to be converted.

    type : str
           Pixel type of the result image.
           Value Suggestion: int2

    width : int
            Width of the image to be generated.
            Value Suggestion: 512
            Assertion: Width >= 1

    height : int
             Height of the image to be generated.
             Value Suggestion: 512
             Assertion: Height >= 1

    Returns
    -------

    image_label : HObject
                  Result image of dimension Width $- Height containing the
                  converted regions.

    See Also
    --------
    label_to_region

    Alternatives
    ------------
    region_to_bin, paint_region

    Predecessors
    ------------
    threshold, regiongrowing, connection, expand_region

    Successors
    ----------
    get_grayval, get_image_pointer1
    """
    with HalconOperator(480) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, type)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.execute()
        image_label = HObject(proc.get_output_object_key(1))
        return image_label  # type: ignore


def region_to_mean(regions: HObject, image: HObject) -> HObject:
    """
    Paint regions with their average gray value.

    Parameters
    ----------

    regions : HObject
              Input regions.

    image : HObject
            original gray-value image.

    Returns
    -------

    image_mean : HObject
                 Result image with painted regions.

    Alternatives
    ------------
    paint_region, intensity

    Predecessors
    ------------
    regiongrowing, connection

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1476) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.execute()
        image_mean = HObject(proc.get_output_object_key(1))
        return image_mean  # type: ignore


def regiongrowing(
    image: HObject,
    raster_height: int,
    raster_width: int,
    tolerance: Union[int, float],
    min_size: int
) -> HObject:
    """
    Segment an image using regiongrowing.

    Parameters
    ----------

    image : HObject
            Input image.

    raster_height : int
                    Vertical distance between tested pixels (height of the
                    raster).
                    Value Suggestion: 3
                    Assertion: RasterHeight >= 1 && odd(RasterHeight)

    raster_width : int
                   Horizontal distance between tested pixels (height of
                   the raster).
                   Value Suggestion: 3
                   Assertion: RasterWidth >= 1 && odd(RasterWidth)

    tolerance : Union[int, float]
                Points with a gray value difference less then or equal to
                tolerance are accumulated into the same object.
                Value Suggestion: 6.0
                Assertion: 0 <= Tolerance && Tolerance < 127

    min_size : int
               Minimum size of the output regions.
               Value Suggestion: 100
               Assertion: MinSize >= 1

    Returns
    -------

    regions : HObject
              Segmented regions.

    Alternatives
    ------------
    regiongrowing_n, regiongrowing_mean, label_to_region

    Predecessors
    ------------
    binomial_filter, mean_image, gauss_filter, smooth_image, median_image,
    anisotropic_diffusion

    Successors
    ----------
    select_shape, reduce_domain, select_gray

    Notes
    -----
    RasterWidth and RasterHeight are automatically converted to odd values
    if necessary.
    """
    with HalconOperator(456) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, raster_height)
        proc.set_input_tuple(1, raster_width)
        proc.set_input_tuple(2, tolerance)
        proc.set_input_tuple(3, min_size)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def regiongrowing_mean(
    image: HObject,
    start_rows: MaybeSequence[int],
    start_columns: MaybeSequence[int],
    tolerance: float,
    min_size: int
) -> HObject:
    """
    Perform a regiongrowing using mean gray values.

    Parameters
    ----------

    image : HObject
            Input image.

    start_rows : MaybeSequence[int]
                 Row coordinates of the starting points.
                 Value Suggestion: []

    start_columns : MaybeSequence[int]
                    Column coordinates of the starting points.
                    Value Suggestion: []

    tolerance : float
                Maximum deviation from the mean.
                Value Suggestion: 5.0
                Assertion: Tolerance > 0.0

    min_size : int
               Minimum size of a region.
               Value Suggestion: 100
               Assertion: MinSize >= 0

    Returns
    -------

    regions : HObject
              Segmented regions.

    Alternatives
    ------------
    regiongrowing, regiongrowing_n

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, anisotropic_diffusion,
    median_image, mean_image

    Successors
    ----------
    select_shape, reduce_domain, opening, expand_region
    """
    with HalconOperator(457) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, start_rows)
        proc.set_input_tuple(1, start_columns)
        proc.set_input_tuple(2, tolerance)
        proc.set_input_tuple(3, min_size)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def regiongrowing_n(
    multi_channel_image: HObject,
    metric: str,
    min_tolerance: Union[int, float],
    max_tolerance: Union[int, float],
    min_size: int
) -> HObject:
    """
    Segment an image using regiongrowing for multi-channel images.

    Parameters
    ----------

    multi_channel_image : HObject
                          Input image.

    metric : str
             Metric for the distance of the feature vectors.
             Value Suggestion: 2-norm

    min_tolerance : Union[int, float]
                    Lower threshold for the features' distance.
                    Value Suggestion: 0.0

    max_tolerance : Union[int, float]
                    Upper threshold for the features' distance.
                    Value Suggestion: 20.0

    min_size : int
               Minimum size of the output regions.
               Value Suggestion: 30

    Returns
    -------

    regions : HObject
              Segmented regions.

    See Also
    --------
    regiongrowing_mean

    Alternatives
    ------------
    class_2dim_sup, class_ndim_norm

    Predecessors
    ------------
    compose2, compose3
    """
    with HalconOperator(455) as proc:
        proc.set_input_object(1, multi_channel_image)
        proc.set_input_tuple(0, metric)
        proc.set_input_tuple(1, min_tolerance)
        proc.set_input_tuple(2, max_tolerance)
        proc.set_input_tuple(3, min_size)
        proc.execute()
        regions = HObject(proc.get_output_object_key(1))
        return regions  # type: ignore


def register_object_model_3d_global(
    object_models_3d: MaybeSequence[HHandle],
    hom_mats_3d: Sequence[Union[int, float]],
    from_val: MaybeSequence[Union[int, str]],
    to: MaybeSequence[int],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Tuple[Sequence[Union[int, float]], Sequence[float]]:
    """
    Improve the relative transformations between 3D object models based on
    their overlaps.

    Parameters
    ----------

    object_models_3d : MaybeSequence[HHandle]
                       Handles of several 3D object models.

    hom_mats_3d : Sequence[Union[int, float]]
                  Approximate relative transformations between the 3D
                  object models.

    from_val : MaybeSequence[Union[int, str]]
               Type of interpretation for the transformations.
               Value Suggestion: 'global'

    to : MaybeSequence[int]
         Target indices of the transformations if From specifies the
         source indices, otherwise the parameter must be empty.
         Value Suggestion: []

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the global 3D object model registration.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the global 3D object model registration.
                      Value Suggestion: []

    Returns
    -------

    hom_mats_3dout : Sequence[Union[int, float]]
                     Resulting Transformations.

    scores : Sequence[float]
             Number of overlapping neighbors for each 3D object model.

    See Also
    --------
    register_object_model_3d_pair, find_surface_model,
    refine_surface_model_pose

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    register_object_model_3d_pair, gen_object_model_3d_from_points

    Successors
    ----------
    affine_trans_object_model_3d, union_object_model_3d,
    sample_object_model_3d, triangulate_object_model_3d
    """
    with HalconOperator(1067) as proc:
        proc.set_input_tuple(0, object_models_3d)
        proc.set_input_tuple(1, hom_mats_3d)
        proc.set_input_tuple(2, from_val)
        proc.set_input_tuple(3, to)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mats_3dout
            proc.get_output_tuple_m(1)   # scores
        )  # type: ignore


def register_object_model_3d_pair(
    object_model_3d1: HHandle,
    object_model_3d2: HHandle,
    method: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[Sequence[Union[int, float]], Sequence[float]]:
    """
    Search for a transformation between two 3D object models.

    Parameters
    ----------

    object_model_3d1 : HHandle
                       Handle of the first 3D object model.

    object_model_3d2 : HHandle
                       Handle of the second 3D object model.

    method : str
             Method for the registration.
             Value Suggestion: 'matching'

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    pose : Sequence[Union[int, float]]
           Pose to transform ObjectModel3D1 in the reference frame of
           ObjectModel3D2.

    score : Sequence[float]
            Overlapping of the two 3D object models.

    See Also
    --------
    register_object_model_3d_global, find_surface_model

    Predecessors
    ------------
    read_object_model_3d, gen_object_model_3d_from_points,
    xyz_to_object_model_3d

    Successors
    ----------
    register_object_model_3d_global, affine_trans_object_model_3d,
    union_object_model_3d
    """
    with HalconOperator(1068) as proc:
        proc.set_input_tuple(0, object_model_3d1)
        proc.set_input_tuple(1, object_model_3d2)
        proc.set_input_tuple(2, method)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1)   # score
        )  # type: ignore


def regress_contours_xld(
    contours: HObject,
    mode: str,
    iterations: int
) -> HObject:
    """
    Calculate the parameters of a regression line to an XLD contour.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    mode : str
           Type of outlier treatment.
           Value Suggestion: no

    iterations : int
                 Number of iterations for the outlier treatment.
                 Value Suggestion: 1

    Returns
    -------

    regress_contours : HObject
                       Resulting XLD contours.

    See Also
    --------
    smooth_contours_xld, get_contour_global_attrib_xld,
    query_contour_global_attribs_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    get_regress_params_xld
    """
    with HalconOperator(61) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, iterations)
        proc.execute()
        regress_contours = HObject(proc.get_output_object_key(1))
        return regress_contours  # type: ignore


def rel_pose_to_fundamental_matrix(
    rel_pose: Sequence[Union[float, int]],
    cov_rel_pose: Sequence[Union[float, int]],
    cam_par_1: Sequence[Union[float, int, str]],
    cam_par_2: Sequence[Union[float, int, str]]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute the fundamental matrix from the relative orientation of two
    cameras.

    Parameters
    ----------

    rel_pose : Sequence[Union[float, int]]
               Relative orientation of the cameras (3D pose).

    cov_rel_pose : Sequence[Union[float, int]]
                   $6- covariance matrix of relative pose.
                   Value Suggestion: []

    cam_par_1 : Sequence[Union[float, int, str]]
                Parameters of the 1. camera.

    cam_par_2 : Sequence[Union[float, int, str]]
                Parameters of the 2. camera.

    Returns
    -------

    fmatrix : Sequence[float]
              Computed fundamental matrix.

    cov_fmat : Sequence[float]
               $9- covariance matrix of the fundamental matrix.

    See Also
    --------
    calibrate_cameras

    Alternatives
    ------------
    essential_to_fundamental_matrix

    Predecessors
    ------------
    vector_to_rel_pose
    """
    with HalconOperator(353) as proc:
        proc.set_input_tuple(0, rel_pose)
        proc.set_input_tuple(1, cov_rel_pose)
        proc.set_input_tuple(2, cam_par_1)
        proc.set_input_tuple(3, cam_par_2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # fmatrix
            proc.get_output_tuple_m(1)   # cov_fmat
        )  # type: ignore


def release_all_compute_devices() -> None:
    """
    Close all compute devices.

    See Also
    --------
    release_compute_device, deactivate_compute_device,
    deactivate_all_compute_devices

    Warnings
    --------
    release_all_compute_devices must not be used in HDevelop!
    """
    with HalconOperator(298) as proc:
        proc.execute()


def release_compute_device(device_handle: HHandle) -> None:
    """
    Close a compute_device.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    See Also
    --------
    release_all_compute_devices, deactivate_compute_device,
    deactivate_all_compute_devices

    Warnings
    --------
    release_compute_device must not be used in HDevelop!
    """
    with HalconOperator(299) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.execute()


def remove_calib_data(
    calib_data_id: HHandle,
    item_type: str,
    item_idx: MaybeSequence[Union[int, str]]
) -> None:
    """
    Remove a data set from a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    item_type : str
                Type of the calibration data item.
                Value Suggestion: tool

    item_idx : MaybeSequence[Union[int, str]]
               Index of the affected item.
               Value Suggestion: 0

    See Also
    --------
    calibrate_cameras

    Predecessors
    ------------
    set_calib_data, remove_calib_data_observ

    Successors
    ----------
    calibrate_hand_eye
    """
    with HalconOperator(1967) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, item_type)
        proc.set_input_tuple(2, item_idx)
        proc.execute()


def remove_calib_data_observ(
    calib_data_id: HHandle,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int
) -> None:
    """
    Remove observation data from a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the observed calibration object.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object pose.
                         Value Suggestion: 0

    Predecessors
    ------------
    find_calib_object, set_calib_data_observ_points,
    set_calib_data_observ_pose

    Successors
    ----------
    remove_calib_data, calibrate_cameras, calibrate_hand_eye
    """
    with HalconOperator(1970) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, calib_obj_idx)
        proc.set_input_tuple(3, calib_obj_pose_idx)
        proc.execute()


def remove_dict_key(
    dict_handle: HHandle,
    key: MaybeSequence[Union[str, int]]
) -> None:
    """
    Remove keys from a dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    key : MaybeSequence[Union[str, int]]
          Key to remove.
          Assertion: length(Key) > 0

    See Also
    --------
    create_dict, set_dict_tuple, get_dict_tuple, set_dict_object,
    get_dict_object, get_dict_param

    Predecessors
    ------------
    create_dict

    Successors
    ----------
    get_dict_param
    """
    with HalconOperator(2165) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, key)
        proc.execute()


def remove_dir(dir_name: str) -> None:
    """
    Delete an empty directory.

    Parameters
    ----------

    dir_name : str
               Name of directory to be deleted.
    """
    with HalconOperator(1641) as proc:
        proc.set_input_tuple(0, dir_name)
        proc.execute()


def remove_noise_region(input_region: HObject, type: str) -> HObject:
    """
    Remove noise from a region.

    Parameters
    ----------

    input_region : HObject
                   Regions to be modified.

    type : str
           Mode of noise removal.
           Value Suggestion: n_4

    Returns
    -------

    output_region : HObject
                    Less noisy regions.

    See Also
    --------
    dilation1, intersection, gen_region_points

    Predecessors
    ------------
    connection, regiongrowing, pouring, class_ndim_norm

    Successors
    ----------
    select_shape
    """
    with HalconOperator(507) as proc:
        proc.set_input_object(1, input_region)
        proc.set_input_tuple(0, type)
        proc.execute()
        output_region = HObject(proc.get_output_object_key(1))
        return output_region  # type: ignore


def remove_obj(objects: HObject, index: MaybeSequence[int]) -> HObject:
    """
    Remove objects from an iconic object tuple.

    Parameters
    ----------

    objects : HObject
              Input object tuple.

    index : MaybeSequence[int]
            Indices of the objects to be removed.

    Returns
    -------

    objects_reduced : HObject
                      Remaining object tuple.

    See Also
    --------
    count_obj, select_obj, copy_obj, insert_obj

    Alternatives
    ------------
    select_obj
    """
    with HalconOperator(2124) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_tuple(0, index)
        proc.execute()
        objects_reduced = HObject(proc.get_output_object_key(1))
        return objects_reduced  # type: ignore


def remove_object_model_3d_attrib(
    object_model_3d: HHandle,
    attributes: MaybeSequence[str]
) -> HHandle:
    """
    Remove attributes of a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the input 3D object model.

    attributes : MaybeSequence[str]
                 Name of the attributes to be removed.
                 Value Suggestion: extended_attribute

    Returns
    -------

    object_model_3dout : HHandle
                         Handle of the resulting 3D object model.

    See Also
    --------
    copy_object_model_3d, set_object_model_3d_attrib

    Alternatives
    ------------
    remove_object_model_3d_attrib_mod

    Predecessors
    ------------
    set_object_model_3d_attrib

    Successors
    ----------
    get_object_model_3d_params
    """
    with HalconOperator(2187) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attributes)
        proc.init_oct(0)
        proc.execute()
        object_model_3dout = proc.get_output_tuple_s(0)
        return object_model_3dout  # type: ignore


def remove_object_model_3d_attrib_mod(
    object_model_3d: HHandle,
    attributes: MaybeSequence[str]
) -> None:
    """
    Remove attributes of a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the input 3D object model.

    attributes : MaybeSequence[str]
                 Name of the attributes to be removed.
                 Value Suggestion: extended_attribute

    See Also
    --------
    copy_object_model_3d, set_object_model_3d_attrib_mod

    Alternatives
    ------------
    remove_object_model_3d_attrib

    Predecessors
    ------------
    set_object_model_3d_attrib_mod

    Successors
    ----------
    get_object_model_3d_params

    Notes
    -----
    remove_object_model_3d_attrib_mod removes Attributes unchecked from
    the 3D object model. Special attention must be paid to retain a
    consistent 3D object model, as most of the operators expect consistent
    3D object models. Furthermore, the mapping of the 3D points to image
    coordinates should not be removed because it speeds up the computation
    of many operators.
    """
    with HalconOperator(2188) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attributes)
        proc.execute()


def remove_sample_identifier_preparation_data(
    sample_identifier: HHandle,
    object_idx: Union[int, str],
    object_sample_idx: Union[int, str]
) -> None:
    """
    Remove preparation data from a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : Union[int, str]
                 Index of the preparation object, of which samples should
                 be removed.

    object_sample_idx : Union[int, str]
                        Index of the preparation sample that should be
                        removed.

    See Also
    --------
    add_sample_identifier_training_data, train_sample_identifier,
    apply_sample_identifier, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_training_data, write_sample_identifier,
    read_sample_identifier, serialize_sample_identifier,
    deserialize_sample_identifier, clear_sample_identifier,
    set_sample_identifier_object_info

    Alternatives
    ------------
    create_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_preparation_data

    Successors
    ----------
    prepare_sample_identifier
    """
    with HalconOperator(910) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, object_sample_idx)
        proc.execute()


def remove_sample_identifier_training_data(
    sample_identifier: HHandle,
    object_idx: Union[int, str],
    object_sample_idx: Union[int, str]
) -> None:
    """
    Remove training data from a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : Union[int, str]
                 Index of the training object, from which samples should
                 be removed.

    object_sample_idx : Union[int, str]
                        Index of the training sample that should be
                        removed.

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, apply_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    clear_sample_identifier, set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_training_data

    Successors
    ----------
    train_sample_identifier
    """
    with HalconOperator(909) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, object_sample_idx)
        proc.execute()


def remove_scene_3d_camera(scene_3d: HHandle, camera_index: int) -> None:
    """
    Remove a camera from a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    camera_index : int
                   Index of the camera to remove.

    See Also
    --------
    add_scene_3d_camera
    """
    with HalconOperator(1214) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, camera_index)
        proc.execute()


def remove_scene_3d_instance(
    scene_3d: HHandle,
    instance_index: MaybeSequence[int]
) -> None:
    """
    Remove an object instance from a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    instance_index : MaybeSequence[int]
                     Index of the instance to remove.

    See Also
    --------
    add_scene_3d_instance
    """
    with HalconOperator(1213) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, instance_index)
        proc.execute()


def remove_scene_3d_label(
    scene_3d: HHandle,
    label_index: MaybeSequence[int]
) -> None:
    """
    Remove a text label from a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    label_index : MaybeSequence[int]
                  Index of the text label to remove.

    See Also
    --------
    add_scene_3d_label
    """
    with HalconOperator(2041) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, label_index)
        proc.execute()


def remove_scene_3d_light(scene_3d: HHandle, light_index: int) -> None:
    """
    Remove a light from a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    light_index : int
                  Light to remove.

    See Also
    --------
    add_scene_3d_light
    """
    with HalconOperator(1212) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, light_index)
        proc.execute()


def remove_texture_inspection_model_image(
    texture_inspection_model: MaybeSequence[HHandle],
    indices: Sequence[int]
) -> Sequence[int]:
    """
    Clear all or a user-defined subset of the images of a texture
    inspection model.

    Parameters
    ----------

    texture_inspection_model : MaybeSequence[HHandle]
                               Handle of the texture inspection model.

    indices : Sequence[int]
              Indices of the images to be deleted from the texture
              inspection model.

    Returns
    -------

    remaining_indices : Sequence[int]
                        Indices of the images that remain in the texture
                        inspection model.

    See Also
    --------
    create_texture_inspection_model, clear_texture_inspection_model,
    set_texture_inspection_model_param,
    get_texture_inspection_model_param, add_texture_inspection_model_image

    Predecessors
    ------------
    train_texture_inspection_model
    """
    with HalconOperator(2085) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.set_input_tuple(1, indices)
        proc.init_oct(0)
        proc.execute()
        remaining_indices = proc.get_output_tuple_m(0)
        return remaining_indices  # type: ignore


def render_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    cam_param: Sequence[Union[int, float, str]],
    pose: Sequence[Union[int, float]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> HObject:
    """
    Render 3D object models to get an image.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    cam_param : Sequence[Union[int, float, str]]
                Camera parameters of the scene.

    pose : Sequence[Union[int, float]]
           3D poses of the objects.

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    image : HObject
            Rendered scene.

    See Also
    --------
    disp_object_model_3d, project_shape_model_3d, object_model_3d_to_xyz

    Predecessors
    ------------
    find_surface_model, fit_primitives_object_model_3d,
    segment_object_model_3d, read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    disp_obj

    Notes
    -----
    Cameras with hypercentric lenses are not supported.
    """
    with HalconOperator(1088) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, cam_param)
        proc.set_input_tuple(2, pose)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def render_scene_3d(scene_3d: HHandle, camera_index: int) -> HObject:
    """
    Render an image of a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    camera_index : int
                   Index of the camera used to display the scene.

    Returns
    -------

    image : HObject
            Rendered 3D scene.

    See Also
    --------
    create_scene_3d

    Alternatives
    ------------
    display_scene_3d
    """
    with HalconOperator(1211) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, camera_index)
        proc.execute()
        image = HObject(proc.get_output_object_key(1))
        return image  # type: ignore


def repeat_matrix(
    matrix_id: HHandle,
    rows: int,
    columns: int
) -> HHandle:
    """
    Repeat a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    rows : int
           Number of copies of input matrix in row direction.
           Value Suggestion: 2
           Assertion: Rows >= 1

    columns : int
              Number of copies of input matrix in column direction.
              Value Suggestion: 2
              Assertion: Columns >= 1

    Returns
    -------

    matrix_repeated_id : HHandle
                         Matrix handle of the repeated copied matrix.

    See Also
    --------
    copy_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(885) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, rows)
        proc.set_input_tuple(2, columns)
        proc.init_oct(0)
        proc.execute()
        matrix_repeated_id = proc.get_output_tuple_s(0)
        return matrix_repeated_id  # type: ignore


def replace_obj(
    objects: HObject,
    objects_replace: HObject,
    index: MaybeSequence[int]
) -> HObject:
    """
    Replaces one or more elements of an iconic object tuple.

    Parameters
    ----------

    objects : HObject
              Iconic Input Object.

    objects_replace : HObject
                      Element(s) to replace.

    index : MaybeSequence[int]
            Index/Indices of elements to be replaced.

    Returns
    -------

    replaced : HObject
               Tuple with replaced elements.

    See Also
    --------
    count_obj, select_obj, copy_obj, insert_obj

    Alternatives
    ------------
    select_obj
    """
    with HalconOperator(2125) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_object(2, objects_replace)
        proc.set_input_tuple(0, index)
        proc.execute()
        replaced = HObject(proc.get_output_object_key(1))
        return replaced  # type: ignore


def reset_fuzzy_measure(measure_handle: HHandle, set_type: str) -> None:
    """
    Reset a fuzzy function.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    set_type : str
               Selection of the fuzzy set.
               Value Suggestion: contrast

    See Also
    --------
    set_fuzzy_measure, set_fuzzy_measure_norm_pair

    Predecessors
    ------------
    set_fuzzy_measure

    Successors
    ----------
    fuzzy_measure_pos, fuzzy_measure_pairs
    """
    with HalconOperator(829) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, set_type)
        proc.execute()


def reset_metrology_object_fuzzy_param(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]]
) -> None:
    """
    Reset all fuzzy parameters and fuzzy functions of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    See Also
    --------
    reset_metrology_object_param

    Predecessors
    ------------
    set_metrology_object_fuzzy_param
    """
    with HalconOperator(806) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.execute()


def reset_metrology_object_param(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]]
) -> None:
    """
    Reset all parameters of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    See Also
    --------
    reset_metrology_object_fuzzy_param

    Predecessors
    ------------
    set_metrology_object_param
    """
    with HalconOperator(807) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.execute()


def reset_obj_db(
    default_image_width: int,
    default_image_height: int,
    default_channels: int
) -> None:
    """
    Reset the HALCON system for iconic objects.

    Parameters
    ----------

    default_image_width : int
                          Default image width (in pixels).
                          Value Suggestion: 128

    default_image_height : int
                           Default image height (in pixels).
                           Value Suggestion: 128

    default_channels : int
                       Usual number of channels.
                       Value Suggestion: 0

    See Also
    --------
    get_channel_info, count_relation

    Notes
    -----
    If the operator reset_obj_db is not called at the beginning of a
    HALCON session, HALCON will be initialized automatically by the
    operator reset_obj_db(128,128,0) causing side effects on region
    clipping, accordingly. When the database was enabled by  the parameter
    value 'database' of the operator set_system, calling reset_obj_db will
    deallocate all iconic objects.
    """
    with HalconOperator(319) as proc:
        proc.set_input_tuple(0, default_image_width)
        proc.set_input_tuple(1, default_image_height)
        proc.set_input_tuple(2, default_channels)
        proc.execute()


def reset_sheet_of_light_model(sheet_of_light_model_id: HHandle) -> None:
    """
    Reset a sheet-of-light model.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    See Also
    --------
    clear_sheet_of_light_model
    """
    with HalconOperator(388) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.execute()


def rft_generic(
    image: HObject,
    direction: str,
    norm: str,
    result_type: str,
    width: int
) -> HObject:
    """
    Compute the real-valued fast Fourier transform of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    direction : str
                Calculate forward or reverse transform.
                Value Suggestion: to_freq

    norm : str
           Normalizing factor of the transform.
           Value Suggestion: sqrt

    result_type : str
                  Image type of the output image.
                  Value Suggestion: complex

    width : int
            Width of the image for which the runtime should be optimized.
            Value Suggestion: 512

    Returns
    -------

    image_fft : HObject
                Fourier-transformed image.

    Alternatives
    ------------
    fft_generic, fft_image, fft_image_inv

    Predecessors
    ------------
    optimize_rft_speed, read_fft_optimization_data

    Successors
    ----------
    convol_fft, correlation_fft, phase_correlation_fft,
    convert_image_type, power_byte, power_real, power_ln, phase_deg,
    phase_rad

    Notes
    -----
    The transformation is always performed for the entire image, i.e., the
    domain of the image is ignored.
    """
    with HalconOperator(1541) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, direction)
        proc.set_input_tuple(1, norm)
        proc.set_input_tuple(2, result_type)
        proc.set_input_tuple(3, width)
        proc.execute()
        image_fft = HObject(proc.get_output_object_key(1))
        return image_fft  # type: ignore


def rgb1_to_gray(rgbimage: HObject) -> HObject:
    """
    Transform an RGB image into a gray scale image.

    Parameters
    ----------

    rgbimage : HObject
               Three-channel RBG image.

    Returns
    -------

    gray_image : HObject
                 Gray scale image.

    Alternatives
    ------------
    trans_from_rgb, rgb3_to_gray

    Predecessors
    ------------
    compose3
    """
    with HalconOperator(1581) as proc:
        proc.set_input_object(1, rgbimage)
        proc.execute()
        gray_image = HObject(proc.get_output_object_key(1))
        return gray_image  # type: ignore


def rgb3_to_gray(
    image_red: HObject,
    image_green: HObject,
    image_blue: HObject
) -> HObject:
    """
    Transform an RGB image to a gray scale image.

    Parameters
    ----------

    image_red : HObject
                Input image (red channel).

    image_green : HObject
                  Input image (green channel).

    image_blue : HObject
                 Input image (blue channel).

    Returns
    -------

    image_gray : HObject
                 Gray scale image.

    Alternatives
    ------------
    rgb1_to_gray, trans_from_rgb

    Predecessors
    ------------
    decompose3
    """
    with HalconOperator(1582) as proc:
        proc.set_input_object(1, image_red)
        proc.set_input_object(2, image_green)
        proc.set_input_object(3, image_blue)
        proc.execute()
        image_gray = HObject(proc.get_output_object_key(1))
        return image_gray  # type: ignore


def rigid_trans_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    pose: Sequence[Union[float, int]]
) -> Sequence[HHandle]:
    """
    Apply a rigid 3D transformation to 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    pose : Sequence[Union[float, int]]
           Poses.

    Returns
    -------

    object_model_3drigid_trans : Sequence[HHandle]
                                 Handles of the transformed 3D object
                                 models.

    See Also
    --------
    affine_trans_point_3d, affine_trans_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    fit_primitives_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz,
    get_object_model_3d_params

    Notes
    -----
    rigid_trans_object_model_3d copies the attributes of type triangle,
    face, polygon, line, 2D mapping coordinates, and extended attribute
    without modification.
    """
    with HalconOperator(1096) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, pose)
        proc.init_oct(0)
        proc.execute()
        object_model_3drigid_trans = proc.get_output_tuple_m(0)
        return object_model_3drigid_trans  # type: ignore


def rigid_trans_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    pose: Sequence[Union[float, int]]
) -> HHandle:
    """
    Apply a rigid 3D transformation to 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the 3D object models.

    pose : Sequence[Union[float, int]]
           Poses.

    Returns
    -------

    object_model_3drigid_trans : HHandle
                                 Handles of the transformed 3D object
                                 models.

    See Also
    --------
    affine_trans_point_3d, affine_trans_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    fit_primitives_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz,
    get_object_model_3d_params

    Notes
    -----
    rigid_trans_object_model_3d copies the attributes of type triangle,
    face, polygon, line, 2D mapping coordinates, and extended attribute
    without modification.
    """
    with HalconOperator(1096) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, pose)
        proc.init_oct(0)
        proc.execute()
        object_model_3drigid_trans = proc.get_output_tuple_s(0)
        return object_model_3drigid_trans  # type: ignore


def roberts(image: HObject, filter_type: str) -> HObject:
    """
    Detect edges using the Roberts filter.

    Parameters
    ----------

    image : HObject
            Input image.

    filter_type : str
                  Filter type.
                  Value Suggestion: gradient_sum

    Returns
    -------

    image_roberts : HObject
                    Roberts-filtered result images.

    See Also
    --------
    laplace, highpass_image, bandpass_image

    Alternatives
    ------------
    edges_image, sobel_amp, frei_amp, kirsch_amp, prewitt_amp

    Predecessors
    ------------
    binomial_filter, gauss_filter

    Successors
    ----------
    threshold, skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1562) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter_type)
        proc.execute()
        image_roberts = HObject(proc.get_output_object_key(1))
        return image_roberts  # type: ignore


def robinson_amp(image: HObject) -> HObject:
    """
    Detect edges (amplitude) using the Robinson operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    sobel_amp, frei_amp, prewitt_amp, roberts

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1553) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_edge_amp = HObject(proc.get_output_object_key(1))
        return image_edge_amp  # type: ignore


def robinson_dir(image: HObject) -> Tuple[HObject, HObject]:
    """
    Detect edges (amplitude and direction) using the Robinson operator.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    image_edge_amp : HObject
                     Edge amplitude (gradient magnitude) image.

    image_edge_dir : HObject
                     Edge direction image.

    See Also
    --------
    bandpass_image, laplace_of_gauss

    Alternatives
    ------------
    edges_image, sobel_dir, kirsch_dir, prewitt_dir, frei_dir

    Predecessors
    ------------
    binomial_filter, gauss_filter, sigma_image, median_image, smooth_image

    Successors
    ----------
    hysteresis_threshold, threshold, gray_skeleton,
    nonmax_suppression_dir, close_edges, close_edges_length

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1552) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_edge_amp
            HObject(proc.get_output_object_key(2))   # image_edge_dir
        )  # type: ignore


def rotate_image(
    image: HObject,
    phi: Union[int, float],
    interpolation: str
) -> HObject:
    """
    Rotate an image about its center.

    Parameters
    ----------

    image : HObject
            Input image.

    phi : Union[int, float]
          Rotation angle.
          Value Suggestion: 90

    interpolation : str
                    Type of interpolation.
                    Value Suggestion: constant

    Returns
    -------

    image_rotate : HObject
                   Rotated image.

    See Also
    --------
    mirror_image

    Alternatives
    ------------
    hom_mat2d_rotate, affine_trans_image

    Notes
    -----
    The domain of the input image is ignored, i.e., assumed to be the full
    rectangle of the image.  The domain of the output image is the
    intersection of the transformed rectangle and the rectangle of the
    output image.  The angle Phi is given in degrees, not in radians.  For
    rotations by 90, 180, and 270 degrees rotate_image is not parallelized
    internally.
    rotate_image can be executed on OpenCL devices if the input image does
    not exceed the maximum size of image objects of the selected device.
    Due to numerical reasons, there can be slight differences in the
    output compared to the execution on the CPU.
    """
    with HalconOperator(1627) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, phi)
        proc.set_input_tuple(1, interpolation)
        proc.execute()
        image_rotate = HObject(proc.get_output_object_key(1))
        return image_rotate  # type: ignore


def roundness(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Shape factors from contour.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    distance : Sequence[float]
               Mean distance from the center.
               Assertion: Distance >= 0.0

    sigma : Sequence[float]
            Standard deviation of Distance.
            Assertion: Sigma >= 0.0

    roundness : Sequence[float]
                Shape factor for roundness.
                Assertion: Roundness <= 1.0

    sides : Sequence[float]
            Number of polygon sides.
            Assertion: Sides >= 0

    See Also
    --------
    contlength

    Alternatives
    ------------
    compactness

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1733) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # distance
            proc.get_output_tuple_m(1),  # sigma
            proc.get_output_tuple_m(2),  # roundness
            proc.get_output_tuple_m(3)   # sides
        )  # type: ignore


def roundness_s(regions: HObject) -> Tuple[float, float, float, float]:
    """
    Shape factors from contour.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    Returns
    -------

    distance : float
               Mean distance from the center.
               Assertion: Distance >= 0.0

    sigma : float
            Standard deviation of Distance.
            Assertion: Sigma >= 0.0

    roundness : float
                Shape factor for roundness.
                Assertion: Roundness <= 1.0

    sides : float
            Number of polygon sides.
            Assertion: Sides >= 0

    See Also
    --------
    contlength

    Alternatives
    ------------
    compactness

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1733) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # distance
            proc.get_output_tuple_s(1),  # sigma
            proc.get_output_tuple_s(2),  # roundness
            proc.get_output_tuple_s(3)   # sides
        )  # type: ignore


def run_bg_esti(
    present_image: HObject,
    bg_esti_handle: HHandle
) -> HObject:
    """
    Estimate the background and return the foreground region.

    Parameters
    ----------

    present_image : HObject
                    Current image.

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    Returns
    -------

    foreground_region : HObject
                        Region of the detected foreground.

    See Also
    --------
    set_bg_esti_params, create_bg_esti, update_bg_esti, give_bg_esti

    Predecessors
    ------------
    create_bg_esti, update_bg_esti

    Successors
    ----------
    give_bg_esti, update_bg_esti

    Notes
    -----
    The passed image (PresentImage) must have the same type and size as
    the background image of the current data set (initialized with
    create_bg_esti).
    """
    with HalconOperator(2005) as proc:
        proc.set_input_object(1, present_image)
        proc.set_input_tuple(0, bg_esti_handle)
        proc.execute()
        foreground_region = HObject(proc.get_output_object_key(1))
        return foreground_region  # type: ignore


def runlength_distribution(
    region: HObject
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Distribution of runs needed for runlength encoding of a region.

    Parameters
    ----------

    region : HObject
             Region to be examined.

    Returns
    -------

    foreground : Sequence[int]
                 Length distribution of the region (foreground).

    background : Sequence[int]
                 Length distribution of the background.

    See Also
    --------
    runlength_features

    Alternatives
    ------------
    runlength_features

    Predecessors
    ------------
    threshold, select_obj
    """
    with HalconOperator(1732) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # foreground
            proc.get_output_tuple_m(1)   # background
        )  # type: ignore


def runlength_features(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[float], Sequence[float], Sequence[float], Sequence[int]]:
    """
    Characteristic values for runlength coding of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    num_runs : Sequence[int]
               Number of runs.
               Assertion: 0 <= NumRuns

    kfactor : Sequence[float]
              Storing factor in relation to a square.
              Assertion: 0 <= KFactor

    lfactor : Sequence[float]
              Mean number of runs per line.
              Assertion: 0 <= LFactor

    mean_length : Sequence[float]
                  Mean length of runs.
                  Assertion: 0 <= MeanLength

    bytes : Sequence[int]
            Number of bytes necessary for coding the region.
            Assertion: 0 <= Bytes

    See Also
    --------
    runlength_distribution

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    All features calculated by the operator runlength_features are not
    rotation invariant because the runlength coding depends on the
    direction. The operator runlength_features does not serve for
    calculating shape features but for controlling and analyzing the
    efficiency of the runlength coding.
    """
    with HalconOperator(1704) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # num_runs
            proc.get_output_tuple_m(1),  # kfactor
            proc.get_output_tuple_m(2),  # lfactor
            proc.get_output_tuple_m(3),  # mean_length
            proc.get_output_tuple_m(4)   # bytes
        )  # type: ignore


def runlength_features_s(
    regions: HObject
) -> Tuple[int, float, float, float, int]:
    """
    Characteristic values for runlength coding of regions.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    num_runs : int
               Number of runs.
               Assertion: 0 <= NumRuns

    kfactor : float
              Storing factor in relation to a square.
              Assertion: 0 <= KFactor

    lfactor : float
              Mean number of runs per line.
              Assertion: 0 <= LFactor

    mean_length : float
                  Mean length of runs.
                  Assertion: 0 <= MeanLength

    bytes : int
            Number of bytes necessary for coding the region.
            Assertion: 0 <= Bytes

    See Also
    --------
    runlength_distribution

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    All features calculated by the operator runlength_features are not
    rotation invariant because the runlength coding depends on the
    direction. The operator runlength_features does not serve for
    calculating shape features but for controlling and analyzing the
    efficiency of the runlength coding.
    """
    with HalconOperator(1704) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # num_runs
            proc.get_output_tuple_s(1),  # kfactor
            proc.get_output_tuple_s(2),  # lfactor
            proc.get_output_tuple_s(3),  # mean_length
            proc.get_output_tuple_s(4)   # bytes
        )  # type: ignore


def saddle_points_sub_pix(
    image: HObject,
    filter: str,
    sigma: float,
    threshold: float
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Subpixel precise detection of saddle points in an image.

    Parameters
    ----------

    image : HObject
            Input image.

    filter : str
             Method for the calculation of the partial derivatives.
             Value Suggestion: facet

    sigma : float
            Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0
            to avoid the smoothing of the input image.
            Assertion: Sigma >= 0.0

    threshold : float
                Minimum absolute value of the eigenvalues of the Hessian
                matrix.
                Value Suggestion: 5.0
                Assertion: Threshold >= 0.0

    Returns
    -------

    row : Sequence[float]
          Row coordinates of the detected saddle points.

    column : Sequence[float]
             Column coordinates of the detected saddle points.

    Alternatives
    ------------
    critical_points_sub_pix, local_min_sub_pix, local_max_sub_pix

    Successors
    ----------
    gen_cross_contour_xld, disp_cross

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1433) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, sigma)
        proc.set_input_tuple(2, threshold)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1)   # column
        )  # type: ignore


def sample_funct_1d(
    function: Sequence[Union[float, int]],
    xmin: Union[float, int],
    xmax: Union[float, int],
    xdist: Union[float, int],
    border: str
) -> Sequence[Union[float, int]]:
    """
    Sample a function equidistantly in an interval.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    xmin : Union[float, int]
           Minimum x value of the output function.

    xmax : Union[float, int]
           Maximum x value of the output function.
           Assertion: XMax > XMin

    xdist : Union[float, int]
            Distance of the samples.
            Assertion: XDist > 0

    border : str
             Border treatment for the input function.
             Value Suggestion: constant

    Returns
    -------

    sampled_function : Sequence[Union[float, int]]
                       Sampled function.

    Predecessors
    ------------
    transform_funct_1d, create_funct_1d_array, create_funct_1d_pairs
    """
    with HalconOperator(1391) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, xmin)
        proc.set_input_tuple(2, xmax)
        proc.set_input_tuple(3, xdist)
        proc.set_input_tuple(4, border)
        proc.init_oct(0)
        proc.execute()
        sampled_function = proc.get_output_tuple_m(0)
        return sampled_function  # type: ignore


def sample_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    sample_distance: MaybeSequence[Union[float, int]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Sequence[HHandle]:
    """
    Sample a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model to be sampled.

    method : str
             Selects between the different subsampling methods.
             Value Suggestion: 'fast'

    sample_distance : MaybeSequence[Union[float, int]]
                      Sampling distance.
                      Value Suggestion: 0.05

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted.
                      Value Suggestion: []

    Returns
    -------

    sampled_object_model_3d : Sequence[HHandle]
                              Handle of the 3D object model that contains
                              the sampled points.

    Alternatives
    ------------
    simplify_object_model_3d, smooth_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, gen_plane_object_model_3d,
    gen_sphere_object_model_3d, gen_cylinder_object_model_3d,
    gen_box_object_model_3d, gen_sphere_object_model_3d_center,
    xyz_to_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, clear_object_model_3d
    """
    with HalconOperator(1066) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, sample_distance)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        sampled_object_model_3d = proc.get_output_tuple_m(0)
        return sampled_object_model_3d  # type: ignore


def sample_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    sample_distance: MaybeSequence[Union[float, int]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> HHandle:
    """
    Sample a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model to be sampled.

    method : str
             Selects between the different subsampling methods.
             Value Suggestion: 'fast'

    sample_distance : MaybeSequence[Union[float, int]]
                      Sampling distance.
                      Value Suggestion: 0.05

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted.
                      Value Suggestion: []

    Returns
    -------

    sampled_object_model_3d : HHandle
                              Handle of the 3D object model that contains
                              the sampled points.

    Alternatives
    ------------
    simplify_object_model_3d, smooth_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, gen_plane_object_model_3d,
    gen_sphere_object_model_3d, gen_cylinder_object_model_3d,
    gen_box_object_model_3d, gen_sphere_object_model_3d_center,
    xyz_to_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, clear_object_model_3d
    """
    with HalconOperator(1066) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, sample_distance)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        sampled_object_model_3d = proc.get_output_tuple_s(0)
        return sampled_object_model_3d  # type: ignore


def scale_image(
    image: HObject,
    mult: Union[int, float],
    add: Union[int, float]
) -> HObject:
    """
    Scale the gray values of an image.

    Parameters
    ----------

    image : HObject
            Image(s) whose gray values are to be scaled.

    mult : Union[int, float]
           Scale factor.
           Value Suggestion: 0.01

    add : Union[int, float]
          Offset.
          Value Suggestion: 0

    Returns
    -------

    image_scaled : HObject
                   Result image(s) by the scale.

    See Also
    --------
    min_max_gray

    Alternatives
    ------------
    mult_image, add_image, sub_image

    Predecessors
    ------------
    min_max_gray

    Notes
    -----
    Note that the acceleration gained by SIMD technology is highest on
    large, compact input regions. However, in rare cases, the execution of
    scale_image might take significantly longer with SIMD technology than
    without, depending on the input region and the capabilities of the
    hardware. In these cases, the use of SIMD technology can be avoided by
    set_system(::'mmx_enable','false':).
    """
    with HalconOperator(1607) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mult)
        proc.set_input_tuple(1, add)
        proc.execute()
        image_scaled = HObject(proc.get_output_object_key(1))
        return image_scaled  # type: ignore


def scale_image_max(image: HObject) -> HObject:
    """
    Maximum gray value spreading in the value range 0 to 255.

    Parameters
    ----------

    image : HObject
            Image to be scaled.

    Returns
    -------

    image_scale_max : HObject
                      contrast enhanced image.

    See Also
    --------
    min_max_gray, gray_histo

    Alternatives
    ------------
    equ_histo_image, scale_image, illuminate, convert_image_type

    Successors
    ----------
    disp_image

    Notes
    -----
    The output always is an image of the type byte.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1551) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        image_scale_max = HObject(proc.get_output_object_key(1))
        return image_scale_max  # type: ignore


def scale_matrix(
    matrix_id: HHandle,
    factor: Union[int, float]
) -> HHandle:
    """
    Scale a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    factor : Union[int, float]
             Scale factor.
             Value Suggestion: 2.0

    Returns
    -------

    matrix_scaled_id : HHandle
                       Matrix handle with the scaled elements.

    See Also
    --------
    mult_element_matrix, mult_element_matrix_mod, div_element_matrix,
    div_element_matrix_mod

    Alternatives
    ------------
    scale_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(877) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, factor)
        proc.init_oct(0)
        proc.execute()
        matrix_scaled_id = proc.get_output_tuple_s(0)
        return matrix_scaled_id  # type: ignore


def scale_matrix_mod(matrix_id: HHandle, factor: Union[int, float]) -> None:
    """
    Scale a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    factor : Union[int, float]
             Scale factor.
             Value Suggestion: 2.0

    See Also
    --------
    mult_element_matrix, mult_element_matrix_mod, div_element_matrix,
    div_element_matrix_mod

    Alternatives
    ------------
    scale_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(876) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, factor)
        proc.execute()


def scale_y_funct_1d(
    function: Sequence[Union[float, int]],
    mult: float,
    add: float
) -> Sequence[Union[float, int]]:
    """
    Multiplication and addition of the y values.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    mult : float
           Factor for scaling of the y values.
           Value Suggestion: 2.0

    add : float
          Constant which is added to the y values.
          Value Suggestion: 0.0

    Returns
    -------

    function_scaled : Sequence[Union[float, int]]
                      Transformed function.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1382) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, mult)
        proc.set_input_tuple(2, add)
        proc.init_oct(0)
        proc.execute()
        function_scaled = proc.get_output_tuple_m(0)
        return function_scaled  # type: ignore


def scene_flow_calib(
    image_rect_1t1: HObject,
    image_rect_2t1: HObject,
    image_rect_1t2: HObject,
    image_rect_2t2: HObject,
    disparity: HObject,
    smoothing_flow: Union[float, int],
    smoothing_disparity: Union[float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]],
    cam_param_rect_1: Sequence[Union[float, int, str]],
    cam_param_rect_2: Sequence[Union[float, int, str]],
    rel_pose_rect: Sequence[Union[float, int]]
) -> Sequence[HHandle]:
    """
    Compute the calibrated scene flow between two stereo image pairs.

    Parameters
    ----------

    image_rect_1t1 : HObject
                     Input image 1 at time $t_{1}$t_1.

    image_rect_2t1 : HObject
                     Input image 2 at time $t_{1}$t_1.

    image_rect_1t2 : HObject
                     Input image 1 at time $t_{2}$t_2.

    image_rect_2t2 : HObject
                     Input image 2 at time $t_{2}$t_2.

    disparity : HObject
                Disparity between input images 1 and 2 at time $t_{1}$t_1.

    smoothing_flow : Union[float, int]
                     Weight of the regularization term relative to the
                     data term (derivatives of the optical flow).
                     Value Suggestion: 40.0
                     Assertion: SmoothingFlow > 0.0

    smoothing_disparity : Union[float, int]
                          Weight of the regularization term relative to
                          the data term (derivatives of the disparity
                          change).
                          Value Suggestion: 40.0
                          Assertion: SmoothingDisparity > 0.0

    gen_param_name : MaybeSequence[str]
                     Parameter name(s) for the algorithm.
                     Value Suggestion: default_parameters

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Parameter value(s) for the algorithm.
                      Value Suggestion: accurate

    cam_param_rect_1 : Sequence[Union[float, int, str]]
                       Internal camera parameters of the rectified camera
                       1.

    cam_param_rect_2 : Sequence[Union[float, int, str]]
                       Internal camera parameters of the rectified camera
                       2.

    rel_pose_rect : Sequence[Union[float, int]]
                    Pose of the rectified camera 2 in relation to the
                    rectified camera 1.

    Returns
    -------

    object_model_3d : Sequence[HHandle]
                      Handle of the 3D object model.

    Alternatives
    ------------
    scene_flow_uncalib, optical_flow_mg

    Predecessors
    ------------
    binocular_disparity, binocular_disparity_mg
    """
    with HalconOperator(1481) as proc:
        proc.set_input_object(1, image_rect_1t1)
        proc.set_input_object(2, image_rect_2t1)
        proc.set_input_object(3, image_rect_1t2)
        proc.set_input_object(4, image_rect_2t2)
        proc.set_input_object(5, disparity)
        proc.set_input_tuple(0, smoothing_flow)
        proc.set_input_tuple(1, smoothing_disparity)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.set_input_tuple(4, cam_param_rect_1)
        proc.set_input_tuple(5, cam_param_rect_2)
        proc.set_input_tuple(6, rel_pose_rect)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_m(0)
        return object_model_3d  # type: ignore


def scene_flow_calib_s(
    image_rect_1t1: HObject,
    image_rect_2t1: HObject,
    image_rect_1t2: HObject,
    image_rect_2t2: HObject,
    disparity: HObject,
    smoothing_flow: Union[float, int],
    smoothing_disparity: Union[float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]],
    cam_param_rect_1: Sequence[Union[float, int, str]],
    cam_param_rect_2: Sequence[Union[float, int, str]],
    rel_pose_rect: Sequence[Union[float, int]]
) -> HHandle:
    """
    Compute the calibrated scene flow between two stereo image pairs.

    Parameters
    ----------

    image_rect_1t1 : HObject
                     Input image 1 at time $t_{1}$t_1.

    image_rect_2t1 : HObject
                     Input image 2 at time $t_{1}$t_1.

    image_rect_1t2 : HObject
                     Input image 1 at time $t_{2}$t_2.

    image_rect_2t2 : HObject
                     Input image 2 at time $t_{2}$t_2.

    disparity : HObject
                Disparity between input images 1 and 2 at time $t_{1}$t_1.

    smoothing_flow : Union[float, int]
                     Weight of the regularization term relative to the
                     data term (derivatives of the optical flow).
                     Value Suggestion: 40.0
                     Assertion: SmoothingFlow > 0.0

    smoothing_disparity : Union[float, int]
                          Weight of the regularization term relative to
                          the data term (derivatives of the disparity
                          change).
                          Value Suggestion: 40.0
                          Assertion: SmoothingDisparity > 0.0

    gen_param_name : MaybeSequence[str]
                     Parameter name(s) for the algorithm.
                     Value Suggestion: default_parameters

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Parameter value(s) for the algorithm.
                      Value Suggestion: accurate

    cam_param_rect_1 : Sequence[Union[float, int, str]]
                       Internal camera parameters of the rectified camera
                       1.

    cam_param_rect_2 : Sequence[Union[float, int, str]]
                       Internal camera parameters of the rectified camera
                       2.

    rel_pose_rect : Sequence[Union[float, int]]
                    Pose of the rectified camera 2 in relation to the
                    rectified camera 1.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    Alternatives
    ------------
    scene_flow_uncalib, optical_flow_mg

    Predecessors
    ------------
    binocular_disparity, binocular_disparity_mg
    """
    with HalconOperator(1481) as proc:
        proc.set_input_object(1, image_rect_1t1)
        proc.set_input_object(2, image_rect_2t1)
        proc.set_input_object(3, image_rect_1t2)
        proc.set_input_object(4, image_rect_2t2)
        proc.set_input_object(5, disparity)
        proc.set_input_tuple(0, smoothing_flow)
        proc.set_input_tuple(1, smoothing_disparity)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.set_input_tuple(4, cam_param_rect_1)
        proc.set_input_tuple(5, cam_param_rect_2)
        proc.set_input_tuple(6, rel_pose_rect)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def scene_flow_uncalib(
    image_rect_1t1: HObject,
    image_rect_2t1: HObject,
    image_rect_1t2: HObject,
    image_rect_2t2: HObject,
    disparity: HObject,
    smoothing_flow: Union[float, int],
    smoothing_disparity: Union[float, int],
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> Tuple[HObject, HObject]:
    """
    Compute the uncalibrated scene flow between two stereo image pairs.

    Parameters
    ----------

    image_rect_1t1 : HObject
                     Input image 1 at time $t_{1}$t_1.

    image_rect_2t1 : HObject
                     Input image 2 at time $t_{1}$t_1.

    image_rect_1t2 : HObject
                     Input image 1 at time $t_{2}$t_2.

    image_rect_2t2 : HObject
                     Input image 2 at time $t_{2}$t_2.

    disparity : HObject
                Disparity between input images 1 and 2 at time $t_{1}$t_1.

    smoothing_flow : Union[float, int]
                     Weight of the regularization term relative to the
                     data term (derivatives of the optical flow).
                     Value Suggestion: 40.0
                     Assertion: SmoothingFlow > 0.0

    smoothing_disparity : Union[float, int]
                          Weight of the regularization term relative to
                          the data term (derivatives of the disparity
                          change).
                          Value Suggestion: 40.0
                          Assertion: SmoothingDisparity > 0.0

    gen_param_name : MaybeSequence[str]
                     Parameter name(s) for the algorithm.
                     Value Suggestion: default_parameters

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Parameter value(s) for the algorithm.
                      Value Suggestion: accurate

    Returns
    -------

    optical_flow : HObject
                   Estimated optical flow.

    disparity_change : HObject
                       Estimated change in disparity.

    Alternatives
    ------------
    scene_flow_calib, optical_flow_mg

    Predecessors
    ------------
    binocular_disparity, binocular_disparity_mg

    Successors
    ----------
    threshold, vector_field_length
    """
    with HalconOperator(1482) as proc:
        proc.set_input_object(1, image_rect_1t1)
        proc.set_input_object(2, image_rect_2t1)
        proc.set_input_object(3, image_rect_1t2)
        proc.set_input_object(4, image_rect_2t2)
        proc.set_input_object(5, disparity)
        proc.set_input_tuple(0, smoothing_flow)
        proc.set_input_tuple(1, smoothing_disparity)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # optical_flow
            HObject(proc.get_output_object_key(2))   # disparity_change
        )  # type: ignore


def screw_to_dual_quat(
    screw_format: str,
    axis_direction_x: Union[float, int],
    axis_direction_y: Union[float, int],
    axis_direction_z: Union[float, int],
    axis_moment_or_point_x: Union[float, int],
    axis_moment_or_point_y: Union[float, int],
    axis_moment_or_point_z: Union[float, int],
    rotation: Union[float, int],
    translation: Union[float, int]
) -> Sequence[Union[float, int]]:
    """
    Convert a screw into a dual quaternion.

    Parameters
    ----------

    screw_format : str
                   Format of the screw parameters.
                   Value Suggestion: moment

    axis_direction_x : Union[float, int]
                       X component of the direction vector of the screw
                       axis.

    axis_direction_y : Union[float, int]
                       Y component of the direction vector of the screw
                       axis.

    axis_direction_z : Union[float, int]
                       Z component of the direction vector of the screw
                       axis.

    axis_moment_or_point_x : Union[float, int]
                             X component of the moment vector or a point
                             on the screw axis.

    axis_moment_or_point_y : Union[float, int]
                             Y component of the moment vector or a point
                             on the screw axis.

    axis_moment_or_point_z : Union[float, int]
                             Z component of the moment vector or a point
                             on the screw axis.

    rotation : Union[float, int]
               Rotation angle in radians.

    translation : Union[float, int]
                  Translation.

    Returns
    -------

    dual_quaternion : Sequence[Union[float, int]]
                      Dual quaternion.

    See Also
    --------
    dual_quat_to_hom_mat3d, pose_to_dual_quat, dual_quat_to_screw,
    dual_quat_to_pose, dual_quat_normalize, serialize_dual_quat,
    deserialize_dual_quat, dual_quat_trans_line_3d, axis_angle_to_quat

    Alternatives
    ------------
    pose_to_dual_quat

    Successors
    ----------
    dual_quat_compose, dual_quat_conjugate, dual_quat_interpolate

    Notes
    -----
    screw_to_dual_quat assumes that the direction vector of the screw axis
    has length 1, i.e., sqrt(L_x^2 + L_y^2 +
    L_z^2)=1$L_{x^2+L_{y}^2+L_{z}^2}=1$. Otherwise the returned dual
    quaternion is not meaningful.
    """
    with HalconOperator(2086) as proc:
        proc.set_input_tuple(0, screw_format)
        proc.set_input_tuple(1, axis_direction_x)
        proc.set_input_tuple(2, axis_direction_y)
        proc.set_input_tuple(3, axis_direction_z)
        proc.set_input_tuple(4, axis_moment_or_point_x)
        proc.set_input_tuple(5, axis_moment_or_point_y)
        proc.set_input_tuple(6, axis_moment_or_point_z)
        proc.set_input_tuple(7, rotation)
        proc.set_input_tuple(8, translation)
        proc.init_oct(0)
        proc.execute()
        dual_quaternion = proc.get_output_tuple_m(0)
        return dual_quaternion  # type: ignore


def search_operator(keyword: str) -> Sequence[str]:
    """
    Search names of all operators assigned to one keyword.

    Parameters
    ----------

    keyword : str
              Keyword for which corresponding operators are searched.
              Value Suggestion: Information

    Returns
    -------

    operator_names : Sequence[str]
                     Operators whose slot 'keyword' contains the keyword.

    See Also
    --------
    get_keywords, get_operator_info, get_param_info

    Predecessors
    ------------
    get_keywords
    """
    with HalconOperator(1116) as proc:
        proc.set_input_tuple(0, keyword)
        proc.init_oct(0)
        proc.execute()
        operator_names = proc.get_output_tuple_m(0)
        return operator_names  # type: ignore


def segment_characters(
    region: HObject,
    image: HObject,
    method: str,
    eliminate_lines: str,
    dot_print: str,
    stroke_width: str,
    char_width: Sequence[int],
    char_height: Sequence[int],
    threshold_offset: int,
    contrast: int
) -> Tuple[HObject, HObject, Sequence[int]]:
    """
    Segments characters in a given region of an image.

    Parameters
    ----------

    region : HObject
             Area in the image where the text lines are located.

    image : HObject
            Input image.

    method : str
             Method to segment the characters.
             Value Suggestion: local_auto_shape

    eliminate_lines : str
                      Eliminate horizontal and vertical lines?
                      Value Suggestion: false

    dot_print : str
                Should dot print characters be detected?
                Value Suggestion: false

    stroke_width : str
                   Stroke width of a character.
                   Value Suggestion: medium

    char_width : Sequence[int]
                 Width of a character.
                 Value Suggestion: 25
                 Assertion: CharWidth >= 1

    char_height : Sequence[int]
                  Height of a character.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    threshold_offset : int
                       Value to adjust the segmentation.
                       Value Suggestion: 0

    contrast : int
               Minimum gray value difference between text and background.
               Value Suggestion: 10
               Assertion: Contrast >= 1

    Returns
    -------

    image_foreground : HObject
                       Image used for the segmentation.

    region_foreground : HObject
                        Region of characters.

    used_threshold : Sequence[int]
                     Threshold used to segment the characters.

    Alternatives
    ------------
    threshold

    Predecessors
    ------------
    text_line_orientation

    Successors
    ----------
    select_characters, connection
    """
    with HalconOperator(425) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, eliminate_lines)
        proc.set_input_tuple(2, dot_print)
        proc.set_input_tuple(3, stroke_width)
        proc.set_input_tuple(4, char_width)
        proc.set_input_tuple(5, char_height)
        proc.set_input_tuple(6, threshold_offset)
        proc.set_input_tuple(7, contrast)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_foreground
            HObject(proc.get_output_object_key(2)),  # region_foreground
            proc.get_output_tuple_m(0)   # used_threshold
        )  # type: ignore


def segment_characters_s(
    region: HObject,
    image: HObject,
    method: str,
    eliminate_lines: str,
    dot_print: str,
    stroke_width: str,
    char_width: Sequence[int],
    char_height: Sequence[int],
    threshold_offset: int,
    contrast: int
) -> Tuple[HObject, HObject, int]:
    """
    Segments characters in a given region of an image.

    Parameters
    ----------

    region : HObject
             Area in the image where the text lines are located.

    image : HObject
            Input image.

    method : str
             Method to segment the characters.
             Value Suggestion: local_auto_shape

    eliminate_lines : str
                      Eliminate horizontal and vertical lines?
                      Value Suggestion: false

    dot_print : str
                Should dot print characters be detected?
                Value Suggestion: false

    stroke_width : str
                   Stroke width of a character.
                   Value Suggestion: medium

    char_width : Sequence[int]
                 Width of a character.
                 Value Suggestion: 25
                 Assertion: CharWidth >= 1

    char_height : Sequence[int]
                  Height of a character.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    threshold_offset : int
                       Value to adjust the segmentation.
                       Value Suggestion: 0

    contrast : int
               Minimum gray value difference between text and background.
               Value Suggestion: 10
               Assertion: Contrast >= 1

    Returns
    -------

    image_foreground : HObject
                       Image used for the segmentation.

    region_foreground : HObject
                        Region of characters.

    used_threshold : int
                     Threshold used to segment the characters.

    Alternatives
    ------------
    threshold

    Predecessors
    ------------
    text_line_orientation

    Successors
    ----------
    select_characters, connection
    """
    with HalconOperator(425) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, method)
        proc.set_input_tuple(1, eliminate_lines)
        proc.set_input_tuple(2, dot_print)
        proc.set_input_tuple(3, stroke_width)
        proc.set_input_tuple(4, char_width)
        proc.set_input_tuple(5, char_height)
        proc.set_input_tuple(6, threshold_offset)
        proc.set_input_tuple(7, contrast)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_foreground
            HObject(proc.get_output_object_key(2)),  # region_foreground
            proc.get_output_tuple_s(0)   # used_threshold
        )  # type: ignore


def segment_contour_attrib_xld(
    contour: HObject,
    attribute: MaybeSequence[str],
    operation: str,
    min: MaybeSequence[Union[int, float, str]],
    max: MaybeSequence[Union[int, float, str]]
) -> HObject:
    """
    Segment XLD contour parts whose local attributes fulfill given
    conditions.

    Parameters
    ----------

    contour : HObject
              Contour to be segmented.

    attribute : MaybeSequence[str]
                Contour attributes to be checked.
                Value Suggestion: distance

    operation : str
                Linkage type of the individual attributes.
                Value Suggestion: and

    min : MaybeSequence[Union[int, float, str]]
          Lower limits of the attribute values.
          Value Suggestion: 150.0

    max : MaybeSequence[Union[int, float, str]]
          Upper limits of the attribute values.
          Value Suggestion: 99999.0
          Assertion: Max >= Min

    Returns
    -------

    contour_part : HObject
                   Segmented contour parts.

    See Also
    --------
    split_contours_xld, get_contour_global_attrib_xld,
    query_contour_attribs_xld, get_contour_attrib_xld

    Predecessors
    ------------
    lines_gauss, edges_sub_pix, apply_distance_transform_xld,
    distance_contours_xld

    Successors
    ----------
    fit_line_contour_xld, fit_ellipse_contour_xld, fit_circle_contour_xld,
    fit_rectangle2_contour_xld
    """
    with HalconOperator(27) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, attribute)
        proc.set_input_tuple(1, operation)
        proc.set_input_tuple(2, min)
        proc.set_input_tuple(3, max)
        proc.execute()
        contour_part = HObject(proc.get_output_object_key(1))
        return contour_part  # type: ignore


def segment_contours_xld(
    contours: HObject,
    mode: str,
    smooth_cont: int,
    max_line_dist_1: float,
    max_line_dist_2: float
) -> HObject:
    """
    Segment XLD contours into line segments and circular or elliptic arcs.

    Parameters
    ----------

    contours : HObject
               Contours to be segmented.

    mode : str
           Mode for the segmentation of the contours.
           Value Suggestion: lines_circles

    smooth_cont : int
                  Number of points used for smoothing the contours.
                  Value Suggestion: 5
                  Assertion: SmoothCont == 0 || SmoothCont >= 3 && odd(SmoothCont)

    max_line_dist_1 : float
                      Maximum distance between a contour and the
                      approximating line (first iteration).
                      Value Suggestion: 4.0
                      Assertion: MaxLineDist1 >= 0.0

    max_line_dist_2 : float
                      Maximum distance between a contour and the
                      approximating line (second iteration).
                      Value Suggestion: 2.0
                      Assertion: MaxLineDist2 >= 0.0

    Returns
    -------

    contours_split : HObject
                     Segmented contours.

    See Also
    --------
    split_contours_xld, get_contour_global_attrib_xld,
    smooth_contours_xld, gen_polygons_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, edges_sub_pix

    Successors
    ----------
    fit_line_contour_xld, fit_ellipse_contour_xld, fit_circle_contour_xld,
    get_contour_global_attrib_xld
    """
    with HalconOperator(28) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, smooth_cont)
        proc.set_input_tuple(2, max_line_dist_1)
        proc.set_input_tuple(3, max_line_dist_2)
        proc.execute()
        contours_split = HObject(proc.get_output_object_key(1))
        return contours_split  # type: ignore


def segment_image_mser(
    image: HObject,
    polarity: str,
    min_area: MaybeSequence[Union[int, float]],
    max_area: MaybeSequence[Union[int, float]],
    delta: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Tuple[HObject, HObject]:
    """
    Segment image using Maximally Stable Extremal Regions (MSER).

    Parameters
    ----------

    image : HObject
            Input image.

    polarity : str
               The polarity of the returned MSERs.
               Value Suggestion: both

    min_area : MaybeSequence[Union[int, float]]
               Minimal size of an MSER.
               Value Suggestion: 10

    max_area : MaybeSequence[Union[int, float]]
               Maximal size of an MSER.
               Value Suggestion: []

    delta : Union[int, float]
            Amount of thresholds for which a region needs to be stable.
            Value Suggestion: 15

    gen_param_name : Sequence[str]
                     List of generic parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float, int]]
                      List of generic parameter values.
                      Value Suggestion: []

    Returns
    -------

    mserdark : HObject
               Segmented dark MSERs.

    mserlight : HObject
                Segmented light MSERs.

    Alternatives
    ------------
    auto_threshold, binary_threshold, char_threshold, local_threshold,
    watersheds, regiongrowing

    Successors
    ----------
    select_shape, select_gray
    """
    with HalconOperator(2087) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, polarity)
        proc.set_input_tuple(1, min_area)
        proc.set_input_tuple(2, max_area)
        proc.set_input_tuple(3, delta)
        proc.set_input_tuple(4, gen_param_name)
        proc.set_input_tuple(5, gen_param_value)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # mserdark
            HObject(proc.get_output_object_key(2))   # mserlight
        )  # type: ignore


def segment_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> Sequence[HHandle]:
    """
    Segment a set of 3D points into sub-sets with similar characteristics.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the input 3D object model.

    gen_param_name : Sequence[str]
                     Names of the generic parameters.

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.

    Returns
    -------

    object_model_3dout : Sequence[HHandle]
                         Handle of the output 3D object model.

    See Also
    --------
    fit_primitives_object_model_3d

    Predecessors
    ------------
    xyz_to_object_model_3d, read_object_model_3d, prepare_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, object_model_3d_to_xyz,
    write_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(412) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dout = proc.get_output_tuple_m(0)
        return object_model_3dout  # type: ignore


def segment_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> HHandle:
    """
    Segment a set of 3D points into sub-sets with similar characteristics.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the input 3D object model.

    gen_param_name : Sequence[str]
                     Names of the generic parameters.

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.

    Returns
    -------

    object_model_3dout : HHandle
                         Handle of the output 3D object model.

    See Also
    --------
    fit_primitives_object_model_3d

    Predecessors
    ------------
    xyz_to_object_model_3d, read_object_model_3d, prepare_object_model_3d

    Successors
    ----------
    get_object_model_3d_params, object_model_3d_to_xyz,
    write_object_model_3d, clear_object_model_3d
    """
    with HalconOperator(412) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dout = proc.get_output_tuple_s(0)
        return object_model_3dout  # type: ignore


def select_characters(
    region: HObject,
    dot_print: str,
    stroke_width: str,
    char_width: Sequence[int],
    char_height: Sequence[int],
    punctuation: str,
    diacritic_marks: str,
    partition_method: str,
    partition_lines: str,
    fragment_distance: str,
    connect_fragments: str,
    clutter_size_max: int,
    stop_after: str
) -> HObject:
    """
    Selects characters from a given region.

    Parameters
    ----------

    region : HObject
             Region of text lines in which to select the characters.

    dot_print : str
                Should dot print characters be detected?
                Value Suggestion: false

    stroke_width : str
                   Stroke width of a character.
                   Value Suggestion: medium

    char_width : Sequence[int]
                 Width of a character.
                 Value Suggestion: 25
                 Assertion: CharWidth >= 1

    char_height : Sequence[int]
                  Height of a character.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    punctuation : str
                  Add punctuation?
                  Value Suggestion: false

    diacritic_marks : str
                      Exist diacritic marks?
                      Value Suggestion: false

    partition_method : str
                       Method to partition neighbored characters.
                       Value Suggestion: none

    partition_lines : str
                      Should lines be partitioned?
                      Value Suggestion: false

    fragment_distance : str
                        Distance of fragments.
                        Value Suggestion: medium

    connect_fragments : str
                        Connect fragments?
                        Value Suggestion: false

    clutter_size_max : int
                       Maximum size of clutter.
                       Value Suggestion: 0
                       Assertion: 0 < ClutterSizeMax

    stop_after : str
                 Stop execution after this step.
                 Value Suggestion: completion

    Returns
    -------

    region_characters : HObject
                        Selected characters.

    Alternatives
    ------------
    connection

    Predecessors
    ------------
    segment_characters, text_line_slant

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp
    """
    with HalconOperator(424) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, dot_print)
        proc.set_input_tuple(1, stroke_width)
        proc.set_input_tuple(2, char_width)
        proc.set_input_tuple(3, char_height)
        proc.set_input_tuple(4, punctuation)
        proc.set_input_tuple(5, diacritic_marks)
        proc.set_input_tuple(6, partition_method)
        proc.set_input_tuple(7, partition_lines)
        proc.set_input_tuple(8, fragment_distance)
        proc.set_input_tuple(9, connect_fragments)
        proc.set_input_tuple(10, clutter_size_max)
        proc.set_input_tuple(11, stop_after)
        proc.execute()
        region_characters = HObject(proc.get_output_object_key(1))
        return region_characters  # type: ignore


def select_contours_xld(
    contours: HObject,
    feature: str,
    min_1: float,
    max_1: float,
    min_2: float,
    max_2: float
) -> HObject:
    """
    Select XLD contours according to several features.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    feature : str
              Feature to select contours with.
              Value Suggestion: contour_length

    min_1 : float
            Lower threshold.
            Value Suggestion: 0.5

    max_1 : float
            Upper threshold.
            Value Suggestion: 200.0

    min_2 : float
            Lower threshold.
            Value Suggestion: -0.5

    max_2 : float
            Upper threshold.
            Value Suggestion: 0.5

    Returns
    -------

    selected_contours : HObject
                        Output XLD contours.

    See Also
    --------
    get_contour_xld, get_contour_attrib_xld, gen_contours_skeleton_xld,
    lines_gauss, lines_facet, edges_sub_pix, get_regress_params_xld,
    get_contour_global_attrib_xld, query_contour_global_attribs_xld

    Predecessors
    ------------
    regress_contours_xld

    Notes
    -----
    Before contour can be filtered by select_contours_xld according to
    'direction' or 'curvature', the parameters of the regression lines to
    the contours must be calculated with regress_contours_xld.  If this
    has not been done, select_contours_xld calls regress_contours_xld
    internally with the parameters Mode $=$ 'no' and Iterations $=$ 1.  If
    a different mode should be used, regress_contours_xld must be called
    explicitly.
    """
    with HalconOperator(59) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, feature)
        proc.set_input_tuple(1, min_1)
        proc.set_input_tuple(2, max_1)
        proc.set_input_tuple(3, min_2)
        proc.set_input_tuple(4, max_2)
        proc.execute()
        selected_contours = HObject(proc.get_output_object_key(1))
        return selected_contours  # type: ignore


def select_feature_set_gmm(
    class_train_data_handle: HHandle,
    selection_method: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Selects an optimal combination from a set of features to classify the
    provided data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    gen_param_name : MaybeSequence[str]
                     Names of generic parameters to configure  the
                     classifier.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of generic parameters to configure  the
                      classifier.
                      Value Suggestion: []

    Returns
    -------

    gmmhandle : HHandle
                A trained GMM classifier using only the selected  features.

    selected_feature_indices : Sequence[str]
                               The selected feature set, contains indices
                               or names.

    score : Sequence[float]
            The achieved score using two-fold cross-validation.

    See Also
    --------
    create_class_gmm, gray_features, region_features

    Alternatives
    ------------
    select_feature_set_mlp, select_feature_set_knn, select_feature_set_svm

    Predecessors
    ------------
    create_class_train_data, add_sample_class_train_data,
    set_feature_lengths_class_train_data

    Successors
    ----------
    classify_class_gmm

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_gmm may deliver a classifier with  a very
    high score. However, the classifier may perform poorly when tested.
    """
    with HalconOperator(1801) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, selection_method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # gmmhandle
            proc.get_output_tuple_m(1),  # selected_feature_indices
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_knn(
    class_train_data_handle: HHandle,
    selection_method: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Selects an optimal subset from a set of features to solve a certain
    classification problem.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    gen_param_name : MaybeSequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    knnhandle : HHandle
                A trained k-NN classifier using only the selected
                features.

    selected_feature_indices : Sequence[str]
                               The selected feature set, contains  indices
                               or names.

    score : Sequence[float]
            The achieved score using two-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_knn, gray_features, region_features

    Alternatives
    ------------
    select_feature_set_mlp, select_feature_set_svm, select_feature_set_gmm

    Predecessors
    ------------
    create_class_train_data, add_sample_class_train_data,
    set_feature_lengths_class_train_data

    Successors
    ----------
    classify_class_knn

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_knn may deliver a classifier with  a very
    high score. However, the classifier may perform poorly when tested.
    """
    with HalconOperator(1802) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, selection_method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # knnhandle
            proc.get_output_tuple_m(1),  # selected_feature_indices
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_mlp(
    class_train_data_handle: HHandle,
    selection_method: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Selects an optimal combination of features to classify the provided
    data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    gen_param_name : MaybeSequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    mlphandle : HHandle
                A trained MLP classifier using only the selected  features.

    selected_feature_indices : Sequence[str]
                               The selected feature set, contains  indices
                               referring.

    score : Sequence[float]
            The achieved score using two-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_mlp, gray_features, region_features

    Alternatives
    ------------
    select_feature_set_knn, select_feature_set_svm, select_feature_set_gmm

    Predecessors
    ------------
    create_class_train_data, add_sample_class_train_data,
    set_feature_lengths_class_train_data

    Successors
    ----------
    classify_class_mlp

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_mlp may deliver a classifier with  a very
    high score. However, the classifier may perform poorly when tested.
    """
    with HalconOperator(1799) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, selection_method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # mlphandle
            proc.get_output_tuple_m(1),  # selected_feature_indices
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_svm(
    class_train_data_handle: HHandle,
    selection_method: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Selects an optimal combination of features to classify the provided
    data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    gen_param_name : MaybeSequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    svmhandle : HHandle
                A trained SVM classifier using only the selected  features.

    selected_feature_indices : Sequence[str]
                               The selected feature set, contains  indices.

    score : Sequence[float]
            The achieved score using two-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_svm, gray_features, region_features

    Alternatives
    ------------
    select_feature_set_mlp, select_feature_set_knn, select_feature_set_gmm

    Predecessors
    ------------
    create_class_train_data, add_sample_class_train_data,
    set_feature_lengths_class_train_data

    Successors
    ----------
    classify_class_svm

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_svm may deliver a classifier with  a very
    high score. However, the classifier may perform poorly when tested.
    """
    with HalconOperator(1800) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, selection_method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # svmhandle
            proc.get_output_tuple_m(1),  # selected_feature_indices
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_trainf_knn(
    training_file: MaybeSequence[str],
    feature_list: MaybeSequence[str],
    selection_method: str,
    width: int,
    height: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Select an optimal combination of features to classify OCR data.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    feature_list : MaybeSequence[str]
                   List of features that should be considered for
                   selection.
                   Value Suggestion: ['zoom_factor','ratio','width','height','foreground','foreground_grid_9','foreground_grid_16','anisometry','compactness','convexity','moments_region_2nd_invar','moments_region_2nd_rel_invar','moments_region_3rd_invar','moments_central','phi','num_connect','num_holes','projection_horizontal','projection_vertical','projection_horizontal_invar','projection_vertical_invar','chord_histo','num_runs','pixel','pixel_invar','pixel_binary','gradient_8dir','cooc','moments_gray_plane']

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    width : int
            Width of the rectangle to which the gray values of the
            segmented character are zoomed.
            Value Suggestion: 15

    height : int
             Height of the rectangle to which the gray values of the
             segmented character are zoomed.
             Value Suggestion: 16

    gen_param_name : Sequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    ocrhandle : HHandle
                Trained OCR-k-NN classifier.

    feature_set : Sequence[str]
                  Selected feature set, contains only entries from
                  FeatureList.

    score : Sequence[float]
            Achieved score using tow-fold cross-validation.

    See Also
    --------
    select_feature_set_knn

    Alternatives
    ------------
    select_feature_set_trainf_svm, select_feature_set_trainf_mlp

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_trainf_knn may deliver a classifier with a
    very high score. However, the classifier may perform poorly when
    tested.
    """
    with HalconOperator(660) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, feature_list)
        proc.set_input_tuple(2, selection_method)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ocrhandle
            proc.get_output_tuple_m(1),  # feature_set
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_trainf_mlp(
    training_file: MaybeSequence[str],
    feature_list: MaybeSequence[str],
    selection_method: str,
    width: int,
    height: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Selects an optimal combination of features to classify OCR data.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    feature_list : MaybeSequence[str]
                   List of features that should be considered for
                   selection.
                   Value Suggestion: ['zoom_factor','ratio','width','height','foreground','foreground_grid_9','foreground_grid_16','anisometry','compactness','convexity','moments_region_2nd_invar','moments_region_2nd_rel_invar','moments_region_3rd_invar','moments_central','phi','num_connect','num_holes','projection_horizontal','projection_vertical','projection_horizontal_invar','projection_vertical_invar','chord_histo','num_runs','pixel','pixel_invar','pixel_binary','gradient_8dir','cooc','moments_gray_plane']

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    width : int
            Width of the rectangle to which the gray values of the
            segmented character are zoomed.
            Value Suggestion: 15

    height : int
             Height of the rectangle to which the gray values of the
             segmented character are zoomed.
             Value Suggestion: 16

    gen_param_name : Sequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    ocrhandle : HHandle
                Trained OCR-MLP classifier.

    feature_set : Sequence[str]
                  Selected feature set, contains only entries from
                  FeatureList.

    score : Sequence[float]
            Achieved score using tow-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_mlp_protected, select_feature_set_mlp

    Alternatives
    ------------
    select_feature_set_trainf_svm, select_feature_set_trainf_knn

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_trainf_mlp may deliver a classifier with a
    very high score. However, the classifier may perform poorly when
    tested.
    """
    with HalconOperator(662) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, feature_list)
        proc.set_input_tuple(2, selection_method)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ocrhandle
            proc.get_output_tuple_m(1),  # feature_set
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_trainf_mlp_protected(
    training_file: MaybeSequence[str],
    password: MaybeSequence[str],
    feature_list: MaybeSequence[str],
    selection_method: str,
    width: int,
    height: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Select an optimal combination of features to classify OCR data from a
    (protected) training file.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    password : MaybeSequence[str]
               Passwords for protected training files.

    feature_list : MaybeSequence[str]
                   List of features that should be considered for
                   selection.
                   Value Suggestion: ['zoom_factor','ratio','width','height','foreground','foreground_grid_9','foreground_grid_16','anisometry','compactness','convexity','moments_region_2nd_invar','moments_region_2nd_rel_invar','moments_region_3rd_invar','moments_central','phi','num_connect','num_holes','projection_horizontal','projection_vertical','projection_horizontal_invar','projection_vertical_invar','chord_histo','num_runs','pixel','pixel_invar','pixel_binary','gradient_8dir','cooc','moments_gray_plane']

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    width : int
            Width of the rectangle to which the gray values of the
            segmented character are zoomed.
            Value Suggestion: 15

    height : int
             Height of the rectangle to which the gray values of the
             segmented character are zoomed.
             Value Suggestion: 16

    gen_param_name : Sequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    ocrhandle : HHandle
                Trained OCR-MLP classifier.

    feature_set : Sequence[str]
                  Selected feature set, contains only entries from
                  FeatureList.

    score : Sequence[float]
            Achieved score using tow-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_mlp, select_feature_set_mlp

    Alternatives
    ------------
    select_feature_set_trainf_svm_protected

    Predecessors
    ------------
    protect_ocr_trainf

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_trainf_mlp_protected may deliver a
    classifier with a very high score. However, the classifier may perform
    poorly when tested.
    """
    with HalconOperator(661) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, password)
        proc.set_input_tuple(2, feature_list)
        proc.set_input_tuple(3, selection_method)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, height)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ocrhandle
            proc.get_output_tuple_m(1),  # feature_set
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_trainf_svm(
    training_file: MaybeSequence[str],
    feature_list: MaybeSequence[str],
    selection_method: str,
    width: int,
    height: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Selects an optimal combination of features to classify OCR  data.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    feature_list : MaybeSequence[str]
                   List of features that should be considered for
                   selection.
                   Value Suggestion: ['zoom_factor','ratio','width','height','foreground','foreground_grid_9','foreground_grid_16','anisometry','compactness','convexity','moments_region_2nd_invar','moments_region_2nd_rel_invar','moments_region_3rd_invar','moments_central','phi','num_connect','num_holes','projection_horizontal','projection_vertical','projection_horizontal_invar','projection_vertical_invar','chord_histo','num_runs','pixel','pixel_invar','pixel_binary','gradient_8dir','cooc','moments_gray_plane']

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    width : int
            Width of the rectangle to which the gray values of the
            segmented character are zoomed.
            Value Suggestion: 15

    height : int
             Height of the rectangle to which the gray values of the
             segmented character are zoomed.
             Value Suggestion: 16

    gen_param_name : Sequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    ocrhandle : HHandle
                Trained OCR-SVM Classifier.

    feature_set : Sequence[str]
                  Selected feature set, contains only entries from
                  FeatureList.

    score : Sequence[float]
            Achieved score using tow-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_svm_protected, select_feature_set_svm

    Alternatives
    ------------
    select_feature_set_trainf_mlp, select_feature_set_trainf_knn,
    select_feature_set_trainf_mlp_protected

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_trainf_svm may deliver a classifier with a
    very high score. However, the classifier may perform poorly when
    tested.
    """
    with HalconOperator(664) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, feature_list)
        proc.set_input_tuple(2, selection_method)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.set_input_tuple(5, gen_param_name)
        proc.set_input_tuple(6, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ocrhandle
            proc.get_output_tuple_m(1),  # feature_set
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_feature_set_trainf_svm_protected(
    training_file: MaybeSequence[str],
    password: MaybeSequence[str],
    feature_list: MaybeSequence[str],
    selection_method: str,
    width: int,
    height: int,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> Tuple[HHandle, Sequence[str], Sequence[float]]:
    """
    Select an optimal combination of features to classify OCR data from a
    (protected) training file.

    Parameters
    ----------

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: ''

    password : MaybeSequence[str]
               Passwords for protected training files.

    feature_list : MaybeSequence[str]
                   List of features that should be considered for
                   selection.
                   Value Suggestion: ['zoom_factor','ratio','width','height','foreground','foreground_grid_9','foreground_grid_16','anisometry','compactness','convexity','moments_region_2nd_invar','moments_region_2nd_rel_invar','moments_region_3rd_invar','moments_central','phi','num_connect','num_holes','projection_horizontal','projection_vertical','projection_horizontal_invar','projection_vertical_invar','chord_histo','num_runs','pixel','pixel_invar','pixel_binary','gradient_8dir','cooc','moments_gray_plane']

    selection_method : str
                       Method to perform the selection.
                       Value Suggestion: 'greedy'

    width : int
            Width of the rectangle to which the gray values of the
            segmented character are zoomed.
            Value Suggestion: 15

    height : int
             Height of the rectangle to which the gray values of the
             segmented character are zoomed.
             Value Suggestion: 16

    gen_param_name : Sequence[str]
                     Names of generic parameters to configure the
                     selection process and the classifier.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of generic parameters to configure the
                      selection process and the classifier.
                      Value Suggestion: []

    Returns
    -------

    ocrhandle : HHandle
                Trained OCR-SVM Classifier.

    feature_set : Sequence[str]
                  Selected feature set, contains only entries from
                  FeatureList.

    score : Sequence[float]
            Achieved score using tow-fold cross-validation.

    See Also
    --------
    select_feature_set_trainf_svm, select_feature_set_svm

    Alternatives
    ------------
    select_feature_set_trainf_mlp_protected

    Predecessors
    ------------
    protect_ocr_trainf

    Notes
    -----
    This operator may take considerable time, depending on the size of the
    data set in the training file, and the number of features.
    Please note, that this operator should not be called, if only a small
    set of training data is available. Due to the risk of overfitting the
    operator select_feature_set_trainf_svm_protected may deliver a
    classifier with  a very high score. However, the classifier may
    perform poorly when tested.
    """
    with HalconOperator(663) as proc:
        proc.set_input_tuple(0, training_file)
        proc.set_input_tuple(1, password)
        proc.set_input_tuple(2, feature_list)
        proc.set_input_tuple(3, selection_method)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, height)
        proc.set_input_tuple(6, gen_param_name)
        proc.set_input_tuple(7, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ocrhandle
            proc.get_output_tuple_m(1),  # feature_set
            proc.get_output_tuple_m(2)   # score
        )  # type: ignore


def select_gray(
    regions: HObject,
    image: HObject,
    features: MaybeSequence[str],
    operation: str,
    min: MaybeSequence[Union[int, float, str]],
    max: MaybeSequence[Union[int, float, str]]
) -> HObject:
    """
    Select regions based on gray value features.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    image : HObject
            Gray value image.

    features : MaybeSequence[str]
               Names of the features.
               Value Suggestion: mean

    operation : str
                Logical connection of features.
                Value Suggestion: and

    min : MaybeSequence[Union[int, float, str]]
          Lower limit(s) of features or 'min'.
          Value Suggestion: 128.0

    max : MaybeSequence[Union[int, float, str]]
          Upper limit(s) of features or 'max'.
          Value Suggestion: 255.0

    Returns
    -------

    selected_regions : HObject
                       Regions having features within the limits.

    See Also
    --------
    deviation_image, entropy_gray, intensity, mean_image, min_max_gray,
    select_obj

    Predecessors
    ------------
    connection, mean_image, entropy_image, sobel_amp, median_separate

    Successors
    ----------
    select_shape, shape_trans, reduce_domain, count_obj

    Notes
    -----
    Note that the operator select_gray only considers  the given Regions
    and ignores any previously set domain of the input image Image. If
    only one feature is used the value of Operation is meaningless.
    Several features are processed in the order in which they are entered.
    The maximum number of features is limited to 100.
    """
    with HalconOperator(1750) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, features)
        proc.set_input_tuple(1, operation)
        proc.set_input_tuple(2, min)
        proc.set_input_tuple(3, max)
        proc.execute()
        selected_regions = HObject(proc.get_output_object_key(1))
        return selected_regions  # type: ignore


def select_grayvalues_from_channels(
    multichannel_image: HObject,
    index_image: HObject
) -> HObject:
    """
    Selection of gray values of a multi-channel image using an index image.

    Parameters
    ----------

    multichannel_image : HObject
                         Multi-channel gray value image.

    index_image : HObject
                  Image, where pixel values are interpreted as channel
                  index.

    Returns
    -------

    selected : HObject
               Resulting image.

    See Also
    --------
    count_channels

    Predecessors
    ------------
    depth_from_focus, mean_image

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1479) as proc:
        proc.set_input_object(1, multichannel_image)
        proc.set_input_object(2, index_image)
        proc.execute()
        selected = HObject(proc.get_output_object_key(1))
        return selected  # type: ignore


def select_lines(
    row_begin_in: Sequence[int],
    col_begin_in: Sequence[int],
    row_end_in: Sequence[int],
    col_end_in: Sequence[int],
    feature: MaybeSequence[str],
    operation: str,
    min: MaybeSequence[Union[int, float, str]],
    max: MaybeSequence[Union[int, float, str]]
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Select lines according to various criteria.

    Parameters
    ----------

    row_begin_in : Sequence[int]
                   Row coordinates of the starting points of the input
                   lines.

    col_begin_in : Sequence[int]
                   Column coordinates of the starting points of the input
                   lines.

    row_end_in : Sequence[int]
                 Row coordinates of the ending points of the input lines.

    col_end_in : Sequence[int]
                 Column coordinates  of the ending points of the input
                 lines.

    feature : MaybeSequence[str]
              Features to be used for selection.
              Value Suggestion: length

    operation : str
                Desired combination of the features.
                Value Suggestion: and

    min : MaybeSequence[Union[int, float, str]]
          Lower limits of the features or 'min'.
          Value Suggestion: min

    max : MaybeSequence[Union[int, float, str]]
          Upper limits of the features or 'max'.
          Value Suggestion: max

    Returns
    -------

    row_begin_out : Sequence[int]
                    Row coordinates of the starting points of the output
                    lines.

    col_begin_out : Sequence[int]
                    Column coordinates of the starting points of the
                    output lines.

    row_end_out : Sequence[int]
                  Row coordinates of the ending points of the output lines.

    col_end_out : Sequence[int]
                  Column coordinates of the ending points of the output
                  lines.

    See Also
    --------
    partition_lines, select_lines_longest, detect_edge_segments,
    select_shape

    Alternatives
    ------------
    line_orientation, line_position, partition_lines

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line

    Warnings
    --------
    select_lines is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    If only one feature is used the value of Operation is meaningless.
    Several features are processed according to the sequence in which they
    are passed.
    """
    with HalconOperator(1738) as proc:
        proc.set_input_tuple(0, row_begin_in)
        proc.set_input_tuple(1, col_begin_in)
        proc.set_input_tuple(2, row_end_in)
        proc.set_input_tuple(3, col_end_in)
        proc.set_input_tuple(4, feature)
        proc.set_input_tuple(5, operation)
        proc.set_input_tuple(6, min)
        proc.set_input_tuple(7, max)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_begin_out
            proc.get_output_tuple_m(1),  # col_begin_out
            proc.get_output_tuple_m(2),  # row_end_out
            proc.get_output_tuple_m(3)   # col_end_out
        )  # type: ignore


def select_lines_longest(
    row_begin_in: Sequence[int],
    col_begin_in: Sequence[int],
    row_end_in: Sequence[int],
    col_end_in: Sequence[int],
    num: int
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Select the longest input lines.

    Parameters
    ----------

    row_begin_in : Sequence[int]
                   Row coordinates of the starting points of the input
                   lines.

    col_begin_in : Sequence[int]
                   Column coordinates of the starting points of the input
                   lines.

    row_end_in : Sequence[int]
                 Row coordinates of the ending points of the input lines.

    col_end_in : Sequence[int]
                 Column coordinates  of the ending points of the input
                 lines.

    num : int
          (Maximum) desired number of output lines.
          Value Suggestion: 10

    Returns
    -------

    row_begin_out : Sequence[int]
                    Row coordinates of the starting points of the output
                    lines.

    col_begin_out : Sequence[int]
                    Column coordinates of the starting points of the
                    output lines.

    row_end_out : Sequence[int]
                  Row coordinates of the ending points of the output lines.

    col_end_out : Sequence[int]
                  Column coordinates of the ending points of the output
                  lines.

    See Also
    --------
    select_lines, partition_lines, detect_edge_segments, select_shape

    Alternatives
    ------------
    line_orientation, line_position, select_lines, partition_lines

    Predecessors
    ------------
    sobel_amp, edges_image, threshold, hysteresis_threshold,
    split_skeleton_region, split_skeleton_lines

    Successors
    ----------
    set_line_width, disp_line

    Warnings
    --------
    select_lines_longest is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1736) as proc:
        proc.set_input_tuple(0, row_begin_in)
        proc.set_input_tuple(1, col_begin_in)
        proc.set_input_tuple(2, row_end_in)
        proc.set_input_tuple(3, col_end_in)
        proc.set_input_tuple(4, num)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_begin_out
            proc.get_output_tuple_m(1),  # col_begin_out
            proc.get_output_tuple_m(2),  # row_end_out
            proc.get_output_tuple_m(3)   # col_end_out
        )  # type: ignore


def select_matching_lines(
    region_in: HObject,
    angle_in: MaybeSequence[float],
    dist_in: MaybeSequence[float],
    line_width: int,
    thresh: int
) -> Tuple[HObject, Sequence[float], Sequence[float]]:
    """
    Select those lines from a set of lines (in HNF) which fit best into a
    region.

    Parameters
    ----------

    region_in : HObject
                Region in which the lines are to be matched.

    angle_in : MaybeSequence[float]
               Angles (in radians) of the normal vectors of the input
               lines.

    dist_in : MaybeSequence[float]
              Distances of the input lines form the origin.

    line_width : int
                 Widths of the lines.
                 Value Suggestion: 7

    thresh : int
             Threshold value for the number of line points in the region.
             Value Suggestion: 100

    Returns
    -------

    region_lines : HObject
                   Region array containing the matched lines.

    angle_out : Sequence[float]
                Angles (in radians) of the normal vectors of the selected
                lines.

    dist_out : Sequence[float]
               Distances of the selected lines from the origin.

    Predecessors
    ------------
    hough_lines
    """
    with HalconOperator(1155) as proc:
        proc.set_input_object(1, region_in)
        proc.set_input_tuple(0, angle_in)
        proc.set_input_tuple(1, dist_in)
        proc.set_input_tuple(2, line_width)
        proc.set_input_tuple(3, thresh)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # region_lines
            proc.get_output_tuple_m(0),  # angle_out
            proc.get_output_tuple_m(1)   # dist_out
        )  # type: ignore


def select_matching_lines_s(
    region_in: HObject,
    angle_in: MaybeSequence[float],
    dist_in: MaybeSequence[float],
    line_width: int,
    thresh: int
) -> Tuple[HObject, float, float]:
    """
    Select those lines from a set of lines (in HNF) which fit best into a
    region.

    Parameters
    ----------

    region_in : HObject
                Region in which the lines are to be matched.

    angle_in : MaybeSequence[float]
               Angles (in radians) of the normal vectors of the input
               lines.

    dist_in : MaybeSequence[float]
              Distances of the input lines form the origin.

    line_width : int
                 Widths of the lines.
                 Value Suggestion: 7

    thresh : int
             Threshold value for the number of line points in the region.
             Value Suggestion: 100

    Returns
    -------

    region_lines : HObject
                   Region array containing the matched lines.

    angle_out : float
                Angles (in radians) of the normal vectors of the selected
                lines.

    dist_out : float
               Distances of the selected lines from the origin.

    Predecessors
    ------------
    hough_lines
    """
    with HalconOperator(1155) as proc:
        proc.set_input_object(1, region_in)
        proc.set_input_tuple(0, angle_in)
        proc.set_input_tuple(1, dist_in)
        proc.set_input_tuple(2, line_width)
        proc.set_input_tuple(3, thresh)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # region_lines
            proc.get_output_tuple_s(0),  # angle_out
            proc.get_output_tuple_s(1)   # dist_out
        )  # type: ignore


def select_obj(objects: HObject, index: MaybeSequence[int]) -> HObject:
    """
    Select objects from an object tuple.

    Parameters
    ----------

    objects : HObject
              Input objects.

    index : MaybeSequence[int]
            Indices of the objects to be selected.
            Value Suggestion: 1
            Assertion: Index >= 1

    Returns
    -------

    object_selected : HObject
                      Selected objects.

    See Also
    --------
    count_obj, concat_obj, obj_to_integer

    Alternatives
    ------------
    copy_obj

    Predecessors
    ------------
    count_obj
    """
    with HalconOperator(587) as proc:
        proc.set_input_object(1, objects)
        proc.set_input_tuple(0, index)
        proc.execute()
        object_selected = HObject(proc.get_output_object_key(1))
        return object_selected  # type: ignore


def select_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    feature: MaybeSequence[str],
    operation: str,
    min_value: MaybeSequence[Union[int, float, str]],
    max_value: MaybeSequence[Union[int, float, str]]
) -> Sequence[HHandle]:
    """
    Select 3D object models from an array of 3D object models according to
    global features.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the available 3D object models to select.

    feature : MaybeSequence[str]
              List of features a test is performed on.
              Value Suggestion: has_triangles

    operation : str
                Logical operation to combine the features given in Feature.
                Value Suggestion: 'and'

    min_value : MaybeSequence[Union[int, float, str]]
                Minimum value for the given feature.
                Value Suggestion: 1

    max_value : MaybeSequence[Union[int, float, str]]
                Maximum value for the given feature.
                Value Suggestion: 1

    Returns
    -------

    object_model_3dselected : Sequence[HHandle]
                              A subset of ObjectModel3D fulfilling the
                              given conditions.

    See Also
    --------
    volume_object_model_3d_relative_to_plane, area_object_model_3d,
    max_diameter_object_model_3d, moments_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, select_points_object_model_3d,
    connection_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz
    """
    with HalconOperator(1079) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, feature)
        proc.set_input_tuple(2, operation)
        proc.set_input_tuple(3, min_value)
        proc.set_input_tuple(4, max_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dselected = proc.get_output_tuple_m(0)
        return object_model_3dselected  # type: ignore


def select_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    feature: MaybeSequence[str],
    operation: str,
    min_value: MaybeSequence[Union[int, float, str]],
    max_value: MaybeSequence[Union[int, float, str]]
) -> HHandle:
    """
    Select 3D object models from an array of 3D object models according to
    global features.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handles of the available 3D object models to select.

    feature : MaybeSequence[str]
              List of features a test is performed on.
              Value Suggestion: has_triangles

    operation : str
                Logical operation to combine the features given in Feature.
                Value Suggestion: 'and'

    min_value : MaybeSequence[Union[int, float, str]]
                Minimum value for the given feature.
                Value Suggestion: 1

    max_value : MaybeSequence[Union[int, float, str]]
                Maximum value for the given feature.
                Value Suggestion: 1

    Returns
    -------

    object_model_3dselected : HHandle
                              A subset of ObjectModel3D fulfilling the
                              given conditions.

    See Also
    --------
    volume_object_model_3d_relative_to_plane, area_object_model_3d,
    max_diameter_object_model_3d, moments_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, select_points_object_model_3d,
    connection_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz
    """
    with HalconOperator(1079) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, feature)
        proc.set_input_tuple(2, operation)
        proc.set_input_tuple(3, min_value)
        proc.set_input_tuple(4, max_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dselected = proc.get_output_tuple_s(0)
        return object_model_3dselected  # type: ignore


def select_points_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    attrib: MaybeSequence[str],
    min_value: MaybeSequence[Union[int, float]],
    max_value: MaybeSequence[Union[int, float]]
) -> Sequence[HHandle]:
    """
    Apply a threshold to an attribute of 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object models.

    attrib : MaybeSequence[str]
             Attributes the threshold is applied to.
             Value Suggestion: 'point_coord_z'

    min_value : MaybeSequence[Union[int, float]]
                Minimum value for the attributes specified by Attrib.
                Value Suggestion: 0.5

    max_value : MaybeSequence[Union[int, float]]
                Maximum value for the attributes specified by Attrib.
                Value Suggestion: 1.0

    Returns
    -------

    object_model_3dthresholded : Sequence[HHandle]
                                 Handle of the reduced 3D object models.

    See Also
    --------
    connection_object_model_3d, reduce_object_model_3d_by_view

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    connection_object_model_3d, project_object_model_3d,
    object_model_3d_to_xyz
    """
    with HalconOperator(1086) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attrib)
        proc.set_input_tuple(2, min_value)
        proc.set_input_tuple(3, max_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dthresholded = proc.get_output_tuple_m(0)
        return object_model_3dthresholded  # type: ignore


def select_points_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    attrib: MaybeSequence[str],
    min_value: MaybeSequence[Union[int, float]],
    max_value: MaybeSequence[Union[int, float]]
) -> HHandle:
    """
    Apply a threshold to an attribute of 3D object models.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object models.

    attrib : MaybeSequence[str]
             Attributes the threshold is applied to.
             Value Suggestion: 'point_coord_z'

    min_value : MaybeSequence[Union[int, float]]
                Minimum value for the attributes specified by Attrib.
                Value Suggestion: 0.5

    max_value : MaybeSequence[Union[int, float]]
                Maximum value for the attributes specified by Attrib.
                Value Suggestion: 1.0

    Returns
    -------

    object_model_3dthresholded : HHandle
                                 Handle of the reduced 3D object models.

    See Also
    --------
    connection_object_model_3d, reduce_object_model_3d_by_view

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    connection_object_model_3d, project_object_model_3d,
    object_model_3d_to_xyz
    """
    with HalconOperator(1086) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attrib)
        proc.set_input_tuple(2, min_value)
        proc.set_input_tuple(3, max_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dthresholded = proc.get_output_tuple_s(0)
        return object_model_3dthresholded  # type: ignore


def select_region_point(
    regions: HObject,
    row: int,
    column: int
) -> HObject:
    """
    Choose all regions containing a given pixel.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    row : int
          Line index of the test pixel.
          Value Suggestion: 100

    column : int
             Column index of the test pixel.
             Value Suggestion: 100

    Returns
    -------

    dest_regions : HObject
                   All regions containing the test pixel.

    See Also
    --------
    get_mbutton, get_mposition

    Alternatives
    ------------
    test_region_point

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    If the regions overlap more than one region might contain the pixel.
    In this case all these regions are returned. If no region contains the
    indicated pixel the empty tuple (= no region) is returned.
    """
    with HalconOperator(1714) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.execute()
        dest_regions = HObject(proc.get_output_object_key(1))
        return dest_regions  # type: ignore


def select_region_spatial(
    regions_1: HObject,
    regions_2: HObject,
    direction: str
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Pose relation of regions.

    Parameters
    ----------

    regions_1 : HObject
                Starting regions

    regions_2 : HObject
                Comparative regions

    direction : str
                Desired neighboring relation.
                Value Suggestion: left

    Returns
    -------

    region_index_1 : Sequence[int]
                     Indices in the input tuples (Regions1 or-
                     Regions2), respectively.

    region_index_2 : Sequence[int]
                     Indices in the input tuples (Regions1 or-
                     Regions2), respectively.

    See Also
    --------
    spatial_relation, find_neighbors, copy_obj, obj_to_integer

    Alternatives
    ------------
    area_center, intersection

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1722) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.set_input_tuple(0, direction)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # region_index_1
            proc.get_output_tuple_m(1)   # region_index_2
        )  # type: ignore


def select_shape(
    regions: HObject,
    features: MaybeSequence[str],
    operation: str,
    min: MaybeSequence[Union[int, float, str]],
    max: MaybeSequence[Union[int, float, str]]
) -> HObject:
    """
    Choose regions with the aid of shape features.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    features : MaybeSequence[str]
               Shape features to be checked.
               Value Suggestion: area

    operation : str
                Linkage type of the individual features.
                Value Suggestion: and

    min : MaybeSequence[Union[int, float, str]]
          Lower limits of the features or 'min'.
          Value Suggestion: 150.0

    max : MaybeSequence[Union[int, float, str]]
          Upper limits of the features or 'max'.
          Value Suggestion: 99999.0
          Assertion: Max >= Min

    Returns
    -------

    selected_regions : HObject
                       Regions fulfilling the condition.

    See Also
    --------
    area_center, circularity, compactness, contlength, convexity,
    rectangularity, elliptic_axis, eccentricity, inner_circle,
    smallest_circle, smallest_rectangle1, smallest_rectangle2,
    inner_rectangle1, roundness, connect_and_holes, area_holes,
    diameter_region, orientation_region, moments_region_2nd,
    moments_region_2nd_invar, moments_region_2nd_rel_invar,
    moments_region_3rd, moments_region_3rd_invar, moments_region_central,
    moments_region_central_invar, select_obj

    Alternatives
    ------------
    select_shape_std

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    select_gray, shape_trans, reduce_domain, count_obj
    """
    with HalconOperator(1703) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, features)
        proc.set_input_tuple(1, operation)
        proc.set_input_tuple(2, min)
        proc.set_input_tuple(3, max)
        proc.execute()
        selected_regions = HObject(proc.get_output_object_key(1))
        return selected_regions  # type: ignore


def select_shape_proto(
    regions: HObject,
    pattern: HObject,
    feature: MaybeSequence[str],
    min: Union[int, float],
    max: Union[int, float]
) -> HObject:
    """
    Choose regions having a certain relation to each other.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    pattern : HObject
              Region compared to Regions.

    feature : MaybeSequence[str]
              Shape features to be checked.
              Value Suggestion: covers

    min : Union[int, float]
          Lower border of feature.
          Value Suggestion: 50.0

    max : Union[int, float]
          Upper border of the feature.
          Value Suggestion: 100.0

    Returns
    -------

    selected_regions : HObject
                       Regions fulfilling the condition.

    See Also
    --------
    opening, erosion1, distance_rr_min_dil, distance_rr_min

    Alternatives
    ------------
    select_shape

    Predecessors
    ------------
    connection, draw_region, gen_circle, gen_rectangle1, gen_rectangle2,
    gen_ellipse

    Successors
    ----------
    select_gray, shape_trans, reduce_domain, count_obj
    """
    with HalconOperator(1701) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_object(2, pattern)
        proc.set_input_tuple(0, feature)
        proc.set_input_tuple(1, min)
        proc.set_input_tuple(2, max)
        proc.execute()
        selected_regions = HObject(proc.get_output_object_key(1))
        return selected_regions  # type: ignore


def select_shape_std(
    regions: HObject,
    shape: str,
    percent: float
) -> HObject:
    """
    Select regions of a given shape.

    Parameters
    ----------

    regions : HObject
              Input regions to be selected.

    shape : str
            Shape features to be checked.
            Value Suggestion: max_area

    percent : float
              Similarity measure.
              Value Suggestion: 70.0

    Returns
    -------

    selected_regions : HObject
                       Regions with desired shape.

    See Also
    --------
    smallest_rectangle1, smallest_rectangle2, rectangularity

    Alternatives
    ------------
    intersection, complement, area_center, select_shape

    Predecessors
    ------------
    threshold, regiongrowing, connection, smallest_rectangle1,
    smallest_rectangle2
    """
    with HalconOperator(1715) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, shape)
        proc.set_input_tuple(1, percent)
        proc.execute()
        selected_regions = HObject(proc.get_output_object_key(1))
        return selected_regions  # type: ignore


def select_shape_xld(
    xld: HObject,
    features: MaybeSequence[str],
    operation: str,
    min: MaybeSequence[Union[int, float, str]],
    max: MaybeSequence[Union[int, float, str]]
) -> HObject:
    """
    Select contours or polygons using shape features.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    features : MaybeSequence[str]
               Shape features to be checked.
               Value Suggestion: area

    operation : str
                Operation type between the individual features.
                Value Suggestion: and

    min : MaybeSequence[Union[int, float, str]]
          Lower limits of the features or 'min'.
          Value Suggestion: 150.0

    max : MaybeSequence[Union[int, float, str]]
          Upper limits of the features or 'max'.
          Value Suggestion: 99999.0
          Assertion: Max >= Min

    Returns
    -------

    selected_xld : HObject
                   Contours or polygons fulfilling the condition(s).

    See Also
    --------
    area_center_xld, area_center_points_xld, circularity_xld,
    compactness_xld, convexity_xld, elliptic_axis_xld,
    elliptic_axis_points_xld, eccentricity_xld, eccentricity_points_xld,
    rectangularity_xld, smallest_circle_xld, smallest_rectangle1_xld,
    smallest_rectangle2_xld, diameter_xld, orientation_xld,
    orientation_points_xld, moments_xld, moments_points_xld, select_obj

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld

    Successors
    ----------
    shape_trans_xld, count_obj
    """
    with HalconOperator(1678) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, features)
        proc.set_input_tuple(1, operation)
        proc.set_input_tuple(2, min)
        proc.set_input_tuple(3, max)
        proc.execute()
        selected_xld = HObject(proc.get_output_object_key(1))
        return selected_xld  # type: ignore


def select_sub_feature_class_train_data(
    class_train_data_handle: HHandle,
    sub_feature_indices: Sequence[Union[int, str]]
) -> HHandle:
    """
    Select certain features from training data to create  training data
    containing less features.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    sub_feature_indices : Sequence[Union[int, str]]
                          Indices or names to select the subfeatures or
                          columns.

    Returns
    -------

    selected_class_train_data_handle : HHandle
                                       Handle of the reduced training data.

    Predecessors
    ------------
    create_class_train_data, add_sample_class_train_data,
    set_feature_lengths_class_train_data

    Successors
    ----------
    add_class_train_data_gmm, add_class_train_data_mlp,
    add_class_train_data_svm, add_class_train_data_knn
    """
    with HalconOperator(1783) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, sub_feature_indices)
        proc.init_oct(0)
        proc.execute()
        selected_class_train_data_handle = proc.get_output_tuple_s(0)
        return selected_class_train_data_handle  # type: ignore


def select_xld_point(
    xlds: HObject,
    row: Union[float, int],
    column: Union[float, int]
) -> HObject:
    """
    Choose all contours or polygons containing a given point.

    Parameters
    ----------

    xlds : HObject
           Contours or polygons to be examined.

    row : Union[float, int]
          Line coordinate of the test point.
          Value Suggestion: 100.0

    column : Union[float, int]
             Column coordinate of the test point.
             Value Suggestion: 100.0

    Returns
    -------

    dest_xlds : HObject
                All contours or polygons containing the test point.

    Alternatives
    ------------
    test_xld_point

    Predecessors
    ------------
    select_contours_xld, close_contours_xld, threshold_sub_pix

    Notes
    -----
    If the test point is on the border of a contour or polygon,
    select_xld_point will deliver unpredictable results, i.e., the contour
    or polygon may be or may not be added to DestXLDs, depending on
    arbitrary factors such as how the polygon is oriented with respect to
    the coordinate system. Note further that for points in the near
    proximity of the contour or polygon sides, a reliable classification
    is practically impossible because of numerical inaccuracies.
    """
    with HalconOperator(1676) as proc:
        proc.set_input_object(1, xlds)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.execute()
        dest_xlds = HObject(proc.get_output_object_key(1))
        return dest_xlds  # type: ignore


def send_data(
    socket: HHandle,
    format: str,
    data: MaybeSequence[Union[float, int, str]],
    to: MaybeSequence[Union[int, str]]
) -> None:
    """
    Send arbitrary data to external devices or applications using a
    generic socket communication.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    format : str
             Specification how to convert the data.
             Value Suggestion: z

    data : MaybeSequence[Union[float, int, str]]
           Value (or tuple of values) holding the data to send.

    to : MaybeSequence[Union[int, str]]
         IP address or hostname and network port of the communication
         partner.
         Value Suggestion: []

    See Also
    --------
    receive_data

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect, get_socket_param,
    set_socket_param

    Successors
    ----------
    close_socket
    """
    with HalconOperator(334) as proc:
        proc.set_input_tuple(0, socket)
        proc.set_input_tuple(1, format)
        proc.set_input_tuple(2, data)
        proc.set_input_tuple(3, to)
        proc.execute()


def send_image(image: HObject, socket: HHandle) -> None:
    """
    Send an image over a socket connection.

    Parameters
    ----------

    image : HObject
            Image to be sent.

    socket : HHandle
             Socket number.

    See Also
    --------
    receive_image, send_region, receive_region, send_tuple, receive_tuple,
    get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect
    """
    with HalconOperator(326) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, socket)
        proc.execute()


def send_mouse_double_click_event(
    window_handle: HHandle,
    row: Union[float, int],
    column: Union[float, int],
    button: int
) -> str:
    """
    Send an event to a buffer window signaling a mouse double click event.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle of the buffer window.

    row : Union[float, int]
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : Union[float, int]
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed.

    Returns
    -------

    processed : str
                'true', if HALCON processed the event.

    See Also
    --------
    send_mouse_up_event, send_mouse_down_event, open_window

    Predecessors
    ------------
    open_window

    Notes
    -----
    send_mouse_double_click_event depends on the library libcanvas, which
    might not be available on embedded systems.
    """
    with HalconOperator(2088) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, button)
        proc.init_oct(0)
        proc.execute()
        processed = proc.get_output_tuple_s(0)
        return processed  # type: ignore


def send_mouse_down_event(
    window_handle: HHandle,
    row: Union[float, int],
    column: Union[float, int],
    button: int
) -> str:
    """
    Send an event to a window buffer signaling a mouse down event.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle of the buffer window.

    row : Union[float, int]
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : Union[float, int]
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed.

    Returns
    -------

    processed : str
                'true', if HALCON processed the event.

    See Also
    --------
    send_mouse_up_event, send_mouse_double_click_event, open_window

    Predecessors
    ------------
    open_window

    Notes
    -----
    send_mouse_down_event depends on the library libcanvas, which might
    not be available on embedded systems.
    """
    with HalconOperator(2089) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, button)
        proc.init_oct(0)
        proc.execute()
        processed = proc.get_output_tuple_s(0)
        return processed  # type: ignore


def send_mouse_drag_event(
    window_handle: HHandle,
    row: Union[float, int],
    column: Union[float, int],
    button: int
) -> str:
    """
    Send an event to a buffer window signaling a mouse drag event.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle of the buffer window.

    row : Union[float, int]
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : Union[float, int]
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed.

    Returns
    -------

    processed : str
                'true', if HALCON processed the event.

    See Also
    --------
    send_mouse_up_event, send_mouse_down_event,
    send_mouse_double_click_event, open_window

    Predecessors
    ------------
    open_window

    Notes
    -----
    send_mouse_drag_event depends on the library libcanvas, which might
    not be available on embedded systems.
    """
    with HalconOperator(2090) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, button)
        proc.init_oct(0)
        proc.execute()
        processed = proc.get_output_tuple_s(0)
        return processed  # type: ignore


def send_mouse_up_event(
    window_handle: HHandle,
    row: Union[float, int],
    column: Union[float, int],
    button: int
) -> str:
    """
    Send an event to a buffer window signaling a mouse up event.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle of the buffer window.

    row : Union[float, int]
          Row coordinate of the mouse cursor in the image coordinate
          system.

    column : Union[float, int]
             Column coordinate of the mouse cursor in the image coordinate
             system.

    button : int
             Mouse button(s) pressed.

    Returns
    -------

    processed : str
                'true', if HALCON processed the event.

    See Also
    --------
    send_mouse_down_event, send_mouse_double_click_event, open_window

    Predecessors
    ------------
    open_window

    Notes
    -----
    send_mouse_up_event depends on the library libcanvas, which might not
    be available on embedded systems.
    """
    with HalconOperator(2091) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, button)
        proc.init_oct(0)
        proc.execute()
        processed = proc.get_output_tuple_s(0)
        return processed  # type: ignore


def send_region(region: HObject, socket: HHandle) -> None:
    """
    Send regions over a socket connection.

    Parameters
    ----------

    region : HObject
             Regions to be sent.

    socket : HHandle
             Socket number.

    See Also
    --------
    receive_region, send_image, receive_image, send_tuple, receive_tuple,
    get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect
    """
    with HalconOperator(328) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, socket)
        proc.execute()


def send_serialized_item(
    socket: HHandle,
    serialized_item_handle: HHandle
) -> None:
    """
    Send a serialized item over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_serialized_item_ptr, serialize_matrix, serialize_metrology_model

    Successors
    ----------
    receive_serialized_item
    """
    with HalconOperator(404) as proc:
        proc.set_input_tuple(0, socket)
        proc.set_input_tuple(1, serialized_item_handle)
        proc.execute()


def send_tuple(socket: HHandle, tuple: Union[float, int, str]) -> None:
    """
    Send a tuple over a socket connection.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    tuple : Union[float, int, str]
            Tuple to be sent.

    See Also
    --------
    receive_tuple, send_image, receive_image, send_region, receive_region,
    get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect
    """
    with HalconOperator(332) as proc:
        proc.set_input_tuple(0, socket)
        proc.set_input_tuple(1, tuple)
        proc.execute()


def send_xld(xld: HObject, socket: HHandle) -> None:
    """
    Send an XLD object over a socket connection.

    Parameters
    ----------

    xld : HObject
          XLD object to be sent.

    socket : HHandle
             Socket number.

    See Also
    --------
    receive_xld, send_image, receive_image, send_region, receive_region,
    send_tuple, receive_tuple, get_next_socket_data_type

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect
    """
    with HalconOperator(330) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, socket)
        proc.execute()


def serialize_bar_code_model(bar_code_handle: HHandle) -> HHandle:
    """
    Serialize a bar code model.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_bar_code_model, set_bar_code_param, find_bar_code

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_bar_code_model
    """
    with HalconOperator(1987) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_calib_data(calib_data_id: HHandle) -> HHandle:
    """
    Serialize a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_calib_data
    """
    with HalconOperator(1962) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_cam_par(
    camera_param: Sequence[Union[int, float, str]]
) -> HHandle:
    """
    Serialize the internal camera parameters.

    Parameters
    ----------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_cam_par
    """
    with HalconOperator(1937) as proc:
        proc.set_input_tuple(0, camera_param)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_camera_setup_model(
    camera_setup_model_id: HHandle
) -> HHandle:
    """
    Serialize a camera setup model.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_camera_setup_model
    """
    with HalconOperator(1951) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_class_box(classif_handle: HHandle) -> HHandle:
    """
    Serialize a classifier.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_box, deserialize_class_box

    Predecessors
    ------------
    create_class_box, enquire_class_box, learn_class_box, test_sampset_box

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_class_box

    Warnings
    --------
    serialize_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1885) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_class_gmm(gmmhandle: HHandle) -> HHandle:
    """
    Serialize a Gaussian Mixture Model (GMM).

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_gmm, read_class_gmm, write_samples_class_gmm,
    deserialize_class_gmm

    Predecessors
    ------------
    train_class_gmm

    Successors
    ----------
    clear_class_gmm, fwrite_serialized_item, send_serialized_item,
    deserialize_class_gmm
    """
    with HalconOperator(1827) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_class_knn(knnhandle: HHandle) -> HHandle:
    """
    Serialize a k-NN classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_knn, read_class_knn, deserialize_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_class_knn
    """
    with HalconOperator(1808) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_class_mlp(mlphandle: HHandle) -> HHandle:
    """
    Serialize a multilayer perceptron (MLP).

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_mlp, read_class_mlp, write_samples_class_mlp,
    deserialize_class_mlp

    Predecessors
    ------------
    train_class_mlp

    Successors
    ----------
    clear_class_mlp, fwrite_serialized_item, send_serialized_item,
    deserialize_class_mlp
    """
    with HalconOperator(1866) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_class_svm(svmhandle: HHandle) -> HHandle:
    """
    Serialize a support vector machine (SVM).

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_svm, read_class_svm, write_samples_class_svm,
    deserialize_class_svm

    Predecessors
    ------------
    train_class_svm

    Successors
    ----------
    clear_class_svm, fwrite_serialized_item, send_serialized_item,
    deserialize_class_svm
    """
    with HalconOperator(1845) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_class_train_data(
    class_train_data_handle: HHandle
) -> HHandle:
    """
    Serialize training data for classifiers.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_train_data, read_class_train_data

    Successors
    ----------
    deserialize_class_train_data
    """
    with HalconOperator(1780) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_component_model(component_model_id: HHandle) -> HHandle:
    """
    Serialize a component model.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_component_model, create_trained_component_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_component_model
    """
    with HalconOperator(1001) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_data_code_2d_model(data_code_handle: HHandle) -> HHandle:
    """
    Serialize a 2D data code model.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_data_code_2d_model, set_data_code_2d_param, find_data_code_2d

    Alternatives
    ------------
    get_data_code_2d_param

    Predecessors
    ------------
    set_data_code_2d_param, find_data_code_2d

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_data_code_2d_model
    """
    with HalconOperator(1773) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_deformable_model(model_id: HHandle) -> HHandle:
    """
    Serialize a deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of a model to be saved.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_deformable_model
    """
    with HalconOperator(964) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_deformable_surface_model(
    deformable_surface_model: HHandle
) -> HHandle:
    """
    Serialize a deformable surface_model.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_deformable_surface_model, read_deformable_surface_model,
    write_deformable_surface_model, deserialize_deformable_surface_model

    Predecessors
    ------------
    read_deformable_surface_model, create_deformable_surface_model

    Successors
    ----------
    clear_deformable_surface_model, fwrite_serialized_item,
    send_serialized_item, deserialize_deformable_surface_model
    """
    with HalconOperator(1023) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_descriptor_model(model_id: HHandle) -> HHandle:
    """
    Serialize a descriptor model.

    Parameters
    ----------

    model_id : HHandle
               Handle of a model to be saved.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model

    Predecessors
    ------------
    points_lepetit, create_uncalib_descriptor_model,
    create_calib_descriptor_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_descriptor_model
    """
    with HalconOperator(945) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_distance_transform_xld(
    distance_transform_id: HHandle
) -> HHandle:
    """
    Serialize an XLD distance transform.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized XLD distance
                             transform.

    See Also
    --------
    deserialize_distance_transform_xld, read_distance_transform_xld,
    apply_distance_transform_xld, get_distance_transform_xld_contour,
    get_distance_transform_xld_param, set_distance_transform_xld_param

    Alternatives
    ------------
    write_distance_transform_xld

    Predecessors
    ------------
    create_distance_transform_xld

    Successors
    ----------
    clear_distance_transform_xld
    """
    with HalconOperator(1355) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_dl_classifier(dlclassifier_handle: HHandle) -> HHandle:
    """
    Serialize a deep-learning-based classifier.

    Parameters
    ----------

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_dl_classifier, apply_dl_classifier,
    train_dl_classifier_batch

    Alternatives
    ------------
    serialize_dl_model

    Predecessors
    ------------
    train_dl_classifier_batch

    Successors
    ----------
    apply_dl_classifier, train_dl_classifier_batch,
    fwrite_serialized_item, send_serialized_item, set_dl_classifier_param,
    get_dl_classifier_param

    Warnings
    --------
    serialize_dl_classifier is obsolete and is only provided for reasons
    of backward compatibility.  New applications should use the common
    CNN-based operator serialize_dl_model.
    """
    with HalconOperator(2126) as proc:
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_dl_model(dlmodel_handle: HHandle) -> HHandle:
    """
    Serialize a deep learning model.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_dl_model, apply_dl_model, train_dl_model_batch,
    train_dl_model_anomaly_dataset

    Predecessors
    ------------
    train_dl_model_batch, train_dl_model_anomaly_dataset

    Successors
    ----------
    train_dl_model_batch, train_dl_model_anomaly_dataset,
    fwrite_serialized_item, send_serialized_item
    """
    with HalconOperator(2168) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_dual_quat(
    dual_quaternion: Sequence[Union[float, int]]
) -> HHandle:
    """
    Serialize a dual quaternion.

    Parameters
    ----------

    dual_quaternion : Sequence[Union[float, int]]
                      Dual quaternion.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    axis_angle_to_quat

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_quat
    """
    with HalconOperator(2092) as proc:
        proc.set_input_tuple(0, dual_quaternion)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_fft_optimization_data() -> HHandle:
    """
    Serialize FFT speed optimization data.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    fft_generic, fft_image, fft_image_inv, wiener_filter,
    wiener_filter_ni, photometric_stereo, sfs_pentland, sfs_mod_lr,
    sfs_orig_lr, deserialize_fft_optimization_data

    Predecessors
    ------------
    optimize_fft_speed, optimize_rft_speed

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_fft_optimization_data
    """
    with HalconOperator(1536) as proc:
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_handle(handle: HHandle) -> HHandle:
    """
    Serialize the content of a handle.

    Parameters
    ----------

    handle : HHandle
             Handle that should be serialized.

    Returns
    -------

    serialized_item : HHandle
                      Handle containing the serialized item.

    Predecessors
    ------------
    tuple_is_serializable, tuple_is_serializable_elem

    Successors
    ----------
    deserialize_handle, fwrite_serialized_item, send_serialized_item
    """
    with HalconOperator(2138) as proc:
        proc.set_input_tuple(0, handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item = proc.get_output_tuple_s(0)
        return serialized_item  # type: ignore


def serialize_hom_mat2d(hom_mat_2d: Sequence[float]) -> HHandle:
    """
    Serialize a homogeneous 2D transformation matrix.

    Parameters
    ----------

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_hom_mat2d
    """
    with HalconOperator(236) as proc:
        proc.set_input_tuple(0, hom_mat_2d)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_hom_mat3d(hom_mat_3d: Sequence[float]) -> HHandle:
    """
    Serialize a homogeneous 3D transformation matrix.

    Parameters
    ----------

    hom_mat_3d : Sequence[float]
                 Transformation matrix.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_hom_mat3d
    """
    with HalconOperator(234) as proc:
        proc.set_input_tuple(0, hom_mat_3d)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_image(image: HObject) -> HHandle:
    """
    Serialize an image object.

    Parameters
    ----------

    image : HObject
            Image object.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    open_window, read_image

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_image
    """
    with HalconOperator(1651) as proc:
        proc.set_input_object(1, image)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_matrix(matrix_id: HHandle) -> HHandle:
    """
    Serialize a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_matrix
    """
    with HalconOperator(841) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_measure(measure_handle: HHandle) -> HHandle:
    """
    Serialize a measure object.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    read_measure, write_measure

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_measure
    """
    with HalconOperator(821) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_metrology_model(metrology_handle: HHandle) -> HHandle:
    """
    Serialize a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_metrology_model, add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure,
    add_metrology_object_line_measure,
    add_metrology_object_rectangle2_measure, set_metrology_object_param,
    set_metrology_object_fuzzy_param, read_metrology_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_metrology_model
    """
    with HalconOperator(795) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ncc_model(model_id: HHandle) -> HHandle:
    """
    Serialize an NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_ncc_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_ncc_model
    """
    with HalconOperator(984) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_object(object: HObject) -> HHandle:
    """
    Serialize an iconic object.

    Parameters
    ----------

    object : HObject
             Iconic object.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_object

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_object
    """
    with HalconOperator(1649) as proc:
        proc.set_input_object(1, object)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_object_model_3d(object_model_3d: HHandle) -> HHandle:
    """
    Serialize a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    read_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    read_object_model_3d, fwrite_serialized_item, send_serialized_item,
    deserialize_object_model_3d
    """
    with HalconOperator(1101) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ocr(ocr_handle: HHandle) -> HHandle:
    """
    Serialize an OCR classifier.

    Parameters
    ----------

    ocr_handle : HHandle
                 ID of the OCR classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_ocr, do_ocr_multi, traind_ocr_class_box,
    trainf_ocr_class_box

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box

    Successors
    ----------
    do_ocr_multi, do_ocr_single, fwrite_serialized_item,
    send_serialized_item, deserialize_ocr

    Warnings
    --------
    serialize_ocr is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.
    """
    with HalconOperator(709) as proc:
        proc.set_input_tuple(0, ocr_handle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ocr_class_cnn(ocrhandle: HHandle) -> HHandle:
    """
    Serialize a CNN-based OCR classifier

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    clear_ocr_class_cnn, fwrite_serialized_item, send_serialized_item,
    deserialize_ocr_class_cnn
    """
    with HalconOperator(2093) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ocr_class_knn(ocrhandle: HHandle) -> HHandle:
    """
    Serialize a k-NN-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_class_knn, read_ocr_class_knn, deserialize_ocr_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_ocr_class_knn
    """
    with HalconOperator(649) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ocr_class_mlp(ocrhandle: HHandle) -> HHandle:
    """
    Serialize a MLP-based OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_ocr_class_mlp, read_ocr_class_mlp, write_class_mlp,
    read_class_mlp, deserialize_ocr_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp

    Successors
    ----------
    clear_ocr_class_mlp, fwrite_serialized_item, send_serialized_item,
    deserialize_ocr_class_mlp
    """
    with HalconOperator(693) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ocr_class_svm(ocrhandle: HHandle) -> HHandle:
    """
    Serialize a SVM-based OCR classifier

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_ocr_class_svm, read_ocr_class_svm, write_class_svm,
    read_class_svm, deserialize_ocr_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm

    Successors
    ----------
    clear_ocr_class_svm, fwrite_serialized_item, send_serialized_item,
    deserialize_ocr_class_svm
    """
    with HalconOperator(675) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_ocv(ocvhandle: HHandle) -> HHandle:
    """
    Serialize an OCV tool.

    Parameters
    ----------

    ocvhandle : HHandle
                Handle of the OCV tool.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    traind_ocv_proj

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_ocv
    """
    with HalconOperator(641) as proc:
        proc.set_input_tuple(0, ocvhandle)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_pose(pose: Sequence[Union[int, float]]) -> HHandle:
    """
    Serialize a pose.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           3D pose.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_pose
    """
    with HalconOperator(1939) as proc:
        proc.set_input_tuple(0, pose)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_quat(quaternion: Sequence[Union[float, int]]) -> HHandle:
    """
    Serialize a quaternion.

    Parameters
    ----------

    quaternion : Sequence[Union[float, int]]
                 Quaternion.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    axis_angle_to_quat

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_quat
    """
    with HalconOperator(238) as proc:
        proc.set_input_tuple(0, quaternion)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_region(region: HObject) -> HHandle:
    """
    Serialize a region.

    Parameters
    ----------

    region : HObject
             Region.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_region

    Predecessors
    ------------
    open_window, read_image, read_region, threshold, regiongrowing

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_region
    """
    with HalconOperator(1653) as proc:
        proc.set_input_object(1, region)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_sample_identifier(sample_identifier: HHandle) -> HHandle:
    """
    Serialize a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Alternatives
    ------------
    write_sample_identifier

    Predecessors
    ------------
    prepare_sample_identifier, train_sample_identifier,
    add_sample_identifier_preparation_data,
    add_sample_identifier_training_data, set_sample_identifier_param

    Successors
    ----------
    clear_sample_identifier
    """
    with HalconOperator(902) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_shape_model(model_id: HHandle) -> HHandle:
    """
    Serialize a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model, create_aniso_shape_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_shape_model
    """
    with HalconOperator(918) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_shape_model_3d(shape_model_3did: HHandle) -> HHandle:
    """
    Serialize a 3D shape model.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_shape_model_3d

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_shape_model_3d
    """
    with HalconOperator(1051) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_sheet_of_light_model(
    sheet_of_light_model_id: HHandle
) -> HHandle:
    """
    Serialize a sheet-of-light model.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_sheet_of_light_model

    Predecessors
    ------------
    create_sheet_of_light_model, set_sheet_of_light_param

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_sheet_of_light_model
    """
    with HalconOperator(377) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_structured_light_model(
    structured_light_model: HHandle
) -> HHandle:
    """
    Serialize a structured light model.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_structured_light_model, read_structured_light_model,
    deserialize_structured_light_model

    Successors
    ----------
    clear_structured_light_model, fwrite_serialized_item,
    send_serialized_item, deserialize_structured_light_model
    """
    with HalconOperator(2127) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_surface_model(surface_model_id: HHandle) -> HHandle:
    """
    Serialize a surface_model.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_surface_model, read_surface_model, write_surface_model

    Predecessors
    ------------
    read_surface_model, create_surface_model, get_surface_model_param

    Successors
    ----------
    clear_surface_model, fwrite_serialized_item, send_serialized_item,
    deserialize_surface_model
    """
    with HalconOperator(1038) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_template(template_id: HHandle) -> HHandle:
    """
    Serialize a template.

    Parameters
    ----------

    template_id : HHandle
                  Handle of the template.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    create_template, create_template_rot

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_template

    Warnings
    --------
    serialize_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1490) as proc:
        proc.set_input_tuple(0, template_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_texture_inspection_model(
    texture_inspection_model: HHandle
) -> HHandle:
    """
    Serialize a texture inspection model.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    create_texture_inspection_model, read_texture_inspection_model,
    deserialize_texture_inspection_model

    Predecessors
    ------------
    train_texture_inspection_model

    Successors
    ----------
    clear_texture_inspection_model, fwrite_serialized_item,
    send_serialized_item, deserialize_texture_inspection_model
    """
    with HalconOperator(2094) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_training_components(
    component_training_id: HHandle
) -> HHandle:
    """
    Serialize a component training result.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Predecessors
    ------------
    train_model_components

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_training_components
    """
    with HalconOperator(1012) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_tuple(tuple: HTupleType) -> HHandle:
    """
    Serialize a tuple.

    Parameters
    ----------

    tuple : HTupleType
            Tuple.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_tuple
    """
    with HalconOperator(218) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_variation_model(model_id: HHandle) -> HHandle:
    """
    Serialize a variation model.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    read_variation_model, write_variation_model

    Predecessors
    ------------
    train_variation_model

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item,
    deserialize_variation_model
    """
    with HalconOperator(82) as proc:
        proc.set_input_tuple(0, model_id)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def serialize_xld(xld: HObject) -> HHandle:
    """
    Serialize an XLD object.

    Parameters
    ----------

    xld : HObject
          XLD object.

    Returns
    -------

    serialized_item_handle : HHandle
                             Handle of the serialized item.

    See Also
    --------
    deserialize_xld

    Predecessors
    ------------
    gen_contour_polygon_xld, gen_parallels_xld, gen_polygons_xld

    Successors
    ----------
    fwrite_serialized_item, send_serialized_item, deserialize_xld
    """
    with HalconOperator(1633) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        serialized_item_handle = proc.get_output_tuple_s(0)
        return serialized_item_handle  # type: ignore


def set_aop_info(
    operator_name: MaybeSequence[Union[str, int]],
    index_name: MaybeSequence[Union[str, int]],
    index_value: MaybeSequence[Union[str, int]],
    info_name: str,
    info_value: MaybeSequence[int]
) -> None:
    """
    Set AOP information for operators.

    Parameters
    ----------

    operator_name : MaybeSequence[Union[str, int]]
                    Operator to set information to
                    Value Suggestion: ''

    index_name : MaybeSequence[Union[str, int]]
                 Further specific index
                 Value Suggestion: ''

    index_value : MaybeSequence[Union[str, int]]
                  Further specific address
                  Value Suggestion: ''

    info_name : str
                Scope of information
                Value Suggestion: max_threads

    info_value : MaybeSequence[int]
                 AOP information value

    Notes
    -----
    set_aop_info modifies the AOP system knowledge. These modifications
    will also be stored by write_aop_knowledge. It is advisable to  have a
    backup knowledge file before modifying the system knowledge.
    """
    with HalconOperator(566) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, index_name)
        proc.set_input_tuple(2, index_value)
        proc.set_input_tuple(3, info_name)
        proc.set_input_tuple(4, info_value)
        proc.execute()


def set_bar_code_param(
    bar_code_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> None:
    """
    Set selected parameters of the bar code model.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that shall be
                     adjusted for finding and decoding bar codes.
                     Value Suggestion: element_size_min

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Values of the generic parameters that are adjusted
                      for finding and decoding bar codes.
                      Value Suggestion: 8

    Alternatives
    ------------
    set_bar_code_param_specific

    Predecessors
    ------------
    create_bar_code_model

    Successors
    ----------
    find_bar_code
    """
    with HalconOperator(1998) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_bar_code_param_specific(
    bar_code_handle: HHandle,
    code_types: MaybeSequence[str],
    gen_param_name: MaybeSequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> None:
    """
    Set selected parameters of the bar code model for selected bar code
    types

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    code_types : MaybeSequence[str]
                 Names of the bar code types for which parameters should
                 be set.
                 Value Suggestion: 'EAN-13'

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that shall be
                     adjusted for finding and decoding bar codes.
                     Value Suggestion: check_char

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic parameters that are adjusted
                      for finding and decoding bar codes.
                      Value Suggestion: absent

    Alternatives
    ------------
    set_bar_code_param

    Predecessors
    ------------
    create_bar_code_model

    Successors
    ----------
    find_bar_code
    """
    with HalconOperator(1997) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, code_types)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_bead_inspection_param(
    bead_inspection_model: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set parameters of the bead inspection model.

    Parameters
    ----------

    bead_inspection_model : HHandle
                            Handle of the bead inspection model.

    gen_param_name : MaybeSequence[str]
                     Name of the model parameter that shall be adjusted
                     for the specified bead inspection model.
                     Value Suggestion: target_thickness

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the model parameter that shall be adjusted
                      for the specified bead inspection model.
                      Value Suggestion: 40

    See Also
    --------
    create_bead_inspection_model, clear_bead_inspection_model

    Alternatives
    ------------
    create_bead_inspection_model

    Predecessors
    ------------
    create_bead_inspection_model

    Successors
    ----------
    apply_bead_inspection_model, get_bead_inspection_param
    """
    with HalconOperator(1982) as proc:
        proc.set_input_tuple(0, bead_inspection_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_bg_esti_params(
    bg_esti_handle: HHandle,
    syspar_1: float,
    syspar_2: float,
    gain_mode: str,
    gain_1: float,
    gain_2: float,
    adapt_mode: str,
    min_diff: float,
    stat_num: int,
    confidence_c: float,
    time_c: float
) -> None:
    """
    Change the parameters of the data set.

    Parameters
    ----------

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    syspar_1 : float
               1. system matrix parameter.
               Value Suggestion: 0.7

    syspar_2 : float
               2. system matrix parameter.
               Value Suggestion: 0.7

    gain_mode : str
                Gain type.
                Value Suggestion: fixed

    gain_1 : float
             Kalman gain / foreground adaptation time.
             Value Suggestion: 0.002
             Assertion: 0.0 <= Gain1

    gain_2 : float
             Kalman gain / background adaptation time.
             Value Suggestion: 0.02
             Assertion: 0.0 <= Gain2

    adapt_mode : str
                 Threshold adaptation.
                 Value Suggestion: on

    min_diff : float
               Foreground/background threshold.
               Value Suggestion: 7.0

    stat_num : int
               Number of statistic data sets.
               Value Suggestion: 10

    confidence_c : float
                   Confidence constant.
                   Value Suggestion: 3.25
                   Assertion: 0.0 < ConfidenceC

    time_c : float
             Constant for decay time.
             Value Suggestion: 15.0
             Assertion: 0.0 < TimeC

    See Also
    --------
    update_bg_esti

    Predecessors
    ------------
    create_bg_esti

    Successors
    ----------
    run_bg_esti

    Notes
    -----
    If GainMode was set to 'frame', the run-time can be extremely long for
    large values of Gain1 or Gain2, because the values for the gains'
    table are determined by a simple binary search.
    """
    with HalconOperator(2007) as proc:
        proc.set_input_tuple(0, bg_esti_handle)
        proc.set_input_tuple(1, syspar_1)
        proc.set_input_tuple(2, syspar_2)
        proc.set_input_tuple(3, gain_mode)
        proc.set_input_tuple(4, gain_1)
        proc.set_input_tuple(5, gain_2)
        proc.set_input_tuple(6, adapt_mode)
        proc.set_input_tuple(7, min_diff)
        proc.set_input_tuple(8, stat_num)
        proc.set_input_tuple(9, confidence_c)
        proc.set_input_tuple(10, time_c)
        proc.execute()


def set_calib_data(
    calib_data_id: HHandle,
    item_type: str,
    item_idx: MaybeSequence[Union[int, str]],
    data_name: str,
    data_value: MaybeSequence[Union[str, int]]
) -> None:
    """
    Set data in a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    item_type : str
                Type of calibration data item.
                Value Suggestion: model

    item_idx : MaybeSequence[Union[int, str]]
               Index of the affected item (depending on the selected
               ItemType).
               Value Suggestion: general

    data_name : str
                Parameter(s) to set.
                Value Suggestion: reference_camera

    data_value : MaybeSequence[Union[str, int]]
                 New value(s).
                 Value Suggestion: 0

    Predecessors
    ------------
    set_calib_data_observ_points, find_calib_object

    Successors
    ----------
    calibrate_cameras, calibrate_hand_eye
    """
    with HalconOperator(1968) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, item_type)
        proc.set_input_tuple(2, item_idx)
        proc.set_input_tuple(3, data_name)
        proc.set_input_tuple(4, data_value)
        proc.execute()


def set_calib_data_calib_object(
    calib_data_id: HHandle,
    calib_obj_idx: int,
    calib_obj_descr: MaybeSequence[Union[float, int, str]]
) -> None:
    """
    Define a calibration object in a calibration model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    calib_obj_idx : int
                    Calibration object index.
                    Value Suggestion: 0

    calib_obj_descr : MaybeSequence[Union[float, int, str]]
                      3D point coordinates or a description file name.

    Predecessors
    ------------
    create_calib_data, set_calib_data_cam_param

    Successors
    ----------
    set_calib_data_cam_param, set_calib_data_observ_points,
    find_calib_object
    """
    with HalconOperator(1978) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, calib_obj_idx)
        proc.set_input_tuple(2, calib_obj_descr)
        proc.execute()


def set_calib_data_cam_param(
    calib_data_id: HHandle,
    camera_idx: Sequence[Union[int, str]],
    camera_type: MaybeSequence[str],
    camera_param: Sequence[Union[float, int, str]]
) -> None:
    """
    Set type and initial parameters of a camera in a calibration data
    model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : Sequence[Union[int, str]]
                 Camera index.
                 Value Suggestion: 0

    camera_type : MaybeSequence[str]
                  Type of the camera.
                  Value Suggestion: []

    camera_param : Sequence[Union[float, int, str]]
                   Initial camera internal parameters.

    Predecessors
    ------------
    create_calib_data, set_calib_data_calib_object

    Successors
    ----------
    set_calib_data_calib_object, set_calib_data_observ_points,
    find_calib_object
    """
    with HalconOperator(1979) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, camera_type)
        proc.set_input_tuple(3, camera_param)
        proc.execute()


def set_calib_data_observ_points(
    calib_data_id: HHandle,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int,
    row: Sequence[Union[float, int]],
    column: Sequence[Union[float, int]],
    index: Sequence[Union[int, str]],
    pose: Sequence[Union[float, int]]
) -> None:
    """
    Set point-based observation data in a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the calibration object.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object.
                         Value Suggestion: 0
                         Assertion: CalibObjPoseIdx >= 0

    row : Sequence[Union[float, int]]
          Row coordinates of the extracted points.

    column : Sequence[Union[float, int]]
             Column coordinates of the extracted points.

    index : Sequence[Union[int, str]]
            Correspondence of the extracted points to the calibration
            marks of the observed calibration object.
            Value Suggestion: all

    pose : Sequence[Union[float, int]]
           Roughly estimated pose of the observed calibration object
           relative to the observing camera.

    Alternatives
    ------------
    find_calib_object

    Predecessors
    ------------
    find_marks_and_pose, set_calib_data_cam_param,
    set_calib_data_calib_object

    Successors
    ----------
    set_calib_data, calibrate_cameras
    """
    with HalconOperator(1975) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, calib_obj_idx)
        proc.set_input_tuple(3, calib_obj_pose_idx)
        proc.set_input_tuple(4, row)
        proc.set_input_tuple(5, column)
        proc.set_input_tuple(6, index)
        proc.set_input_tuple(7, pose)
        proc.execute()


def set_calib_data_observ_pose(
    calib_data_id: HHandle,
    camera_idx: int,
    calib_obj_idx: int,
    calib_obj_pose_idx: int,
    obj_in_camera_pose: Sequence[Union[float, int]]
) -> None:
    """
    Set observed calibration object poses in a calibration data model.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    camera_idx : int
                 Index of the observing camera.
                 Value Suggestion: 0

    calib_obj_idx : int
                    Index of the calibration object.
                    Value Suggestion: 0

    calib_obj_pose_idx : int
                         Index of the observed calibration object.
                         Value Suggestion: 0
                         Assertion: CalibObjPoseIdx >= 0

    obj_in_camera_pose : Sequence[Union[float, int]]
                         Pose of the observed calibration object relative
                         to the observing camera.

    Alternatives
    ------------
    find_calib_object

    Predecessors
    ------------
    find_marks_and_pose, set_calib_data_cam_param,
    set_calib_data_calib_object

    Successors
    ----------
    set_calib_data, calibrate_cameras
    """
    with HalconOperator(1973) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, calib_obj_idx)
        proc.set_input_tuple(3, calib_obj_pose_idx)
        proc.set_input_tuple(4, obj_in_camera_pose)
        proc.execute()


def set_camera_setup_cam_param(
    camera_setup_model_id: HHandle,
    camera_idx: Sequence[int],
    camera_type: MaybeSequence[str],
    camera_param: Sequence[Union[float, int, str]],
    camera_pose: Sequence[Union[float, int]]
) -> None:
    """
    Define type, parameters, and relative pose of a camera in a camera
    setup model.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    camera_idx : Sequence[int]
                 Index of the camera in the setup.

    camera_type : MaybeSequence[str]
                  Type of the camera.
                  Value Suggestion: []

    camera_param : Sequence[Union[float, int, str]]
                   Internal camera parameters.

    camera_pose : Sequence[Union[float, int]]
                  Pose of the camera relative to the setup's coordinate
                  system.
    """
    with HalconOperator(1957) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, camera_type)
        proc.set_input_tuple(3, camera_param)
        proc.set_input_tuple(4, camera_pose)
        proc.execute()


def set_camera_setup_param(
    camera_setup_model_id: HHandle,
    camera_idx: MaybeSequence[Union[int, str]],
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> None:
    """
    Set generic camera setup model parameters.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    camera_idx : MaybeSequence[Union[int, str]]
                 Unique index of the camera in the setup.
                 Value Suggestion: 0

    gen_param_name : str
                     Names of the generic parameters to be set.

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Values of the generic parameters to be set.

    Predecessors
    ------------
    create_camera_setup_model, read_camera_setup_model
    """
    with HalconOperator(1956) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.set_input_tuple(1, camera_idx)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_check(check: MaybeSequence[str]) -> None:
    """
    Activating and deactivating of HALCON control modes.

    Parameters
    ----------

    check : MaybeSequence[str]
            Desired control mode.
            Value Suggestion: default

    See Also
    --------
    get_check, set_color, set_rgb, set_hsi, write_string
    """
    with HalconOperator(318) as proc:
        proc.set_input_tuple(0, check)
        proc.execute()


def set_class_box_param(
    classif_handle: HHandle,
    flag: str,
    value: Union[int, float]
) -> None:
    """
    Set system parameters for classification.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    flag : str
           Name of the wanted parameter.
           Value Suggestion: split_error

    value : Union[int, float]
            Value of the parameter.
            Value Suggestion: 0.1

    See Also
    --------
    enquire_class_box, get_class_box_param, learn_class_box

    Predecessors
    ------------
    create_class_box, enquire_class_box

    Successors
    ----------
    learn_class_box, test_sampset_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    set_class_box_param is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1887) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, flag)
        proc.set_input_tuple(2, value)
        proc.execute()


def set_color(window_handle: HHandle, color: MaybeSequence[str]) -> None:
    """
    Set output color.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    color : MaybeSequence[str]
            Output color names.
            Value Suggestion: white

    See Also
    --------
    get_rgb, disp_region, set_paint

    Alternatives
    ------------
    set_rgb, set_hsi

    Predecessors
    ------------
    query_color

    Successors
    ----------
    disp_region
    """
    with HalconOperator(1238) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, color)
        proc.execute()


def set_colored(window_handle: HHandle, number_of_colors: int) -> None:
    """
    Set multiple output colors.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    number_of_colors : int
                       Number of output colors.
                       Value Suggestion: 12

    See Also
    --------
    query_colored, set_color, disp_region

    Predecessors
    ------------
    query_colored, set_color

    Successors
    ----------
    disp_region
    """
    with HalconOperator(1237) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, number_of_colors)
        proc.execute()


def set_comprise(window_handle: HHandle, mode: str) -> None:
    """
    Define the image matrix output clipping.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    mode : str
           Clipping mode for gray value output.
           Value Suggestion: object

    See Also
    --------
    get_comprise, disp_image, disp_color

    Predecessors
    ------------
    get_comprise

    Successors
    ----------
    disp_image

    Warnings
    --------
    set_comprise is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    If Mode was set to 'image', undefined gray values may be displayed.
    Depending on the context they are black or can have random content.
    See the examples.
    """
    with HalconOperator(1236) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, mode)
        proc.execute()


def set_compute_device_param(
    device_handle: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[str, int, float]]
) -> None:
    """
    Set parameters of an compute device.

    Parameters
    ----------

    device_handle : HHandle
                    Compute device handle.

    gen_param_name : str
                     Name of the parameter to set.
                     Value Suggestion: buffer_cache_capacity

    gen_param_value : MaybeSequence[Union[str, int, float]]
                      New parameter value.

    See Also
    --------
    get_compute_device_param

    Predecessors
    ------------
    activate_compute_device
    """
    with HalconOperator(297) as proc:
        proc.set_input_tuple(0, device_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_content_update_callback(
    window_handle: HHandle,
    callback_function: int,
    callback_context: Union[int, HHandle]
) -> None:
    """
    Sets the callback for content updates in buffer window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    callback_function : int
                        Callback for content updates.

    callback_context : Union[int, HHandle]
                       Parameter to CallbackFunction.

    See Also
    --------
    flush_buffer

    Notes
    -----
    set_content_update_callback depends on the library libcanvas, which
    might not be available on embedded systems.
    """
    with HalconOperator(2095) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, callback_function)
        proc.set_input_tuple(2, callback_context)
        proc.execute()


def set_contour_style(window_handle: HHandle, style: str) -> None:
    """
    Define the contour display fill style.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    style : str
            Fill style of contour displays.
            Value Suggestion: stroke

    See Also
    --------
    get_contour_style, disp_xld, set_line_width, set_line_style

    Predecessors
    ------------
    get_contour_style

    Successors
    ----------
    disp_xld, disp_obj
    """
    with HalconOperator(2179) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, style)
        proc.execute()


def set_current_dir(dir_name: str) -> None:
    """
    Set the current working directory.

    Parameters
    ----------

    dir_name : str
               Name of current working directory to be set.
    """
    with HalconOperator(1639) as proc:
        proc.set_input_tuple(0, dir_name)
        proc.execute()


def set_data_code_2d_param(
    data_code_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, str, float]]
) -> None:
    """
    Set selected parameters of the 2D data code model.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters that shall be
                     adjusted for the 2D data code.
                     Value Suggestion: polarity

    gen_param_value : MaybeSequence[Union[int, str, float]]
                      Values of the generic parameters that are adjusted
                      for the 2D data code.
                      Value Suggestion: light_on_dark

    See Also
    --------
    query_data_code_2d_params, get_data_code_2d_param,
    get_data_code_2d_results, get_data_code_2d_objects

    Alternatives
    ------------
    read_data_code_2d_model

    Predecessors
    ------------
    create_data_code_2d_model, read_data_code_2d_model

    Successors
    ----------
    get_data_code_2d_param, find_data_code_2d, write_data_code_2d_model
    """
    with HalconOperator(1769) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_deep_ocr_param(
    deep_ocr_handle: HHandle,
    gen_param_name: str,
    gen_param_value: HTupleType
) -> None:
    """
    Set the parameters of a Deep OCR model.

    Parameters
    ----------

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: detection_image_width

    gen_param_value : HTupleType
                      Value of the generic parameter.
                      Value Suggestion: 1024

    See Also
    --------
    get_deep_ocr_param

    Predecessors
    ------------
    create_deep_ocr, get_deep_ocr_param

    Successors
    ----------
    get_deep_ocr_param

    Notes
    -----
    System requirements:  To successfully set 'gpu' parameters, cuDNN and
    cuBLAS are  required, i.e., to set the parameter GenParamName 'device'
    to a GPU.  For further details, please refer to the ``Installation
    Guide'',  paragraph ``Requirements for Deep Learning and
    Deep-Learning-Based Methods''.
    """
    with HalconOperator(2216) as proc:
        proc.set_input_tuple(0, deep_ocr_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_deformable_model_origin(
    model_id: HHandle,
    row: float,
    column: float
) -> None:
    """
    Set the origin (reference point) of a deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    row : float
          Row coordinate of the origin of the deformable model.

    column : float
             Column coordinate of the origin of the deformable model.

    See Also
    --------
    area_center

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model,
    read_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model, get_deformable_model_origin
    """
    with HalconOperator(958) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def set_deformable_model_param(
    model_id: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> None:
    """
    Set selected parameters of the deformable model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : Sequence[str]
                     Parameter names.

    gen_param_value : Sequence[Union[float, int, str]]
                      Parameter values.

    See Also
    --------
    get_deformable_model_contours, get_deformable_model_params

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model,
    read_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model,
    find_planar_calib_deformable_model
    """
    with HalconOperator(959) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_descriptor_model_origin(
    model_id: HHandle,
    row: Union[float, int],
    column: Union[float, int]
) -> None:
    """
    Sets the origin of a descriptor model.

    Parameters
    ----------

    model_id : HHandle
               Handle of a descriptor model.

    row : Union[float, int]
          Translation of origin in row direction.
          Value Suggestion: 0

    column : Union[float, int]
             Translation of origin in column direction.
             Value Suggestion: 0

    See Also
    --------
    get_descriptor_model_origin, create_uncalib_descriptor_model

    Predecessors
    ------------
    create_uncalib_descriptor_model, create_calib_descriptor_model,
    read_descriptor_model
    """
    with HalconOperator(956) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def set_diagonal_matrix(
    matrix_id: HHandle,
    vector_id: HHandle,
    diagonal: int
) -> None:
    """
    Set the diagonal elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    vector_id : HHandle
                Matrix handle containing the diagonal elements to be set.

    diagonal : int
               Position of the diagonal.
               Value Suggestion: 0

    See Also
    --------
    get_diagonal_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(887) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, vector_id)
        proc.set_input_tuple(2, diagonal)
        proc.execute()


def set_dict_object(
    object: HObject,
    dict_handle: HHandle,
    key: Union[str, int]
) -> None:
    """
    Add a key/object pair to the dictionary.

    Parameters
    ----------

    object : HObject
             Object to be associated with the key.

    dict_handle : HHandle
                  Dictionary handle.

    key : Union[str, int]
          Key string.
          Assertion: length(Key) > 0

    See Also
    --------
    create_dict, set_dict_tuple, get_dict_tuple, get_dict_object,
    remove_dict_key, get_dict_param

    Alternatives
    ------------
    set_dict_tuple

    Predecessors
    ------------
    create_dict

    Successors
    ----------
    set_dict_tuple
    """
    with HalconOperator(2169) as proc:
        proc.set_input_object(1, object)
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, key)
        proc.execute()


def set_dict_tuple(
    dict_handle: HHandle,
    key: Union[str, int],
    tuple: Sequence[Union[int, float, str]]
) -> None:
    """
    Add a key/tuple pair to the dictionary.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    key : Union[str, int]
          Key string.
          Assertion: length(Key) > 0

    tuple : Sequence[Union[int, float, str]]
            Tuple value to be associated with the key.

    See Also
    --------
    create_dict, get_dict_tuple, set_dict_object, get_dict_object,
    get_dict_param, remove_dict_key

    Alternatives
    ------------
    set_dict_object

    Predecessors
    ------------
    create_dict

    Successors
    ----------
    set_dict_object

    Notes
    -----
    Note that if the tuple contains any handles (which are treated as
    simple integers) only the handle values are copied by the operation,
    not the resources behind those handles.
    """
    with HalconOperator(2170) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, key)
        proc.set_input_tuple(2, tuple)
        proc.execute()


def set_distance_transform_xld_param(
    distance_transform_id: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, str]]
) -> None:
    """
    Set new parameters for an XLD distance transform.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: mode

    gen_param_value : MaybeSequence[Union[float, str]]
                      Values of the generic parameters.
                      Value Suggestion: point_to_point

    See Also
    --------
    write_distance_transform_xld, serialize_distance_transform_xld,
    get_distance_transform_xld_contour, read_distance_transform_xld,
    deserialize_distance_transform_xld, clear_distance_transform_xld

    Predecessors
    ------------
    get_distance_transform_xld_param

    Successors
    ----------
    apply_distance_transform_xld
    """
    with HalconOperator(1357) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_dl_classifier_param(
    dlclassifier_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set the parameters of a deep-learning-based classifier.

    Parameters
    ----------

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: classes

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Value of the generic parameter.
                      Value Suggestion: ['class_1','class_2','class_3']

    See Also
    --------
    get_dl_classifier_param

    Alternatives
    ------------
    set_dl_model_param

    Predecessors
    ------------
    read_dl_classifier

    Successors
    ----------
    get_dl_classifier_param, apply_dl_classifier, train_dl_classifier_batch

    Warnings
    --------
    set_dl_classifier_param is obsolete and is only provided for reasons
    of backward compatibility. New applications should use the common
    CNN-based operator set_dl_model_param instead.

    Notes
    -----
    To successfully set 'gpu' parameters, cuDNN and cuBLAS are  required,
    i.e., to set the parameter GenParamName 'runtime' to 'gpu' or to set
    the GenParamName 'gpu'. For further details, please refer to the
    ``Installation Guide'',  paragraph ``Requirements for Deep Learning
    and Deep-Learning-Based Methods''.
    """
    with HalconOperator(2128) as proc:
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_dl_model_param(
    dlmodel_handle: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set the parameters of a deep learning model.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: learning_rate

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Value of the generic parameter.
                      Value Suggestion: 0.001

    See Also
    --------
    get_dl_model_param

    Predecessors
    ------------
    read_dl_model, get_dl_model_param

    Successors
    ----------
    get_dl_model_param, apply_dl_model, train_dl_model_batch,
    train_dl_model_anomaly_dataset

    Notes
    -----
    System requirements:  To successfully set 'gpu' parameters, cuDNN and
    cuBLAS are  required, i.e., to set the parameter GenParamName
    'runtime' to 'gpu'.  For further details, please refer to the
    ``Installation Guide'',  paragraph ``Requirements for Deep Learning
    and Deep-Learning-Based Methods''.
    """
    with HalconOperator(2171) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_dl_pruning_param(
    dlpruning_handle: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set parameter in a pruning data handle.

    Parameters
    ----------

    dlpruning_handle : HHandle
                       Pruning data handle.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: percentage

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Value of the generic parameter.
                      Value Suggestion: 10

    See Also
    --------
    get_dl_pruning_param

    Predecessors
    ------------
    create_dl_pruning, get_dl_pruning_param
    """
    with HalconOperator(2217) as proc:
        proc.set_input_tuple(0, dlpruning_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_draw(window_handle: HHandle, mode: str) -> None:
    """
    Define the region fill mode.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    mode : str
           Fill mode for region output.
           Value Suggestion: fill

    See Also
    --------
    get_draw, disp_region, set_paint, disp_image, set_line_width,
    set_line_style

    Predecessors
    ------------
    get_draw

    Successors
    ----------
    disp_region

    Notes
    -----
    If the output mode is 'margin' and the line width is more than one,
    objects may not be displayed.
    """
    with HalconOperator(1235) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, mode)
        proc.execute()


def set_drawing_object_callback(
    draw_handle: HHandle,
    draw_object_event: MaybeSequence[str],
    callback_function: MaybeSequence[int]
) -> None:
    """
    Add a callback function to a drawing object.

    Parameters
    ----------

    draw_handle : HHandle
                  Handle of the drawing object.

    draw_object_event : MaybeSequence[str]
                        Events to be captured.

    callback_function : MaybeSequence[int]
                        Callback functions.

    See Also
    --------
    create_drawing_object_rectangle1, attach_drawing_object_to_window,
    detach_drawing_object_from_window

    Predecessors
    ------------
    attach_drawing_object_to_window

    Successors
    ----------
    close_window, clear_drawing_object, detach_drawing_object_from_window,
    get_drawing_object_iconic, get_drawing_object_params

    Notes
    -----
    No graphical operator should be called within the callback, like for
    example disp_obj, for otherwise a deadlock may occur.
    """
    with HalconOperator(1162) as proc:
        proc.set_input_tuple(0, draw_handle)
        proc.set_input_tuple(1, draw_object_event)
        proc.set_input_tuple(2, callback_function)
        proc.execute()


def set_drawing_object_params(
    draw_id: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> None:
    """
    Set the parameters of a drawing object.

    Parameters
    ----------

    draw_id : HHandle
              Handle of the drawing object.

    gen_param_name : MaybeSequence[str]
                     Parameter names of the drawing object.

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Parameter values.

    See Also
    --------
    attach_drawing_object_to_window, get_drawing_object_iconic,
    set_drawing_object_callback

    Predecessors
    ------------
    create_drawing_object_rectangle1, create_drawing_object_rectangle2,
    create_drawing_object_ellipse, create_drawing_object_circle,
    create_drawing_object_line, create_drawing_object_ellipse_sector,
    create_drawing_object_circle_sector, create_drawing_object_xld,
    attach_drawing_object_to_window

    Successors
    ----------
    get_drawing_object_params, attach_drawing_object_to_window,
    get_drawing_object_iconic
    """
    with HalconOperator(1304) as proc:
        proc.set_input_tuple(0, draw_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_drawing_object_xld(contour: HObject, draw_id: HHandle) -> None:
    """
    Set the contour of an interactive draw XLD.

    Parameters
    ----------

    contour : HObject
              XLD contour.

    draw_id : HHandle
              Handle of the drawing object.

    See Also
    --------
    attach_drawing_object_to_window

    Alternatives
    ------------
    create_drawing_object_xld

    Predecessors
    ------------
    create_drawing_object_xld

    Successors
    ----------
    attach_drawing_object_to_window, clear_drawing_object
    """
    with HalconOperator(1306) as proc:
        proc.set_input_object(1, contour)
        proc.set_input_tuple(0, draw_id)
        proc.execute()


def set_feature_lengths_class_train_data(
    class_train_data_handle: HHandle,
    sub_feature_length: Sequence[int],
    names: Sequence[str]
) -> None:
    """
    Define subfeatures in training data.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data that should be
                              partitioned into subfeatures.

    sub_feature_length : Sequence[int]
                         Length of the subfeatures.

    names : Sequence[str]
            Names of the subfeatures.

    Predecessors
    ------------
    create_class_train_data, add_sample_class_train_data

    Successors
    ----------
    select_feature_set_knn, select_feature_set_svm,
    select_feature_set_mlp, select_feature_set_gmm
    """
    with HalconOperator(1784) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, sub_feature_length)
        proc.set_input_tuple(2, names)
        proc.execute()


def set_fix(window_handle: HHandle, mode: str) -> None:
    """
    Set fixing of "`look-up-table"' (lut)

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    mode : str
           Mode of fixing.
           Value Suggestion: true

    See Also
    --------
    get_fix, set_pixel, set_rgb, set_color, set_hsi, set_gray

    Predecessors
    ------------
    get_fix

    Successors
    ----------
    set_pixel, set_rgb

    Warnings
    --------
    set_fix is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    As a side effect set_fix can change colors of "`non-HALCON windows"'.
    """
    with HalconOperator(1292) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, mode)
        proc.execute()


def set_fixed_lut(window_handle: HHandle, mode: str) -> None:
    """
    Fix "`look-up-table"' (lut) for "`real color images"'.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    mode : str
           Mode of fixing.
           Value Suggestion: true

    Predecessors
    ------------
    get_fixed_lut

    Warnings
    --------
    set_fixed_lut is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1294) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, mode)
        proc.execute()


def set_font(window_handle: HHandle, font: str) -> None:
    """
    Set the font used for text output.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    font : str
           Name of new font.

    See Also
    --------
    get_font, query_font, open_window

    Predecessors
    ------------
    open_window

    Successors
    ----------
    query_font

    Notes
    -----
    For different machines the available fonts may differ a lot. Therefore
    it is suggested to use the operator query_font or the procedure
    set_display_font.
    """
    with HalconOperator(1202) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, font)
        proc.execute()


def set_framegrabber_callback(
    acq_handle: HHandle,
    callback_type: str,
    callback_function: int,
    user_context: int
) -> None:
    """
    Register a callback function for an image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    callback_type : str
                    Callback type.
                    Value Suggestion: transfer_end

    callback_function : int
                        Pointer to the callback function to be set.

    user_context : int
                   Pointer to user-specific context data.

    See Also
    --------
    open_framegrabber, get_framegrabber_callback

    Predecessors
    ------------
    open_framegrabber, set_framegrabber_param

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async, get_framegrabber_param

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    set_framegrabber_callback runs in parallel with all non-exclusive
    operators inside and outside of this group.
    """
    with HalconOperator(2028) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, callback_type)
        proc.set_input_tuple(2, callback_function)
        proc.set_input_tuple(3, user_context)
        proc.execute()


def set_framegrabber_lut(
    acq_handle: HHandle,
    image_red: Sequence[int],
    image_green: Sequence[int],
    image_blue: Sequence[int]
) -> None:
    """
    Set look-up table of the image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    image_red : Sequence[int]
                Red level of the LUT entries.

    image_green : Sequence[int]
                  Green level of the LUT entries.

    image_blue : Sequence[int]
                 Blue level of the LUT entries.

    See Also
    --------
    get_framegrabber_lut, open_framegrabber

    Predecessors
    ------------
    open_framegrabber, get_framegrabber_lut

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    set_framegrabber_lut runs in parallel with all non-exclusive operators
    inside and outside of this group.
    """
    with HalconOperator(2039) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, image_red)
        proc.set_input_tuple(2, image_green)
        proc.set_input_tuple(3, image_blue)
        proc.execute()


def set_framegrabber_param(
    acq_handle: HHandle,
    param: MaybeSequence[str],
    value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set specific parameters of an image acquisition device.

    Parameters
    ----------

    acq_handle : HHandle
                 Handle of the acquisition device to be used.

    param : MaybeSequence[str]
            Parameter name.

    value : MaybeSequence[Union[str, float, int]]
            Parameter value to be set.

    See Also
    --------
    open_framegrabber, info_framegrabber, get_framegrabber_param

    Predecessors
    ------------
    open_framegrabber

    Successors
    ----------
    grab_image, grab_data, grab_image_start, grab_image_async,
    grab_data_async, get_framegrabber_param

    Notes
    -----
    For a multithreaded application all image acquisition operators  (as
    listed in open_framegrabber) are an own group in which
    info_framegrabber, open_framegrabber, close_framegrabber and
    close_all_framegrabbers are executed exclusively.
    set_framegrabber_param runs in parallel with all non-exclusive
    operators inside and outside of this group.
    """
    with HalconOperator(2026) as proc:
        proc.set_input_tuple(0, acq_handle)
        proc.set_input_tuple(1, param)
        proc.set_input_tuple(2, value)
        proc.execute()


def set_full_matrix(
    matrix_id: HHandle,
    values: MaybeSequence[Union[int, float]]
) -> None:
    """
    Set all values of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    values : MaybeSequence[Union[int, float]]
             Values to be set.

    See Also
    --------
    get_full_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(891) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, values)
        proc.execute()


def set_fuzzy_measure(
    measure_handle: HHandle,
    set_type: str,
    function: Sequence[Union[float, int]]
) -> None:
    """
    Specify a fuzzy function.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    set_type : str
               Selection of the fuzzy set.
               Value Suggestion: contrast

    function : Sequence[Union[float, int]]
               Fuzzy function.

    See Also
    --------
    reset_fuzzy_measure

    Alternatives
    ------------
    set_fuzzy_measure_norm_pair

    Predecessors
    ------------
    gen_measure_arc, gen_measure_rectangle2, create_funct_1d_pairs,
    transform_funct_1d

    Successors
    ----------
    fuzzy_measure_pos, fuzzy_measure_pairs
    """
    with HalconOperator(831) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, set_type)
        proc.set_input_tuple(2, function)
        proc.execute()


def set_fuzzy_measure_norm_pair(
    measure_handle: HHandle,
    pair_size: Union[float, int],
    set_type: str,
    function: Sequence[Union[float, int]]
) -> None:
    """
    Specify a normalized fuzzy function for edge pairs.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    pair_size : Union[float, int]
                Favored width of edge pairs.
                Value Suggestion: 10.0

    set_type : str
               Selection of the fuzzy set.
               Value Suggestion: size_abs_diff

    function : Sequence[Union[float, int]]
               Fuzzy function.

    See Also
    --------
    reset_fuzzy_measure

    Alternatives
    ------------
    transform_funct_1d, set_fuzzy_measure

    Predecessors
    ------------
    gen_measure_arc, gen_measure_rectangle2, create_funct_1d_pairs

    Successors
    ----------
    fuzzy_measure_pairs, fuzzy_measure_pairing
    """
    with HalconOperator(830) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, pair_size)
        proc.set_input_tuple(2, set_type)
        proc.set_input_tuple(3, function)
        proc.execute()


def set_gray(
    window_handle: HHandle,
    gray_values: MaybeSequence[int]
) -> None:
    """
    Define gray values for region output.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    gray_values : MaybeSequence[int]
                  Gray values for region output.
                  Value Suggestion: 255

    See Also
    --------
    set_color

    Successors
    ----------
    disp_region
    """
    with HalconOperator(1234) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, gray_values)
        proc.execute()


def set_grayval(
    image: HObject,
    row: MaybeSequence[int],
    column: MaybeSequence[int],
    grayval: MaybeSequence[Union[int, float]]
) -> None:
    """
    Set single gray values in an image.

    Parameters
    ----------

    image : HObject
            Image to be modified.

    row : MaybeSequence[int]
          Row coordinates of the pixels to be modified.
          Value Suggestion: 0
          Assertion: 0 <= Row && Row < height(Image)

    column : MaybeSequence[int]
             Column coordinates of the pixels to be modified.
             Value Suggestion: 0
             Assertion: 0 <= Column && Column < width(Image)

    grayval : MaybeSequence[Union[int, float]]
              Gray values to be used.
              Value Suggestion: 255.0

    See Also
    --------
    get_grayval, gen_image_const, gen_image1, gen_image_proto

    Alternatives
    ------------
    get_image_pointer1, paint_gray, paint_region

    Predecessors
    ------------
    read_image, get_image_pointer1, gen_image_proto, gen_image1

    Notes
    -----
    The operator set_grayval produces quite some overhead. Typically, it
    is used to set single gray values of an image. It is not suitable for
    programming image processing operations such as filters. In this case
    it is more useful to use the operator get_image_pointer1 and to
    directly use the C or C++ interface for integrating own procedures.
    Note also that set_grayval modifies the content of an already existing
    image (Image). Besides, even other image objects may be affected: For
    example, if you created Image via copy_obj from another image object,
    set_grayval will also modify the image matrix of this other image
    object. Therefore, set_grayval should only be used to overpaint newly
    created image objects.
    """
    with HalconOperator(574) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, grayval)
        proc.execute()


def set_hsi(
    window_handle: HHandle,
    hue: MaybeSequence[int],
    saturation: MaybeSequence[int],
    intensity: MaybeSequence[int]
) -> None:
    """
    Define output colors (HSI-coded).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    hue : MaybeSequence[int]
          Hue for region output.
          Value Suggestion: 30
          Assertion: 0 <= Hue && Hue <= 255

    saturation : MaybeSequence[int]
                 Saturation for region output.
                 Value Suggestion: 255
                 Assertion: 0 <= Saturation && Saturation <= 255

    intensity : MaybeSequence[int]
                Intensity for region output.
                Value Suggestion: 84
                Assertion: 0 <= Intensity && Intensity <= 255

    See Also
    --------
    get_hsi, trans_from_rgb, trans_to_rgb, disp_region

    Predecessors
    ------------
    get_hsi

    Successors
    ----------
    disp_region

    Notes
    -----
    The colors are internally stored as RGB triples. Some HSI triples can
    not be represented by a valid RGB triple (i.e. in the range 0..255).
    In this case the nearest color which can be represented is used
    instead.
    """
    with HalconOperator(1233) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, hue)
        proc.set_input_tuple(2, saturation)
        proc.set_input_tuple(3, intensity)
        proc.execute()


def set_icon(icon: HObject, window_handle: HHandle) -> None:
    """
    Icon definition for region output.

    Parameters
    ----------

    icon : HObject
           Icon for center of gravity.

    window_handle : HHandle
                    Window handle.

    Predecessors
    ------------
    gen_circle, gen_ellipse, gen_rectangle1, gen_rectangle2, draw_region

    Successors
    ----------
    set_shape, disp_region
    """
    with HalconOperator(1261) as proc:
        proc.set_input_object(1, icon)
        proc.set_input_tuple(0, window_handle)
        proc.execute()


def set_insert(window_handle: HHandle, mode: str) -> None:
    """
    Define the pixel output function.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    mode : str
           Name of the display function.
           Value Suggestion: copy

    See Also
    --------
    get_insert, query_insert

    Predecessors
    ------------
    query_insert, get_insert

    Successors
    ----------
    disp_region

    Warnings
    --------
    set_insert is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1232) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, mode)
        proc.execute()


def set_io_channel_param(
    iochannel_handle: MaybeSequence[HHandle],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[HTupleElementType]
) -> None:
    """
    Set specific parameters of I/O channels.

    Parameters
    ----------

    iochannel_handle : MaybeSequence[HHandle]
                       Handles of the opened I/O channels.

    gen_param_name : Sequence[str]
                     Parameter names.
                     Value Suggestion: []

    gen_param_value : Sequence[HTupleElementType]
                      Parameter values to set.
                      Value Suggestion: []

    See Also
    --------
    open_io_channel, query_io_device, get_io_channel_param,
    read_io_channel, write_io_channel

    Predecessors
    ------------
    open_io_channel

    Successors
    ----------
    read_io_channel, write_io_channel
    """
    with HalconOperator(2013) as proc:
        proc.set_input_tuple(0, iochannel_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_io_device_param(
    iodevice_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Configure a specific I/O device instance.

    Parameters
    ----------

    iodevice_handle : HHandle
                      Handle of the opened I/O device.

    gen_param_name : MaybeSequence[str]
                     Parameter names.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Parameter values to set.
                      Value Suggestion: []

    See Also
    --------
    open_io_device, query_io_interface, get_io_device_param

    Predecessors
    ------------
    open_io_device

    Successors
    ----------
    open_io_channel
    """
    with HalconOperator(2019) as proc:
        proc.set_input_tuple(0, iodevice_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_line_approx(window_handle: HHandle, approximation: int) -> None:
    """
    Define the approximation error for contour display.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    approximation : int
                    Maximum deviation from the original contour.
                    Value Suggestion: 0
                    Assertion: Approximation >= 0

    See Also
    --------
    get_line_approx, set_line_style, set_draw, disp_region, disp_polygon

    Alternatives
    ------------
    get_region_polygon, disp_polygon

    Predecessors
    ------------
    get_line_approx

    Successors
    ----------
    disp_region

    Warnings
    --------
    set_line_approx is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(1231) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, approximation)
        proc.execute()


def set_line_style(window_handle: HHandle, style: Sequence[int]) -> None:
    """
    Define a contour output pattern.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    style : Sequence[int]
            Contour pattern.
            Value Suggestion: []

    See Also
    --------
    get_line_style, set_line_approx, disp_region

    Predecessors
    ------------
    get_line_style

    Successors
    ----------
    disp_region
    """
    with HalconOperator(1230) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, style)
        proc.execute()


def set_line_width(window_handle: HHandle, width: float) -> None:
    """
    Define the line width for region contour output.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    width : float
            Line width for region output in contour mode.
            Value Suggestion: 1.0
            Assertion: Width >= 1.0 && Width <= 2000.0

    See Also
    --------
    get_line_width, query_line_width, set_draw, disp_region

    Predecessors
    ------------
    query_line_width, get_line_width

    Successors
    ----------
    disp_region

    Notes
    -----
    The line width is important if the output mode was set to 'margin'
    (see set_draw). If the line width is greater than one, regions may not
    always be displayed correctly.
    """
    with HalconOperator(1229) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, width)
        proc.execute()


def set_local_deformable_model_metric(
    image: HObject,
    vector_field: HObject,
    model_id: HHandle,
    metric: str
) -> None:
    """
    Set the metric of a local deformable model that was created from XLD
    contours.

    Parameters
    ----------

    image : HObject
            Input image used for the determination of the polarity.

    vector_field : HObject
                   Vector field of the local deformation.

    model_id : HHandle
               Handle of the model.

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    See Also
    --------
    create_local_deformable_model_xld

    Predecessors
    ------------
    create_local_deformable_model_xld, find_local_deformable_model

    Successors
    ----------
    find_local_deformable_model

    Notes
    -----
    set_local_deformable_model_metric can only be used with deformable
    models that were created from XLD contours.
    """
    with HalconOperator(972) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, vector_field)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, metric)
        proc.execute()


def set_lut(
    window_handle: HHandle,
    look_up_table: MaybeSequence[Union[int, str]]
) -> None:
    """
    Set "`look-up-table"' (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    look_up_table : MaybeSequence[Union[int, str]]
                    Name of look-up-table, values of look-up-table (RGB)
                    or file name.
                    Value Suggestion: default

    See Also
    --------
    get_lut, query_lut, set_color, set_rgb, set_hsi, write_lut

    Predecessors
    ------------
    query_lut, get_lut

    Notes
    -----
    set_lut can only be used with monitors supporting 256 gray
    levels/colors.
    """
    with HalconOperator(1290) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, look_up_table)
        proc.execute()


def set_lut_style(
    window_handle: HHandle,
    hue: float,
    saturation: float,
    intensity: float
) -> None:
    """
    Changing the look-up-table (lut).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    hue : float
          Modification of color value.
          Value Suggestion: 0.0
          Assertion: 0.0 >= Hue && Hue <= 1.0

    saturation : float
                 Modification of saturation.
                 Value Suggestion: 1.5
                 Assertion: 0.0 <= Saturation

    intensity : float
                Modification of intensity.
                Value Suggestion: 1.5
                Assertion: 0.0 <= Intensity

    See Also
    --------
    get_lut_style

    Alternatives
    ------------
    set_lut, scale_image

    Predecessors
    ------------
    get_lut_style

    Successors
    ----------
    set_lut

    Warnings
    --------
    set_lut_style is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1288) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, hue)
        proc.set_input_tuple(2, saturation)
        proc.set_input_tuple(3, intensity)
        proc.execute()


def set_message_obj(
    object_data: HObject,
    message_handle: HHandle,
    key: Union[str, int]
) -> None:
    """
    Add a key/object pair to the message.

    Parameters
    ----------

    object_data : HObject
                  Object to be associated with the key.

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    key : Union[str, int]
          Key string or integer.

    See Also
    --------
    create_message, clear_message, set_message_tuple, get_message_tuple,
    get_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Alternatives
    ------------
    set_message_tuple

    Predecessors
    ------------
    create_message

    Successors
    ----------
    enqueue_message, set_message_tuple
    """
    with HalconOperator(537) as proc:
        proc.set_input_object(1, object_data)
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, key)
        proc.execute()


def set_message_param(
    message_handle: HHandle,
    gen_param_name: str,
    key: MaybeSequence[Union[str, int]],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set message parameter or invoke commands on the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    gen_param_name : str
                     Names of the message parameters or action commands.
                     Value Suggestion: remove_key

    key : MaybeSequence[Union[str, int]]
          Message keys the parameter/command should be applied to.

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the message parameters or action commands.

    See Also
    --------
    create_message, clear_message, set_message_tuple, get_message_tuple,
    set_message_obj, get_message_obj, get_message_param, enqueue_message,
    dequeue_message

    Predecessors
    ------------
    dequeue_message, create_message

    Successors
    ----------
    enqueue_message, clear_message
    """
    with HalconOperator(535) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, key)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_message_queue_param(
    queue_handle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set message queue parameters or invoke commands on the queue.

    Parameters
    ----------

    queue_handle : HHandle
                   Message queue handle.
                   Assertion: QueueHandle != 0

    gen_param_name : MaybeSequence[str]
                     Names of the queue parameters or action commands.
                     Value Suggestion: max_message_num

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the queue parameters or action commands.
                      Value Suggestion: 1

    See Also
    --------
    create_message_queue, clear_message_queue, enqueue_message,
    dequeue_message, get_message_queue_param, create_message,
    clear_message, set_message_tuple, get_message_tuple, set_message_obj,
    get_message_obj

    Predecessors
    ------------
    create_message_queue

    Successors
    ----------
    clear_message_queue
    """
    with HalconOperator(529) as proc:
        proc.set_input_tuple(0, queue_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_message_tuple(
    message_handle: HHandle,
    key: Union[str, int],
    tuple_data: Sequence[HTupleElementType]
) -> None:
    """
    Add a key/tuple pair to the message.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    key : Union[str, int]
          Key string or integer.

    tuple_data : Sequence[HTupleElementType]
                 Tuple value to be associated with the key.

    See Also
    --------
    create_message, clear_message, get_message_tuple, set_message_obj,
    get_message_obj, set_message_param, get_message_param,
    enqueue_message, dequeue_message

    Alternatives
    ------------
    set_message_obj

    Predecessors
    ------------
    create_message

    Successors
    ----------
    enqueue_message, set_message_obj

    Notes
    -----
    Note that if the tuple contains any handles (which are treated as
    simple integers) only the handle values are copied by the operation,
    not the resources behind those handles.
    """
    with HalconOperator(539) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, key)
        proc.set_input_tuple(2, tuple_data)
        proc.execute()


def set_metrology_model_image_size(
    metrology_handle: HHandle,
    width: int,
    height: int
) -> None:
    """
    Set the size of the image of metrology objects.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    width : int
            Width of the image to be processed.
            Value Suggestion: 640

    height : int
             Height of the image to be processed.
             Value Suggestion: 480

    Predecessors
    ------------
    create_metrology_model

    Successors
    ----------
    set_metrology_model_param, add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure,
    add_metrology_object_line_measure,
    add_metrology_object_rectangle2_measure, add_metrology_object_generic

    Notes
    -----
    Note that the operator set_metrology_model_image_size should be called
    before adding metrology objects to the metrology model using the
    operators add_metrology_object_generic,
    add_metrology_object_circle_measure,
    add_metrology_object_ellipse_measure,
    add_metrology_object_line_measure, or
    add_metrology_object_rectangle2_measure.  Otherwise, all measure
    regions of existing metrology objects will be recomputed automatically
    upon calling set_metrology_model_image_size or apply_metrology_model.
    """
    with HalconOperator(819) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, width)
        proc.set_input_tuple(2, height)
        proc.execute()


def set_metrology_model_param(
    metrology_handle: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set parameters that are valid for the entire metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    gen_param_name : str
                     Name of the generic parameter.
                     Value Suggestion: camera_param

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Value of the generic parameter.
                      Value Suggestion: []

    See Also
    --------
    set_metrology_object_param, align_metrology_model,
    get_metrology_model_param

    Predecessors
    ------------
    create_metrology_model, set_metrology_model_image_size

    Successors
    ----------
    add_metrology_object_generic, get_metrology_object_model_contour
    """
    with HalconOperator(793) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_metrology_object_fuzzy_param(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int]]
) -> None:
    """
    Set fuzzy parameters or fuzzy functions for a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: fuzzy_thresh

    gen_param_value : Sequence[Union[float, int]]
                      Values of the generic parameters.
                      Value Suggestion: 0.5

    See Also
    --------
    set_metrology_object_param

    Predecessors
    ------------
    get_metrology_object_fuzzy_param

    Successors
    ----------
    apply_metrology_model, reset_metrology_object_fuzzy_param,
    get_metrology_object_fuzzy_param
    """
    with HalconOperator(810) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_metrology_object_param(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float, int]]
) -> None:
    """
    Set parameters for the metrology objects of a metrology model.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: num_instances

    gen_param_value : Sequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: 1

    See Also
    --------
    set_metrology_object_fuzzy_param

    Predecessors
    ------------
    get_metrology_object_param

    Successors
    ----------
    apply_metrology_model, reset_metrology_object_param,
    get_metrology_object_param
    """
    with HalconOperator(811) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_mshape(window_handle: HHandle, cursor: str) -> None:
    """
    Set the current mouse pointer shape.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    cursor : str
             Mouse pointer name.
             Value Suggestion: arrow

    See Also
    --------
    get_mshape, query_mshape

    Predecessors
    ------------
    open_window, query_mshape, get_mshape

    Warnings
    --------
    This operator does not work in an HDevelop graphics window opened with
    dev_open_window.
    """
    with HalconOperator(1277) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, cursor)
        proc.execute()


def set_ncc_model_origin(
    model_id: HHandle,
    row: float,
    column: float
) -> None:
    """
    Set the origin (reference point) of an NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    row : float
          Row coordinate of the origin of the NCC model.

    column : float
             Column coordinate of the origin of the NCC model.

    See Also
    --------
    area_center

    Predecessors
    ------------
    create_ncc_model, read_ncc_model

    Successors
    ----------
    find_ncc_model, get_ncc_model_origin, find_ncc_models
    """
    with HalconOperator(990) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def set_ncc_model_param(
    model_id: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> None:
    """
    Set selected parameters of the NCC model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : Sequence[str]
                     Parameter names.

    gen_param_value : Sequence[Union[float, int, str]]
                      Parameter values.

    Predecessors
    ------------
    create_ncc_model

    Successors
    ----------
    find_ncc_model
    """
    with HalconOperator(992) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_object_model_3d_attrib(
    object_model_3d: HHandle,
    attrib_name: MaybeSequence[str],
    attach_ext_attrib_to: str,
    attrib_values: MaybeSequence[Union[float, int]]
) -> HHandle:
    """
    Set attributes of a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the input 3D object model.

    attrib_name : MaybeSequence[str]
                  Name of the attributes.

    attach_ext_attrib_to : str
                           Defines where extended attributes are attached
                           to.
                           Value Suggestion: []

    attrib_values : MaybeSequence[Union[float, int]]
                    Attribute values.

    Returns
    -------

    object_model_3dout : HHandle
                         Handle of the resulting 3D object model.

    See Also
    --------
    copy_object_model_3d, remove_object_model_3d_attrib

    Alternatives
    ------------
    set_object_model_3d_attrib_mod

    Predecessors
    ------------
    gen_empty_object_model_3d

    Successors
    ----------
    get_object_model_3d_params

    Notes
    -----
    If multiple attributes are given in AttribName, AttribValues is
    divided into sub-tuples of equal length. Each sub-tuple is then
    assigned to one attribute. E.g., if AttribName and AttribValues are
    set to
    AttribName := ['&attrib1','&attrib2','&attrib3'],
    AttribValues := [0.0,1.0,2.0,3.0,4.0,5.0],
    the following values are assigned to the individual attributes:
    '&attrib1' = [0.0,1.0], '&attrib2' = [2.0,3.0], '&attrib3' =
    [4.0,5.0].
    Consequently, it is not possible to set multiple attributes of
    different lengths in one call.
    set_object_model_3d_attrib stores the input AttribValues unmodified in
    the 3D object model. Therefore, special attention must be paid to the
    consistency of the input data, as most of the operators expect
    consistent 3D object models.
    """
    with HalconOperator(1064) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attrib_name)
        proc.set_input_tuple(2, attach_ext_attrib_to)
        proc.set_input_tuple(3, attrib_values)
        proc.init_oct(0)
        proc.execute()
        object_model_3dout = proc.get_output_tuple_s(0)
        return object_model_3dout  # type: ignore


def set_object_model_3d_attrib_mod(
    object_model_3d: HHandle,
    attrib_name: MaybeSequence[str],
    attach_ext_attrib_to: str,
    attrib_values: MaybeSequence[Union[float, int]]
) -> None:
    """
    Set attributes of a 3D object model.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    attrib_name : MaybeSequence[str]
                  Name of the attributes.

    attach_ext_attrib_to : str
                           Defines where extended attributes are attached
                           to.
                           Value Suggestion: []

    attrib_values : MaybeSequence[Union[float, int]]
                    Attribute values.

    See Also
    --------
    copy_object_model_3d, remove_object_model_3d_attrib_mod

    Alternatives
    ------------
    set_object_model_3d_attrib

    Predecessors
    ------------
    gen_empty_object_model_3d

    Successors
    ----------
    get_object_model_3d_params

    Notes
    -----
    If multiple attributes are given in AttribName, AttribValues is
    divided into sub-tuples of equal length. Each sub-tuple is then
    assigned to one attribute. E.g., if AttribName and AttribValues are
    set to
    AttribName := ['&attrib1','&attrib2','&attrib3'],
    AttribValues := [0.0,1.0,2.0,3.0,4.0,5.0],
    the following values are assigned to the individual attributes:
    '&attrib1' = [0.0,1.0], '&attrib2' = [2.0,3.0], '&attrib3' =
    [4.0,5.0].
    Consequently, it is not possible to set multiple attributes of
    different lengths in one call.
    set_object_model_3d_attrib_mod modifies the content of an already
    existing 3D object model.  The operator stores the input AttribValues
    unmodified in the 3D object model. Therefore, special attention must
    be paid to the consistency of the input data, as most of the operators
    expect consistent 3D object models.
    """
    with HalconOperator(1063) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, attrib_name)
        proc.set_input_tuple(2, attach_ext_attrib_to)
        proc.set_input_tuple(3, attrib_values)
        proc.execute()


def set_offset_template(template_id: HHandle, gray_offset: int) -> None:
    """
    Gray value offset for template.

    Parameters
    ----------

    template_id : HHandle
                  Template number.

    gray_offset : int
                  Offset of gray values.
                  Value Suggestion: 0

    Predecessors
    ------------
    create_template, adapt_template, read_template

    Successors
    ----------
    best_match, best_match_mg, best_match_rot, fast_match, fast_match_mg

    Warnings
    --------
    set_offset_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1496) as proc:
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, gray_offset)
        proc.execute()


def set_operator_timeout(
    operator_name: MaybeSequence[str],
    timeout: MaybeSequence[Union[int, float, str]],
    mode: str
) -> None:
    """
    Set a timeout for an operator.

    Parameters
    ----------

    operator_name : MaybeSequence[str]
                    Operator for which the timeout shall be set.

    timeout : MaybeSequence[Union[int, float, str]]
              Timeout in seconds.
              Value Suggestion: 1

    mode : str
           Timeout mode to be set.
           Value Suggestion: cancel

    See Also
    --------
    interrupt_operator, get_current_hthread_id

    Alternatives
    ------------
    interrupt_operator

    Notes
    -----
    Note that not all operators support timeouts. If a given operator
    supports timeouts and which modes are supported is described in the
    execution information section of the reference documentation of the
    corresponding operator.
    Also note that there is no hard guarantee about the granularity of the
    timeout. The granularity can depend on the operator, its input data
    and the speed of the device. It is typically finer than 10 ms.
    """
    with HalconOperator(2129) as proc:
        proc.set_input_tuple(0, operator_name)
        proc.set_input_tuple(1, timeout)
        proc.set_input_tuple(2, mode)
        proc.execute()


def set_origin_pose(
    pose_in: Sequence[Union[int, float]],
    dx: float,
    dy: float,
    dz: float
) -> Sequence[Union[int, float]]:
    """
    Translate the origin of a 3D pose.

    Parameters
    ----------

    pose_in : Sequence[Union[int, float]]
              original 3D pose.

    dx : float
         translation of the origin in x-direction.
         Value Suggestion: 0

    dy : float
         translation of the origin in y-direction.
         Value Suggestion: 0

    dz : float
         translation of the origin in z-direction.
         Value Suggestion: 0

    Returns
    -------

    pose_new_origin : Sequence[Union[int, float]]
                      new 3D pose after applying the translation.

    See Also
    --------
    hom_mat3d_translate_local

    Predecessors
    ------------
    create_pose, hom_mat3d_to_pose, camera_calibration,
    hand_eye_calibration

    Successors
    ----------
    write_pose, pose_to_hom_mat3d, image_points_to_world_plane,
    contour_to_world_plane_xld
    """
    with HalconOperator(1917) as proc:
        proc.set_input_tuple(0, pose_in)
        proc.set_input_tuple(1, dx)
        proc.set_input_tuple(2, dy)
        proc.set_input_tuple(3, dz)
        proc.init_oct(0)
        proc.execute()
        pose_new_origin = proc.get_output_tuple_m(0)
        return pose_new_origin  # type: ignore


def set_paint(
    window_handle: HHandle,
    mode: Sequence[Union[int, str, float]]
) -> None:
    """
    Define the gray value output mode.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    mode : Sequence[Union[int, str, float]]
           Output mode. Additional parameters possible.
           Value Suggestion: default

    See Also
    --------
    get_paint, query_paint, disp_image, set_shape, set_rgb, set_color,
    set_gray, set_window_param, update_window_pose

    Predecessors
    ------------
    query_paint, get_paint

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1228) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, mode)
        proc.execute()


def set_params_class_knn(
    knnhandle: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, float, str]]
) -> None:
    """
    Set parameters for k-NN classification.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the k-NN classifier.
                     Value Suggestion: ['method','k','max_num_classes']

    gen_param_value : Sequence[Union[int, float, str]]
                      Values of the generic parameters that can be
                      adjusted for the k-NN classifier.
                      Value Suggestion: ['classes_distance',5,1]

    See Also
    --------
    create_class_knn, read_class_knn, get_params_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn

    Successors
    ----------
    classify_class_knn
    """
    with HalconOperator(1812) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_part(
    window_handle: HHandle,
    row_1: Union[int, float],
    column_1: Union[int, float],
    row_2: Union[int, float],
    column_2: Union[int, float]
) -> None:
    """
    Modify the displayed image part.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row_1 : Union[int, float]
            Row of the upper left corner of the chosen image part.
            Value Suggestion: 0

    column_1 : Union[int, float]
               Column of the upper left corner of the chosen image part.
               Value Suggestion: 0

    row_2 : Union[int, float]
            Row of the lower right corner of the chosen image part.
            Value Suggestion: -1
            Assertion: Row2 >= Row1 || Row2 == -1 || Row1 == 0 && Row2 == -2

    column_2 : Union[int, float]
               Column of the lower right corner of the chosen image part.
               Value Suggestion: -1
               Assertion: Column2 >= Column1 || Column2 == -1 || Column1 == 0 && Column2 == -2

    See Also
    --------
    get_part, set_part_style, disp_region, disp_image, disp_color

    Alternatives
    ------------
    affine_trans_image

    Predecessors
    ------------
    get_part

    Successors
    ----------
    set_part_style, disp_image, disp_region
    """
    with HalconOperator(1227) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row_1)
        proc.set_input_tuple(2, column_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.execute()


def set_part_style(window_handle: HHandle, style: int) -> None:
    """
    Define an interpolation method for gray value output.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    style : int
            Interpolation method for image output: 0 (fast, low quality)
            to 2 (slow, high quality).
            Value Suggestion: 0

    See Also
    --------
    get_part_style, set_part, disp_image, disp_color

    Alternatives
    ------------
    affine_trans_image

    Predecessors
    ------------
    get_part_style

    Successors
    ----------
    set_part, disp_image, disp_region
    """
    with HalconOperator(1226) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, style)
        proc.execute()


def set_pixel(window_handle: HHandle, pixel: MaybeSequence[int]) -> None:
    """
    Define a color lookup table index.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    pixel : MaybeSequence[int]
            Color lookup table index.
            Value Suggestion: 128

    See Also
    --------
    get_pixel, set_lut, disp_region, disp_image, disp_color

    Alternatives
    ------------
    set_rgb, set_color, set_hsi

    Predecessors
    ------------
    get_pixel

    Successors
    ----------
    disp_image, disp_region

    Warnings
    --------
    set_pixel is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1225) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, pixel)
        proc.execute()


def set_planar_calib_deformable_model_metric(
    image: HObject,
    model_id: HHandle,
    pose: Sequence[Union[float, int]],
    metric: str
) -> None:
    """
    Set the metric of a planar calibrated deformable model that was
    created from XLD contours.

    Parameters
    ----------

    image : HObject
            Input image used for the determination of the polarity.

    model_id : HHandle
               Handle of the model.

    pose : Sequence[Union[float, int]]
           Pose of the model in the image.

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    See Also
    --------
    create_planar_calib_deformable_model_xld

    Predecessors
    ------------
    create_planar_calib_deformable_model_xld,
    find_planar_calib_deformable_model

    Successors
    ----------
    find_planar_calib_deformable_model

    Notes
    -----
    set_planar_calib_deformable_model_metric can only be used with
    deformable models that were created from XLD contours.
    """
    with HalconOperator(973) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, pose)
        proc.set_input_tuple(2, metric)
        proc.execute()


def set_planar_uncalib_deformable_model_metric(
    image: HObject,
    model_id: HHandle,
    hom_mat_2d: Sequence[float],
    metric: str
) -> None:
    """
    Set the metric of a planar uncalibrated deformable model that was
    created from XLD contours.

    Parameters
    ----------

    image : HObject
            Input image used for the determination of the polarity.

    model_id : HHandle
               Handle of the model.

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    See Also
    --------
    create_planar_uncalib_deformable_model_xld

    Predecessors
    ------------
    create_planar_uncalib_deformable_model_xld,
    find_planar_uncalib_deformable_model

    Successors
    ----------
    find_planar_uncalib_deformable_model

    Notes
    -----
    set_planar_uncalib_deformable_model_metric can only be used with
    deformable models that were created from XLD contours.
    """
    with HalconOperator(974) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, hom_mat_2d)
        proc.set_input_tuple(2, metric)
        proc.execute()


def set_profile_sheet_of_light(
    profile_disparity_image: HObject,
    sheet_of_light_model_id: HHandle,
    movement_poses: Sequence[Union[int, float]]
) -> None:
    """
    Set sheet of light profiles by measured disparities.

    Parameters
    ----------

    profile_disparity_image : HObject
                              Disparity image that contains several
                              profiles.

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    movement_poses : Sequence[Union[int, float]]
                     Poses describing the movement of the scene under
                     measurement between the previously processed profile
                     image and the current profile image.

    See Also
    --------
    query_sheet_of_light_params, get_sheet_of_light_param,
    get_sheet_of_light_result, apply_sheet_of_light_calibration

    Successors
    ----------
    get_sheet_of_light_result, get_sheet_of_light_result_object_model_3d
    """
    with HalconOperator(383) as proc:
        proc.set_input_object(1, profile_disparity_image)
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, movement_poses)
        proc.execute()


def set_reference_template(
    template_id: HHandle,
    row: float,
    column: float
) -> None:
    """
    Define reference position for a matching template.

    Parameters
    ----------

    template_id : HHandle
                  Template number.

    row : float
          Reference position of template (row).

    column : float
             Reference position of template (column).

    Predecessors
    ------------
    create_template, create_template_rot, read_template, adapt_template

    Successors
    ----------
    best_match, best_match_mg, best_match_rot, fast_match, fast_match_mg

    Warnings
    --------
    set_reference_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1497) as proc:
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def set_regularization_params_class_mlp(
    mlphandle: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[float, int]]
) -> None:
    """
    Set the regularization parameters of a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : str
                     Name of the regularization parameter to set.
                     Value Suggestion: weight_prior

    gen_param_value : MaybeSequence[Union[float, int]]
                      Value of the regularization parameter.
                      Value Suggestion: 1.0

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    get_regularization_params_class_mlp, train_class_mlp
    """
    with HalconOperator(1881) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_regularization_params_ocr_class_mlp(
    ocrhandle: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[float, int]]
) -> None:
    """
    Set the regularization parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : str
                     Name of the regularization parameter to return.
                     Value Suggestion: weight_prior

    gen_param_value : MaybeSequence[Union[float, int]]
                      Value of the regularization parameter.
                      Value Suggestion: 1.0

    Predecessors
    ------------
    create_ocr_class_mlp

    Successors
    ----------
    get_regularization_params_ocr_class_mlp, trainf_ocr_class_mlp
    """
    with HalconOperator(706) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_rejection_params_class_mlp(
    mlphandle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set the parameters of a rejection class.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: sampling_strategy

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: hyperbox_around_all_classes

    Predecessors
    ------------
    create_class_mlp

    Successors
    ----------
    train_class_mlp
    """
    with HalconOperator(1878) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_rejection_params_ocr_class_mlp(
    ocrhandle: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[str]
) -> None:
    """
    Set the rejection class parameters of an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    gen_param_name : MaybeSequence[str]
                     Name of the general parameter.
                     Value Suggestion: sampling_strategy

    gen_param_value : MaybeSequence[str]
                      Value of the general parameter.
                      Value Suggestion: hyperbox_around_all_classes

    Predecessors
    ------------
    create_ocr_class_mlp, read_ocr_class_mlp

    Successors
    ----------
    trainf_ocr_class_mlp
    """
    with HalconOperator(704) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_rgb(
    window_handle: HHandle,
    red: MaybeSequence[int],
    green: MaybeSequence[int],
    blue: MaybeSequence[int]
) -> None:
    """
    Set the color definition via RGB values.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    red : MaybeSequence[int]
          Red component of the color.
          Value Suggestion: 255
          Assertion: 0 <= Red && Red <= 255

    green : MaybeSequence[int]
            Green component of the color.
            Value Suggestion: 0
            Assertion: 0 <= Green && Green <= 255

    blue : MaybeSequence[int]
           Blue component of the color.
           Value Suggestion: 0
           Assertion: 0 <= Blue && Blue <= 255

    See Also
    --------
    disp_region

    Alternatives
    ------------
    set_hsi, set_color, set_gray

    Successors
    ----------
    disp_image, disp_region

    Notes
    -----
    If a passed is not available, an exception is raised. If
    set_check(::'~color':) set_check(::'color':)} was called before,
    HALCON uses a similar color and suppresses the error.
    """
    with HalconOperator(1224) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, red)
        proc.set_input_tuple(2, green)
        proc.set_input_tuple(3, blue)
        proc.execute()


def set_rgba(
    window_handle: HHandle,
    red: MaybeSequence[int],
    green: MaybeSequence[int],
    blue: MaybeSequence[int],
    alpha: MaybeSequence[int]
) -> None:
    """
    Set the color definition via RGBA values.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    red : MaybeSequence[int]
          Red component of the color.
          Value Suggestion: 255
          Assertion: 0 <= Red && Red <= 255

    green : MaybeSequence[int]
            Green component of the color.
            Value Suggestion: 0
            Assertion: 0 <= Green && Green <= 255

    blue : MaybeSequence[int]
           Blue component of the color.
           Value Suggestion: 0
           Assertion: 0 <= Blue && Blue <= 255

    alpha : MaybeSequence[int]
            Alpha component of the color.
            Value Suggestion: 255
            Assertion: 0 <= Alpha && Alpha <= 255

    Alternatives
    ------------
    set_rgb, set_color

    Successors
    ----------
    disp_obj

    Notes
    -----
    set_rgba depends on the library libcanvas, which might not be
    available on embedded systems.
    """
    with HalconOperator(2096) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, red)
        proc.set_input_tuple(2, green)
        proc.set_input_tuple(3, blue)
        proc.set_input_tuple(4, alpha)
        proc.execute()


def set_sample_identifier_object_info(
    sample_identifier: HHandle,
    object_idx: MaybeSequence[Union[int, str]],
    info_name: str,
    info_value: MaybeSequence[str]
) -> None:
    """
    Define a name or a description for an object of a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    object_idx : MaybeSequence[Union[int, str]]
                 Index of the object for which information is set.

    info_name : str
                Define, for which kind of object information is set.
                Value Suggestion: training_object_name

    info_value : MaybeSequence[str]
                 Information about the object.

    See Also
    --------
    create_sample_identifier, prepare_sample_identifier,
    train_sample_identifier, apply_sample_identifier,
    get_sample_identifier_object_info, set_sample_identifier_param,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    read_sample_identifier, serialize_sample_identifier,
    deserialize_sample_identifier, clear_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_preparation_data,
    add_sample_identifier_training_data
    """
    with HalconOperator(908) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, object_idx)
        proc.set_input_tuple(2, info_name)
        proc.set_input_tuple(3, info_value)
        proc.execute()


def set_sample_identifier_param(
    sample_identifier: HHandle,
    gen_param_name: str,
    gen_param_value: Union[float, int, str]
) -> None:
    """
    Set selected parameters of a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    gen_param_name : str
                     Parameter name.
                     Value Suggestion: rating_method

    gen_param_value : Union[float, int, str]
                      Parameter value.
                      Value Suggestion: score_single

    See Also
    --------
    add_sample_identifier_preparation_data, prepare_sample_identifier,
    add_sample_identifier_training_data, train_sample_identifier,
    apply_sample_identifier, get_sample_identifier_param,
    get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, write_sample_identifier,
    serialize_sample_identifier, deserialize_sample_identifier,
    set_sample_identifier_object_info

    Alternatives
    ------------
    create_sample_identifier

    Predecessors
    ------------
    create_sample_identifier, read_sample_identifier
    """
    with HalconOperator(906) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_scene_3d_camera_pose(
    scene_3d: HHandle,
    camera_index: int,
    pose: MaybeSequence[Union[float, int]]
) -> None:
    """
    Set the pose of a camera in a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    camera_index : int
                   Index of the camera.

    pose : MaybeSequence[Union[float, int]]
           New pose of the camera.

    See Also
    --------
    set_scene_3d_to_world_pose, set_scene_3d_instance_pose

    Predecessors
    ------------
    add_scene_3d_camera
    """
    with HalconOperator(1210) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, camera_index)
        proc.set_input_tuple(2, pose)
        proc.execute()


def set_scene_3d_instance_param(
    scene_3d: HHandle,
    instance_index: MaybeSequence[int],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> None:
    """
    Set parameters of an instance in a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    instance_index : MaybeSequence[int]
                     Index of the instance.

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: color

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters.
                      Value Suggestion: green

    See Also
    --------
    set_scene_3d_param

    Predecessors
    ------------
    add_scene_3d_instance
    """
    with HalconOperator(1209) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, instance_index)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_scene_3d_instance_pose(
    scene_3d: HHandle,
    instance_index: MaybeSequence[int],
    pose: MaybeSequence[Union[float, int]]
) -> None:
    """
    Set the pose of an instance in a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    instance_index : MaybeSequence[int]
                     Index of the instance.

    pose : MaybeSequence[Union[float, int]]
           New pose of the instance.

    See Also
    --------
    set_scene_3d_to_world_pose, set_scene_3d_camera_pose

    Predecessors
    ------------
    add_scene_3d_instance
    """
    with HalconOperator(1208) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, instance_index)
        proc.set_input_tuple(2, pose)
        proc.execute()


def set_scene_3d_label_param(
    scene_3d: HHandle,
    label_index: MaybeSequence[int],
    gen_param_name: str,
    gen_param_value: Sequence[Union[str, int, float]]
) -> None:
    """
    Set parameters of a text label in a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    label_index : MaybeSequence[int]
                  Index of the text label.

    gen_param_name : str
                     Names of the generic parameters.
                     Value Suggestion: 'color'

    gen_param_value : Sequence[Union[str, int, float]]
                      Values of the generic parameters.
                      Value Suggestion: 'red'

    Predecessors
    ------------
    add_scene_3d_label
    """
    with HalconOperator(2042) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, label_index)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_scene_3d_light_param(
    scene_3d: HHandle,
    light_index: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, int, float]]
) -> None:
    """
    Set parameters of a light in a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    light_index : int
                  Index of the light source.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: 'ambient'

    gen_param_value : MaybeSequence[Union[str, int, float]]
                      Values of the generic parameters.
                      Value Suggestion: [0.2,0.2,0.2]

    Predecessors
    ------------
    add_scene_3d_instance
    """
    with HalconOperator(1207) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, light_index)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def set_scene_3d_param(
    scene_3d: HHandle,
    gen_param_name: str,
    gen_param_value: Union[str, int, float]
) -> None:
    """
    Set parameters of a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    gen_param_name : str
                     Names of the generic parameters.
                     Value Suggestion: quality

    gen_param_value : Union[str, int, float]
                      Values of the generic parameters.
                      Value Suggestion: high

    See Also
    --------
    set_scene_3d_instance_param

    Predecessors
    ------------
    create_scene_3d
    """
    with HalconOperator(1206) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_scene_3d_to_world_pose(
    scene_3d: HHandle,
    to_world_pose: MaybeSequence[Union[float, int]]
) -> None:
    """
    Set the pose of a 3D scene.

    Parameters
    ----------

    scene_3d : HHandle
               Handle of the 3D scene.

    to_world_pose : MaybeSequence[Union[float, int]]
                    New pose of the 3D scene.

    See Also
    --------
    set_scene_3d_instance_pose

    Predecessors
    ------------
    create_scene_3d
    """
    with HalconOperator(1205) as proc:
        proc.set_input_tuple(0, scene_3d)
        proc.set_input_tuple(1, to_world_pose)
        proc.execute()


def set_serial_param(
    serial_handle: HHandle,
    baud_rate: Union[int, str],
    data_bits: Union[int, str],
    flow_control: str,
    parity: str,
    stop_bits: Union[int, str],
    total_time_out: Union[int, str],
    inter_char_time_out: Union[int, str]
) -> None:
    """
    Set the parameters of a serial device.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    baud_rate : Union[int, str]
                Speed of the serial interface.
                Value Suggestion: unchanged

    data_bits : Union[int, str]
                Number of data bits of the serial interface.
                Value Suggestion: unchanged

    flow_control : str
                   Type of flow control of the serial interface.
                   Value Suggestion: unchanged

    parity : str
             Parity of the serial interface.
             Value Suggestion: unchanged

    stop_bits : Union[int, str]
                Number of stop bits of the serial interface.
                Value Suggestion: unchanged

    total_time_out : Union[int, str]
                     Total timeout of the serial interface in ms.
                     Value Suggestion: unchanged

    inter_char_time_out : Union[int, str]
                          Inter-character timeout of the serial interface
                          in ms.
                          Value Suggestion: unchanged

    See Also
    --------
    get_serial_param

    Predecessors
    ------------
    open_serial, get_serial_param

    Successors
    ----------
    read_serial, write_serial
    """
    with HalconOperator(311) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.set_input_tuple(1, baud_rate)
        proc.set_input_tuple(2, data_bits)
        proc.set_input_tuple(3, flow_control)
        proc.set_input_tuple(4, parity)
        proc.set_input_tuple(5, stop_bits)
        proc.set_input_tuple(6, total_time_out)
        proc.set_input_tuple(7, inter_char_time_out)
        proc.execute()


def set_shape(window_handle: HHandle, shape: str) -> None:
    """
    Define the region output shape.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    shape : str
            Region output mode.
            Value Suggestion: original

    See Also
    --------
    get_shape, query_shape, disp_region

    Predecessors
    ------------
    set_icon, query_shape, get_shape

    Successors
    ----------
    disp_region

    Notes
    -----
    Caution is advised for gray value output operators with output
    parameter settings that use region output.
    """
    with HalconOperator(1223) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, shape)
        proc.execute()


def set_shape_model_clutter(
    clutter_region: HObject,
    model_id: HHandle,
    hom_mat_2d: Sequence[float],
    clutter_contrast: int,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> None:
    """
    Set the clutter parameters of a shape model.

    Parameters
    ----------

    clutter_region : HObject
                     Region where no clutter should occur.

    model_id : HHandle
               Handle of the model.

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    clutter_contrast : int
                       Minimum contrast of clutter in the search images.
                       Value Suggestion: 128

    gen_param_name : MaybeSequence[str]
                     Parameter names.

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Parameter values.

    See Also
    --------
    set_shape_model_param

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, create_shape_model_xld,
    create_scaled_shape_model_xld, create_aniso_shape_model_xld

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models,
    get_shape_model_clutter
    """
    with HalconOperator(2180) as proc:
        proc.set_input_object(1, clutter_region)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, hom_mat_2d)
        proc.set_input_tuple(2, clutter_contrast)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.execute()


def set_shape_model_metric(
    image: HObject,
    model_id: HHandle,
    hom_mat_2d: Sequence[float],
    metric: str
) -> None:
    """
    Set the metric of a shape model that was created from XLD contours.

    Parameters
    ----------

    image : HObject
            Input image used for the determination of the polarity.

    model_id : HHandle
               Handle of the model.

    hom_mat_2d : Sequence[float]
                 Transformation matrix.

    metric : str
             Match metric.
             Value Suggestion: use_polarity

    See Also
    --------
    create_shape_model_xld, create_scaled_shape_model_xld,
    create_aniso_shape_model_xld

    Predecessors
    ------------
    create_shape_model_xld, create_scaled_shape_model_xld,
    create_aniso_shape_model_xld

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model

    Notes
    -----
    set_shape_model_metric can only be used with shape models that were
    created from XLD contours.
    """
    with HalconOperator(933) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, hom_mat_2d)
        proc.set_input_tuple(2, metric)
        proc.execute()


def set_shape_model_origin(
    model_id: HHandle,
    row: float,
    column: float
) -> None:
    """
    Set the origin (reference point) of a shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    row : float
          Row coordinate of the origin of the shape model.

    column : float
             Column coordinate of the origin of the shape model.

    See Also
    --------
    area_center

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model,
    create_aniso_shape_model, read_shape_model

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model,
    find_shape_models, find_scaled_shape_models, find_aniso_shape_models,
    get_shape_model_origin
    """
    with HalconOperator(926) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def set_shape_model_param(
    model_id: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> None:
    """
    Set selected parameters of the shape model.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    gen_param_name : Sequence[str]
                     Parameter names.

    gen_param_value : Sequence[Union[float, int, str]]
                      Parameter values.

    See Also
    --------
    create_shape_model_xld, create_scaled_shape_model_xld,
    create_aniso_shape_model_xld, set_shape_model_clutter,
    get_shape_model_clutter

    Predecessors
    ------------
    create_shape_model_xld, create_scaled_shape_model_xld,
    create_aniso_shape_model_xld

    Successors
    ----------
    find_shape_model, find_scaled_shape_model, find_aniso_shape_model
    """
    with HalconOperator(934) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_sheet_of_light_param(
    sheet_of_light_model_id: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set selected parameters of the sheet-of-light model.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    gen_param_name : str
                     Name of the model parameter that shall be adjusted
                     for the sheet-of-light model.
                     Value Suggestion: method

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the model parameter that shall be adjusted
                      for the sheet-of-light model.
                      Value Suggestion: center_of_gravity

    See Also
    --------
    query_sheet_of_light_params, get_sheet_of_light_param,
    get_sheet_of_light_result

    Alternatives
    ------------
    create_sheet_of_light_model

    Successors
    ----------
    get_sheet_of_light_param, measure_profile_sheet_of_light,
    apply_sheet_of_light_calibration
    """
    with HalconOperator(385) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_socket_param(
    socket: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[float, int, str]]
) -> None:
    """
    Set a socket parameter.

    Parameters
    ----------

    socket : HHandle
             Socket number.

    gen_param_name : MaybeSequence[str]
                     Name of the socket parameter.

    gen_param_value : MaybeSequence[Union[float, int, str]]
                      Value of the socket parameter.
                      Value Suggestion: on

    See Also
    --------
    get_socket_param

    Predecessors
    ------------
    open_socket_connect, socket_accept_connect

    Successors
    ----------
    send_data, receive_data
    """
    with HalconOperator(336) as proc:
        proc.set_input_tuple(0, socket)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_spy(class_val: str, value: Union[str, int, float]) -> None:
    """
    Control of the HALCON Debugging Tools.

    Parameters
    ----------

    class_val : str
                Control mode
                Value Suggestion: mode

    value : Union[str, int, float]
            State of the control mode to be set.
            Value Suggestion: on

    See Also
    --------
    get_spy, query_spy

    Predecessors
    ------------
    reset_obj_db

    Notes
    -----
    Note that under Windows the output on stdout works only in combination
    with a console application, i.e., you can not use it together with
    HDevelop.
    """
    with HalconOperator(372) as proc:
        proc.set_input_tuple(0, class_val)
        proc.set_input_tuple(1, value)
        proc.execute()


def set_stereo_model_image_pairs(
    stereo_model_id: HHandle,
    from_val: Sequence[int],
    to: Sequence[int]
) -> None:
    """
    Specify image pairs to be used for surface stereo reconstruction.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    from_val : Sequence[int]
               Camera indices for the from cameras in the image pairs.

    to : Sequence[int]
         Camera indices for the to cameras in the  image pairs.

    See Also
    --------
    set_stereo_model_param, get_stereo_model_image_pairs

    Predecessors
    ------------
    create_stereo_model

    Successors
    ----------
    reconstruct_surface_stereo
    """
    with HalconOperator(524) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, from_val)
        proc.set_input_tuple(2, to)
        proc.execute()


def set_stereo_model_param(
    stereo_model_id: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> None:
    """
    Set stereo model parameters.

    Parameters
    ----------

    stereo_model_id : HHandle
                      Handle of the stereo model.

    gen_param_name : MaybeSequence[str]
                     Names of the parameters to be set.

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the parameters to be set.

    See Also
    --------
    get_stereo_model_param, set_stereo_model_image_pairs

    Predecessors
    ------------
    create_stereo_model

    Successors
    ----------
    reconstruct_surface_stereo, reconstruct_points_stereo
    """
    with HalconOperator(526) as proc:
        proc.set_input_tuple(0, stereo_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_structured_light_model_param(
    structured_light_model: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set parameters of a structured light model.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    gen_param_name : MaybeSequence[str]
                     Name of the model parameter to be adjusted.
                     Value Suggestion: min_stripe_width

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      New value of the model parameter.
                      Value Suggestion: 32

    See Also
    --------
    get_structured_light_model_param

    Predecessors
    ------------
    create_structured_light_model
    """
    with HalconOperator(2130) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_sub_matrix(
    matrix_id: HHandle,
    matrix_sub_id: HHandle,
    row: int,
    column: int
) -> None:
    """
    Set a sub-matrix of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    matrix_sub_id : HHandle
                    Matrix handle of the input sub-matrix.

    row : int
          Upper row position of the sub-matrix in the matrix.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : int
             Left column position of the sub-matrix in the matrix.
             Value Suggestion: 0
             Assertion: Column >= 0

    See Also
    --------
    get_sub_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    The conditions 0 <=$- Row $<$ size of matrix Matrix in the row
    direction, Row $+$ size of matrix MatrixSub in the row direction <=$-
    size of matrix Matrix in the row direction, 0 <=$
    arRef{Column} $<$ size of Matrix in the column direction, and Column
    $+$ size of matrix MatrixSub in the columns direction <=$- size of
    Matrix in the column direction must be satisfied.
    """
    with HalconOperator(889) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, matrix_sub_id)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.execute()


def set_surface_model_param(
    surface_model_id: HHandle,
    gen_param_name: str,
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set parameters and properties of a surface model.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    gen_param_name : str
                     Name of the parameter.
                     Value Suggestion: camera_parameter

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Value of the parameter.

    See Also
    --------
    create_surface_model, get_surface_model_param

    Predecessors
    ------------
    create_surface_model, read_surface_model, get_surface_model_param

    Successors
    ----------
    find_surface_model, refine_surface_model_pose, write_surface_model,
    find_surface_model_image, refine_surface_model_pose_image

    Notes
    -----
    Note that in some cases, if this operator encounters an error
    condition while modifying the surface model, such as an out-of-memory
    error, the model might be left in an inconsistent, partly changed
    state. In such cases, it is recommended to clear the surface model and
    to no longer use it.
    This does not apply to error codes due to invalid parameters, which
    are checked before performing any model modification.
    Also note that setting some of the options requires re-generation of
    internal data structures and can take as long as the original
    create_surface_model.
    """
    with HalconOperator(2097) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_system(
    system_parameter: MaybeSequence[str],
    value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set HALCON system parameters.

    Parameters
    ----------

    system_parameter : MaybeSequence[str]
                       Name of the system parameter to be changed.
                       Value Suggestion: init_new_image

    value : MaybeSequence[Union[int, float, str]]
            New value of the system parameter.
            Value Suggestion: true

    See Also
    --------
    get_system, set_check, count_seconds

    Predecessors
    ------------
    reset_obj_db, get_system, set_check

    Notes
    -----
    Note that despite the information under 'Parallelization' concerning
    the multithreading type, not all parameters are reentrant. Operators
    that are followed by '*)' are set exclusively only.
    """
    with HalconOperator(317) as proc:
        proc.set_input_tuple(0, system_parameter)
        proc.set_input_tuple(1, value)
        proc.execute()


def set_text_model_param(
    text_model: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set parameters of a text model.

    Parameters
    ----------

    text_model : HHandle
                 Text model.

    gen_param_name : MaybeSequence[str]
                     Names of the parameters to be set.
                     Value Suggestion: min_contrast

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Values of the parameters to be set.
                      Value Suggestion: 10

    See Also
    --------
    get_text_model_param

    Predecessors
    ------------
    create_text_model_reader

    Successors
    ----------
    find_text
    """
    with HalconOperator(419) as proc:
        proc.set_input_tuple(0, text_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_texture_inspection_model_param(
    texture_inspection_model: HHandle,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Set parameters of a texture inspection model.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    gen_param_name : MaybeSequence[str]
                     Name of the model parameter to be adjusted.
                     Value Suggestion: gen_result_handle

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      New value of the model parameter.
                      Value Suggestion: true

    See Also
    --------
    get_texture_inspection_model_param

    Predecessors
    ------------
    create_texture_inspection_model

    Successors
    ----------
    add_texture_inspection_model_image, train_texture_inspection_model
    """
    with HalconOperator(2098) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def set_tposition(window_handle: HHandle, row: int, column: int) -> None:
    """
    Set the position of the text cursor.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : int
          Row index of text cursor position.
          Value Suggestion: 24

    column : int
             Column index of text cursor position.
             Value Suggestion: 12

    See Also
    --------
    read_string, write_string

    Alternatives
    ------------
    new_line

    Predecessors
    ------------
    open_window

    Successors
    ----------
    write_string, read_string
    """
    with HalconOperator(1192) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def set_tshape(window_handle: HHandle, text_cursor: str) -> None:
    """
    Set the shape of the text cursor.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    text_cursor : str
                  Name of cursor shape.
                  Value Suggestion: invisible

    See Also
    --------
    get_tshape, query_tshape, write_string, read_string

    Predecessors
    ------------
    open_window, query_tshape, get_tshape

    Successors
    ----------
    write_string, read_string

    Warnings
    --------
    set_tshape is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1191) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, text_cursor)
        proc.execute()


def set_value_matrix(
    matrix_id: HHandle,
    row: MaybeSequence[int],
    column: MaybeSequence[int],
    value: MaybeSequence[Union[int, float]]
) -> None:
    """
    Set one or more elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    row : MaybeSequence[int]
          Row numbers of the matrix elements to be modified.
          Value Suggestion: 0
          Assertion: Row >= 0

    column : MaybeSequence[int]
             Column numbers of the matrix elements to be modified.
             Value Suggestion: 0
             Assertion: Column >= 0

    value : MaybeSequence[Union[int, float]]
            Values to be set in the indicated matrix elements.
            Value Suggestion: 0

    See Also
    --------
    get_value_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    clear_matrix
    """
    with HalconOperator(893) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, value)
        proc.execute()


def set_window_attr(
    attribute_name: str,
    attribute_value: Union[str, int]
) -> None:
    """
    Set window characteristics.

    Parameters
    ----------

    attribute_name : str
                     Name of the attribute that should be modified.

    attribute_value : Union[str, int]
                      Value of the attribute that should be set.

    See Also
    --------
    open_window, get_window_attr, set_window_param

    Predecessors
    ------------
    open_window, set_draw, set_color, set_colored, set_line_width

    Notes
    -----
    You have to call set_window_attr before calling open_window.
    """
    with HalconOperator(1176) as proc:
        proc.set_input_tuple(0, attribute_name)
        proc.set_input_tuple(1, attribute_value)
        proc.execute()


def set_window_dc(window_handle: HHandle, winhdc: int) -> None:
    """
    Set the device context of a virtual graphics window (Windows NT).

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    winhdc : int
             device context of WINHWnd.
             Assertion: WINHDC != 0

    See Also
    --------
    new_extern_window, disp_region, disp_image, disp_color, set_lut,
    query_color, set_color, set_rgb, set_hsi, set_pixel, set_gray,
    set_part, set_part_style, query_window_type, get_window_type,
    set_window_type, get_mposition, set_tposition, set_window_extents,
    get_window_extents, set_window_attr, set_check, set_system

    Predecessors
    ------------
    new_extern_window

    Successors
    ----------
    disp_image, disp_region

    Notes
    -----
    The window WindowHandle has to be created with new_extern_window
    beforehand.
    """
    with HalconOperator(1170) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, winhdc)
        proc.execute()


def set_window_extents(
    window_handle: HHandle,
    row: int,
    column: int,
    width: int,
    height: int
) -> None:
    """
    Modify position and size of a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    row : int
          Row index of upper left corner in target position.
          Value Suggestion: 0

    column : int
             Column index of upper left corner in target position.
             Value Suggestion: 0

    width : int
            Width of the window.
            Value Suggestion: 512

    height : int
             Height of the window.
             Value Suggestion: 512

    See Also
    --------
    get_window_extents, open_window

    Predecessors
    ------------
    open_window

    Notes
    -----
    Modifying the size of the window does not automatically redraw the
    window contents. This has to be done by the program by redisplaying
    the desired data.
    """
    with HalconOperator(1174) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.set_input_tuple(3, width)
        proc.set_input_tuple(4, height)
        proc.execute()


def set_window_param(
    window_handle: HHandle,
    param: str,
    value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Set window parameters.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    param : str
            Name of the parameter.
            Value Suggestion: flush

    value : MaybeSequence[Union[str, float, int]]
            Value to be set.
            Value Suggestion: false

    See Also
    --------
    get_window_param, set_window_attr, set_part_style

    Predecessors
    ------------
    open_window

    Successors
    ----------
    disp_image

    Notes
    -----
    The parameters 'anti_aliasing', 'flush', 'graphics_stack',
    'graphics_stack_max_element_num', 'graphics_stack_max_memory_size',
    and 'region_quality' depend on the library libcanvas, which might not
    be available on embedded systems.
    """
    with HalconOperator(1222) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, param)
        proc.set_input_tuple(2, value)
        proc.execute()


def set_window_type(window_type: str) -> None:
    """
    Specify a window type.

    Parameters
    ----------

    window_type : str
                  Name of the window type which has to be set.
                  Value Suggestion: X-Window

    See Also
    --------
    open_window, query_window_type, get_window_type

    Predecessors
    ------------
    open_window
    """
    with HalconOperator(1173) as proc:
        proc.set_input_tuple(0, window_type)
        proc.execute()


def sfs_mod_lr(
    image: HObject,
    slant: Union[float, int],
    tilt: Union[float, int],
    albedo: Union[float, int],
    ambient: Union[float, int]
) -> HObject:
    """
    Reconstruct a surface from a gray value image.

    Parameters
    ----------

    image : HObject
            Shaded input image.

    slant : Union[float, int]
            Angle between the light source and the positive z-axis (in
            degrees).
            Value Suggestion: 45.0

    tilt : Union[float, int]
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).
           Value Suggestion: 45.0

    albedo : Union[float, int]
             Amount of light reflected by the surface.
             Value Suggestion: 1.0
             Assertion: Albedo >= 0.0

    ambient : Union[float, int]
              Amount of ambient light.
              Value Suggestion: 0.0
              Assertion: Ambient >= 0.0

    Returns
    -------

    height : HObject
             Reconstructed height field.

    Predecessors
    ------------
    estimate_al_am, estimate_sl_al_lr, estimate_sl_al_zc,
    estimate_tilt_lr, estimate_tilt_zc, optimize_fft_speed

    Successors
    ----------
    shade_height_field

    Notes
    -----
    sfs_mod_lr assumes that the heights are to be extracted on a lattice
    with step width 1.  If this is not the case, the calculated heights
    must be multiplied with the step width after the call to sfs_mod_lr.
    A Cartesian coordinate system with the origin in the lower left corner
    of the image is used internally. sfs_mod_lr can only handle
    byte-images.
    """
    with HalconOperator(402) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, slant)
        proc.set_input_tuple(1, tilt)
        proc.set_input_tuple(2, albedo)
        proc.set_input_tuple(3, ambient)
        proc.execute()
        height = HObject(proc.get_output_object_key(1))
        return height  # type: ignore


def sfs_orig_lr(
    image: HObject,
    slant: Union[float, int],
    tilt: Union[float, int],
    albedo: Union[float, int],
    ambient: Union[float, int]
) -> HObject:
    """
    Reconstruct a surface from a gray value image.

    Parameters
    ----------

    image : HObject
            Shaded input image.

    slant : Union[float, int]
            Angle between the light source and the positive z-axis (in
            degrees).
            Value Suggestion: 45.0

    tilt : Union[float, int]
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).
           Value Suggestion: 45.0

    albedo : Union[float, int]
             Amount of light reflected by the surface.
             Value Suggestion: 1.0
             Assertion: Albedo >= 0.0

    ambient : Union[float, int]
              Amount of ambient light.
              Value Suggestion: 0.0
              Assertion: Ambient >= 0.0

    Returns
    -------

    height : HObject
             Reconstructed height field.

    Predecessors
    ------------
    estimate_al_am, estimate_sl_al_lr, estimate_sl_al_zc,
    estimate_tilt_lr, estimate_tilt_zc, optimize_fft_speed

    Successors
    ----------
    shade_height_field

    Notes
    -----
    sfs_orig_lr assumes that the heights are to be extracted on a lattice
    with step width 1.  If this is not the case, the calculated heights
    must be multiplied with the step width after the call to sfs_orig_lr.
    A Cartesian coordinate system with the origin in the lower left corner
    of the image is used internally. sfs_orig_lr can only handle
    byte-images.
    """
    with HalconOperator(401) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, slant)
        proc.set_input_tuple(1, tilt)
        proc.set_input_tuple(2, albedo)
        proc.set_input_tuple(3, ambient)
        proc.execute()
        height = HObject(proc.get_output_object_key(1))
        return height  # type: ignore


def sfs_pentland(
    image: HObject,
    slant: Union[float, int],
    tilt: Union[float, int],
    albedo: Union[float, int],
    ambient: Union[float, int]
) -> HObject:
    """
    Reconstruct a surface from a gray value image.

    Parameters
    ----------

    image : HObject
            Shaded input image.

    slant : Union[float, int]
            Angle between the light source and the positive z-axis (in
            degrees).
            Value Suggestion: 45.0

    tilt : Union[float, int]
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).
           Value Suggestion: 45.0

    albedo : Union[float, int]
             Amount of light reflected by the surface.
             Value Suggestion: 1.0
             Assertion: Albedo >= 0.0

    ambient : Union[float, int]
              Amount of ambient light.
              Value Suggestion: 0.0
              Assertion: Ambient >= 0.0

    Returns
    -------

    height : HObject
             Reconstructed height field.

    Predecessors
    ------------
    estimate_al_am, estimate_sl_al_lr, estimate_sl_al_zc,
    estimate_tilt_lr, estimate_tilt_zc, optimize_fft_speed

    Successors
    ----------
    shade_height_field

    Notes
    -----
    sfs_pentland assumes that the heights are to be extracted on a lattice
    with step width 1.  If this is not the case, the calculated heights
    must be multiplied with the step width after the call to sfs_pentland.
    A Cartesian coordinate system with the origin in the lower left corner
    of the image is used internally. sfs_pentland can only handle
    byte-images.
    """
    with HalconOperator(400) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, slant)
        proc.set_input_tuple(1, tilt)
        proc.set_input_tuple(2, albedo)
        proc.set_input_tuple(3, ambient)
        proc.execute()
        height = HObject(proc.get_output_object_key(1))
        return height  # type: ignore


def shade_height_field(
    image_height: HObject,
    slant: Union[float, int],
    tilt: Union[float, int],
    albedo: Union[float, int],
    ambient: Union[float, int],
    shadows: str
) -> HObject:
    """
    Shade a height field.

    Parameters
    ----------

    image_height : HObject
                   Height field to be shaded.

    slant : Union[float, int]
            Angle between the light source and the positive z-axis (in
            degrees).
            Value Suggestion: 0.0

    tilt : Union[float, int]
           Angle between the light source and the x-axis after projection
           into the xy-plane (in degrees).
           Value Suggestion: 0.0

    albedo : Union[float, int]
             Amount of light reflected by the surface.
             Value Suggestion: 1.0
             Assertion: Albedo >= 0.0

    ambient : Union[float, int]
              Amount of ambient light.
              Value Suggestion: 0.0
              Assertion: Ambient >= 0.0

    shadows : str
              Should shadows be calculated?
              Value Suggestion: false

    Returns
    -------

    image_shade : HObject
                  Shaded image.

    Predecessors
    ------------
    sfs_mod_lr, sfs_orig_lr, sfs_pentland, photometric_stereo

    Notes
    -----
    shade_height_field assumes that the heights are given on a lattice
    with step width 1.  If this is not the case, the heights must be
    divided by the step width before the call to shade_height_field.
    Otherwise, the derivatives used internally to compute the orientation
    of the surface will be estimated to steep or too flat.  Example: The
    height field is given on 100*100 points on the square [0,1]*[0,1].
    Then the heights must be divided by 1/100 first.  A Cartesian
    coordinate system with the origin in the lower left corner of the
    image is used internally.
    """
    with HalconOperator(392) as proc:
        proc.set_input_object(1, image_height)
        proc.set_input_tuple(0, slant)
        proc.set_input_tuple(1, tilt)
        proc.set_input_tuple(2, albedo)
        proc.set_input_tuple(3, ambient)
        proc.set_input_tuple(4, shadows)
        proc.execute()
        image_shade = HObject(proc.get_output_object_key(1))
        return image_shade  # type: ignore


def shape_histo_all(
    region: HObject,
    image: HObject,
    feature: str
) -> Tuple[Sequence[Union[int, float]], Sequence[float]]:
    """
    Determine a histogram of features along all threshold values.

    Parameters
    ----------

    region : HObject
             Region in which the features are to be examined.

    image : HObject
            Gray value image.

    feature : str
              Feature to be examined.
              Value Suggestion: connected_components

    Returns
    -------

    absolute_histo : Sequence[Union[int, float]]
                     Absolute distribution of the feature.

    relative_histo : Sequence[float]
                     Relative distribution of the feature.

    See Also
    --------
    compactness, connection, connect_and_holes, convexity, count_obj,
    entropy_gray, gray_histo

    Alternatives
    ------------
    shape_histo_point

    Successors
    ----------
    histo_to_thresh, threshold, gen_region_histo

    Notes
    -----
    The operator shape_histo_all expects a region and exactly one gray
    value image as input.  Because of the power of this operator the
    runtime of shape_histo_all is relatively large!
    Note that the operator shape_histo_all only considers  the given
    Region and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1748) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, feature)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # absolute_histo
            proc.get_output_tuple_m(1)   # relative_histo
        )  # type: ignore


def shape_histo_point(
    region: HObject,
    image: HObject,
    feature: str,
    row: int,
    column: int
) -> Tuple[Sequence[Union[int, float]], Sequence[float]]:
    """
    Determine a histogram of features along all threshold values.

    Parameters
    ----------

    region : HObject
             Region in which the features are to be examined.

    image : HObject
            Gray value image.

    feature : str
              Feature to be examined.
              Value Suggestion: convexity

    row : int
          Row of the pixel which the region must contain.
          Value Suggestion: 256

    column : int
             Column of the pixel which the region must contain.
             Value Suggestion: 256

    Returns
    -------

    absolute_histo : Sequence[Union[int, float]]
                     Absolute distribution of the feature.

    relative_histo : Sequence[float]
                     Relative distribution of the feature.

    See Also
    --------
    connection, connect_and_holes, convexity, compactness

    Alternatives
    ------------
    shape_histo_all

    Predecessors
    ------------
    get_mbutton, area_center

    Successors
    ----------
    histo_to_thresh, threshold, gen_region_histo

    Notes
    -----
    Note that the operator shape_histo_point only considers  the given
    Region and ignores any previously set domain of the input image Image.
    """
    with HalconOperator(1747) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, feature)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # absolute_histo
            proc.get_output_tuple_m(1)   # relative_histo
        )  # type: ignore


def shape_trans(region: HObject, type: str) -> HObject:
    """
    Transform the shape of a region.

    Parameters
    ----------

    region : HObject
             Regions to be transformed.

    type : str
           Type of transformation.
           Value Suggestion: convex

    Returns
    -------

    region_trans : HObject
                   Transformed regions.

    See Also
    --------
    convexity, elliptic_axis, area_center, smallest_rectangle1,
    smallest_rectangle2, inner_rectangle1, set_shape, select_shape,
    inner_circle

    Predecessors
    ------------
    connection, regiongrowing

    Successors
    ----------
    disp_region, regiongrowing_mean, area_center

    Notes
    -----
    If Type = 'outer_circle' is selected it might happen that the
    resulting circular region does not completely cover the input region.
    This is because internally the operators smallest_circle and
    gen_circle are used to compute the outer circle. As described in the
    documentation of smallest_circle, the calculated radius can be too
    small by up to 1/sqrt(2)-0.5$1/2-0.5$ pixels. Additionally, the circle
    that is generated by gen_circle is translated by up to 0.5 pixels in
    both directions, i.e., by up to 1/sqrt(2)$1/2$ pixels. Consequently,
    when adding up both effects, the original region might protrude beyond
    the returned circular region by at most 1 pixel.
    """
    with HalconOperator(508) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, type)
        proc.execute()
        region_trans = HObject(proc.get_output_object_key(1))
        return region_trans  # type: ignore


def shape_trans_xld(xld: HObject, type: str) -> HObject:
    """
    Transform the shape of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be transformed.

    type : str
           Type of transformation.
           Value Suggestion: convex

    Returns
    -------

    xldtrans : HObject
               Transformed contours respectively polygons.

    See Also
    --------
    smallest_circle_xld, smallest_rectangle1_xld, smallest_rectangle2_xld,
    elliptic_axis_xld

    Alternatives
    ------------
    smallest_circle_xld, smallest_rectangle1_xld, smallest_rectangle2_xld,
    elliptic_axis_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld, test_self_intersection_xld
    """
    with HalconOperator(1689) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, type)
        proc.execute()
        xldtrans = HObject(proc.get_output_object_key(1))
        return xldtrans  # type: ignore


def shock_filter(
    image: HObject,
    theta: float,
    iterations: int,
    mode: str,
    sigma: float
) -> HObject:
    """
    Apply a shock filter to an image.

    Parameters
    ----------

    image : HObject
            Input image.

    theta : float
            Time step.
            Value Suggestion: 0.5
            Assertion: 0 < Theta <= 0.7

    iterations : int
                 Number of iterations.
                 Value Suggestion: 10
                 Assertion: Iterations >= 1

    mode : str
           Type of edge detector.
           Value Suggestion: canny

    sigma : float
            Smoothing of edge detector.
            Value Suggestion: 1.0
            Assertion: Theta >= 0

    Returns
    -------

    sharpened_image : HObject
                      Output image.

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1545) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, theta)
        proc.set_input_tuple(1, iterations)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, sigma)
        proc.execute()
        sharpened_image = HObject(proc.get_output_object_key(1))
        return sharpened_image  # type: ignore


def sigma_image(
    image: HObject,
    mask_height: int,
    mask_width: int,
    sigma: int
) -> HObject:
    """
    Non-linear smoothing with the sigma filter.

    Parameters
    ----------

    image : HObject
            Image to be smoothed.

    mask_height : int
                  Height of the mask (number of lines).
                  Value Suggestion: 5
                  Assertion: odd(MaskHeight)

    mask_width : int
                 Width of the mask (number of columns).
                 Value Suggestion: 5
                 Assertion: odd(MaskWidth)

    sigma : int
            Max. deviation to the average.
            Value Suggestion: 3

    Returns
    -------

    image_sigma : HObject
                  Smoothed image.

    See Also
    --------
    smooth_image, binomial_filter, gauss_filter, mean_image

    Alternatives
    ------------
    anisotropic_diffusion, rank_image

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    If even values instead of odd values are given for MaskHeight or
    MaskWidth, the routine uses the next larger odd values instead (this
    way the center of the filter mask is always explicitly determined).
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1408) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_height)
        proc.set_input_tuple(1, mask_width)
        proc.set_input_tuple(2, sigma)
        proc.execute()
        image_sigma = HObject(proc.get_output_object_key(1))
        return image_sigma  # type: ignore


def signal_condition(condition_handle: HHandle) -> None:
    """
    Signal a condition synchronization object.

    Parameters
    ----------

    condition_handle : HHandle
                       Condition synchronization object.

    See Also
    --------
    wait_condition, timed_wait_condition

    Predecessors
    ------------
    create_condition, wait_condition
    """
    with HalconOperator(545) as proc:
        proc.set_input_tuple(0, condition_handle)
        proc.execute()


def signal_event(event_handle: HHandle) -> None:
    """
    Unlock an event synchronization object.

    Parameters
    ----------

    event_handle : HHandle
                   Event synchronization object.

    Predecessors
    ------------
    wait_event

    Successors
    ----------
    wait_event, clear_event
    """
    with HalconOperator(555) as proc:
        proc.set_input_tuple(0, event_handle)
        proc.execute()


def sim_caltab(
    cal_plate_descr: str,
    camera_param: Sequence[Union[int, float, str]],
    cal_plate_pose: Sequence[Union[int, float]],
    gray_background: int,
    gray_plate: int,
    gray_marks: int,
    scale_fac: float
) -> HObject:
    """
    Simulate an image with calibration plate.

    Parameters
    ----------

    cal_plate_descr : str
                      File name of the calibration plate description.
                      Value Suggestion: calplate_320mm.cpd

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    cal_plate_pose : Sequence[Union[int, float]]
                     External camera parameters (3D pose of the
                     calibration plate in camera coordinates).

    gray_background : int
                      Gray value of image background.
                      Value Suggestion: 128
                      Assertion: 0 <= GrayBackground <= 255

    gray_plate : int
                 Gray value of calibration plate.
                 Value Suggestion: 80
                 Assertion: 0 <= GrayPlate <= 255

    gray_marks : int
                 Gray value of calibration marks.
                 Value Suggestion: 224
                 Assertion: 0 <= GrayMarks <= 255

    scale_fac : float
                Scaling factor to reduce oversampling.
                Value Suggestion: 1.0
                Assertion: 1.0 >= ScaleFac

    Returns
    -------

    sim_image : HObject
                Simulated calibration image.

    See Also
    --------
    find_caltab, find_marks_and_pose, camera_calibration, disp_caltab,
    create_pose, hom_mat3d_to_pose, project_3d_point, gen_caltab

    Predecessors
    ------------
    camera_calibration, find_marks_and_pose, read_pose, read_cam_par,
    hom_mat3d_to_pose

    Successors
    ----------
    find_caltab
    """
    with HalconOperator(1944) as proc:
        proc.set_input_tuple(0, cal_plate_descr)
        proc.set_input_tuple(1, camera_param)
        proc.set_input_tuple(2, cal_plate_pose)
        proc.set_input_tuple(3, gray_background)
        proc.set_input_tuple(4, gray_plate)
        proc.set_input_tuple(5, gray_marks)
        proc.set_input_tuple(6, scale_fac)
        proc.execute()
        sim_image = HObject(proc.get_output_object_key(1))
        return sim_image  # type: ignore


def simplify_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    amount: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float]]
) -> Sequence[HHandle]:
    """
    Simplify a triangulated 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model that should be
                      simplified.

    method : str
             Method that should be used for simplification.
             Value Suggestion: 'preserve_point_coordinates'

    amount : Union[int, float]
             Degree of simplification (default: percentage of remaining
             model points).

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    simplified_object_model_3d : Sequence[HHandle]
                                 Handle of the simplified 3D object model.

    Alternatives
    ------------
    sample_object_model_3d, smooth_object_model_3d

    Predecessors
    ------------
    prepare_object_model_3d, read_object_model_3d,
    triangulate_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    disp_object_model_3d, smallest_bounding_box_object_model_3d
    """
    with HalconOperator(1060) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, amount)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        simplified_object_model_3d = proc.get_output_tuple_m(0)
        return simplified_object_model_3d  # type: ignore


def simplify_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    amount: Union[int, float],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, float]]
) -> HHandle:
    """
    Simplify a triangulated 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model that should be
                      simplified.

    method : str
             Method that should be used for simplification.
             Value Suggestion: 'preserve_point_coordinates'

    amount : Union[int, float]
             Degree of simplification (default: percentage of remaining
             model points).

    gen_param_name : Sequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, float]]
                      Values of the generic parameters.
                      Value Suggestion: []

    Returns
    -------

    simplified_object_model_3d : HHandle
                                 Handle of the simplified 3D object model.

    Alternatives
    ------------
    sample_object_model_3d, smooth_object_model_3d

    Predecessors
    ------------
    prepare_object_model_3d, read_object_model_3d,
    triangulate_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    disp_object_model_3d, smallest_bounding_box_object_model_3d
    """
    with HalconOperator(1060) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, amount)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        simplified_object_model_3d = proc.get_output_tuple_s(0)
        return simplified_object_model_3d  # type: ignore


def simulate_defocus(image: HObject, blurring: float) -> HObject:
    """
    Simulate an uniform out-of-focus blurring of an image.

    Parameters
    ----------

    image : HObject
            Image to blur.

    blurring : float
               Degree of blurring.
               Value Suggestion: 5.0

    Returns
    -------

    defocused_image : HObject
                      Blurred image.

    See Also
    --------
    gen_psf_defocus, simulate_motion, gen_psf_motion

    Predecessors
    ------------
    gen_psf_defocus, simulate_motion, gen_psf_motion

    Successors
    ----------
    wiener_filter, wiener_filter_ni
    """
    with HalconOperator(80) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, blurring)
        proc.execute()
        defocused_image = HObject(proc.get_output_object_key(1))
        return defocused_image  # type: ignore


def simulate_motion(
    image: HObject,
    blurring: float,
    angle: int,
    type: int
) -> HObject:
    """
    Simulation of (linearly) motion blur.

    Parameters
    ----------

    image : HObject
            image to be blurred.

    blurring : float
               extent of blurring.
               Value Suggestion: 20.0

    angle : int
            Angle between direction of motion and x-axis (anticlockwise).
            Value Suggestion: 0

    type : int
           impulse response of motion blur.
           Value Suggestion: 3

    Returns
    -------

    moved_image : HObject
                  motion blurred image.

    See Also
    --------
    gen_psf_motion, simulate_defocus, gen_psf_defocus

    Predecessors
    ------------
    gen_psf_motion, gen_psf_motion

    Successors
    ----------
    simulate_defocus, wiener_filter, wiener_filter_ni
    """
    with HalconOperator(78) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, blurring)
        proc.set_input_tuple(1, angle)
        proc.set_input_tuple(2, type)
        proc.execute()
        moved_image = HObject(proc.get_output_object_key(1))
        return moved_image  # type: ignore


def sin_image(image: HObject) -> HObject:
    """
    Calculate the sine of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    sin_image : HObject
                Output image.

    See Also
    --------
    cos_image, tan_image, asin_image, acos_image, atan_image, atan2_image

    Notes
    -----
    sin_image can be executed on OpenCL devices.
    """
    with HalconOperator(1603) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        sin_image = HObject(proc.get_output_object_key(1))
        return sin_image  # type: ignore


def skeleton(region: HObject) -> HObject:
    """
    Compute the skeleton of a region.

    Parameters
    ----------

    region : HObject
             Region to be thinned.

    Returns
    -------

    skeleton : HObject
               Resulting skeleton.

    See Also
    --------
    gray_skeleton, sobel_amp, edges_image, roberts, bandpass_image,
    threshold

    Alternatives
    ------------
    morph_skeleton, thinning

    Predecessors
    ------------
    sobel_amp, edges_image, bandpass_image, threshold, hysteresis_threshold

    Successors
    ----------
    junctions_skeleton, pruning
    """
    with HalconOperator(486) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        skeleton = HObject(proc.get_output_object_key(1))
        return skeleton  # type: ignore


def slide_image(
    window_handle_source_1: HHandle,
    window_handle_source_2: HHandle,
    window_handle: HHandle
) -> None:
    """
    Interactive output from two window buffers.

    Parameters
    ----------

    window_handle_source_1 : HHandle
                             Source window handle of the "`upper window"'.

    window_handle_source_2 : HHandle
                             Source window handle of the "`lower window"'.

    window_handle : HHandle
                    Output window handle.

    See Also
    --------
    open_window, move_rectangle

    Alternatives
    ------------
    copy_rectangle, get_mposition

    Predecessors
    ------------
    open_window

    Warnings
    --------
    The operator slide_image does not work with HDevelop graphics windows.
    It is only provided for reasons of backward compatibility.

    Notes
    -----
    The three windows must have the same size and have to reside on the
    same computer.
    """
    with HalconOperator(1172) as proc:
        proc.set_input_tuple(0, window_handle_source_1)
        proc.set_input_tuple(1, window_handle_source_2)
        proc.set_input_tuple(2, window_handle)
        proc.execute()


def smallest_bounding_box_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    type: str
) -> Tuple[Sequence[Union[int, float]], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Calculate the smallest bounding box around the points of a 3D object
    model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    type : str
           The method that is used to estimate the smallest box.
           Value Suggestion: 'oriented'

    Returns
    -------

    pose : Sequence[Union[int, float]]
           The pose that describes the position and orientation of the box
           that is generated. The pose has its origin in the center of the
           box and is oriented such that the x-axis is aligned with the
           longest side of the box.

    length_1 : Sequence[float]
               The length of the longest side of the box.

    length_2 : Sequence[float]
               The length of the second longest side of the box.

    length_3 : Sequence[float]
               The length of the third longest side of the box.

    See Also
    --------
    smallest_sphere_object_model_3d

    Predecessors
    ------------
    connection_object_model_3d, simplify_object_model_3d

    Successors
    ----------
    gen_box_object_model_3d
    """
    with HalconOperator(1075) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1),  # length_1
            proc.get_output_tuple_m(2),  # length_2
            proc.get_output_tuple_m(3)   # length_3
        )  # type: ignore


def smallest_bounding_box_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    type: str
) -> Tuple[Sequence[Union[int, float]], float, float, float]:
    """
    Calculate the smallest bounding box around the points of a 3D object
    model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    type : str
           The method that is used to estimate the smallest box.
           Value Suggestion: 'oriented'

    Returns
    -------

    pose : Sequence[Union[int, float]]
           The pose that describes the position and orientation of the box
           that is generated. The pose has its origin in the center of the
           box and is oriented such that the x-axis is aligned with the
           longest side of the box.

    length_1 : float
               The length of the longest side of the box.

    length_2 : float
               The length of the second longest side of the box.

    length_3 : float
               The length of the third longest side of the box.

    See Also
    --------
    smallest_sphere_object_model_3d

    Predecessors
    ------------
    connection_object_model_3d, simplify_object_model_3d

    Successors
    ----------
    gen_box_object_model_3d
    """
    with HalconOperator(1075) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_s(1),  # length_1
            proc.get_output_tuple_s(2),  # length_2
            proc.get_output_tuple_s(3)   # length_3
        )  # type: ignore


def smallest_circle(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Smallest surrounding circle of a region.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row : Sequence[float]
          Line index of the center.

    column : Sequence[float]
             Column index of the center.

    radius : Sequence[float]
             Radius of the surrounding circle.
             Assertion: Radius >= 0

    See Also
    --------
    set_shape, select_shape, inner_circle

    Alternatives
    ------------
    elliptic_axis, smallest_rectangle1, smallest_rectangle2

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    gen_circle, disp_circle

    Notes
    -----
    Internally, the calculation is based on the center coordinates of the
    region pixels. To take into account that pixels are not just
    infinitely small points but have a certain area, the calculated radius
    is enlarged by 0.5 before it is returned in Radius. This, in most
    cases, gives acceptable results. However, in the worst case (pixel
    diagonal) this enlargement is not sufficient. If one wants to ensure
    that the border of the input region completely lies within the circle,
    one had to enlarge the radius by 1/sqrt(2)$1/2$ instead of 0.5.
    Consequently, the value returned in Radius must be corrected by
    1/sqrt(2)-0.5$1/2-0.5$. However, this would also be only an upper
    bound, i.e., the circle with the corrected radius would be slightly
    too big in most cases.
    Figure{smallest_circle-result} The smallest surrounding circle of a
    region. Note that the calculation is based on the center coordinates
    of the region pixels and that 0.5 is added to the resulting radius.
    Figure
    """
    with HalconOperator(1700) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2)   # radius
        )  # type: ignore


def smallest_circle_s(regions: HObject) -> Tuple[float, float, float]:
    """
    Smallest surrounding circle of a region.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row : float
          Line index of the center.

    column : float
             Column index of the center.

    radius : float
             Radius of the surrounding circle.
             Assertion: Radius >= 0

    See Also
    --------
    set_shape, select_shape, inner_circle

    Alternatives
    ------------
    elliptic_axis, smallest_rectangle1, smallest_rectangle2

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    gen_circle, disp_circle

    Notes
    -----
    Internally, the calculation is based on the center coordinates of the
    region pixels. To take into account that pixels are not just
    infinitely small points but have a certain area, the calculated radius
    is enlarged by 0.5 before it is returned in Radius. This, in most
    cases, gives acceptable results. However, in the worst case (pixel
    diagonal) this enlargement is not sufficient. If one wants to ensure
    that the border of the input region completely lies within the circle,
    one had to enlarge the radius by 1/sqrt(2)$1/2$ instead of 0.5.
    Consequently, the value returned in Radius must be corrected by
    1/sqrt(2)-0.5$1/2-0.5$. However, this would also be only an upper
    bound, i.e., the circle with the corrected radius would be slightly
    too big in most cases.
    Figure{smallest_circle-result} The smallest surrounding circle of a
    region. Note that the calculation is based on the center coordinates
    of the region pixels and that 0.5 is added to the resulting radius.
    Figure
    """
    with HalconOperator(1700) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # radius
        )  # type: ignore


def smallest_circle_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """
    Smallest enclosing circle of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the center of the enclosing circle.

    column : Sequence[float]
             Column coordinate of the center of the enclosing circle.

    radius : Sequence[float]
             Radius of the enclosing circle.
             Assertion: Radius >= 0

    See Also
    --------
    elliptic_axis_xld, smallest_rectangle1_xld, smallest_rectangle2_xld,
    shape_trans_xld

    Alternatives
    ------------
    smallest_rectangle1_xld, smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_ellipse_contour_xld
    """
    with HalconOperator(1688) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2)   # radius
        )  # type: ignore


def smallest_circle_xld_s(xld: HObject) -> Tuple[float, float, float]:
    """
    Smallest enclosing circle of contours or polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row : float
          Row coordinate of the center of the enclosing circle.

    column : float
             Column coordinate of the center of the enclosing circle.

    radius : float
             Radius of the enclosing circle.
             Assertion: Radius >= 0

    See Also
    --------
    elliptic_axis_xld, smallest_rectangle1_xld, smallest_rectangle2_xld,
    shape_trans_xld

    Alternatives
    ------------
    smallest_rectangle1_xld, smallest_rectangle2_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_ellipse_contour_xld
    """
    with HalconOperator(1688) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2)   # radius
        )  # type: ignore


def smallest_rectangle1(
    regions: HObject
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Surrounding rectangle parallel to the coordinate axes.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row_1 : Sequence[int]
            Line index of upper left corner point.

    column_1 : Sequence[int]
               Column index of upper left corner point.

    row_2 : Sequence[int]
            Line index of lower right corner point.

    column_2 : Sequence[int]
               Column index of lower right corner point.

    See Also
    --------
    select_shape

    Alternatives
    ------------
    height_width_ratio, smallest_rectangle2, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    disp_rectangle1, gen_rectangle1

    Notes
    -----
    In case of empty region the result of Row1,Column1, Row2 and Column2
    (all are 0) can lead to confusion.
    """
    with HalconOperator(1699) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_1
            proc.get_output_tuple_m(1),  # column_1
            proc.get_output_tuple_m(2),  # row_2
            proc.get_output_tuple_m(3)   # column_2
        )  # type: ignore


def smallest_rectangle1_s(regions: HObject) -> Tuple[int, int, int, int]:
    """
    Surrounding rectangle parallel to the coordinate axes.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row_1 : int
            Line index of upper left corner point.

    column_1 : int
               Column index of upper left corner point.

    row_2 : int
            Line index of lower right corner point.

    column_2 : int
               Column index of lower right corner point.

    See Also
    --------
    select_shape

    Alternatives
    ------------
    height_width_ratio, smallest_rectangle2, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    disp_rectangle1, gen_rectangle1

    Notes
    -----
    In case of empty region the result of Row1,Column1, Row2 and Column2
    (all are 0) can lead to confusion.
    """
    with HalconOperator(1699) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def smallest_rectangle1_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Enclosing rectangle parallel to the coordinate axes of contours or
    polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row_1 : Sequence[float]
            Row coordinate of upper left corner point of the enclosing
            rectangle.

    column_1 : Sequence[float]
               Column coordinate of upper left corner point of the
               enclosing rectangle.

    row_2 : Sequence[float]
            Row coordinate of lower right corner point of the enclosing
            rectangle.

    column_2 : Sequence[float]
               Column coordinate of lower right corner point of the
               enclosing rectangle.

    See Also
    --------
    shape_trans_xld, smallest_rectangle2_xld, smallest_circle_xld,
    elliptic_axis_xld, area_center_xld

    Alternatives
    ------------
    height_width_ratio_xld, smallest_rectangle2_xld, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    In case of empty contours the result of Row1,Column1, Row2 and Column2
    (all are 0) can lead to confusion.
    """
    with HalconOperator(1687) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row_1
            proc.get_output_tuple_m(1),  # column_1
            proc.get_output_tuple_m(2),  # row_2
            proc.get_output_tuple_m(3)   # column_2
        )  # type: ignore


def smallest_rectangle1_xld_s(
    xld: HObject
) -> Tuple[float, float, float, float]:
    """
    Enclosing rectangle parallel to the coordinate axes of contours or
    polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row_1 : float
            Row coordinate of upper left corner point of the enclosing
            rectangle.

    column_1 : float
               Column coordinate of upper left corner point of the
               enclosing rectangle.

    row_2 : float
            Row coordinate of lower right corner point of the enclosing
            rectangle.

    column_2 : float
               Column coordinate of lower right corner point of the
               enclosing rectangle.

    See Also
    --------
    shape_trans_xld, smallest_rectangle2_xld, smallest_circle_xld,
    elliptic_axis_xld, area_center_xld

    Alternatives
    ------------
    height_width_ratio_xld, smallest_rectangle2_xld, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_polygons_xld

    Notes
    -----
    In case of empty contours the result of Row1,Column1, Row2 and Column2
    (all are 0) can lead to confusion.
    """
    with HalconOperator(1687) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row_1
            proc.get_output_tuple_s(1),  # column_1
            proc.get_output_tuple_s(2),  # row_2
            proc.get_output_tuple_s(3)   # column_2
        )  # type: ignore


def smallest_rectangle2(
    regions: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Smallest surrounding rectangle with any orientation.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row : Sequence[float]
          Line index of the center.

    column : Sequence[float]
             Column index of the center.

    phi : Sequence[float]
          Orientation of the surrounding rectangle (arc measure)
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : Sequence[float]
               First radius (half length) of the surrounding rectangle.
               Assertion: Length1 >= 0.0

    length_2 : Sequence[float]
               Second radius (half width) of the surrounding rectangle.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    See Also
    --------
    smallest_circle, set_shape

    Alternatives
    ------------
    elliptic_axis, smallest_rectangle1

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    disp_rectangle2, gen_rectangle2
    """
    with HalconOperator(1698) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # phi
            proc.get_output_tuple_m(3),  # length_1
            proc.get_output_tuple_m(4)   # length_2
        )  # type: ignore


def smallest_rectangle2_s(
    regions: HObject
) -> Tuple[float, float, float, float, float]:
    """
    Smallest surrounding rectangle with any orientation.

    Parameters
    ----------

    regions : HObject
              Regions to be examined.

    Returns
    -------

    row : float
          Line index of the center.

    column : float
             Column index of the center.

    phi : float
          Orientation of the surrounding rectangle (arc measure)
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : float
               First radius (half length) of the surrounding rectangle.
               Assertion: Length1 >= 0.0

    length_2 : float
               Second radius (half width) of the surrounding rectangle.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    See Also
    --------
    smallest_circle, set_shape

    Alternatives
    ------------
    elliptic_axis, smallest_rectangle1

    Predecessors
    ------------
    threshold, regiongrowing, connection, runlength_features

    Successors
    ----------
    disp_rectangle2, gen_rectangle2
    """
    with HalconOperator(1698) as proc:
        proc.set_input_object(1, regions)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # length_1
            proc.get_output_tuple_s(4)   # length_2
        )  # type: ignore


def smallest_rectangle2_xld(
    xld: HObject
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Smallest enclosing rectangle with arbitrary orientation of contours or
    polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row : Sequence[float]
          Row coordinate of the center point of the enclosing rectangle.

    column : Sequence[float]
             Column coordinate of the center point of the enclosing
             rectangle.

    phi : Sequence[float]
          Orientation of the enclosing rectangle (arc measure)
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : Sequence[float]
               First radius (half length) of the enclosing rectangle.
               Assertion: Length1 >= 0.0

    length_2 : Sequence[float]
               Second radius (half width) of the enclosing rectangle.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    See Also
    --------
    smallest_rectangle1, smallest_circle, elliptic_axis_xld

    Alternatives
    ------------
    smallest_rectangle1, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_polygons_xld
    """
    with HalconOperator(1686) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # row
            proc.get_output_tuple_m(1),  # column
            proc.get_output_tuple_m(2),  # phi
            proc.get_output_tuple_m(3),  # length_1
            proc.get_output_tuple_m(4)   # length_2
        )  # type: ignore


def smallest_rectangle2_xld_s(
    xld: HObject
) -> Tuple[float, float, float, float, float]:
    """
    Smallest enclosing rectangle with arbitrary orientation of contours or
    polygons.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be examined.

    Returns
    -------

    row : float
          Row coordinate of the center point of the enclosing rectangle.

    column : float
             Column coordinate of the center point of the enclosing
             rectangle.

    phi : float
          Orientation of the enclosing rectangle (arc measure)
          Assertion: - pi / 2 < Phi && Phi <= pi / 2

    length_1 : float
               First radius (half length) of the enclosing rectangle.
               Assertion: Length1 >= 0.0

    length_2 : float
               Second radius (half width) of the enclosing rectangle.
               Assertion: Length2 >= 0.0 && Length2 <= Length1

    See Also
    --------
    smallest_rectangle1, smallest_circle, elliptic_axis_xld

    Alternatives
    ------------
    smallest_rectangle1, shape_trans_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, edges_sub_pix, threshold_sub_pix,
    gen_contour_polygon_xld

    Successors
    ----------
    gen_polygons_xld
    """
    with HalconOperator(1686) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # row
            proc.get_output_tuple_s(1),  # column
            proc.get_output_tuple_s(2),  # phi
            proc.get_output_tuple_s(3),  # length_1
            proc.get_output_tuple_s(4)   # length_2
        )  # type: ignore


def smallest_sphere_object_model_3d(
    object_model_3d: MaybeSequence[HHandle]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Calculate the smallest sphere around the points of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    center_point : Sequence[float]
                   x-, y-, and z-coordinates describing the center point
                   of the sphere.

    radius : Sequence[float]
             The estimated radius of the sphere.

    See Also
    --------
    smallest_bounding_box_object_model_3d

    Predecessors
    ------------
    connection_object_model_3d

    Successors
    ----------
    gen_sphere_object_model_3d
    """
    with HalconOperator(1076) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # center_point
            proc.get_output_tuple_m(1)   # radius
        )  # type: ignore


def smallest_sphere_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle]
) -> Tuple[Sequence[float], float]:
    """
    Calculate the smallest sphere around the points of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    Returns
    -------

    center_point : Sequence[float]
                   x-, y-, and z-coordinates describing the center point
                   of the sphere.

    radius : float
             The estimated radius of the sphere.

    See Also
    --------
    smallest_bounding_box_object_model_3d

    Predecessors
    ------------
    connection_object_model_3d

    Successors
    ----------
    gen_sphere_object_model_3d
    """
    with HalconOperator(1076) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # center_point
            proc.get_output_tuple_s(1)   # radius
        )  # type: ignore


def smooth_contours_xld(
    contours: HObject,
    num_regr_points: int
) -> HObject:
    """
    Smooth an XLD contour.

    Parameters
    ----------

    contours : HObject
               Contour to be smoothed.

    num_regr_points : int
                      Number of points used to calculate the regression
                      line.
                      Value Suggestion: 5
                      Assertion: NumRegrPoints >= 3 && odd(NumRegrPoints)

    Returns
    -------

    smoothed_contours : HObject
                        Smoothed contour.

    See Also
    --------
    get_contour_xld

    Predecessors
    ------------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Successors
    ----------
    affine_trans_contour_xld, gen_polygons_xld, local_max_contours_xld
    """
    with HalconOperator(63) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, num_regr_points)
        proc.execute()
        smoothed_contours = HObject(proc.get_output_object_key(1))
        return smoothed_contours  # type: ignore


def smooth_funct_1d_gauss(
    function: Sequence[Union[float, int]],
    sigma: float
) -> Sequence[Union[float, int]]:
    """
    Smooth an equidistant 1D function with a Gaussian function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Function to be smoothed.

    sigma : float
            Sigma of the Gaussian function for the smoothing.
            Value Suggestion: 2.0

    Returns
    -------

    smoothed_function : Sequence[Union[float, int]]
                        Smoothed function.

    Alternatives
    ------------
    smooth_funct_1d_mean

    Predecessors
    ------------
    create_funct_1d_array, sample_funct_1d

    Successors
    ----------
    match_funct_1d_trans, distance_funct_1d
    """
    with HalconOperator(1395) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, sigma)
        proc.init_oct(0)
        proc.execute()
        smoothed_function = proc.get_output_tuple_m(0)
        return smoothed_function  # type: ignore


def smooth_funct_1d_mean(
    function: Sequence[Union[float, int]],
    smooth_size: int,
    iterations: int
) -> Sequence[Union[float, int]]:
    """
    Smooth an equidistant 1D function by averaging its values.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               1D function.

    smooth_size : int
                  Size of the averaging mask.
                  Value Suggestion: 9
                  Assertion: SmoothSize > 0

    iterations : int
                 Number of iterations for the smoothing.
                 Value Suggestion: 3
                 Assertion: Iterations >= 1

    Returns
    -------

    smoothed_function : Sequence[Union[float, int]]
                        Smoothed function.

    Alternatives
    ------------
    smooth_funct_1d_gauss

    Predecessors
    ------------
    create_funct_1d_array, sample_funct_1d

    Notes
    -----
    If an even value instead of an odd value is given for SmoothSize, the
    routine uses the next larger odd value instead (this way the center of
    the filter mask is always explicitly determined).
    """
    with HalconOperator(1401) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, smooth_size)
        proc.set_input_tuple(2, iterations)
        proc.init_oct(0)
        proc.execute()
        smoothed_function = proc.get_output_tuple_m(0)
        return smoothed_function  # type: ignore


def smooth_image(image: HObject, filter: str, alpha: float) -> HObject:
    """
    Smooth an image using various filters.

    Parameters
    ----------

    image : HObject
            Image to be smoothed.

    filter : str
             Filter.
             Value Suggestion: deriche2

    alpha : float
            Filter parameter: small values cause strong smoothing (vice
            versa by using 'gauss').
            Value Suggestion: 0.5
            Assertion: Alpha > 0

    Returns
    -------

    image_smooth : HObject
                   Smoothed image.

    See Also
    --------
    info_smooth, median_image, sigma_image, anisotropic_diffusion

    Alternatives
    ------------
    binomial_filter, gauss_filter, mean_image, derivate_gauss,
    isotropic_diffusion

    Predecessors
    ------------
    read_image

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1407) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter)
        proc.set_input_tuple(1, alpha)
        proc.execute()
        image_smooth = HObject(proc.get_output_object_key(1))
        return image_smooth  # type: ignore


def smooth_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> Sequence[HHandle]:
    """
    Smooth the 3D points of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model containing 3D point
                      data.

    method : str
             Smoothing method.
             Value Suggestion: mls

    gen_param_name : Sequence[str]
                     Names of generic smoothing parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of generic smoothing parameters.
                      Value Suggestion: []

    Returns
    -------

    smooth_object_model_3d : Sequence[HHandle]
                             Handle of the 3D object model with the
                             smoothed 3D point data.

    Alternatives
    ------------
    surface_normals_object_model_3d, sample_object_model_3d,
    simplify_object_model_3d
    """
    with HalconOperator(516) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        smooth_object_model_3d = proc.get_output_tuple_m(0)
        return smooth_object_model_3d  # type: ignore


def smooth_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> HHandle:
    """
    Smooth the 3D points of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model containing 3D point
                      data.

    method : str
             Smoothing method.
             Value Suggestion: mls

    gen_param_name : Sequence[str]
                     Names of generic smoothing parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of generic smoothing parameters.
                      Value Suggestion: []

    Returns
    -------

    smooth_object_model_3d : HHandle
                             Handle of the 3D object model with the
                             smoothed 3D point data.

    Alternatives
    ------------
    surface_normals_object_model_3d, sample_object_model_3d,
    simplify_object_model_3d
    """
    with HalconOperator(516) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        smooth_object_model_3d = proc.get_output_tuple_s(0)
        return smooth_object_model_3d  # type: ignore


def sobel_amp(
    image: HObject,
    filter_type: str,
    size: MaybeSequence[int]
) -> HObject:
    """
    Detect edges (amplitude) using the Sobel operator.

    Parameters
    ----------

    image : HObject
            Input image.

    filter_type : str
                  Filter type.
                  Value Suggestion: sum_abs

    size : MaybeSequence[int]
           Size of filter mask.
           Value Suggestion: 3

    Returns
    -------

    edge_amplitude : HObject
                     Edge amplitude (gradient magnitude) image.

    See Also
    --------
    laplace, highpass_image, bandpass_image

    Alternatives
    ------------
    frei_amp, roberts, kirsch_amp, prewitt_amp, robinson_amp

    Predecessors
    ------------
    binomial_filter, gauss_filter, mean_image, anisotropic_diffusion,
    sigma_image

    Successors
    ----------
    threshold, nonmax_suppression_amp, gray_skeleton

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1560) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter_type)
        proc.set_input_tuple(1, size)
        proc.execute()
        edge_amplitude = HObject(proc.get_output_object_key(1))
        return edge_amplitude  # type: ignore


def sobel_dir(
    image: HObject,
    filter_type: str,
    size: MaybeSequence[int]
) -> Tuple[HObject, HObject]:
    """
    Detect edges (amplitude and direction) using the Sobel operator.

    Parameters
    ----------

    image : HObject
            Input image.

    filter_type : str
                  Filter type.
                  Value Suggestion: sum_abs

    size : MaybeSequence[int]
           Size of filter mask.
           Value Suggestion: 3

    Returns
    -------

    edge_amplitude : HObject
                     Edge amplitude (gradient magnitude) image.

    edge_direction : HObject
                     Edge direction image.

    See Also
    --------
    roberts, laplace, highpass_image, bandpass_image

    Alternatives
    ------------
    edges_image, frei_dir, kirsch_dir, prewitt_dir, robinson_dir

    Predecessors
    ------------
    binomial_filter, gauss_filter, mean_image, anisotropic_diffusion,
    sigma_image

    Successors
    ----------
    nonmax_suppression_dir, hysteresis_threshold, threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1561) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter_type)
        proc.set_input_tuple(1, size)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # edge_amplitude
            HObject(proc.get_output_object_key(2))   # edge_direction
        )  # type: ignore


def socket_accept_connect(
    accepting_socket: HHandle,
    wait: str
) -> HHandle:
    """
    Accept a connection request on a listening socket of the protocol type
    'HALCON' or 'TCP'/'TCP4'/'TCP6'.

    Parameters
    ----------

    accepting_socket : HHandle
                       Socket number of the accepting socket.

    wait : str
           Should the operator wait until a connection request arrives?
           Value Suggestion: auto

    Returns
    -------

    socket : HHandle
             Socket number.

    See Also
    --------
    open_socket_connect, close_socket, get_socket_param, set_socket_param

    Predecessors
    ------------
    open_socket_accept

    Successors
    ----------
    send_image, receive_image, send_region, receive_region, send_tuple,
    receive_tuple, send_data, receive_data
    """
    with HalconOperator(341) as proc:
        proc.set_input_tuple(0, accepting_socket)
        proc.set_input_tuple(1, wait)
        proc.init_oct(0)
        proc.execute()
        socket = proc.get_output_tuple_s(0)
        return socket  # type: ignore


def solve_matrix(
    matrix_lhsid: HHandle,
    matrix_lhstype: str,
    epsilon: float,
    matrix_rhsid: HHandle
) -> HHandle:
    """
    Compute the solution of a system of equations.

    Parameters
    ----------

    matrix_lhsid : HHandle
                   Matrix handle of the input matrix of the left hand side.

    matrix_lhstype : str
                     The type of the input matrix of the left hand side.
                     Value Suggestion: general

    epsilon : float
              Type of solving and limitation to set singular values to be
              0.
              Value Suggestion: 0.0

    matrix_rhsid : HHandle
                   Matrix handle of the input matrix of right hand side.

    Returns
    -------

    matrix_result_id : HHandle
                       New matrix handle with the solution.

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix

    Notes
    -----
    For MatrixLHSType = 'symmetric', 'positive_definite', or
    'upper_triangular' the upper triangular part of the input MatrixLHS
    must contain the relevant information of the matrix.  The strictly
    lower triangular part of the matrix is not referenced.  For
    MatrixLHSType = 'lower_triangular' the lower triangular part of the
    input MatrixLHS must contain the relevant information of the matrix.
    The strictly upper triangular part of the matrix is not referenced.
    For MatrixLHSType = 'tridiagonal', only the main diagonal, the
    superdiagonal, and the subdiagonal of the input MatrixLHS are used.
    The other parts of the matrix are not referenced.  If the referenced
    part of the input MatrixLHS is not of the specified type, an exception
    is raised.
    """
    with HalconOperator(851) as proc:
        proc.set_input_tuple(0, matrix_lhsid)
        proc.set_input_tuple(1, matrix_lhstype)
        proc.set_input_tuple(2, epsilon)
        proc.set_input_tuple(3, matrix_rhsid)
        proc.init_oct(0)
        proc.execute()
        matrix_result_id = proc.get_output_tuple_s(0)
        return matrix_result_id  # type: ignore


def sort_contours_xld(
    contours: HObject,
    sort_mode: str,
    order: str,
    row_or_col: str
) -> HObject:
    """
    Sort contours with respect to their relative position.

    Parameters
    ----------

    contours : HObject
               Contours to be sorted.

    sort_mode : str
                Kind of sorting.
                Value Suggestion: upper_left

    order : str
            Increasing or decreasing sorting order.
            Value Suggestion: true

    row_or_col : str
                 Sorting first with respect to row, then to column.
                 Value Suggestion: row

    Returns
    -------

    sorted_contours : HObject
                      Sorted contours.

    See Also
    --------
    sort_region
    """
    with HalconOperator(16) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, sort_mode)
        proc.set_input_tuple(1, order)
        proc.set_input_tuple(2, row_or_col)
        proc.execute()
        sorted_contours = HObject(proc.get_output_object_key(1))
        return sorted_contours  # type: ignore


def sort_region(
    regions: HObject,
    sort_mode: MaybeSequence[Union[int, float, str]],
    order: str,
    row_or_col: str
) -> HObject:
    """
    Sorting of regions with respect to their relative position.

    Parameters
    ----------

    regions : HObject
              Regions to be sorted.

    sort_mode : MaybeSequence[Union[int, float, str]]
                Kind of sorting.
                Value Suggestion: first_point

    order : str
            Increasing or decreasing sorting order.
            Value Suggestion: true

    row_or_col : str
                 Sorting first with respect to row, then to column.
                 Value Suggestion: row

    Returns
    -------

    sorted_regions : HObject
                     Sorted regions.

    Successors
    ----------
    do_ocr_multi_class_mlp, do_ocr_single_class_mlp
    """
    with HalconOperator(723) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, sort_mode)
        proc.set_input_tuple(1, order)
        proc.set_input_tuple(2, row_or_col)
        proc.execute()
        sorted_regions = HObject(proc.get_output_object_key(1))
        return sorted_regions  # type: ignore


def sp_distribution(
    percent_salt: Union[float, int],
    percent_pepper: Union[float, int]
) -> Sequence[float]:
    """
    Generate a salt-and-pepper noise distribution.

    Parameters
    ----------

    percent_salt : Union[float, int]
                   Percentage of salt (white noise pixels).
                   Value Suggestion: 5.0
                   Assertion: 0.0 <= PercentSalt && PercentSalt <= 100.0

    percent_pepper : Union[float, int]
                     Percentage of pepper (black noise pixels).
                     Value Suggestion: 5.0
                     Assertion: 0.0 <= PercentPepper && PercentPepper <= 100.0

    Returns
    -------

    distribution : Sequence[float]
                   Resulting noise distribution.

    See Also
    --------
    gauss_distribution, noise_distribution_mean, add_noise_white

    Alternatives
    ------------
    gauss_distribution, noise_distribution_mean

    Successors
    ----------
    add_noise_distribution
    """
    with HalconOperator(1444) as proc:
        proc.set_input_tuple(0, percent_salt)
        proc.set_input_tuple(1, percent_pepper)
        proc.init_oct(0)
        proc.execute()
        distribution = proc.get_output_tuple_m(0)
        return distribution  # type: ignore


def spatial_relation(
    regions_1: HObject,
    regions_2: HObject,
    percent: int
) -> Tuple[Sequence[int], Sequence[int], Sequence[str], Sequence[str]]:
    """
    Pose relation of regions with regard to - the coordinate axes.

    Parameters
    ----------

    regions_1 : HObject
                Starting regions.

    regions_2 : HObject
                Comparative regions.

    percent : int
              Percentage of the area of the comparative region which must
              be located left/right or- above/below the region margins of
              the starting region.
              Value Suggestion: 50
              Assertion: 0 <= Percent && Percent <= 100

    Returns
    -------

    region_index_1 : Sequence[int]
                     Indices of the regions in the tuple of the input
                     regions which fulfill the pose relation.

    region_index_2 : Sequence[int]
                     Indices of the regions in the tuple of the input
                     regions which fulfill the pose relation.

    relation_1 : Sequence[str]
                 Horizontal pose relation in which RegionIndex2[n] stands
                 with RegionIndex1[n].

    relation_2 : Sequence[str]
                 Vertical pose relation in which RegionIndex2[n] stands
                 with RegionIndex1[n].

    See Also
    --------
    select_region_spatial, find_neighbors, copy_obj, obj_to_integer

    Alternatives
    ------------
    area_center, intersection

    Predecessors
    ------------
    threshold, regiongrowing, connection
    """
    with HalconOperator(1723) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.set_input_tuple(0, percent)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # region_index_1
            proc.get_output_tuple_m(1),  # region_index_2
            proc.get_output_tuple_m(2),  # relation_1
            proc.get_output_tuple_m(3)   # relation_2
        )  # type: ignore


def split_contours_xld(
    polygons: HObject,
    mode: str,
    weight: int,
    smooth: int
) -> HObject:
    """
    Split XLD contours at dominant points.

    Parameters
    ----------

    polygons : HObject
               Polygons for which the corresponding contours are to be
               split.

    mode : str
           Mode for the splitting of the contours.
           Value Suggestion: polygon

    weight : int
             Weight for the sensitiveness.
             Value Suggestion: 1

    smooth : int
             Width of the smoothing mask.
             Value Suggestion: 5

    Returns
    -------

    contours : HObject
               Split contours.

    See Also
    --------
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix

    Predecessors
    ------------
    gen_polygons_xld

    Successors
    ----------
    regress_contours_xld
    """
    with HalconOperator(46) as proc:
        proc.set_input_object(1, polygons)
        proc.set_input_tuple(0, mode)
        proc.set_input_tuple(1, weight)
        proc.set_input_tuple(2, smooth)
        proc.execute()
        contours = HObject(proc.get_output_object_key(1))
        return contours  # type: ignore


def split_skeleton_lines(
    skeleton_region: HObject,
    max_distance: int
) -> Tuple[Sequence[int], Sequence[int], Sequence[int], Sequence[int]]:
    """
    Split lines represented by one pixel wide, non-branching lines.

    Parameters
    ----------

    skeleton_region : HObject
                      Input lines (represented by 1 pixel wide,
                      non-branching regions).

    max_distance : int
                   Maximum distance of the line points to the line segment
                   connecting both end points.
                   Value Suggestion: 3

    Returns
    -------

    begin_row : Sequence[int]
                Row coordinates of the start points of the output lines.

    begin_col : Sequence[int]
                Column coordinates of the start points of the output lines.

    end_row : Sequence[int]
              Row coordinates of the end points of the output lines.

    end_col : Sequence[int]
              Column coordinates of the end points of the output lines.

    See Also
    --------
    split_skeleton_region, detect_edge_segments

    Predecessors
    ------------
    connection, select_shape, skeleton, junctions_skeleton, difference

    Successors
    ----------
    select_lines, partition_lines, disp_line

    Notes
    -----
    The input regions must represent non-branching lines, that is single
    branches of the skeleton.
    """
    with HalconOperator(511) as proc:
        proc.set_input_object(1, skeleton_region)
        proc.set_input_tuple(0, max_distance)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # begin_row
            proc.get_output_tuple_m(1),  # begin_col
            proc.get_output_tuple_m(2),  # end_row
            proc.get_output_tuple_m(3)   # end_col
        )  # type: ignore


def split_skeleton_region(
    skeleton_region: HObject,
    max_distance: int
) -> HObject:
    """
    Split lines represented by one pixel wide, non-branching regions.

    Parameters
    ----------

    skeleton_region : HObject
                      Input lines (represented by 1 pixel wide,
                      non-branching regions).

    max_distance : int
                   Maximum distance of the line points to the line segment
                   connecting both end points.
                   Value Suggestion: 3

    Returns
    -------

    region_lines : HObject
                   Split lines.

    See Also
    --------
    split_skeleton_lines, get_region_polygon, gen_polygons_xld

    Predecessors
    ------------
    connection, select_shape, skeleton, junctions_skeleton, difference

    Successors
    ----------
    count_obj, select_shape, select_obj, area_center, elliptic_axis,
    smallest_rectangle2, get_region_polygon, get_region_contour

    Notes
    -----
    The input regions must represent non-branching lines, that is single
    branches of the skeleton.
    """
    with HalconOperator(512) as proc:
        proc.set_input_object(1, skeleton_region)
        proc.set_input_tuple(0, max_distance)
        proc.execute()
        region_lines = HObject(proc.get_output_object_key(1))
        return region_lines  # type: ignore


def sqrt_image(image: HObject) -> HObject:
    """
    Calculate the square root of an image.

    Parameters
    ----------

    image : HObject
            Input image

    Returns
    -------

    sqrt_image : HObject
                 Output image

    See Also
    --------
    pow_image
    """
    with HalconOperator(1605) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        sqrt_image = HObject(proc.get_output_object_key(1))
        return sqrt_image  # type: ignore


def sqrt_matrix(matrix_id: HHandle) -> HHandle:
    """
    Compute the square root values of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    matrix_sqrt_id : HHandle
                     Matrix handle with the square root values of the
                     input matrix.

    See Also
    --------
    pow_scalar_element_matrix, pow_scalar_element_matrix_mod

    Alternatives
    ------------
    sqrt_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(866) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        matrix_sqrt_id = proc.get_output_tuple_s(0)
        return matrix_sqrt_id  # type: ignore


def sqrt_matrix_mod(matrix_id: HHandle) -> None:
    """
    Compute the square root values of the elements of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Alternatives
    ------------
    sqrt_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(865) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.execute()


def stationary_camera_self_calibration(
    num_images: int,
    image_width: int,
    image_height: int,
    reference_image: int,
    mapping_source: Sequence[int],
    mapping_dest: Sequence[int],
    hom_matrices_2d: Sequence[float],
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    num_correspondences: Sequence[int],
    estimation_method: str,
    camera_model: Sequence[str],
    fixed_camera_params: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Perform a self-calibration of a stationary projective camera.

    Parameters
    ----------

    num_images : int
                 Number of different images that are used for the
                 calibration.
                 Assertion: NumImages >= 2

    image_width : int
                  Width of the images from which the points were extracted.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images from which the points were
                   extracted.
                   Assertion: ImageHeight > 0

    reference_image : int
                      Index of the reference image.

    mapping_source : Sequence[int]
                     Indices of the source images of the transformations.

    mapping_dest : Sequence[int]
                   Indices of the target images of the transformations.

    hom_matrices_2d : Sequence[float]
                      Array of $3- projective transformation matrices.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             source images.

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             source images.

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             destination images.

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             destination images.

    num_correspondences : Sequence[int]
                          Number of point correspondences in the
                          respective image pair.

    estimation_method : str
                        Estimation algorithm for the calibration.
                        Value Suggestion: gold_standard

    camera_model : Sequence[str]
                   Camera model to be used.
                   Value Suggestion: ['focus','principal_point']

    fixed_camera_params : str
                          Are the camera parameters identical for all
                          images?
                          Value Suggestion: true

    Returns
    -------

    camera_matrices : Sequence[float]
                      (Array of) $3- projective camera matrices that
                      determine the internal camera parameters.

    kappa : Sequence[float]
            Radial distortion of the camera.

    rotation_matrices : Sequence[float]
                        Array of $3-                     transformation
                        matrices that determine rotation of the camera in
                        the respective image.

    x : Sequence[float]
        X-Component of the direction vector of each point if
        EstimationMethod $=$ 'gold_standard' is used.

    y : Sequence[float]
        Y-Component of the direction vector of each point if
        EstimationMethod $=$ 'gold_standard' is used.

    z : Sequence[float]
        Z-Component of the direction vector of each point if
        EstimationMethod $=$ 'gold_standard' is used.

    error : Sequence[float]
            Average error per reconstructed point if EstimationMethod $=$
            'gold_standard' is used.

    See Also
    --------
    gen_projective_mosaic

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided

    Successors
    ----------
    gen_spherical_mosaic
    """
    with HalconOperator(1907) as proc:
        proc.set_input_tuple(0, num_images)
        proc.set_input_tuple(1, image_width)
        proc.set_input_tuple(2, image_height)
        proc.set_input_tuple(3, reference_image)
        proc.set_input_tuple(4, mapping_source)
        proc.set_input_tuple(5, mapping_dest)
        proc.set_input_tuple(6, hom_matrices_2d)
        proc.set_input_tuple(7, rows_1)
        proc.set_input_tuple(8, cols_1)
        proc.set_input_tuple(9, rows_2)
        proc.set_input_tuple(10, cols_2)
        proc.set_input_tuple(11, num_correspondences)
        proc.set_input_tuple(12, estimation_method)
        proc.set_input_tuple(13, camera_model)
        proc.set_input_tuple(14, fixed_camera_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_matrices
            proc.get_output_tuple_m(1),  # kappa
            proc.get_output_tuple_m(2),  # rotation_matrices
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6)   # error
        )  # type: ignore


def stationary_camera_self_calibration_s(
    num_images: int,
    image_width: int,
    image_height: int,
    reference_image: int,
    mapping_source: Sequence[int],
    mapping_dest: Sequence[int],
    hom_matrices_2d: Sequence[float],
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    num_correspondences: Sequence[int],
    estimation_method: str,
    camera_model: Sequence[str],
    fixed_camera_params: str
) -> Tuple[Sequence[float], float, Sequence[float], Sequence[float], Sequence[float], Sequence[float], float]:
    """
    Perform a self-calibration of a stationary projective camera.

    Parameters
    ----------

    num_images : int
                 Number of different images that are used for the
                 calibration.
                 Assertion: NumImages >= 2

    image_width : int
                  Width of the images from which the points were extracted.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images from which the points were
                   extracted.
                   Assertion: ImageHeight > 0

    reference_image : int
                      Index of the reference image.

    mapping_source : Sequence[int]
                     Indices of the source images of the transformations.

    mapping_dest : Sequence[int]
                   Indices of the target images of the transformations.

    hom_matrices_2d : Sequence[float]
                      Array of $3- projective transformation matrices.

    rows_1 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             source images.

    cols_1 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             source images.

    rows_2 : Sequence[Union[float, int]]
             Row coordinates of corresponding points in the respective
             destination images.

    cols_2 : Sequence[Union[float, int]]
             Column coordinates of corresponding points in the respective
             destination images.

    num_correspondences : Sequence[int]
                          Number of point correspondences in the
                          respective image pair.

    estimation_method : str
                        Estimation algorithm for the calibration.
                        Value Suggestion: gold_standard

    camera_model : Sequence[str]
                   Camera model to be used.
                   Value Suggestion: ['focus','principal_point']

    fixed_camera_params : str
                          Are the camera parameters identical for all
                          images?
                          Value Suggestion: true

    Returns
    -------

    camera_matrices : Sequence[float]
                      (Array of) $3- projective camera matrices that
                      determine the internal camera parameters.

    kappa : float
            Radial distortion of the camera.

    rotation_matrices : Sequence[float]
                        Array of $3-                     transformation
                        matrices that determine rotation of the camera in
                        the respective image.

    x : Sequence[float]
        X-Component of the direction vector of each point if
        EstimationMethod $=$ 'gold_standard' is used.

    y : Sequence[float]
        Y-Component of the direction vector of each point if
        EstimationMethod $=$ 'gold_standard' is used.

    z : Sequence[float]
        Z-Component of the direction vector of each point if
        EstimationMethod $=$ 'gold_standard' is used.

    error : float
            Average error per reconstructed point if EstimationMethod $=$
            'gold_standard' is used.

    See Also
    --------
    gen_projective_mosaic

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided

    Successors
    ----------
    gen_spherical_mosaic
    """
    with HalconOperator(1907) as proc:
        proc.set_input_tuple(0, num_images)
        proc.set_input_tuple(1, image_width)
        proc.set_input_tuple(2, image_height)
        proc.set_input_tuple(3, reference_image)
        proc.set_input_tuple(4, mapping_source)
        proc.set_input_tuple(5, mapping_dest)
        proc.set_input_tuple(6, hom_matrices_2d)
        proc.set_input_tuple(7, rows_1)
        proc.set_input_tuple(8, cols_1)
        proc.set_input_tuple(9, rows_2)
        proc.set_input_tuple(10, cols_2)
        proc.set_input_tuple(11, num_correspondences)
        proc.set_input_tuple(12, estimation_method)
        proc.set_input_tuple(13, camera_model)
        proc.set_input_tuple(14, fixed_camera_params)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # camera_matrices
            proc.get_output_tuple_s(1),  # kappa
            proc.get_output_tuple_m(2),  # rotation_matrices
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_s(6)   # error
        )  # type: ignore


def sub_image(
    image_minuend: HObject,
    image_subtrahend: HObject,
    mult: Union[int, float],
    add: Union[int, float]
) -> HObject:
    """
    Subtract two images.

    Parameters
    ----------

    image_minuend : HObject
                    Minuend(s).

    image_subtrahend : HObject
                       Subtrahend(s).

    mult : Union[int, float]
           Correction factor.
           Value Suggestion: 1.0

    add : Union[int, float]
          Correction value.
          Value Suggestion: 128.0

    Returns
    -------

    image_sub : HObject
                Result image(s) by the subtraction.

    See Also
    --------
    add_image, mult_image, dyn_threshold, check_difference

    Alternatives
    ------------
    mult_image, add_image

    Successors
    ----------
    dual_threshold

    Notes
    -----
    Note that the acceleration gained by SIMD technology is highest on
    large, compact input regions. However, in rare cases, the execution of
    sub_image might take significantly longer with SIMD technology than
    without, depending on the input region and the capabilities of the
    hardware. In these cases, the use of SIMD technology can be avoided by
    set_system(::'mmx_enable','false':).
    """
    with HalconOperator(1606) as proc:
        proc.set_input_object(1, image_minuend)
        proc.set_input_object(2, image_subtrahend)
        proc.set_input_tuple(0, mult)
        proc.set_input_tuple(1, add)
        proc.execute()
        image_sub = HObject(proc.get_output_object_key(1))
        return image_sub  # type: ignore


def sub_matrix(matrix_aid: HHandle, matrix_bid: HHandle) -> HHandle:
    """
    Subtract two matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    Returns
    -------

    matrix_sub_id : HHandle
                    Matrix handle with the difference of the input
                    matrices.

    See Also
    --------
    add_matrix, add_matrix_mod

    Alternatives
    ------------
    sub_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(879) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.init_oct(0)
        proc.execute()
        matrix_sub_id = proc.get_output_tuple_s(0)
        return matrix_sub_id  # type: ignore


def sub_matrix_mod(matrix_aid: HHandle, matrix_bid: HHandle) -> None:
    """
    Subtract two matrices.

    Parameters
    ----------

    matrix_aid : HHandle
                 Matrix handle of the input matrix A.

    matrix_bid : HHandle
                 Matrix handle of the input matrix B.

    See Also
    --------
    add_matrix, add_matrix_mod

    Alternatives
    ------------
    sub_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(878) as proc:
        proc.set_input_tuple(0, matrix_aid)
        proc.set_input_tuple(1, matrix_bid)
        proc.execute()


def suggest_lexicon(
    lexicon_handle: HHandle,
    word: str
) -> Tuple[str, int]:
    """
    Find a similar word in a lexicon.

    Parameters
    ----------

    lexicon_handle : HHandle
                     Handle of the lexicon.

    word : str
           Word to be looked up.
           Value Suggestion: 'word'

    Returns
    -------

    suggestion : str
                 Most similar word found in the lexicon.

    num_corrections : int
                      Difference between the words in edit operations.

    See Also
    --------
    create_lexicon

    Alternatives
    ------------
    lookup_lexicon
    """
    with HalconOperator(667) as proc:
        proc.set_input_tuple(0, lexicon_handle)
        proc.set_input_tuple(1, word)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # suggestion
            proc.get_output_tuple_s(1)   # num_corrections
        )  # type: ignore


def sum_matrix(matrix_id: HHandle, sum_type: str) -> HHandle:
    """
    Returns the elementwise sum of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    sum_type : str
               Type of summation.
               Value Suggestion: columns

    Returns
    -------

    matrix_sum_id : HHandle
                    Matrix handle with the sum of the input matrix.

    See Also
    --------
    norm_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(871) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, sum_type)
        proc.init_oct(0)
        proc.execute()
        matrix_sum_id = proc.get_output_tuple_s(0)
        return matrix_sum_id  # type: ignore


def surface_normals_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> Sequence[HHandle]:
    """
    Calculate the 3D surface normals of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model containing 3D point
                      data.

    method : str
             Normals calculation method.
             Value Suggestion: mls

    gen_param_name : Sequence[str]
                     Names of generic smoothing parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of generic smoothing parameters.
                      Value Suggestion: []

    Returns
    -------

    object_model_3dnormals : Sequence[HHandle]
                             Handle of the 3D object model with calculated
                             3D normals.

    Alternatives
    ------------
    smooth_object_model_3d

    Predecessors
    ------------
    sample_object_model_3d

    Successors
    ----------
    create_surface_model, fuse_object_model_3d
    """
    with HalconOperator(515) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dnormals = proc.get_output_tuple_m(0)
        return object_model_3dnormals  # type: ignore


def surface_normals_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> HHandle:
    """
    Calculate the 3D surface normals of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model containing 3D point
                      data.

    method : str
             Normals calculation method.
             Value Suggestion: mls

    gen_param_name : Sequence[str]
                     Names of generic smoothing parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of generic smoothing parameters.
                      Value Suggestion: []

    Returns
    -------

    object_model_3dnormals : HHandle
                             Handle of the 3D object model with calculated
                             3D normals.

    Alternatives
    ------------
    smooth_object_model_3d

    Predecessors
    ------------
    sample_object_model_3d

    Successors
    ----------
    create_surface_model, fuse_object_model_3d
    """
    with HalconOperator(515) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.execute()
        object_model_3dnormals = proc.get_output_tuple_s(0)
        return object_model_3dnormals  # type: ignore


def svd_matrix(
    matrix_id: HHandle,
    svdtype: str,
    compute_singular_vectors: str
) -> Tuple[HHandle, HHandle, HHandle]:
    """
    Compute the singular value decomposition of a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    svdtype : str
              Type of computation.
              Value Suggestion: full

    compute_singular_vectors : str
                               Computation of singular values.
                               Value Suggestion: both

    Returns
    -------

    matrix_uid : HHandle
                 Matrix handle with the left singular vectors.

    matrix_sid : HHandle
                 Matrix handle with singular values.

    matrix_vid : HHandle
                 Matrix handle with the right singular vectors.

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(846) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, svdtype)
        proc.set_input_tuple(2, compute_singular_vectors)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # matrix_uid
            proc.get_output_tuple_s(1),  # matrix_sid
            proc.get_output_tuple_s(2)   # matrix_vid
        )  # type: ignore


def symm_difference(region_1: HObject, region_2: HObject) -> HObject:
    """
    Calculate the symmetric difference of two regions.

    Parameters
    ----------

    region_1 : HObject
               Input region 1.

    region_2 : HObject
               Input region 2.

    Returns
    -------

    region_difference : HObject
                        Resulting region.

    See Also
    --------
    intersection, union1, union2, complement, difference

    Successors
    ----------
    select_shape, disp_region

    Notes
    -----
    Empty regions are valid for both parameters.  On output, empty regions
    may result.  The value of the system flag 'store_empty_region'
    determines the behavior in this case.
    """
    with HalconOperator(502) as proc:
        proc.set_input_object(1, region_1)
        proc.set_input_object(2, region_2)
        proc.execute()
        region_difference = HObject(proc.get_output_object_key(1))
        return region_difference  # type: ignore


def symm_difference_closed_contours_xld(
    contours_1: HObject,
    contours_2: HObject
) -> HObject:
    """
    Compute the symmetric difference of closed contours.

    Parameters
    ----------

    contours_1 : HObject
                 Contours enclosing the first region.

    contours_2 : HObject
                 Contours enclosing the second region.

    Returns
    -------

    contours_difference : HObject
                          Contours enclosing the symmetric difference.

    See Also
    --------
    intersection_closed_contours_xld, difference_closed_contours_xld,
    union2_closed_contours_xld, symm_difference_closed_polygons_xld

    Alternatives
    ------------
    symm_difference

    Predecessors
    ------------
    gen_contour_region_xld, zero_crossing_sub_pix, threshold_sub_pix
    """
    with HalconOperator(8) as proc:
        proc.set_input_object(1, contours_1)
        proc.set_input_object(2, contours_2)
        proc.execute()
        contours_difference = HObject(proc.get_output_object_key(1))
        return contours_difference  # type: ignore


def symm_difference_closed_polygons_xld(
    polygons_1: HObject,
    polygons_2: HObject
) -> HObject:
    """
    Compute the symmetric difference of closed polygons.

    Parameters
    ----------

    polygons_1 : HObject
                 Polygons enclosing the first region.

    polygons_2 : HObject
                 Polygons enclosing the second region.

    Returns
    -------

    polygons_difference : HObject
                          Polygons enclosing the symmetric difference.

    See Also
    --------
    intersection_closed_polygons_xld, difference_closed_polygons_xld,
    union2_closed_polygons_xld, symm_difference_closed_contours_xld

    Alternatives
    ------------
    symm_difference

    Predecessors
    ------------
    gen_polygons_xld

    Notes
    -----
    The resulting polygons PolygonsDifference contain no references to the
    XLD contours that are possibly referenced by Polygons1 and Polygons2.
    Hence, operators that access the contours associated with a polygon,
    e.g., split_contours_xld will not work correctly.
    """
    with HalconOperator(7) as proc:
        proc.set_input_object(1, polygons_1)
        proc.set_input_object(2, polygons_2)
        proc.execute()
        polygons_difference = HObject(proc.get_output_object_key(1))
        return polygons_difference  # type: ignore


def symmetry(
    image: HObject,
    mask_size: int,
    direction: float,
    exponent: float
) -> HObject:
    """
    Symmetry of gray values along a row.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_size : int
                Extension of search area.
                Value Suggestion: 40

    direction : float
                Angle of test direction.
                Value Suggestion: 0.0

    exponent : float
               Exponent for weighting.
               Value Suggestion: 0.5
               Assertion: 0 < Exponent && Exponent <= 1

    Returns
    -------

    image_symmetry : HObject
                     Symmetry image.

    Successors
    ----------
    threshold

    Notes
    -----
    Currently only horizontal search lines are implemented. Note that the
    parameter Direction exists for future extensions and can currently
    only have the value 0.0.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1478) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_size)
        proc.set_input_tuple(1, direction)
        proc.set_input_tuple(2, exponent)
        proc.execute()
        image_symmetry = HObject(proc.get_output_object_key(1))
        return image_symmetry  # type: ignore


def system_call(command: str) -> None:
    """
    Execute a system command.

    Parameters
    ----------

    command : str
              Command to be called by the system.
              Value Suggestion: ls

    See Also
    --------
    wait_seconds, count_seconds

    Predecessors
    ------------
    count_seconds
    """
    with HalconOperator(316) as proc:
        proc.set_input_tuple(0, command)
        proc.execute()


def tan_image(image: HObject) -> HObject:
    """
    Calculate the tangent of an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    tan_image : HObject
                Output image.

    See Also
    --------
    sin_image, cos_image, asin_image, acos_image, atan_image, atan2_image

    Notes
    -----
    tan_image can be executed on OpenCL devices.
    """
    with HalconOperator(1601) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        tan_image = HObject(proc.get_output_object_key(1))
        return tan_image  # type: ignore


def test_closed_xld(xld: HObject) -> Sequence[int]:
    """
    Test whether contours or polygons are closed.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be tested.

    Returns
    -------

    is_closed : Sequence[int]
                Tuple with Boolean numbers.

    Predecessors
    ------------
    gen_contour_region_xld, edges_sub_pix
    """
    with HalconOperator(1667) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        is_closed = proc.get_output_tuple_m(0)
        return is_closed  # type: ignore


def test_closed_xld_s(xld: HObject) -> int:
    """
    Test whether contours or polygons are closed.

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be tested.

    Returns
    -------

    is_closed : int
                Tuple with Boolean numbers.

    Predecessors
    ------------
    gen_contour_region_xld, edges_sub_pix
    """
    with HalconOperator(1667) as proc:
        proc.set_input_object(1, xld)
        proc.init_oct(0)
        proc.execute()
        is_closed = proc.get_output_tuple_s(0)
        return is_closed  # type: ignore


def test_equal_obj(objects_1: HObject, objects_2: HObject) -> int:
    """
    Compare image objects regarding equality.

    Parameters
    ----------

    objects_1 : HObject
                Test objects.

    objects_2 : HObject
                Comparative objects.

    Returns
    -------

    is_equal : int
               Boolean result value.

    See Also
    --------
    compare_obj, test_equal_region

    Notes
    -----
    Image matrices and XLDs are not compared regarding their contents.
    Thus, two images or XLDs, respectively, are ``equal'' if they are
    located at the same place in the storage. By contrast, regions that
    are not located at the same place in the storage are compared
    regarding their actual contents. If the input parameters are empty and
    the behavior was set via the operator
    set_system(::'no_object_result','true':), the parameter IsEqual is set
    to TRUE, since all input (= empty set) is equal.
    """
    with HalconOperator(591) as proc:
        proc.set_input_object(1, objects_1)
        proc.set_input_object(2, objects_2)
        proc.init_oct(0)
        proc.execute()
        is_equal = proc.get_output_tuple_s(0)
        return is_equal  # type: ignore


def test_equal_region(regions_1: HObject, regions_2: HObject) -> int:
    """
    Test whether the regions of two objects are identical.

    Parameters
    ----------

    regions_1 : HObject
                Test regions.

    regions_2 : HObject
                Comparative regions.

    Returns
    -------

    is_equal : int
               Boolean result value.

    See Also
    --------
    test_equal_obj

    Alternatives
    ------------
    intersection, complement, area_center
    """
    with HalconOperator(590) as proc:
        proc.set_input_object(1, regions_1)
        proc.set_input_object(2, regions_2)
        proc.init_oct(0)
        proc.execute()
        is_equal = proc.get_output_tuple_s(0)
        return is_equal  # type: ignore


def test_region_point(
    regions: HObject,
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]]
) -> int:
    """
    Test if the region contains a given point.

    Parameters
    ----------

    regions : HObject
              Region(s) to be examined.

    row : MaybeSequence[Union[int, float]]
          Row index of the test pixel(s).
          Value Suggestion: 100

    column : MaybeSequence[Union[int, float]]
             Column index of the test pixel(s).
             Value Suggestion: 100

    Returns
    -------

    is_inside : int
                Boolean result value.

    See Also
    --------
    select_region_point

    Alternatives
    ------------
    union1, intersection, area_center

    Predecessors
    ------------
    threshold, regiongrowing, connection

    Notes
    -----
    The test pixel is not contained in an empty region (no pixel of the
    region corresponds to the pixel). If all regions are empty IsInside is
    set to FALSE.
    In case of an empty input object (empty tuple) Regions and
    set_system('no_object_result','true'), an empty tuple is  returned in
    IsInside. If  set_system('no_object_result','false') was set, an
    exception is  raised.
    """
    with HalconOperator(1712) as proc:
        proc.set_input_object(1, regions)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        is_inside = proc.get_output_tuple_s(0)
        return is_inside  # type: ignore


def test_sampset_box(
    classif_handle: HHandle,
    samp_key: HHandle
) -> float:
    """
    Classify a set of arrays.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    samp_key : HHandle
               Key of the test data.

    Returns
    -------

    error : float
            Error during the assignment.

    See Also
    --------
    enquire_class_box, learn_class_box, learn_sampset_box, read_sampset

    Predecessors
    ------------
    create_class_box, learn_class_box, set_class_box_param

    Successors
    ----------
    enquire_class_box, learn_class_box, write_class_box, close_class_box,
    clear_sampset

    Warnings
    --------
    test_sampset_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.
    """
    with HalconOperator(1897) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, samp_key)
        proc.init_oct(0)
        proc.execute()
        error = proc.get_output_tuple_s(0)
        return error  # type: ignore


def test_self_intersection_xld(
    xld: HObject,
    close_xld: str
) -> Sequence[int]:
    """
    Test XLD contours or polygons for self intersection.

    Parameters
    ----------

    xld : HObject
          Input contours or polygons.

    close_xld : str
                Should the input contours or polygons be closed first?
                Value Suggestion: true

    Returns
    -------

    does_intersect : Sequence[int]
                     1 for contours or polygons with self intersection and
                     0 otherwise.

    Notes
    -----
    A contour or polygon touches itself if a contour or polygon point lies
    exactly on a contour or polygon segment.  However, whether a point
    lies exactly on a contour or polygon segment or not can practically
    not be decided because of numerical reasons.
    """
    with HalconOperator(1675) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, close_xld)
        proc.init_oct(0)
        proc.execute()
        does_intersect = proc.get_output_tuple_m(0)
        return does_intersect  # type: ignore


def test_self_intersection_xld_s(xld: HObject, close_xld: str) -> int:
    """
    Test XLD contours or polygons for self intersection.

    Parameters
    ----------

    xld : HObject
          Input contours or polygons.

    close_xld : str
                Should the input contours or polygons be closed first?
                Value Suggestion: true

    Returns
    -------

    does_intersect : int
                     1 for contours or polygons with self intersection and
                     0 otherwise.

    Notes
    -----
    A contour or polygon touches itself if a contour or polygon point lies
    exactly on a contour or polygon segment.  However, whether a point
    lies exactly on a contour or polygon segment or not can practically
    not be decided because of numerical reasons.
    """
    with HalconOperator(1675) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, close_xld)
        proc.init_oct(0)
        proc.execute()
        does_intersect = proc.get_output_tuple_s(0)
        return does_intersect  # type: ignore


def test_subset_region(
    region_1: HObject,
    region_2: HObject
) -> Sequence[int]:
    """
    Test whether a region is contained in another region.

    Parameters
    ----------

    region_1 : HObject
               Test region.

    region_2 : HObject
               Region for comparison.

    Returns
    -------

    is_subset : Sequence[int]
                Is Region1 contained in Region2?

    See Also
    --------
    test_equal_region, compare_obj

    Alternatives
    ------------
    difference, area_center
    """
    with HalconOperator(589) as proc:
        proc.set_input_object(1, region_1)
        proc.set_input_object(2, region_2)
        proc.init_oct(0)
        proc.execute()
        is_subset = proc.get_output_tuple_m(0)
        return is_subset  # type: ignore


def test_subset_region_s(region_1: HObject, region_2: HObject) -> int:
    """
    Test whether a region is contained in another region.

    Parameters
    ----------

    region_1 : HObject
               Test region.

    region_2 : HObject
               Region for comparison.

    Returns
    -------

    is_subset : int
                Is Region1 contained in Region2?

    See Also
    --------
    test_equal_region, compare_obj

    Alternatives
    ------------
    difference, area_center
    """
    with HalconOperator(589) as proc:
        proc.set_input_object(1, region_1)
        proc.set_input_object(2, region_2)
        proc.init_oct(0)
        proc.execute()
        is_subset = proc.get_output_tuple_s(0)
        return is_subset  # type: ignore


def test_xld_point(
    xld: HObject,
    row: MaybeSequence[float],
    column: MaybeSequence[float]
) -> Sequence[int]:
    """
    Test whether one or more contours or polygons enclose the given
    point(s).

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be tested.

    row : MaybeSequence[float]
          Row coordinates of the points to be tested.

    column : MaybeSequence[float]
             Column coordinates of the points to be tested.

    Returns
    -------

    is_inside : Sequence[int]
                Tuple with Boolean numbers.

    Predecessors
    ------------
    select_contours_xld, close_contours_xld, threshold_sub_pix

    Notes
    -----
    If a test point is on the border of the contour or polygon,
    test_xld_point will deliver unpredictable results, i.e. the result may
    be 0 or 1 depending on arbitrary factors such as how the polygon is
    oriented with respect to the coordinate system. Note further that for
    points in the near proximity of the contour or polygon sides, a
    reliable classification is practically impossible because of numerical
    inaccuracies.
    """
    with HalconOperator(1677) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        is_inside = proc.get_output_tuple_m(0)
        return is_inside  # type: ignore


def test_xld_point_s(
    xld: HObject,
    row: MaybeSequence[float],
    column: MaybeSequence[float]
) -> int:
    """
    Test whether one or more contours or polygons enclose the given
    point(s).

    Parameters
    ----------

    xld : HObject
          Contours or polygons to be tested.

    row : MaybeSequence[float]
          Row coordinates of the points to be tested.

    column : MaybeSequence[float]
             Column coordinates of the points to be tested.

    Returns
    -------

    is_inside : int
                Tuple with Boolean numbers.

    Predecessors
    ------------
    select_contours_xld, close_contours_xld, threshold_sub_pix

    Notes
    -----
    If a test point is on the border of the contour or polygon,
    test_xld_point will deliver unpredictable results, i.e. the result may
    be 0 or 1 depending on arbitrary factors such as how the polygon is
    oriented with respect to the coordinate system. Note further that for
    points in the near proximity of the contour or polygon sides, a
    reliable classification is practically impossible because of numerical
    inaccuracies.
    """
    with HalconOperator(1677) as proc:
        proc.set_input_object(1, xld)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.init_oct(0)
        proc.execute()
        is_inside = proc.get_output_tuple_s(0)
        return is_inside  # type: ignore


def testd_ocr_class_box(
    character: HObject,
    image: HObject,
    ocr_handle: HHandle,
    class_val: MaybeSequence[str]
) -> Sequence[float]:
    """
    Test an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be tested.

    image : HObject
            Gray values for the characters.

    ocr_handle : HHandle
                 ID of the desired OCR-classifier.

    class_val : MaybeSequence[str]
                Class (name) of the characters.
                Value Suggestion: 'a'

    Returns
    -------

    confidence : Sequence[float]
                 Confidence for the character to belong to the class.

    Predecessors
    ------------
    read_ocr, trainf_ocr_class_box, traind_ocr_class_box

    Warnings
    --------
    testd_ocr_class_box is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(725) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocr_handle)
        proc.set_input_tuple(1, class_val)
        proc.init_oct(0)
        proc.execute()
        confidence = proc.get_output_tuple_m(0)
        return confidence  # type: ignore


def testd_ocr_class_box_s(
    character: HObject,
    image: HObject,
    ocr_handle: HHandle,
    class_val: MaybeSequence[str]
) -> float:
    """
    Test an OCR classifier.

    Parameters
    ----------

    character : HObject
                Characters to be tested.

    image : HObject
            Gray values for the characters.

    ocr_handle : HHandle
                 ID of the desired OCR-classifier.

    class_val : MaybeSequence[str]
                Class (name) of the characters.
                Value Suggestion: 'a'

    Returns
    -------

    confidence : float
                 Confidence for the character to belong to the class.

    Predecessors
    ------------
    read_ocr, trainf_ocr_class_box, traind_ocr_class_box

    Warnings
    --------
    testd_ocr_class_box is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(725) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocr_handle)
        proc.set_input_tuple(1, class_val)
        proc.init_oct(0)
        proc.execute()
        confidence = proc.get_output_tuple_s(0)
        return confidence  # type: ignore


def text_line_orientation(
    region: HObject,
    image: HObject,
    char_height: int,
    orientation_from: float,
    orientation_to: float
) -> Sequence[float]:
    """
    Determines the orientation of a text line or paragraph.

    Parameters
    ----------

    region : HObject
             Area of text lines.

    image : HObject
            Input image.

    char_height : int
                  Height of the text lines.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    orientation_from : float
                       Minimum rotation of the text lines.
                       Value Suggestion: -0.523599
                       Assertion: -2 * pi <= OrientationFrom <= 2 * pi

    orientation_to : float
                     Maximum rotation of the text lines.
                     Value Suggestion: 0.523599
                     Assertion: OrientationFrom <= OrientationTo && OrientationTo < OrientationFrom + pi

    Returns
    -------

    orientation_angle : Sequence[float]
                        Calculated rotation angle of the text lines.

    Successors
    ----------
    rotate_image, affine_trans_image, affine_trans_image_size
    """
    with HalconOperator(427) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, char_height)
        proc.set_input_tuple(1, orientation_from)
        proc.set_input_tuple(2, orientation_to)
        proc.init_oct(0)
        proc.execute()
        orientation_angle = proc.get_output_tuple_m(0)
        return orientation_angle  # type: ignore


def text_line_orientation_s(
    region: HObject,
    image: HObject,
    char_height: int,
    orientation_from: float,
    orientation_to: float
) -> float:
    """
    Determines the orientation of a text line or paragraph.

    Parameters
    ----------

    region : HObject
             Area of text lines.

    image : HObject
            Input image.

    char_height : int
                  Height of the text lines.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    orientation_from : float
                       Minimum rotation of the text lines.
                       Value Suggestion: -0.523599
                       Assertion: -2 * pi <= OrientationFrom <= 2 * pi

    orientation_to : float
                     Maximum rotation of the text lines.
                     Value Suggestion: 0.523599
                     Assertion: OrientationFrom <= OrientationTo && OrientationTo < OrientationFrom + pi

    Returns
    -------

    orientation_angle : float
                        Calculated rotation angle of the text lines.

    Successors
    ----------
    rotate_image, affine_trans_image, affine_trans_image_size
    """
    with HalconOperator(427) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, char_height)
        proc.set_input_tuple(1, orientation_from)
        proc.set_input_tuple(2, orientation_to)
        proc.init_oct(0)
        proc.execute()
        orientation_angle = proc.get_output_tuple_s(0)
        return orientation_angle  # type: ignore


def text_line_slant(
    region: HObject,
    image: HObject,
    char_height: int,
    slant_from: float,
    slant_to: float
) -> Sequence[float]:
    """
    Determines the slant of characters of a text line or paragraph.

    Parameters
    ----------

    region : HObject
             Area of text lines.

    image : HObject
            Input image.

    char_height : int
                  Height of the text lines.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    slant_from : float
                 Minimum slant of the characters
                 Value Suggestion: -0.523599
                 Assertion: - pi / 4 <= SlantFrom && SlantFrom <= SlantTo

    slant_to : float
               Maximum slant of the characters
               Value Suggestion: 0.523599
               Assertion: - pi / 4 <= SlantTo && SlantTo <= pi / 4

    Returns
    -------

    slant_angle : Sequence[float]
                  Calculated slant of the characters in the region

    Successors
    ----------
    hom_mat2d_slant, affine_trans_image, affine_trans_image_size
    """
    with HalconOperator(426) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, char_height)
        proc.set_input_tuple(1, slant_from)
        proc.set_input_tuple(2, slant_to)
        proc.init_oct(0)
        proc.execute()
        slant_angle = proc.get_output_tuple_m(0)
        return slant_angle  # type: ignore


def text_line_slant_s(
    region: HObject,
    image: HObject,
    char_height: int,
    slant_from: float,
    slant_to: float
) -> float:
    """
    Determines the slant of characters of a text line or paragraph.

    Parameters
    ----------

    region : HObject
             Area of text lines.

    image : HObject
            Input image.

    char_height : int
                  Height of the text lines.
                  Value Suggestion: 25
                  Assertion: CharHeight >= 1

    slant_from : float
                 Minimum slant of the characters
                 Value Suggestion: -0.523599
                 Assertion: - pi / 4 <= SlantFrom && SlantFrom <= SlantTo

    slant_to : float
               Maximum slant of the characters
               Value Suggestion: 0.523599
               Assertion: - pi / 4 <= SlantTo && SlantTo <= pi / 4

    Returns
    -------

    slant_angle : float
                  Calculated slant of the characters in the region

    Successors
    ----------
    hom_mat2d_slant, affine_trans_image, affine_trans_image_size
    """
    with HalconOperator(426) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, char_height)
        proc.set_input_tuple(1, slant_from)
        proc.set_input_tuple(2, slant_to)
        proc.init_oct(0)
        proc.execute()
        slant_angle = proc.get_output_tuple_s(0)
        return slant_angle  # type: ignore


def texture_laws(
    image: HObject,
    filter_types: str,
    shift: int,
    filter_size: int
) -> HObject:
    """
    Filter an image using a Laws texture filter.

    Parameters
    ----------

    image : HObject
            Images to which the texture transformation is to be applied.

    filter_types : str
                   Desired filter.
                   Value Suggestion: el

    shift : int
            Shift to reduce the gray value dynamics.
            Value Suggestion: 2

    filter_size : int
                  Size of the filter kernel.
                  Value Suggestion: 5

    Returns
    -------

    image_texture : HObject
                    Texture images.

    See Also
    --------
    class_2dim_sup, class_ndim_norm

    Alternatives
    ------------
    convol_image

    Successors
    ----------
    mean_image, binomial_filter, gauss_filter, median_image, histo_2dim,
    learn_ndim_norm, threshold

    Notes
    -----
    texture_laws can be executed on OpenCL devices.
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1402) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, filter_types)
        proc.set_input_tuple(1, shift)
        proc.set_input_tuple(2, filter_size)
        proc.execute()
        image_texture = HObject(proc.get_output_object_key(1))
        return image_texture  # type: ignore


def thickening(
    region: HObject,
    struct_element_1: HObject,
    struct_element_2: HObject,
    row: int,
    column: int,
    iterations: int
) -> HObject:
    """
    Add the result of a hit-or-miss operation to a region.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_element_1 : HObject
                       Structuring element for the foreground.

    struct_element_2 : HObject
                       Structuring element for the background.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 16

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 16

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_thick : HObject
                   Result of the thickening operator.

    See Also
    --------
    hit_or_miss

    Alternatives
    ------------
    thickening_golay, thickening_seq

    Predecessors
    ------------
    golay_elements, threshold, regiongrowing, connection, union1,
    watersheds, class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points, gen_struct_elements,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    thickening is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    If the reference point is contained in StructElement1 the input region
    remains unchanged.
    """
    with HalconOperator(745) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element_1)
        proc.set_input_object(3, struct_element_2)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        region_thick = HObject(proc.get_output_object_key(1))
        return region_thick  # type: ignore


def thickening_golay(
    region: HObject,
    golay_element: str,
    rotation: int
) -> HObject:
    """
    Add the result of a hit-or-miss operation to a region (using a Golay
    structuring element).

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_thick : HObject
                   Result of the thickening operator.

    See Also
    --------
    erosion_golay, hit_or_miss_golay

    Alternatives
    ------------
    thickening, thickening_seq

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    thickening_golay is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.
    """
    with HalconOperator(744) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, rotation)
        proc.execute()
        region_thick = HObject(proc.get_output_object_key(1))
        return region_thick  # type: ignore


def thickening_seq(
    region: HObject,
    golay_element: str,
    iterations: int
) -> HObject:
    """
    Add the result of a hit-or-miss operation to a region (sequential).

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_thick : HObject
                   Result of the thickening operator.

    See Also
    --------
    erosion_golay, thinning_seq

    Alternatives
    ------------
    thickening_golay, thickening

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    thickening_seq is obsolete and is only provided for reasons of
    backward compatibility.
    """
    with HalconOperator(743) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, iterations)
        proc.execute()
        region_thick = HObject(proc.get_output_object_key(1))
        return region_thick  # type: ignore


def thinning(
    region: HObject,
    struct_element_1: HObject,
    struct_element_2: HObject,
    row: int,
    column: int,
    iterations: int
) -> HObject:
    """
    Remove the result of a hit-or-miss operation from a region.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_element_1 : HObject
                       Structuring element for the foreground.

    struct_element_2 : HObject
                       Structuring element for the background.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 0

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 0

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    region_thin : HObject
                  Result of the thinning operator.

    See Also
    --------
    hit_or_miss

    Alternatives
    ------------
    thinning_golay, thinning_seq

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    thinning is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(742) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element_1)
        proc.set_input_object(3, struct_element_2)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.set_input_tuple(2, iterations)
        proc.execute()
        region_thin = HObject(proc.get_output_object_key(1))
        return region_thin  # type: ignore


def thinning_golay(
    region: HObject,
    golay_element: str,
    rotation: int
) -> HObject:
    """
    Remove the result of a hit-or-miss operation from a region (using a
    Golay structuring element).

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: h

    rotation : int
               Rotation of the Golay element. Depending on the element,
               not all rotations are valid.
               Value Suggestion: 0

    Returns
    -------

    region_thin : HObject
                  Result of the thinning operator.

    See Also
    --------
    erosion_golay, hit_or_miss_golay

    Alternatives
    ------------
    thinning_seq, thinning

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection

    Warnings
    --------
    thinning_golay is obsolete and is only provided for reasons of
    backward compatibility.

    Notes
    -----
    Not all values of Rotation are valid for any Golay element.
    """
    with HalconOperator(741) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, rotation)
        proc.execute()
        region_thin = HObject(proc.get_output_object_key(1))
        return region_thin  # type: ignore


def thinning_seq(
    region: HObject,
    golay_element: str,
    iterations: Union[int, str]
) -> HObject:
    """
    Remove the result of a hit-or-miss operation from a region
    (sequential).

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    golay_element : str
                    Structuring element from the Golay alphabet.
                    Value Suggestion: l

    iterations : Union[int, str]
                 Number of iterations. For 'f', 'f2', 'h' and 'i' the only
                 useful value is 1.
                 Value Suggestion: 20

    Returns
    -------

    region_thin : HObject
                  Result of the thinning operator.

    See Also
    --------
    hit_or_miss_seq, erosion_golay, difference, thinning_golay, thinning,
    thickening_seq

    Alternatives
    ------------
    skeleton, morph_skiz, expand_region

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points, gen_struct_elements,
    gen_region_polygon_filled

    Successors
    ----------
    pruning, reduce_domain, select_shape, area_center, connection,
    complement

    Warnings
    --------
    thinning_seq is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(740) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, golay_element)
        proc.set_input_tuple(1, iterations)
        proc.execute()
        region_thin = HObject(proc.get_output_object_key(1))
        return region_thin  # type: ignore


def threshold(
    image: HObject,
    min_gray: MaybeSequence[Union[int, float, str]],
    max_gray: MaybeSequence[Union[int, float, str]]
) -> HObject:
    """
    Segment an image using global threshold.

    Parameters
    ----------

    image : HObject
            Input image.

    min_gray : MaybeSequence[Union[int, float, str]]
               Lower threshold for the gray values or 'min'.
               Value Suggestion: 128.0

    max_gray : MaybeSequence[Union[int, float, str]]
               Upper threshold for the gray values or 'max'.
               Value Suggestion: 255.0
               Assertion: MaxGray >= MinGray

    Returns
    -------

    region : HObject
             Segmented region.

    See Also
    --------
    zero_crossing, background_seg, regiongrowing

    Alternatives
    ------------
    class_2dim_sup, hysteresis_threshold, dyn_threshold, binary_threshold,
    char_threshold, auto_threshold, dual_threshold

    Predecessors
    ------------
    histo_to_thresh, min_max_gray, sobel_amp, binomial_filter,
    gauss_filter, reduce_domain, fill_interlace

    Successors
    ----------
    connection, dilation1, erosion1, opening, closing, rank_region,
    shape_trans, skeleton

    Notes
    -----
    For input images of an integer type, floating point values in MinGray
    and MaxGray are truncated.
    """
    with HalconOperator(453) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, min_gray)
        proc.set_input_tuple(1, max_gray)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def threshold_sub_pix(
    image: HObject,
    threshold: Union[float, int]
) -> HObject:
    """
    Extract level crossings from an image with subpixel accuracy.

    Parameters
    ----------

    image : HObject
            Input image.

    threshold : Union[float, int]
                Threshold for the level crossings.
                Value Suggestion: 128

    Returns
    -------

    border : HObject
             Extracted level crossings.

    See Also
    --------
    zero_crossing_sub_pix

    Alternatives
    ------------
    threshold
    """
    with HalconOperator(454) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, threshold)
        proc.execute()
        border = HObject(proc.get_output_object_key(1))
        return border  # type: ignore


def tile_channels(
    image: HObject,
    num_columns: int,
    tile_order: str
) -> HObject:
    """
    Tile multiple images into a large image.

    Parameters
    ----------

    image : HObject
            Input image.

    num_columns : int
                  Number of columns to use for the output image.
                  Value Suggestion: 1
                  Assertion: NumColumns >= 1

    tile_order : str
                 Order of the input images in the output image.
                 Value Suggestion: vertical

    Returns
    -------

    tiled_image : HObject
                  Tiled output image.

    See Also
    --------
    change_format, crop_part, crop_rectangle1

    Alternatives
    ------------
    tile_images, tile_images_offset

    Predecessors
    ------------
    append_channel
    """
    with HalconOperator(1138) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, num_columns)
        proc.set_input_tuple(1, tile_order)
        proc.execute()
        tiled_image = HObject(proc.get_output_object_key(1))
        return tiled_image  # type: ignore


def tile_images(
    images: HObject,
    num_columns: int,
    tile_order: str
) -> HObject:
    """
    Tile multiple image objects into a large image.

    Parameters
    ----------

    images : HObject
             Input images.

    num_columns : int
                  Number of columns to use for the output image.
                  Value Suggestion: 1
                  Assertion: NumColumns >= 1

    tile_order : str
                 Order of the input images in the output image.
                 Value Suggestion: vertical

    Returns
    -------

    tiled_image : HObject
                  Tiled output image.

    See Also
    --------
    change_format, crop_part, crop_rectangle1

    Alternatives
    ------------
    tile_channels, tile_images_offset

    Predecessors
    ------------
    append_channel
    """
    with HalconOperator(1137) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, num_columns)
        proc.set_input_tuple(1, tile_order)
        proc.execute()
        tiled_image = HObject(proc.get_output_object_key(1))
        return tiled_image  # type: ignore


def tile_images_offset(
    images: HObject,
    offset_row: MaybeSequence[int],
    offset_col: MaybeSequence[int],
    row_1: MaybeSequence[int],
    col_1: MaybeSequence[int],
    row_2: MaybeSequence[int],
    col_2: MaybeSequence[int],
    width: int,
    height: int
) -> HObject:
    """
    Tile multiple image objects into a large image with explicit
    positioning information.

    Parameters
    ----------

    images : HObject
             Input images.

    offset_row : MaybeSequence[int]
                 Row coordinate of the upper left corner of the input
                 images in the output image.
                 Value Suggestion: 0

    offset_col : MaybeSequence[int]
                 Column coordinate of the upper left corner of the input
                 images in the output image.
                 Value Suggestion: 0

    row_1 : MaybeSequence[int]
            Row coordinate of the upper left corner of the copied part of
            the respective input image.
            Value Suggestion: -1

    col_1 : MaybeSequence[int]
            Column coordinate of the upper left corner of the copied part
            of the respective input image.
            Value Suggestion: -1

    row_2 : MaybeSequence[int]
            Row coordinate of the lower right corner of the copied part of
            the respective input image.
            Value Suggestion: -1

    col_2 : MaybeSequence[int]
            Column coordinate of the lower right corner of the copied part
            of the respective input image.
            Value Suggestion: -1

    width : int
            Width of the output image.
            Value Suggestion: 512

    height : int
             Height of the output image.
             Value Suggestion: 512

    Returns
    -------

    tiled_image : HObject
                  Tiled output image.

    See Also
    --------
    change_format, crop_part, crop_rectangle1

    Alternatives
    ------------
    tile_channels, tile_images

    Predecessors
    ------------
    append_channel

    Notes
    -----
    If the input images all have the same size and tile the output image
    exactly, the operator tile_images usually will be slightly faster.
    """
    with HalconOperator(1136) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, offset_row)
        proc.set_input_tuple(1, offset_col)
        proc.set_input_tuple(2, row_1)
        proc.set_input_tuple(3, col_1)
        proc.set_input_tuple(4, row_2)
        proc.set_input_tuple(5, col_2)
        proc.set_input_tuple(6, width)
        proc.set_input_tuple(7, height)
        proc.execute()
        tiled_image = HObject(proc.get_output_object_key(1))
        return tiled_image  # type: ignore


def timed_wait_condition(
    condition_handle: HHandle,
    mutex_handle: HHandle,
    timeout: int
) -> None:
    """
    Bounded wait on the signal of a condition synchronization object.

    Parameters
    ----------

    condition_handle : HHandle
                       Condition synchronization object.

    mutex_handle : HHandle
                   Mutex synchronization object.

    timeout : int
              Timeout in micro seconds.

    Successors
    ----------
    signal_condition, clear_condition
    """
    with HalconOperator(546) as proc:
        proc.set_input_tuple(0, condition_handle)
        proc.set_input_tuple(1, mutex_handle)
        proc.set_input_tuple(2, timeout)
        proc.execute()


def top_hat(region: HObject, struct_element: HObject) -> HObject:
    """
    Compute the top hat of regions.

    Parameters
    ----------

    region : HObject
             Regions to be processed.

    struct_element : HObject
                     Structuring element (position independent).

    Returns
    -------

    region_top_hat : HObject
                     Result of the top hat operator.

    See Also
    --------
    bottom_hat, gray_tophat, opening

    Alternatives
    ------------
    opening, difference

    Predecessors
    ------------
    threshold, regiongrowing, connection, union1, watersheds,
    class_ndim_norm, gen_circle, gen_ellipse, gen_rectangle1,
    gen_rectangle2, draw_region, gen_region_points,
    gen_region_polygon_filled

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(754) as proc:
        proc.set_input_object(1, region)
        proc.set_input_object(2, struct_element)
        proc.execute()
        region_top_hat = HObject(proc.get_output_object_key(1))
        return region_top_hat  # type: ignore


def topographic_sketch(image: HObject) -> HObject:
    """
    Compute the topographic primal sketch of an image.

    Parameters
    ----------

    image : HObject
            Image for which the topographic primal sketch is to be
            computed.

    Returns
    -------

    sketch : HObject
             Label image containing the 11 classes.

    Successors
    ----------
    threshold

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1453) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        sketch = HObject(proc.get_output_object_key(1))
        return sketch  # type: ignore


def train_class_gmm(
    gmmhandle: HHandle,
    max_iter: int,
    threshold: float,
    class_priors: str,
    regularize: float
) -> Tuple[Sequence[int], Sequence[int]]:
    """
    Train a Gaussian Mixture Model.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    max_iter : int
               Maximum number of iterations of the expectation
               maximization algorithm
               Value Suggestion: 100

    threshold : float
                Threshold for relative change of the error for the
                expectation maximization algorithm to terminate.
                Value Suggestion: 0.001
                Assertion: Threshold >= 0.0 && Threshold <= 1.0

    class_priors : str
                   Mode to determine the a-priori probabilities of the
                   classes
                   Value Suggestion: training

    regularize : float
                 Regularization value for preventing covariance matrix
                 singularity.
                 Value Suggestion: 0.0001
                 Assertion: Regularize >= 0.0 && Regularize < 1.0

    Returns
    -------

    centers : Sequence[int]
              Number of found centers per class

    iter : Sequence[int]
           Number of executed iterations per class

    See Also
    --------
    create_class_gmm

    Alternatives
    ------------
    read_class_gmm

    Predecessors
    ------------
    add_sample_class_gmm, read_samples_class_gmm

    Successors
    ----------
    evaluate_class_gmm, classify_class_gmm, write_class_gmm,
    create_class_lut_gmm
    """
    with HalconOperator(1834) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, max_iter)
        proc.set_input_tuple(2, threshold)
        proc.set_input_tuple(3, class_priors)
        proc.set_input_tuple(4, regularize)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # centers
            proc.get_output_tuple_m(1)   # iter
        )  # type: ignore


def train_class_knn(
    knnhandle: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> None:
    """
    Creates the search trees for a k-NN classifier.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the k-NN classifier creation.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the k-NN classifier creation.
                      Value Suggestion: []

    See Also
    --------
    create_class_knn, read_class_knn

    Alternatives
    ------------
    select_feature_set_knn

    Predecessors
    ------------
    add_sample_class_knn, read_class_knn
    """
    with HalconOperator(1814) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def train_class_mlp(
    mlphandle: HHandle,
    max_iterations: int,
    weight_tolerance: float,
    error_tolerance: float
) -> Tuple[float, Sequence[float]]:
    """
    Train a multilayer perceptron.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    max_iterations : int
                     Maximum number of iterations of the optimization
                     algorithm.
                     Value Suggestion: 200

    weight_tolerance : float
                       Threshold for the difference of the weights of the
                       MLP between two iterations of the optimization
                       algorithm.
                       Value Suggestion: 1.0
                       Assertion: WeightTolerance >= 1.0e-8

    error_tolerance : float
                      Threshold for the difference of the mean error of
                      the MLP on the training data between two iterations
                      of the optimization algorithm.
                      Value Suggestion: 0.01
                      Assertion: ErrorTolerance >= 1.0e-8

    Returns
    -------

    error : float
            Mean error of the MLP on the training data.

    error_log : Sequence[float]
                Mean error of the MLP on the training data as a function
                of the number of iterations of the optimization algorithm.

    See Also
    --------
    create_class_mlp

    Alternatives
    ------------
    train_dl_classifier_batch, read_class_mlp

    Predecessors
    ------------
    add_sample_class_mlp, read_samples_class_mlp,
    set_regularization_params_class_mlp

    Successors
    ----------
    evaluate_class_mlp, classify_class_mlp, write_class_mlp,
    create_class_lut_mlp
    """
    with HalconOperator(1873) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, max_iterations)
        proc.set_input_tuple(2, weight_tolerance)
        proc.set_input_tuple(3, error_tolerance)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # error
            proc.get_output_tuple_m(1)   # error_log
        )  # type: ignore


def train_class_svm(
    svmhandle: HHandle,
    epsilon: float,
    train_mode: Union[str, int]
) -> None:
    """
    Train a support vector machine.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    epsilon : float
              Stop parameter for training.
              Value Suggestion: 0.001

    train_mode : Union[str, int]
                 Mode of training. For normal operation: 'default'. If SVs
                 already included in the SVM should be used for training:
                 'add_sv_to_train_set'. For alpha seeding: the respective
                 SVM handle.
                 Value Suggestion: default

    See Also
    --------
    create_class_svm

    Alternatives
    ------------
    train_dl_classifier_batch, read_class_svm

    Predecessors
    ------------
    add_sample_class_svm, read_samples_class_svm

    Successors
    ----------
    classify_class_svm, write_class_svm, create_class_lut_svm
    """
    with HalconOperator(1853) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, epsilon)
        proc.set_input_tuple(2, train_mode)
        proc.execute()


def train_dl_classifier_batch(
    batch_images: HObject,
    dlclassifier_handle: HHandle,
    batch_labels: Sequence[Union[str, int]]
) -> HHandle:
    """
    Perform a training step of a deep-learning-based classifier on a batch
    of  images.

    Parameters
    ----------

    batch_images : HObject
                   Images comprising the batch.

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    batch_labels : Sequence[Union[str, int]]
                   Corresponding labels for each of the images.
                   Value Suggestion: []

    Returns
    -------

    dlclassifier_train_result_handle : HHandle
                                       Handle of the training results from
                                       the  deep-learning-based classifier.

    See Also
    --------
    apply_dl_classifier

    Alternatives
    ------------
    train_dl_model_batch, train_class_mlp, train_class_svm

    Predecessors
    ------------
    read_dl_classifier, set_dl_classifier_param, get_dl_classifier_param

    Successors
    ----------
    get_dl_classifier_train_result, apply_dl_classifier,
    clear_dl_classifier_train_result, clear_dl_classifier

    Warnings
    --------
    train_dl_classifier_batch is obsolete and is only provided for reasons
    of backward compatibility.  New applications should use the common
    CNN-based operator train_dl_model_batch.

    Notes
    -----
    The operator train_dl_classifier_batch internally calls functions that
    might not be deterministic. Therefore, results from multiple calls of
    train_dl_classifier_batch can slightly differ, although the same input
    values have been used.
    To run this operator, cuDNN and cuBLAS are required. For further
    details, please refer to the ``Installation Guide'',  paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    """
    with HalconOperator(2131) as proc:
        proc.set_input_object(1, batch_images)
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.set_input_tuple(1, batch_labels)
        proc.init_oct(0)
        proc.execute()
        dlclassifier_train_result_handle = proc.get_output_tuple_s(0)
        return dlclassifier_train_result_handle  # type: ignore


def train_dl_model_anomaly_dataset(
    dlmodel_handle: HHandle,
    dlsamples: Sequence[HHandle],
    dltrain_param: HHandle
) -> HHandle:
    """
    Train a deep learning model for anomaly detection.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Deep learning model handle.

    dlsamples : Sequence[HHandle]
                Tuple of Dictionaries with input images and corresponding
                information.

    dltrain_param : HHandle
                    Parameter for training the anomaly detection model.
                    Value Suggestion: []

    Returns
    -------

    dltrain_result : HHandle
                     Dictionary with the train result data.

    See Also
    --------
    apply_dl_model

    Predecessors
    ------------
    read_dl_model, set_dl_model_param, get_dl_model_param

    Successors
    ----------
    apply_dl_model

    Notes
    -----
    The operator train_dl_model_anomaly_dataset internally calls functions
    that might not be deterministic. Therefore, results from multiple
    calls of train_dl_model_anomaly_dataset can slightly differ, although
    the same input values have been used.
    System requirements:  To run this operator on GPU by setting 'runtime'
    to 'gpu' (see get_dl_model_param), cuDNN and cuBLAS are required. For
    further details, please refer to the ``Installation Guide'', paragraph
    ``Requirements for Deep Learning and Deep-Learning-Based Methods''.
    Alternatively, this operator can also be run on CPU by setting
    'runtime' to 'cpu'.
    """
    with HalconOperator(2189) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, dlsamples)
        proc.set_input_tuple(2, dltrain_param)
        proc.init_oct(0)
        proc.execute()
        dltrain_result = proc.get_output_tuple_s(0)
        return dltrain_result  # type: ignore


def train_dl_model_batch(
    dlmodel_handle: HHandle,
    dlsample_batch: Sequence[HHandle]
) -> HHandle:
    """
    Train a deep learning model.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Deep learning model handle.

    dlsample_batch : Sequence[HHandle]
                     Tuple of Dictionaries with input images and
                     corresponding information.

    Returns
    -------

    dltrain_result : HHandle
                     Dictionary with the train result data.

    See Also
    --------
    apply_dl_model

    Predecessors
    ------------
    read_dl_model, set_dl_model_param, get_dl_model_param

    Successors
    ----------
    apply_dl_model

    Notes
    -----
    The operator train_dl_model_batch internally calls functions that
    might not be deterministic. Therefore, results from multiple calls of
    train_dl_model_batch can slightly differ, although the same input
    values have been used.  Setting 'cudnn_deterministic' of set_system
    may influence this behavior.
    System requirements:  Implementation on CPU is limited to specific
    platform types.  To run this operator on GPU by setting 'runtime' to
    'gpu' (see get_dl_model_param), cuDNN and cuBLAS are required. Please
    refer to the ``Installation Guide'', paragraph ``Requirements for Deep
    Learning and Deep-Learning-Based Methods'', for the specific system
    requirements.
    """
    with HalconOperator(2172) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, dlsample_batch)
        proc.init_oct(0)
        proc.execute()
        dltrain_result = proc.get_output_tuple_s(0)
        return dltrain_result  # type: ignore


def train_model_components(
    model_image: HObject,
    initial_components: HObject,
    training_images: HObject,
    contrast_low: MaybeSequence[Union[int, str]],
    contrast_high: MaybeSequence[Union[int, str]],
    min_size: MaybeSequence[Union[int, str]],
    min_score: MaybeSequence[float],
    search_row_tol: MaybeSequence[int],
    search_column_tol: MaybeSequence[int],
    search_angle_tol: MaybeSequence[float],
    training_emphasis: str,
    ambiguity_criterion: str,
    max_contour_overlap: float,
    cluster_threshold: float
) -> Tuple[HObject, HHandle]:
    """
    Train components and relations for the component-based matching.

    Parameters
    ----------

    model_image : HObject
                  Input image from which the shape models of the initial
                  components should be created.

    initial_components : HObject
                         Contour regions or enclosing regions of the
                         initial components.

    training_images : HObject
                      Training images that are used for training the model
                      components.

    contrast_low : MaybeSequence[Union[int, str]]
                   Lower hysteresis threshold for the contrast of the
                   initial components in the image.
                   Value Suggestion: auto
                   Assertion: ContrastLow > 0

    contrast_high : MaybeSequence[Union[int, str]]
                    Upper hysteresis threshold for the contrast of the
                    initial components in the image.
                    Value Suggestion: auto
                    Assertion: ContrastHigh > 0 && ContrastHigh >= ContrastLow

    min_size : MaybeSequence[Union[int, str]]
               Minimum size of connected contour regions.
               Value Suggestion: auto
               Assertion: MinSize >= 0

    min_score : MaybeSequence[float]
                Minimum score of the instances of the initial components
                to be found.
                Value Suggestion: 0.5
                Assertion: 0 <= MinScore && MinScore <= 1

    search_row_tol : MaybeSequence[int]
                     Search tolerance in row direction.
                     Value Suggestion: -1
                     Assertion: SearchRowTol == -1 || SearchColumnTol >= 0

    search_column_tol : MaybeSequence[int]
                        Search tolerance in column direction.
                        Value Suggestion: -1
                        Assertion: SearchColumnTol == -1 || SearchColumnTol >= 0

    search_angle_tol : MaybeSequence[float]
                       Angle search tolerance.
                       Value Suggestion: -1
                       Assertion: SearchAngleTol == -1 || SearchAngleTol >= 0

    training_emphasis : str
                        Decision whether the training emphasis should lie
                        on a fast computation or on a high robustness.
                        Value Suggestion: speed

    ambiguity_criterion : str
                          Criterion for solving ambiguous matches of the
                          initial components in the training images.
                          Value Suggestion: rigidity

    max_contour_overlap : float
                          Maximum contour overlap of the found initial
                          components in a training image.
                          Value Suggestion: 0.2
                          Assertion: 0 <= MaxContourOverlap && MaxContourOverlap <= 1

    cluster_threshold : float
                        Threshold for clustering the initial components.
                        Value Suggestion: 0.5
                        Assertion: 0 <= ClusterThreshold && ClusterThreshold <= 1

    Returns
    -------

    model_components : HObject
                       Contour regions of rigid model components.

    component_training_id : HHandle
                            Handle of the training result.

    See Also
    --------
    create_shape_model, find_shape_model

    Predecessors
    ------------
    gen_initial_components

    Successors
    ----------
    inspect_clustered_components, cluster_model_components,
    modify_component_relations, write_training_components,
    get_training_components, get_component_relations,
    create_trained_component_model, clear_training_components
    """
    with HalconOperator(1017) as proc:
        proc.set_input_object(1, model_image)
        proc.set_input_object(2, initial_components)
        proc.set_input_object(3, training_images)
        proc.set_input_tuple(0, contrast_low)
        proc.set_input_tuple(1, contrast_high)
        proc.set_input_tuple(2, min_size)
        proc.set_input_tuple(3, min_score)
        proc.set_input_tuple(4, search_row_tol)
        proc.set_input_tuple(5, search_column_tol)
        proc.set_input_tuple(6, search_angle_tol)
        proc.set_input_tuple(7, training_emphasis)
        proc.set_input_tuple(8, ambiguity_criterion)
        proc.set_input_tuple(9, max_contour_overlap)
        proc.set_input_tuple(10, cluster_threshold)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # model_components
            proc.get_output_tuple_s(0)   # component_training_id
        )  # type: ignore


def train_sample_identifier(
    sample_identifier: HHandle,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[str, int, float]]
) -> None:
    """
    Train a sample identifier.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    gen_param_name : Sequence[str]
                     Parameter name.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[str, int, float]]
                      Parameter value.
                      Value Suggestion: []

    See Also
    --------
    create_sample_identifier, add_sample_identifier_preparation_data,
    prepare_sample_identifier, apply_sample_identifier,
    set_sample_identifier_param, get_sample_identifier_param,
    get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, serialize_sample_identifier,
    deserialize_sample_identifier, clear_sample_identifier,
    set_sample_identifier_object_info

    Alternatives
    ------------
    read_sample_identifier

    Predecessors
    ------------
    add_sample_identifier_training_data

    Successors
    ----------
    apply_sample_identifier, write_sample_identifier
    """
    with HalconOperator(911) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def train_texture_inspection_model(
    texture_inspection_model: HHandle
) -> None:
    """
    Train a texture inspection model.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    Predecessors
    ------------
    add_texture_inspection_model_image, set_texture_inspection_model_param

    Successors
    ----------
    apply_texture_inspection_model, clear_texture_inspection_model,
    remove_texture_inspection_model_image, write_texture_inspection_model,
    serialize_texture_inspection_model
    """
    with HalconOperator(2099) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.execute()


def train_variation_model(images: HObject, model_id: HHandle) -> None:
    """
    Train a variation model.

    Parameters
    ----------

    images : HObject
             Images of the object to be trained.

    model_id : HHandle
               ID of the variation model.

    See Also
    --------
    prepare_variation_model, compare_variation_model,
    compare_ext_variation_model, clear_variation_model

    Predecessors
    ------------
    create_variation_model, find_shape_model, affine_trans_image,
    concat_obj

    Successors
    ----------
    prepare_variation_model

    Notes
    -----
    At most 65535 training images can be trained.
    """
    with HalconOperator(91) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, model_id)
        proc.execute()


def traind_ocr_class_box(
    character: HObject,
    image: HObject,
    ocr_handle: HHandle,
    class_val: MaybeSequence[str]
) -> float:
    """
    Train an OCR classifier by the input of regions.

    Parameters
    ----------

    character : HObject
                Characters to be trained.

    image : HObject
            Gray values for the characters.

    ocr_handle : HHandle
                 ID of the desired OCR-classifier.

    class_val : MaybeSequence[str]
                Class (name) of the characters.
                Value Suggestion: 'a'

    Returns
    -------

    avg_confidence : float
                     Average confidence during a re-classification of the
                     trained characters.

    Alternatives
    ------------
    trainf_ocr_class_box

    Predecessors
    ------------
    create_ocr_class_box, read_ocr

    Successors
    ----------
    write_ocr, do_ocr_multi, do_ocr_single

    Warnings
    --------
    traind_ocr_class_box is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.
    """
    with HalconOperator(717) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, ocr_handle)
        proc.set_input_tuple(1, class_val)
        proc.init_oct(0)
        proc.execute()
        avg_confidence = proc.get_output_tuple_s(0)
        return avg_confidence  # type: ignore


def traind_ocv_proj(
    pattern: HObject,
    ocvhandle: HHandle,
    name: MaybeSequence[str],
    mode: str
) -> None:
    """
    Training of an OCV tool.

    Parameters
    ----------

    pattern : HObject
              Pattern to be trained.

    ocvhandle : HHandle
                Handle of the OCV tool to be trained.

    name : MaybeSequence[str]
           Name(s) of the object(s) to analyze.
           Value Suggestion: 'a'

    mode : str
           Mode for training (only one mode implemented).
           Value Suggestion: single

    See Also
    --------
    traind_ocr_class_box

    Predecessors
    ------------
    write_ocr_trainf, create_ocv_proj, read_ocv, threshold, connection,
    select_shape

    Successors
    ----------
    close_ocv
    """
    with HalconOperator(639) as proc:
        proc.set_input_object(1, pattern)
        proc.set_input_tuple(0, ocvhandle)
        proc.set_input_tuple(1, name)
        proc.set_input_tuple(2, mode)
        proc.execute()


def trainf_ocr_class_box(
    ocr_handle: HHandle,
    training_file: MaybeSequence[str]
) -> float:
    """
    Train an OCR classifier with the help of a training file.

    Parameters
    ----------

    ocr_handle : HHandle
                 ID of the desired OCR-network.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'train_ocr'

    Returns
    -------

    avg_confidence : float
                     Average confidence during a re-classification of the
                     trained characters.

    Alternatives
    ------------
    traind_ocr_class_box

    Predecessors
    ------------
    create_ocr_class_box, read_ocr

    Successors
    ----------
    traind_ocr_class_box, write_ocr, do_ocr_multi, do_ocr_single

    Warnings
    --------
    trainf_ocr_class_box is obsolete and is only provided for reasons of
    backward compatibility.  New applications should use the MLP, SVM or
    CNN based operators instead.

    Notes
    -----
    The names of the characters in the file must fit the network.
    """
    with HalconOperator(718) as proc:
        proc.set_input_tuple(0, ocr_handle)
        proc.set_input_tuple(1, training_file)
        proc.init_oct(0)
        proc.execute()
        avg_confidence = proc.get_output_tuple_s(0)
        return avg_confidence  # type: ignore


def trainf_ocr_class_knn(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[int, str, float]]
) -> None:
    """
    Trains an k-NN classifier for an OCR task.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the k-NN classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    gen_param_name : Sequence[str]
                     Names of the generic parameters that can be adjusted
                     for the k-NN classifier creation.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[int, str, float]]
                      Values of the generic parameters that can be
                      adjusted for the k-NN classifier creation.
                      Value Suggestion: []

    See Also
    --------
    train_class_knn

    Alternatives
    ------------
    read_ocr_class_knn

    Predecessors
    ------------
    create_ocr_class_knn, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image

    Successors
    ----------
    do_ocr_single_class_knn, do_ocr_multi_class_knn
    """
    with HalconOperator(655) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def trainf_ocr_class_mlp(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    max_iterations: int,
    weight_tolerance: float,
    error_tolerance: float
) -> Tuple[float, Sequence[float]]:
    """
    Train an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    max_iterations : int
                     Maximum number of iterations of the optimization
                     algorithm.
                     Value Suggestion: 200

    weight_tolerance : float
                       Threshold for the difference of the weights of the
                       MLP between two iterations of the optimization
                       algorithm.
                       Value Suggestion: 1.0
                       Assertion: WeightTolerance >= 1.0e-8

    error_tolerance : float
                      Threshold for the difference of the mean error of
                      the MLP on the training data between two iterations
                      of the optimization algorithm.
                      Value Suggestion: 0.01
                      Assertion: ErrorTolerance >= 1.0e-8

    Returns
    -------

    error : float
            Mean error of the MLP on the training data.

    error_log : Sequence[float]
                Mean error of the MLP on the training data as a function
                of the number of iterations of the optimization algorithm.

    See Also
    --------
    train_class_mlp

    Alternatives
    ------------
    read_ocr_class_mlp

    Predecessors
    ------------
    create_ocr_class_mlp, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image, set_regularization_params_ocr_class_mlp

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp, write_ocr_class_mlp
    """
    with HalconOperator(701) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, max_iterations)
        proc.set_input_tuple(3, weight_tolerance)
        proc.set_input_tuple(4, error_tolerance)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # error
            proc.get_output_tuple_m(1)   # error_log
        )  # type: ignore


def trainf_ocr_class_mlp_protected(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    password: MaybeSequence[str],
    max_iterations: int,
    weight_tolerance: float,
    error_tolerance: float
) -> Tuple[float, Sequence[float]]:
    """
    Train an OCR classifier with data from a (protected) training file.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    password : MaybeSequence[str]
               Passwords for protected training files.

    max_iterations : int
                     Maximum number of iterations of the optimization
                     algorithm.
                     Value Suggestion: 200

    weight_tolerance : float
                       Threshold for the difference of the weights of the
                       MLP between two iterations of the optimization
                       algorithm.
                       Value Suggestion: 1.0
                       Assertion: WeightTolerance >= 1.0e-8

    error_tolerance : float
                      Threshold for the difference of the mean error of
                      the MLP on the training data between two iterations
                      of the optimization algorithm.
                      Value Suggestion: 0.01
                      Assertion: ErrorTolerance >= 1.0e-8

    Returns
    -------

    error : float
            Mean error of the MLP on the training data.

    error_log : Sequence[float]
                Mean error of the MLP on the training data as a function
                of the number of iterations of the optimization algorithm.

    See Also
    --------
    trainf_ocr_class_mlp, train_class_mlp

    Alternatives
    ------------
    read_ocr_class_mlp

    Predecessors
    ------------
    create_ocr_class_mlp, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image, protect_ocr_trainf

    Successors
    ----------
    do_ocr_single_class_mlp, do_ocr_multi_class_mlp, write_ocr_class_mlp
    """
    with HalconOperator(700) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, password)
        proc.set_input_tuple(3, max_iterations)
        proc.set_input_tuple(4, weight_tolerance)
        proc.set_input_tuple(5, error_tolerance)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # error
            proc.get_output_tuple_m(1)   # error_log
        )  # type: ignore


def trainf_ocr_class_svm(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    epsilon: float,
    train_mode: Union[str, int]
) -> None:
    """
    Train an OCR classifier.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    epsilon : float
              Stop parameter for training.
              Value Suggestion: 0.001

    train_mode : Union[str, int]
                 Mode of training.
                 Value Suggestion: default

    See Also
    --------
    train_class_svm

    Alternatives
    ------------
    read_ocr_class_svm

    Predecessors
    ------------
    create_ocr_class_svm, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm, write_ocr_class_svm
    """
    with HalconOperator(684) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, epsilon)
        proc.set_input_tuple(3, train_mode)
        proc.execute()


def trainf_ocr_class_svm_protected(
    ocrhandle: HHandle,
    training_file: MaybeSequence[str],
    password: MaybeSequence[str],
    epsilon: float,
    train_mode: Union[str, int]
) -> None:
    """
    Train an OCR classifier with data from a (protected) training file.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    training_file : MaybeSequence[str]
                    Names of the training files.
                    Value Suggestion: 'ocr.trf'

    password : MaybeSequence[str]
               Passwords for protected training files.

    epsilon : float
              Stop parameter for training.
              Value Suggestion: 0.001

    train_mode : Union[str, int]
                 Mode of training.
                 Value Suggestion: default

    See Also
    --------
    trainf_ocr_class_svm, train_class_svm

    Alternatives
    ------------
    read_ocr_class_svm

    Predecessors
    ------------
    create_ocr_class_svm, write_ocr_trainf, append_ocr_trainf,
    write_ocr_trainf_image, protect_ocr_trainf

    Successors
    ----------
    do_ocr_single_class_svm, do_ocr_multi_class_svm, write_ocr_class_svm
    """
    with HalconOperator(683) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, training_file)
        proc.set_input_tuple(2, password)
        proc.set_input_tuple(3, epsilon)
        proc.set_input_tuple(4, train_mode)
        proc.execute()


def trans_from_rgb(
    image_red: HObject,
    image_green: HObject,
    image_blue: HObject,
    color_space: str
) -> Tuple[HObject, HObject, HObject]:
    """
    Transform an image from the RGB color space to an arbitrary color
    space.

    Parameters
    ----------

    image_red : HObject
                Input image (red channel).

    image_green : HObject
                  Input image (green channel).

    image_blue : HObject
                 Input image (blue channel).

    color_space : str
                  Color space of the output image.
                  Value Suggestion: hsv

    Returns
    -------

    image_result_1 : HObject
                     Color-transformed output image (channel 1).

    image_result_2 : HObject
                     Color-transformed output image (channel 1).

    image_result_3 : HObject
                     Color-transformed output image (channel 1).

    See Also
    --------
    trans_to_rgb

    Alternatives
    ------------
    linear_trans_color, rgb1_to_gray, rgb3_to_gray

    Predecessors
    ------------
    decompose3

    Successors
    ----------
    compose3

    Notes
    -----
    As the calculations are made with a different numerical precision, the
    OpenCL implementation of the cielab transformation for images of type
    int4 is slightly less accurate than the pure C version.
    """
    with HalconOperator(1583) as proc:
        proc.set_input_object(1, image_red)
        proc.set_input_object(2, image_green)
        proc.set_input_object(3, image_blue)
        proc.set_input_tuple(0, color_space)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_result_1
            HObject(proc.get_output_object_key(2)),  # image_result_2
            HObject(proc.get_output_object_key(3))   # image_result_3
        )  # type: ignore


def trans_pose_shape_model_3d(
    shape_model_3did: HHandle,
    pose_in: Sequence[Union[int, float]],
    transformation: str
) -> Sequence[Union[int, float]]:
    """
    Transform a pose that refers to the coordinate system of a 3D object
    model to a pose that refers to the reference coordinate system of a 3D
    shape model and vice versa.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    pose_in : Sequence[Union[int, float]]
              Pose to be transformed in the source system.

    transformation : str
                     Direction of the transformation.
                     Value Suggestion: ref_to_model

    Returns
    -------

    pose_out : Sequence[Union[int, float]]
               Transformed 3D pose in the target system.

    Alternatives
    ------------
    hom_mat3d_translate, hom_mat3d_rotate

    Predecessors
    ------------
    find_shape_model_3d
    """
    with HalconOperator(1054) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, pose_in)
        proc.set_input_tuple(2, transformation)
        proc.init_oct(0)
        proc.execute()
        pose_out = proc.get_output_tuple_m(0)
        return pose_out  # type: ignore


def trans_to_rgb(
    image_input_1: HObject,
    image_input_2: HObject,
    image_input_3: HObject,
    color_space: str
) -> Tuple[HObject, HObject, HObject]:
    """
    Transform an image from an arbitrary color space to the RGB color
    space.

    Parameters
    ----------

    image_input_1 : HObject
                    Input image (channel 1).

    image_input_2 : HObject
                    Input image (channel 2).

    image_input_3 : HObject
                    Input image (channel 3).

    color_space : str
                  Color space of the input image.
                  Value Suggestion: hsv

    Returns
    -------

    image_red : HObject
                Red channel.

    image_green : HObject
                  Green channel.

    image_blue : HObject
                 Blue channel.

    See Also
    --------
    decompose3

    Alternatives
    ------------
    linear_trans_color

    Predecessors
    ------------
    decompose3

    Successors
    ----------
    compose3, disp_color

    Notes
    -----
    As the calculations are made with a different numerical precision, the
    OpenCL implementation of the cielab transformation for images of type
    int4 is slightly less accurate than the pure C version.
    """
    with HalconOperator(1584) as proc:
        proc.set_input_object(1, image_input_1)
        proc.set_input_object(2, image_input_2)
        proc.set_input_object(3, image_input_3)
        proc.set_input_tuple(0, color_space)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # image_red
            HObject(proc.get_output_object_key(2)),  # image_green
            HObject(proc.get_output_object_key(3))   # image_blue
        )  # type: ignore


def transform_funct_1d(
    function: Sequence[Union[float, int]],
    params: Sequence[float]
) -> Sequence[Union[float, int]]:
    """
    Transform a function using given transformation parameters.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    params : Sequence[float]
             Transformation parameters between the functions.

    Returns
    -------

    transformed_function : Sequence[Union[float, int]]
                           Transformed function.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array, match_funct_1d_trans
    """
    with HalconOperator(1392) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, params)
        proc.init_oct(0)
        proc.execute()
        transformed_function = proc.get_output_tuple_m(0)
        return transformed_function  # type: ignore


def transform_metrology_object(
    metrology_handle: HHandle,
    index: MaybeSequence[Union[str, int]],
    row: MaybeSequence[Union[int, float]],
    column: MaybeSequence[Union[int, float]],
    phi: MaybeSequence[Union[int, float]],
    mode: MaybeSequence[str]
) -> None:
    """
    Transform metrology objects of a metrology model, e.g. for alignment.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    index : MaybeSequence[Union[str, int]]
            Index of the metrology objects.
            Value Suggestion: all

    row : MaybeSequence[Union[int, float]]
          Translation in row direction.

    column : MaybeSequence[Union[int, float]]
             Translation in column direction.

    phi : MaybeSequence[Union[int, float]]
          Rotation angle.

    mode : MaybeSequence[str]
           Mode of the transformation.
           Value Suggestion: absolute

    Warnings
    --------
    transform_metrology_object is obsolete and is only provided for
    reasons of backward compatibility.  New applications should use the
    operator align_metrology_model instead.

    Notes
    -----
    Note that any results (fitted geometric shapes) that have been
    generated by the operator apply_metrology_model before calling
    transform_metrology_object are discarded during the transformation.
    """
    with HalconOperator(796) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, row)
        proc.set_input_tuple(3, column)
        proc.set_input_tuple(4, phi)
        proc.set_input_tuple(5, mode)
        proc.execute()


def translate_measure(
    measure_handle: HHandle,
    row: Union[int, float],
    column: Union[int, float]
) -> None:
    """
    Translate a measure object.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    row : Union[int, float]
          Row coordinate of the new reference point.
          Value Suggestion: 50.0

    column : Union[int, float]
             Column coordinate of the new reference point.
             Value Suggestion: 100.0

    See Also
    --------
    close_measure

    Alternatives
    ------------
    gen_measure_rectangle2, gen_measure_arc

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc

    Successors
    ----------
    measure_pos, measure_pairs, fuzzy_measure_pos, fuzzy_measure_pairs,
    fuzzy_measure_pairing, measure_thresh
    """
    with HalconOperator(837) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.execute()


def transpose_matrix(matrix_id: HHandle) -> HHandle:
    """
    Transpose a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    Returns
    -------

    matrix_transposed_id : HHandle
                           Matrix handle with the transpose of the input
                           matrix.

    See Also
    --------
    invert_matrix, invert_matrix_mod

    Alternatives
    ------------
    transpose_matrix_mod

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(856) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.init_oct(0)
        proc.execute()
        matrix_transposed_id = proc.get_output_tuple_s(0)
        return matrix_transposed_id  # type: ignore


def transpose_matrix_mod(matrix_id: HHandle) -> None:
    """
    Transpose a matrix.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    See Also
    --------
    invert_matrix, invert_matrix_mod

    Alternatives
    ------------
    transpose_matrix

    Predecessors
    ------------
    create_matrix

    Successors
    ----------
    get_full_matrix, get_value_matrix
    """
    with HalconOperator(855) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.execute()


def transpose_region(region: HObject, row: int, column: int) -> HObject:
    """
    Reflect a region about a point.

    Parameters
    ----------

    region : HObject
             Region to be reflected.

    row : int
          Row coordinate of the reference point.
          Value Suggestion: 0

    column : int
             Column coordinate of the reference point.
             Value Suggestion: 0

    Returns
    -------

    transposed : HObject
                 Transposed region.

    See Also
    --------
    dilation1, opening, closing

    Successors
    ----------
    reduce_domain, select_shape, area_center, connection
    """
    with HalconOperator(739) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, row)
        proc.set_input_tuple(1, column)
        proc.execute()
        transposed = HObject(proc.get_output_object_key(1))
        return transposed  # type: ignore


def triangulate_object_model_3d(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> Tuple[Sequence[HHandle], Sequence[Union[int, str]]]:
    """
    Create a surface triangulation for a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model containing 3D point
                      data.

    method : str
             Triangulation method.
             Value Suggestion: greedy

    gen_param_name : Sequence[str]
                     Names of the generic triangulation parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic triangulation parameters.
                      Value Suggestion: []

    Returns
    -------

    triangulated_object_model_3d : Sequence[HHandle]
                                   Handle of the 3D object model with the
                                   triangulated surface.

    information : Sequence[Union[int, str]]
                  Additional information about the triangulation process.

    Predecessors
    ------------
    read_object_model_3d, gen_plane_object_model_3d,
    gen_sphere_object_model_3d, gen_cylinder_object_model_3d,
    gen_box_object_model_3d, gen_sphere_object_model_3d_center,
    sample_object_model_3d

    Successors
    ----------
    write_object_model_3d, render_object_model_3d,
    project_object_model_3d, simplify_object_model_3d
    """
    with HalconOperator(517) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # triangulated_object_model_3d
            proc.get_output_tuple_m(1)   # information
        )  # type: ignore


def triangulate_object_model_3d_s(
    object_model_3d: MaybeSequence[HHandle],
    method: str,
    gen_param_name: Sequence[str],
    gen_param_value: Sequence[Union[float, int, str]]
) -> Tuple[HHandle, Union[int, str]]:
    """
    Create a surface triangulation for a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model containing 3D point
                      data.

    method : str
             Triangulation method.
             Value Suggestion: greedy

    gen_param_name : Sequence[str]
                     Names of the generic triangulation parameters.
                     Value Suggestion: []

    gen_param_value : Sequence[Union[float, int, str]]
                      Values of the generic triangulation parameters.
                      Value Suggestion: []

    Returns
    -------

    triangulated_object_model_3d : HHandle
                                   Handle of the 3D object model with the
                                   triangulated surface.

    information : Union[int, str]
                  Additional information about the triangulation process.

    Predecessors
    ------------
    read_object_model_3d, gen_plane_object_model_3d,
    gen_sphere_object_model_3d, gen_cylinder_object_model_3d,
    gen_box_object_model_3d, gen_sphere_object_model_3d_center,
    sample_object_model_3d

    Successors
    ----------
    write_object_model_3d, render_object_model_3d,
    project_object_model_3d, simplify_object_model_3d
    """
    with HalconOperator(517) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, method)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # triangulated_object_model_3d
            proc.get_output_tuple_s(1)   # information
        )  # type: ignore


def trimmed_mean(
    image: HObject,
    mask: HObject,
    number: int,
    margin: Union[int, float, str]
) -> HObject:
    """
    Smooth an image with an arbitrary rank mask.

    Parameters
    ----------

    image : HObject
            Image to be filtered.

    mask : HObject
           Image whose region serves as filter mask.

    number : int
             Number of averaged pixels. Typical value:       Surface(Mask)
             / 2.
             Value Suggestion: 5

    margin : Union[int, float, str]
             Border treatment.
             Value Suggestion: mirrored

    Returns
    -------

    image_tmean : HObject
                  Filtered output image.

    See Also
    --------
    gen_circle, gen_rectangle1, gray_erosion_rect, gray_dilation_rect

    Alternatives
    ------------
    sigma_image, median_weighted, median_image

    Predecessors
    ------------
    read_image, draw_region, gen_circle, gen_rectangle1

    Successors
    ----------
    threshold, dyn_threshold, regiongrowing

    Notes
    -----
    Note that filter operators may return unexpected results if  an image
    with a reduced domain is used as input. Please refer to the  chapter
    Filters.
    """
    with HalconOperator(1410) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, mask)
        proc.set_input_tuple(0, number)
        proc.set_input_tuple(1, margin)
        proc.execute()
        image_tmean = HObject(proc.get_output_object_key(1))
        return image_tmean  # type: ignore


def try_lock_mutex(mutex_handle: HHandle) -> int:
    """
    Lock a mutex synchronization object.

    Parameters
    ----------

    mutex_handle : HHandle
                   Mutex synchronization object.

    Returns
    -------

    busy : int
           Mutex already locked?

    See Also
    --------
    lock_mutex

    Predecessors
    ------------
    create_mutex

    Successors
    ----------
    unlock_mutex
    """
    with HalconOperator(562) as proc:
        proc.set_input_tuple(0, mutex_handle)
        proc.init_oct(0)
        proc.execute()
        busy = proc.get_output_tuple_s(0)
        return busy  # type: ignore


def try_wait_event(event_handle: HHandle) -> int:
    """
    Lock an event synchronization object only if it is unlocked.

    Parameters
    ----------

    event_handle : HHandle
                   Event synchronization object.

    Returns
    -------

    busy : int
           Object already locked?

    See Also
    --------
    wait_event

    Predecessors
    ------------
    create_event

    Successors
    ----------
    signal_event
    """
    with HalconOperator(556) as proc:
        proc.set_input_tuple(0, event_handle)
        proc.init_oct(0)
        proc.execute()
        busy = proc.get_output_tuple_s(0)
        return busy  # type: ignore


def tuple_abs(
    t: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Compute the absolute value of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    abs : Sequence[Union[float, int]]
          Absolute value of the input tuple.

    Alternatives
    ------------
    tuple_fabs
    """
    with HalconOperator(211) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        abs = proc.get_output_tuple_m(0)
        return abs  # type: ignore


def tuple_abs_s(t: MaybeSequence[Union[float, int]]) -> Union[float, int]:
    """
    Compute the absolute value of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    abs : Union[float, int]
          Absolute value of the input tuple.

    Alternatives
    ------------
    tuple_fabs
    """
    with HalconOperator(211) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        abs = proc.get_output_tuple_s(0)
        return abs  # type: ignore


def tuple_acos(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the arccosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: -1 <= T <= 1

    Returns
    -------

    acos : Sequence[float]
           Arccosine of the input tuple.

    See Also
    --------
    tuple_cos, tuple_cosh, tuple_acosh

    Alternatives
    ------------
    tuple_asin, tuple_atan, tuple_atan2
    """
    with HalconOperator(204) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        acos = proc.get_output_tuple_m(0)
        return acos  # type: ignore


def tuple_acos_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the arccosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: -1 <= T <= 1

    Returns
    -------

    acos : float
           Arccosine of the input tuple.

    See Also
    --------
    tuple_cos, tuple_cosh, tuple_acosh

    Alternatives
    ------------
    tuple_asin, tuple_atan, tuple_atan2
    """
    with HalconOperator(204) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        acos = proc.get_output_tuple_s(0)
        return acos  # type: ignore


def tuple_acosh(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the inverse hyperbolic cosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    acosh : Sequence[float]
            Inverse hyperbolic cosine of the input tuple.

    See Also
    --------
    tuple_cosh, tuple_cos, tuple_acos

    Alternatives
    ------------
    tuple_asinh, tuple_atanh
    """
    with HalconOperator(2192) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        acosh = proc.get_output_tuple_m(0)
        return acosh  # type: ignore


def tuple_acosh_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the inverse hyperbolic cosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    acosh : float
            Inverse hyperbolic cosine of the input tuple.

    See Also
    --------
    tuple_cosh, tuple_cos, tuple_acos

    Alternatives
    ------------
    tuple_asinh, tuple_atanh
    """
    with HalconOperator(2192) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        acosh = proc.get_output_tuple_s(0)
        return acosh  # type: ignore


def tuple_add(
    s1: MaybeSequence[Union[float, int, str]],
    s2: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Add two tuples.

    Parameters
    ----------

    s1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    s2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    sum : Sequence[Union[float, int, str]]
          Sum of the input tuples.

    See Also
    --------
    tuple_cumul

    Alternatives
    ------------
    tuple_sub
    """
    with HalconOperator(216) as proc:
        proc.set_input_tuple(0, s1)
        proc.set_input_tuple(1, s2)
        proc.init_oct(0)
        proc.execute()
        sum = proc.get_output_tuple_m(0)
        return sum  # type: ignore


def tuple_add_s(
    s1: MaybeSequence[Union[float, int, str]],
    s2: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Add two tuples.

    Parameters
    ----------

    s1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    s2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    sum : Union[float, int, str]
          Sum of the input tuples.

    See Also
    --------
    tuple_cumul

    Alternatives
    ------------
    tuple_sub
    """
    with HalconOperator(216) as proc:
        proc.set_input_tuple(0, s1)
        proc.set_input_tuple(1, s2)
        proc.init_oct(0)
        proc.execute()
        sum = proc.get_output_tuple_s(0)
        return sum  # type: ignore


def tuple_and(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Compute the logical and of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    and_val : Sequence[int]
              Logical and of the input tuples.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_or, tuple_xor, tuple_not
    """
    with HalconOperator(171) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        and_val = proc.get_output_tuple_m(0)
        return and_val  # type: ignore


def tuple_and_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Compute the logical and of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    and_val : int
              Logical and of the input tuples.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_or, tuple_xor, tuple_not
    """
    with HalconOperator(171) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        and_val = proc.get_output_tuple_s(0)
        return and_val  # type: ignore


def tuple_asin(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the arcsine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: -1 <= T <= 1

    Returns
    -------

    asin : Sequence[float]
           Arcsine of the input tuple.

    See Also
    --------
    tuple_sin, tuple_sinh, tuple_asinh

    Alternatives
    ------------
    tuple_acos, tuple_atan, tuple_atan2
    """
    with HalconOperator(205) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        asin = proc.get_output_tuple_m(0)
        return asin  # type: ignore


def tuple_asin_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the arcsine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: -1 <= T <= 1

    Returns
    -------

    asin : float
           Arcsine of the input tuple.

    See Also
    --------
    tuple_sin, tuple_sinh, tuple_asinh

    Alternatives
    ------------
    tuple_acos, tuple_atan, tuple_atan2
    """
    with HalconOperator(205) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        asin = proc.get_output_tuple_s(0)
        return asin  # type: ignore


def tuple_asinh(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the inverse hyperbolic sine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    asinh : Sequence[float]
            Inverse hyperbolic sine of the input tuple.

    See Also
    --------
    tuple_asin, tuple_sin, tuple_asin

    Alternatives
    ------------
    tuple_acosh, tuple_atanh
    """
    with HalconOperator(2193) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        asinh = proc.get_output_tuple_m(0)
        return asinh  # type: ignore


def tuple_asinh_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the inverse hyperbolic sine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    asinh : float
            Inverse hyperbolic sine of the input tuple.

    See Also
    --------
    tuple_asin, tuple_sin, tuple_asin

    Alternatives
    ------------
    tuple_acosh, tuple_atanh
    """
    with HalconOperator(2193) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        asinh = proc.get_output_tuple_s(0)
        return asinh  # type: ignore


def tuple_atan(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the arctangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    atan : Sequence[float]
           Arctangent of the input tuple.

    See Also
    --------
    tuple_tan, tuple_tanh, tuple_atanh

    Alternatives
    ------------
    tuple_atan2, tuple_asin, tuple_acos
    """
    with HalconOperator(203) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        atan = proc.get_output_tuple_m(0)
        return atan  # type: ignore


def tuple_atan2(
    y: MaybeSequence[Union[float, int]],
    x: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Compute the arctangent of a tuple for all four quadrants.

    Parameters
    ----------

    y : MaybeSequence[Union[float, int]]
        Input tuple of the y-values.

    x : MaybeSequence[Union[float, int]]
        Input tuple of the x-values.

    Returns
    -------

    atan : Sequence[float]
           Arctangent of the input tuple.

    See Also
    --------
    tuple_tan, tuple_tanh

    Alternatives
    ------------
    tuple_atan, tuple_asin, tuple_acos
    """
    with HalconOperator(202) as proc:
        proc.set_input_tuple(0, y)
        proc.set_input_tuple(1, x)
        proc.init_oct(0)
        proc.execute()
        atan = proc.get_output_tuple_m(0)
        return atan  # type: ignore


def tuple_atan2_s(
    y: MaybeSequence[Union[float, int]],
    x: MaybeSequence[Union[float, int]]
) -> float:
    """
    Compute the arctangent of a tuple for all four quadrants.

    Parameters
    ----------

    y : MaybeSequence[Union[float, int]]
        Input tuple of the y-values.

    x : MaybeSequence[Union[float, int]]
        Input tuple of the x-values.

    Returns
    -------

    atan : float
           Arctangent of the input tuple.

    See Also
    --------
    tuple_tan, tuple_tanh

    Alternatives
    ------------
    tuple_atan, tuple_asin, tuple_acos
    """
    with HalconOperator(202) as proc:
        proc.set_input_tuple(0, y)
        proc.set_input_tuple(1, x)
        proc.init_oct(0)
        proc.execute()
        atan = proc.get_output_tuple_s(0)
        return atan  # type: ignore


def tuple_atan_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the arctangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    atan : float
           Arctangent of the input tuple.

    See Also
    --------
    tuple_tan, tuple_tanh, tuple_atanh

    Alternatives
    ------------
    tuple_atan2, tuple_asin, tuple_acos
    """
    with HalconOperator(203) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        atan = proc.get_output_tuple_s(0)
        return atan  # type: ignore


def tuple_atanh(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the inverse hyperbolic tangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    atanh : Sequence[float]
            Inverse hyperbolic tangent of the input tuple.

    See Also
    --------
    tuple_tanh, tuple_tan, tuple_atan, tuple_atan2

    Alternatives
    ------------
    tuple_asinh, tuple_acosh
    """
    with HalconOperator(2194) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        atanh = proc.get_output_tuple_m(0)
        return atanh  # type: ignore


def tuple_atanh_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the inverse hyperbolic tangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    atanh : float
            Inverse hyperbolic tangent of the input tuple.

    See Also
    --------
    tuple_tanh, tuple_tan, tuple_atan, tuple_atan2

    Alternatives
    ------------
    tuple_asinh, tuple_acosh
    """
    with HalconOperator(2194) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        atanh = proc.get_output_tuple_s(0)
        return atanh  # type: ignore


def tuple_band(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Compute the bitwise and of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    band : Sequence[int]
           Binary and of the input tuples.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_bor, tuple_bxor, tuple_bnot
    """
    with HalconOperator(175) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        band = proc.get_output_tuple_m(0)
        return band  # type: ignore


def tuple_band_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Compute the bitwise and of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    band : int
           Binary and of the input tuples.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_bor, tuple_bxor, tuple_bnot
    """
    with HalconOperator(175) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        band = proc.get_output_tuple_s(0)
        return band  # type: ignore


def tuple_bnot(t: MaybeSequence[int]) -> Sequence[int]:
    """
    Compute the bitwise not of a tuple.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    Returns
    -------

    bnot : Sequence[int]
           Binary not of the input tuple.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_band, tuple_bor, tuple_bxor
    """
    with HalconOperator(172) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        bnot = proc.get_output_tuple_m(0)
        return bnot  # type: ignore


def tuple_bnot_s(t: MaybeSequence[int]) -> int:
    """
    Compute the bitwise not of a tuple.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    Returns
    -------

    bnot : int
           Binary not of the input tuple.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_band, tuple_bor, tuple_bxor
    """
    with HalconOperator(172) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        bnot = proc.get_output_tuple_s(0)
        return bnot  # type: ignore


def tuple_bor(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Compute the bitwise or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    bor : Sequence[int]
          Binary or of the input tuples.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_band, tuple_bxor, tuple_bnot
    """
    with HalconOperator(174) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        bor = proc.get_output_tuple_m(0)
        return bor  # type: ignore


def tuple_bor_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Compute the bitwise or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    bor : int
          Binary or of the input tuples.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_band, tuple_bxor, tuple_bnot
    """
    with HalconOperator(174) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        bor = proc.get_output_tuple_s(0)
        return bor  # type: ignore


def tuple_bxor(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Compute the bitwise exclusive or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    bxor : Sequence[int]
           Binary exclusive or of the input tuples.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_band, tuple_bor, tuple_bnot
    """
    with HalconOperator(173) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        bxor = proc.get_output_tuple_m(0)
        return bxor  # type: ignore


def tuple_bxor_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Compute the bitwise exclusive or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    bxor : int
           Binary exclusive or of the input tuples.

    See Also
    --------
    tuple_and, tuple_or, tuple_xor, tuple_not

    Alternatives
    ------------
    tuple_band, tuple_bor, tuple_bnot
    """
    with HalconOperator(173) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        bxor = proc.get_output_tuple_s(0)
        return bxor  # type: ignore


def tuple_cbrt(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the cube root of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    cbrt : Sequence[float]
           Cube root of the input tuple.

    See Also
    --------
    tuple_sqrt

    Alternatives
    ------------
    tuple_pow
    """
    with HalconOperator(2195) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        cbrt = proc.get_output_tuple_m(0)
        return cbrt  # type: ignore


def tuple_cbrt_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the cube root of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    cbrt : float
           Cube root of the input tuple.

    See Also
    --------
    tuple_sqrt

    Alternatives
    ------------
    tuple_pow
    """
    with HalconOperator(2195) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        cbrt = proc.get_output_tuple_s(0)
        return cbrt  # type: ignore


def tuple_ceil(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the ceiling function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    ceil : Sequence[float]
           Ceiling function of the input tuple.
    """
    with HalconOperator(191) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        ceil = proc.get_output_tuple_m(0)
        return ceil  # type: ignore


def tuple_ceil_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the ceiling function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    ceil : float
           Ceiling function of the input tuple.
    """
    with HalconOperator(191) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        ceil = proc.get_output_tuple_s(0)
        return ceil  # type: ignore


def tuple_chr(t: MaybeSequence[int]) -> Sequence[str]:
    """
    Convert a tuple of integer numbers into strings.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple with Unicode character codes or ANSI codes.
        Assertion: 0 <= T

    Returns
    -------

    chr : Sequence[str]
          Output tuple with strings built from the character codes in the
          input tuple.

    See Also
    --------
    tuple_ord, tuple_ords

    Alternatives
    ------------
    tuple_chrt
    """
    with HalconOperator(180) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        chr = proc.get_output_tuple_m(0)
        return chr  # type: ignore


def tuple_chr_s(t: MaybeSequence[int]) -> str:
    """
    Convert a tuple of integer numbers into strings.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple with Unicode character codes or ANSI codes.
        Assertion: 0 <= T

    Returns
    -------

    chr : str
          Output tuple with strings built from the character codes in the
          input tuple.

    See Also
    --------
    tuple_ord, tuple_ords

    Alternatives
    ------------
    tuple_chrt
    """
    with HalconOperator(180) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        chr = proc.get_output_tuple_s(0)
        return chr  # type: ignore


def tuple_chrt(t: MaybeSequence[int]) -> Sequence[Union[str, int]]:
    """
    Convert a tuple of integer numbers into strings.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple with integer numbers.
        Assertion: 0 <= T

    Returns
    -------

    chrt : Sequence[Union[str, int]]
           Output tuple with strings that are separated by the number 0.

    See Also
    --------
    tuple_ord, tuple_ords, read_serial

    Alternatives
    ------------
    tuple_chr
    """
    with HalconOperator(178) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        chrt = proc.get_output_tuple_m(0)
        return chrt  # type: ignore


def tuple_chrt_s(t: MaybeSequence[int]) -> Union[str, int]:
    """
    Convert a tuple of integer numbers into strings.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple with integer numbers.
        Assertion: 0 <= T

    Returns
    -------

    chrt : Union[str, int]
           Output tuple with strings that are separated by the number 0.

    See Also
    --------
    tuple_ord, tuple_ords, read_serial

    Alternatives
    ------------
    tuple_chr
    """
    with HalconOperator(178) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        chrt = proc.get_output_tuple_s(0)
        return chrt  # type: ignore


def tuple_concat(
    t1: MaybeSequence[Union[float, int, str]],
    t2: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Concatenate two tuples to a new one.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    concat : Sequence[Union[float, int, str]]
             Concatenation of input tuples.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_gen_const, tuple_str_bit_select, tuple_select,
    tuple_str_first_n, tuple_str_last_n, tuple_substr
    """
    with HalconOperator(134) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        concat = proc.get_output_tuple_m(0)
        return concat  # type: ignore


def tuple_concat_s(
    t1: MaybeSequence[Union[float, int, str]],
    t2: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Concatenate two tuples to a new one.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    concat : Union[float, int, str]
             Concatenation of input tuples.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_gen_const, tuple_str_bit_select, tuple_select,
    tuple_str_first_n, tuple_str_last_n, tuple_substr
    """
    with HalconOperator(134) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        concat = proc.get_output_tuple_s(0)
        return concat  # type: ignore


def tuple_cos(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the cosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    cos : Sequence[float]
          Cosine of the input tuple.

    See Also
    --------
    tuple_acos, tuple_cosh, tuple_acosh

    Alternatives
    ------------
    tuple_sin, tuple_tan
    """
    with HalconOperator(207) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        cos = proc.get_output_tuple_m(0)
        return cos  # type: ignore


def tuple_cos_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the cosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    cos : float
          Cosine of the input tuple.

    See Also
    --------
    tuple_acos, tuple_cosh, tuple_acosh

    Alternatives
    ------------
    tuple_sin, tuple_tan
    """
    with HalconOperator(207) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        cos = proc.get_output_tuple_s(0)
        return cos  # type: ignore


def tuple_cosh(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the hyperbolic cosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    cosh : Sequence[float]
           Hyperbolic cosine of the input tuple.

    See Also
    --------
    tuple_acosh, tuple_cos, tuple_acos

    Alternatives
    ------------
    tuple_sinh, tuple_tanh
    """
    with HalconOperator(198) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        cosh = proc.get_output_tuple_m(0)
        return cosh  # type: ignore


def tuple_cosh_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the hyperbolic cosine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    cosh : float
           Hyperbolic cosine of the input tuple.

    See Also
    --------
    tuple_acosh, tuple_cos, tuple_acos

    Alternatives
    ------------
    tuple_sinh, tuple_tanh
    """
    with HalconOperator(198) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        cosh = proc.get_output_tuple_s(0)
        return cosh  # type: ignore


def tuple_cumul(
    tuple: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Calculate the cumulative sums of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    Returns
    -------

    cumul : Sequence[Union[float, int]]
            Cumulative sum of the corresponding tuple elements.

    See Also
    --------
    tuple_min2, tuple_max2, tuple_add

    Alternatives
    ------------
    tuple_sum
    """
    with HalconOperator(121) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        cumul = proc.get_output_tuple_m(0)
        return cumul  # type: ignore


def tuple_cumul_s(
    tuple: MaybeSequence[Union[float, int]]
) -> Union[float, int]:
    """
    Calculate the cumulative sums of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    Returns
    -------

    cumul : Union[float, int]
            Cumulative sum of the corresponding tuple elements.

    See Also
    --------
    tuple_min2, tuple_max2, tuple_add

    Alternatives
    ------------
    tuple_sum
    """
    with HalconOperator(121) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        cumul = proc.get_output_tuple_s(0)
        return cumul  # type: ignore


def tuple_deg(rad: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Convert a tuple from radians to degrees.

    Parameters
    ----------

    rad : MaybeSequence[Union[float, int]]
          Input tuple.

    Returns
    -------

    deg : Sequence[float]
          Input tuple in degrees.

    See Also
    --------
    tuple_rad
    """
    with HalconOperator(201) as proc:
        proc.set_input_tuple(0, rad)
        proc.init_oct(0)
        proc.execute()
        deg = proc.get_output_tuple_m(0)
        return deg  # type: ignore


def tuple_deg_s(rad: MaybeSequence[Union[float, int]]) -> float:
    """
    Convert a tuple from radians to degrees.

    Parameters
    ----------

    rad : MaybeSequence[Union[float, int]]
          Input tuple.

    Returns
    -------

    deg : float
          Input tuple in degrees.

    See Also
    --------
    tuple_rad
    """
    with HalconOperator(201) as proc:
        proc.set_input_tuple(0, rad)
        proc.init_oct(0)
        proc.execute()
        deg = proc.get_output_tuple_s(0)
        return deg  # type: ignore


def tuple_deviation(
    tuple: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Return the standard deviation of the elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    Returns
    -------

    deviation : Sequence[float]
                Standard deviation of tuple elements.

    Alternatives
    ------------
    tuple_mean, tuple_sum, tuple_min, tuple_max, tuple_length, tuple_median
    """
    with HalconOperator(126) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        deviation = proc.get_output_tuple_m(0)
        return deviation  # type: ignore


def tuple_deviation_s(tuple: MaybeSequence[Union[float, int]]) -> float:
    """
    Return the standard deviation of the elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    Returns
    -------

    deviation : float
                Standard deviation of tuple elements.

    Alternatives
    ------------
    tuple_mean, tuple_sum, tuple_min, tuple_max, tuple_length, tuple_median
    """
    with HalconOperator(126) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        deviation = proc.get_output_tuple_s(0)
        return deviation  # type: ignore


def tuple_difference(
    set_1: HTupleType,
    set_2: HTupleType
) -> Sequence[HTupleElementType]:
    """
    Compute the difference set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    difference : Sequence[HTupleElementType]
                 The difference set of two input tuples.

    See Also
    --------
    tuple_intersection, tuple_symmdiff, tuple_union

    Alternatives
    ------------
    tuple_symmdiff
    """
    with HalconOperator(98) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        difference = proc.get_output_tuple_m(0)
        return difference  # type: ignore


def tuple_difference_s(
    set_1: HTupleType,
    set_2: HTupleType
) -> HTupleElementType:
    """
    Compute the difference set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    difference : HTupleElementType
                 The difference set of two input tuples.

    See Also
    --------
    tuple_intersection, tuple_symmdiff, tuple_union

    Alternatives
    ------------
    tuple_symmdiff
    """
    with HalconOperator(98) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        difference = proc.get_output_tuple_s(0)
        return difference  # type: ignore


def tuple_div(
    q1: MaybeSequence[Union[float, int]],
    q2: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Divide two tuples.

    Parameters
    ----------

    q1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    q2 : MaybeSequence[Union[float, int]]
         Input tuple 2.
         Assertion: Q2 != 0

    Returns
    -------

    quot : Sequence[Union[float, int]]
           Quotient of the input tuples.

    Alternatives
    ------------
    tuple_mult
    """
    with HalconOperator(213) as proc:
        proc.set_input_tuple(0, q1)
        proc.set_input_tuple(1, q2)
        proc.init_oct(0)
        proc.execute()
        quot = proc.get_output_tuple_m(0)
        return quot  # type: ignore


def tuple_div_s(
    q1: MaybeSequence[Union[float, int]],
    q2: MaybeSequence[Union[float, int]]
) -> Union[float, int]:
    """
    Divide two tuples.

    Parameters
    ----------

    q1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    q2 : MaybeSequence[Union[float, int]]
         Input tuple 2.
         Assertion: Q2 != 0

    Returns
    -------

    quot : Union[float, int]
           Quotient of the input tuples.

    Alternatives
    ------------
    tuple_mult
    """
    with HalconOperator(213) as proc:
        proc.set_input_tuple(0, q1)
        proc.set_input_tuple(1, q2)
        proc.init_oct(0)
        proc.execute()
        quot = proc.get_output_tuple_s(0)
        return quot  # type: ignore


def tuple_environment(names: MaybeSequence[str]) -> Sequence[str]:
    """
    Read one or more environment variables.

    Parameters
    ----------

    names : MaybeSequence[str]
            Tuple containing name(s) of the environment variable(s).

    Returns
    -------

    values : Sequence[str]
             Content of the environment variable(s).

    Alternatives
    ------------
    tuple_strstr, tuple_strrstr, tuple_strchr, tuple_strrchr,
    tuple_strlen, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_substr
    """
    with HalconOperator(146) as proc:
        proc.set_input_tuple(0, names)
        proc.init_oct(0)
        proc.execute()
        values = proc.get_output_tuple_m(0)
        return values  # type: ignore


def tuple_environment_s(names: MaybeSequence[str]) -> str:
    """
    Read one or more environment variables.

    Parameters
    ----------

    names : MaybeSequence[str]
            Tuple containing name(s) of the environment variable(s).

    Returns
    -------

    values : str
             Content of the environment variable(s).

    Alternatives
    ------------
    tuple_strstr, tuple_strrstr, tuple_strchr, tuple_strrchr,
    tuple_strlen, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_substr
    """
    with HalconOperator(146) as proc:
        proc.set_input_tuple(0, names)
        proc.init_oct(0)
        proc.execute()
        values = proc.get_output_tuple_s(0)
        return values  # type: ignore


def tuple_equal(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test whether two tuples are equal.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    equal : int
            Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal, tuple_equal_elem, tuple_not_equal_elem,
    tuple_less_elem, tuple_greater_elem, tuple_less_equal_elem,
    tuple_greater_equal_elem
    """
    with HalconOperator(167) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        equal = proc.get_output_tuple_s(0)
        return equal  # type: ignore


def tuple_equal_elem(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Test, whether two tuples are elementwise equal.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    equal : Sequence[int]
            Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_not_equal_elem, tuple_less_elem, tuple_greater_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(161) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        equal = proc.get_output_tuple_m(0)
        return equal  # type: ignore


def tuple_equal_elem_s(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test, whether two tuples are elementwise equal.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    equal : int
            Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_not_equal_elem, tuple_less_elem, tuple_greater_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(161) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        equal = proc.get_output_tuple_s(0)
        return equal  # type: ignore


def tuple_erf(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the error function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    erf : Sequence[float]
          Value of the error function of the input tuple.

    See Also
    --------
    tuple_exp

    Alternatives
    ------------
    tuple_erfc
    """
    with HalconOperator(2196) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        erf = proc.get_output_tuple_m(0)
        return erf  # type: ignore


def tuple_erf_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the error function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    erf : float
          Value of the error function of the input tuple.

    See Also
    --------
    tuple_exp

    Alternatives
    ------------
    tuple_erfc
    """
    with HalconOperator(2196) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        erf = proc.get_output_tuple_s(0)
        return erf  # type: ignore


def tuple_erfc(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the complementary error function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    erfc : Sequence[float]
           Value of the complementary error function of the input tuple.

    See Also
    --------
    tuple_exp

    Alternatives
    ------------
    tuple_erf
    """
    with HalconOperator(2197) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        erfc = proc.get_output_tuple_m(0)
        return erfc  # type: ignore


def tuple_erfc_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the complementary error function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    erfc : float
           Value of the complementary error function of the input tuple.

    See Also
    --------
    tuple_exp

    Alternatives
    ------------
    tuple_erf
    """
    with HalconOperator(2197) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        erfc = proc.get_output_tuple_s(0)
        return erfc  # type: ignore


def tuple_exp(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the exponential of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    exp : Sequence[float]
          Exponential of the input tuple.

    See Also
    --------
    tuple_log, tuple_log2, tuple_log10

    Alternatives
    ------------
    tuple_exp2, tuple_exp10, tuple_pow
    """
    with HalconOperator(196) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        exp = proc.get_output_tuple_m(0)
        return exp  # type: ignore


def tuple_exp10(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the base 10 exponential of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    exp : Sequence[float]
          Base 10 exponential of the input tuple.

    See Also
    --------
    tuple_log, tuple_log2, tuple_log10

    Alternatives
    ------------
    tuple_exp, tuple_exp2, tuple_pow
    """
    with HalconOperator(2198) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        exp = proc.get_output_tuple_m(0)
        return exp  # type: ignore


def tuple_exp10_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the base 10 exponential of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    exp : float
          Base 10 exponential of the input tuple.

    See Also
    --------
    tuple_log, tuple_log2, tuple_log10

    Alternatives
    ------------
    tuple_exp, tuple_exp2, tuple_pow
    """
    with HalconOperator(2198) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        exp = proc.get_output_tuple_s(0)
        return exp  # type: ignore


def tuple_exp2(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the base 2 exponential of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    exp : Sequence[float]
          Base 2 exponential of the input tuple.

    See Also
    --------
    tuple_log, tuple_log2, tuple_log10

    Alternatives
    ------------
    tuple_exp, tuple_exp10, tuple_pow
    """
    with HalconOperator(2199) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        exp = proc.get_output_tuple_m(0)
        return exp  # type: ignore


def tuple_exp2_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the base 2 exponential of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    exp : float
          Base 2 exponential of the input tuple.

    See Also
    --------
    tuple_log, tuple_log2, tuple_log10

    Alternatives
    ------------
    tuple_exp, tuple_exp10, tuple_pow
    """
    with HalconOperator(2199) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        exp = proc.get_output_tuple_s(0)
        return exp  # type: ignore


def tuple_exp_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the exponential of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    exp : float
          Exponential of the input tuple.

    See Also
    --------
    tuple_log, tuple_log2, tuple_log10

    Alternatives
    ------------
    tuple_exp2, tuple_exp10, tuple_pow
    """
    with HalconOperator(196) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        exp = proc.get_output_tuple_s(0)
        return exp  # type: ignore


def tuple_fabs(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the absolute value of a tuple (as floating point numbers).

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    abs : Sequence[float]
          Absolute value of the input tuple.

    Alternatives
    ------------
    tuple_abs
    """
    with HalconOperator(209) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        abs = proc.get_output_tuple_m(0)
        return abs  # type: ignore


def tuple_fabs_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the absolute value of a tuple (as floating point numbers).

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    abs : float
          Absolute value of the input tuple.

    Alternatives
    ------------
    tuple_abs
    """
    with HalconOperator(209) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        abs = proc.get_output_tuple_s(0)
        return abs  # type: ignore


def tuple_find(
    tuple: MaybeSequence[Union[float, int, str]],
    to_find: MaybeSequence[Union[float, int, str]]
) -> Sequence[int]:
    """
    Return the indices of all occurrences of a tuple within another tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple to examine.

    to_find : MaybeSequence[Union[float, int, str]]
              Input tuple with values to find.

    Returns
    -------

    indices : Sequence[int]
              Indices of the occurrences of the values to find in the
              tuple to examine.

    Alternatives
    ------------
    tuple_find_first, tuple_find_last, tuple_sort, tuple_inverse,
    tuple_equal_elem
    """
    with HalconOperator(130) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_m(0)
        return indices  # type: ignore


def tuple_find_first(
    tuple: MaybeSequence[Union[int, float, str]],
    to_find: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Return the index of the first occurrence of a tuple within another
    tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[int, float, str]]
            Input tuple to examine.

    to_find : MaybeSequence[Union[int, float, str]]
              Input tuple with values to find.

    Returns
    -------

    index : int
            Index of the first occurrence of the values to find.

    Alternatives
    ------------
    tuple_find, tuple_find_last, tuple_sort, tuple_equal_elem
    """
    with HalconOperator(129) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def tuple_find_last(
    tuple: MaybeSequence[Union[int, float, str]],
    to_find: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Return the index of the last occurrence of a tuple within another
    tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[int, float, str]]
            Input tuple to examine.

    to_find : MaybeSequence[Union[int, float, str]]
              Input tuple with values to find.

    Returns
    -------

    index : int
            Index of the last occurrence of the values to find.

    Alternatives
    ------------
    tuple_find, tuple_find_first, tuple_sort, tuple_equal_elem
    """
    with HalconOperator(128) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        index = proc.get_output_tuple_s(0)
        return index  # type: ignore


def tuple_find_s(
    tuple: MaybeSequence[Union[float, int, str]],
    to_find: MaybeSequence[Union[float, int, str]]
) -> int:
    """
    Return the indices of all occurrences of a tuple within another tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple to examine.

    to_find : MaybeSequence[Union[float, int, str]]
              Input tuple with values to find.

    Returns
    -------

    indices : int
              Indices of the occurrences of the values to find in the
              tuple to examine.

    Alternatives
    ------------
    tuple_find_first, tuple_find_last, tuple_sort, tuple_inverse,
    tuple_equal_elem
    """
    with HalconOperator(130) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_s(0)
        return indices  # type: ignore


def tuple_first_n(
    tuple: MaybeSequence[Union[float, int, str]],
    index: int
) -> Sequence[Union[float, int, str]]:
    """
    Select the first elements of a tuple up to the index ``n''.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : int
            Index of the last element to select.

    Returns
    -------

    selected : Sequence[Union[float, int, str]]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_last_n, tuple_select, tuple_str_bit_select, tuple_concat,
    tuple_select_mask
    """
    with HalconOperator(137) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_m(0)
        return selected  # type: ignore


def tuple_first_n_s(
    tuple: MaybeSequence[Union[float, int, str]],
    index: int
) -> Union[float, int, str]:
    """
    Select the first elements of a tuple up to the index ``n''.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : int
            Index of the last element to select.

    Returns
    -------

    selected : Union[float, int, str]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_last_n, tuple_select, tuple_str_bit_select, tuple_concat,
    tuple_select_mask
    """
    with HalconOperator(137) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_floor(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the floor function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    floor : Sequence[float]
            Floor function of the input tuple.

    Alternatives
    ------------
    tuple_ceil
    """
    with HalconOperator(192) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        floor = proc.get_output_tuple_m(0)
        return floor  # type: ignore


def tuple_floor_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the floor function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    floor : float
            Floor function of the input tuple.

    Alternatives
    ------------
    tuple_ceil
    """
    with HalconOperator(192) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        floor = proc.get_output_tuple_s(0)
        return floor  # type: ignore


def tuple_fmod(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the remainder of the floating point division of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.
         Assertion: T2 != 0.0

    Returns
    -------

    fmod : Sequence[float]
           Remainder of the division of the input tuples.

    See Also
    --------
    tuple_floor, tuple_ceil

    Alternatives
    ------------
    tuple_mod
    """
    with HalconOperator(189) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        fmod = proc.get_output_tuple_m(0)
        return fmod  # type: ignore


def tuple_fmod_s(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the remainder of the floating point division of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.
         Assertion: T2 != 0.0

    Returns
    -------

    fmod : float
           Remainder of the division of the input tuples.

    See Also
    --------
    tuple_floor, tuple_ceil

    Alternatives
    ------------
    tuple_mod
    """
    with HalconOperator(189) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        fmod = proc.get_output_tuple_s(0)
        return fmod  # type: ignore


def tuple_gen_const(
    length: Union[float, int],
    const: HTupleElementType
) -> Sequence[Union[float, int, str]]:
    """
    Generate a tuple of a specific length and initialize its elements.

    Parameters
    ----------

    length : Union[float, int]
             Length of tuple to generate.

    const : HTupleElementType
            Constant for initializing the tuple elements.

    Returns
    -------

    newtuple : Sequence[Union[float, int, str]]
               New Tuple.

    See Also
    --------
    tuple_rand

    Alternatives
    ------------
    tuple_str_bit_select, tuple_select, tuple_str_first_n,
    tuple_str_last_n, tuple_concat, tuple_insert, tuple_replace,
    tuple_gen_sequence
    """
    with HalconOperator(145) as proc:
        proc.set_input_tuple(0, length)
        proc.set_input_tuple(1, const)
        proc.init_oct(0)
        proc.execute()
        newtuple = proc.get_output_tuple_m(0)
        return newtuple  # type: ignore


def tuple_gen_const_s(
    length: Union[float, int],
    const: HTupleElementType
) -> Union[float, int, str]:
    """
    Generate a tuple of a specific length and initialize its elements.

    Parameters
    ----------

    length : Union[float, int]
             Length of tuple to generate.

    const : HTupleElementType
            Constant for initializing the tuple elements.

    Returns
    -------

    newtuple : Union[float, int, str]
               New Tuple.

    See Also
    --------
    tuple_rand

    Alternatives
    ------------
    tuple_str_bit_select, tuple_select, tuple_str_first_n,
    tuple_str_last_n, tuple_concat, tuple_insert, tuple_replace,
    tuple_gen_sequence
    """
    with HalconOperator(145) as proc:
        proc.set_input_tuple(0, length)
        proc.set_input_tuple(1, const)
        proc.init_oct(0)
        proc.execute()
        newtuple = proc.get_output_tuple_s(0)
        return newtuple  # type: ignore


def tuple_gen_sequence(
    start: Union[float, int],
    end: Union[float, int],
    step: Union[float, int]
) -> Sequence[Union[float, int]]:
    """
    Generate a tuple with a sequence of equidistant values.

    Parameters
    ----------

    start : Union[float, int]
            Start value of the tuple.

    end : Union[float, int]
          Maximum value for the last entry.

    step : Union[float, int]
           Increment value.

    Returns
    -------

    sequence : Sequence[Union[float, int]]
               The resulting sequence.

    See Also
    --------
    tuple_rand

    Alternatives
    ------------
    tuple_str_bit_select, tuple_select, tuple_str_first_n,
    tuple_str_last_n, tuple_concat, tuple_insert, tuple_replace,
    tuple_gen_const
    """
    with HalconOperator(144) as proc:
        proc.set_input_tuple(0, start)
        proc.set_input_tuple(1, end)
        proc.set_input_tuple(2, step)
        proc.init_oct(0)
        proc.execute()
        sequence = proc.get_output_tuple_m(0)
        return sequence  # type: ignore


def tuple_gen_sequence_s(
    start: Union[float, int],
    end: Union[float, int],
    step: Union[float, int]
) -> Union[float, int]:
    """
    Generate a tuple with a sequence of equidistant values.

    Parameters
    ----------

    start : Union[float, int]
            Start value of the tuple.

    end : Union[float, int]
          Maximum value for the last entry.

    step : Union[float, int]
           Increment value.

    Returns
    -------

    sequence : Union[float, int]
               The resulting sequence.

    See Also
    --------
    tuple_rand

    Alternatives
    ------------
    tuple_str_bit_select, tuple_select, tuple_str_first_n,
    tuple_str_last_n, tuple_concat, tuple_insert, tuple_replace,
    tuple_gen_const
    """
    with HalconOperator(144) as proc:
        proc.set_input_tuple(0, start)
        proc.set_input_tuple(1, end)
        proc.set_input_tuple(2, step)
        proc.init_oct(0)
        proc.execute()
        sequence = proc.get_output_tuple_s(0)
        return sequence  # type: ignore


def tuple_greater(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test whether a tuple is greater than another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    greater : int
              Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_greater_equal, tuple_less, tuple_less_equal, tuple_equal,
    tuple_not_equal, tuple_equal_elem, tuple_not_equal_elem,
    tuple_less_elem, tuple_greater_elem, tuple_less_equal_elem,
    tuple_greater_equal_elem
    """
    with HalconOperator(165) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        greater = proc.get_output_tuple_s(0)
        return greater  # type: ignore


def tuple_greater_elem(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Test, whether a tuple is elementwise greater than another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    greater : Sequence[int]
              Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_less_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(159) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        greater = proc.get_output_tuple_m(0)
        return greater  # type: ignore


def tuple_greater_elem_s(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test, whether a tuple is elementwise greater than another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    greater : int
              Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_less_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(159) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        greater = proc.get_output_tuple_s(0)
        return greater  # type: ignore


def tuple_greater_equal(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test whether a tuple is greater or equal to another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    greatereq : int
                Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_greater, tuple_less, tuple_less_equal, tuple_equal,
    tuple_not_equal, tuple_equal_elem, tuple_not_equal_elem,
    tuple_less_elem, tuple_greater_elem, tuple_less_equal_elem,
    tuple_greater_equal_elem
    """
    with HalconOperator(164) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        greatereq = proc.get_output_tuple_s(0)
        return greatereq  # type: ignore


def tuple_greater_equal_elem(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Test, whether a tuple is elementwise greater or equal to another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    greatereq : Sequence[int]
                Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_less_elem,
    tuple_greater_elem, tuple_less_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(158) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        greatereq = proc.get_output_tuple_m(0)
        return greatereq  # type: ignore


def tuple_greater_equal_elem_s(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test, whether a tuple is elementwise greater or equal to another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    greatereq : int
                Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_less_elem,
    tuple_greater_elem, tuple_less_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(158) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        greatereq = proc.get_output_tuple_s(0)
        return greatereq  # type: ignore


def tuple_histo_range(
    tuple: Sequence[Union[float, int]],
    min: Union[float, int],
    max: Union[float, int],
    num_bins: int
) -> Tuple[Sequence[int], float]:
    """
    Calculate the value distribution of a tuple within a certain value
    range.

    Parameters
    ----------

    tuple : Sequence[Union[float, int]]
            Input tuple.

    min : Union[float, int]
          Minimum value.

    max : Union[float, int]
          Maximum value.
          Assertion: Max >= Min

    num_bins : int
               Number of bins.
               Assertion: NumBins >= 1

    Returns
    -------

    histo : Sequence[int]
            Histogram to be calculated.

    bin_size : float
               Bin size.

    See Also
    --------
    gray_histo, gray_histo_abs, gray_histo_range

    Predecessors
    ------------
    tuple_min, tuple_max

    Successors
    ----------
    create_funct_1d_array

    Notes
    -----
    If all the data of the Tuple are of type integer the value of BinSize
    may cause the following effects: For BinSize $>$ 1 multiple
    consecutive numbers are assigned to the same bin. If BinSize is no
    integer the numbers are distributed uneven among the bins, e.g., for
    BinSize $=$ 1.5 the first and second number are assigned to the first
    bin, the third number is assigned to the second bin, and the fourth
    and fifth number are assigned to the third bin. This becomes
    noticeable in several peeks in the histogram Histo. If BinSize $<$ 1
    some classes are not assigned by any number, e.g., for BinSize $=$ 0.5
    the first number is assigned to the first bin and the second number is
    assigned to the third bin. The histogram Histo shows some gaps, which
    resembles the structure of a comb.
    If the Tuple has entries of type real and $Min = Max$, all entries of
    the corresponding value are assigned only to the first bin.
    """
    with HalconOperator(109) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, min)
        proc.set_input_tuple(2, max)
        proc.set_input_tuple(3, num_bins)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # histo
            proc.get_output_tuple_s(1)   # bin_size
        )  # type: ignore


def tuple_histo_range_s(
    tuple: Sequence[Union[float, int]],
    min: Union[float, int],
    max: Union[float, int],
    num_bins: int
) -> Tuple[int, float]:
    """
    Calculate the value distribution of a tuple within a certain value
    range.

    Parameters
    ----------

    tuple : Sequence[Union[float, int]]
            Input tuple.

    min : Union[float, int]
          Minimum value.

    max : Union[float, int]
          Maximum value.
          Assertion: Max >= Min

    num_bins : int
               Number of bins.
               Assertion: NumBins >= 1

    Returns
    -------

    histo : int
            Histogram to be calculated.

    bin_size : float
               Bin size.

    See Also
    --------
    gray_histo, gray_histo_abs, gray_histo_range

    Predecessors
    ------------
    tuple_min, tuple_max

    Successors
    ----------
    create_funct_1d_array

    Notes
    -----
    If all the data of the Tuple are of type integer the value of BinSize
    may cause the following effects: For BinSize $>$ 1 multiple
    consecutive numbers are assigned to the same bin. If BinSize is no
    integer the numbers are distributed uneven among the bins, e.g., for
    BinSize $=$ 1.5 the first and second number are assigned to the first
    bin, the third number is assigned to the second bin, and the fourth
    and fifth number are assigned to the third bin. This becomes
    noticeable in several peeks in the histogram Histo. If BinSize $<$ 1
    some classes are not assigned by any number, e.g., for BinSize $=$ 0.5
    the first number is assigned to the first bin and the second number is
    assigned to the third bin. The histogram Histo shows some gaps, which
    resembles the structure of a comb.
    If the Tuple has entries of type real and $Min = Max$, all entries of
    the corresponding value are assigned only to the first bin.
    """
    with HalconOperator(109) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, min)
        proc.set_input_tuple(2, max)
        proc.set_input_tuple(3, num_bins)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # histo
            proc.get_output_tuple_s(1)   # bin_size
        )  # type: ignore


def tuple_hypot(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the hypotenuse of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    hypot : Sequence[float]
            Hypotenuse of the input tuples.

    See Also
    --------
    tuple_mult, tuple_add

    Alternatives
    ------------
    tuple_sqrt
    """
    with HalconOperator(2200) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        hypot = proc.get_output_tuple_m(0)
        return hypot  # type: ignore


def tuple_hypot_s(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the hypotenuse of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    hypot : float
            Hypotenuse of the input tuples.

    See Also
    --------
    tuple_mult, tuple_add

    Alternatives
    ------------
    tuple_sqrt
    """
    with HalconOperator(2200) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        hypot = proc.get_output_tuple_s(0)
        return hypot  # type: ignore


def tuple_insert(
    tuple: MaybeSequence[Union[float, int, str]],
    index: int,
    insert_tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Inserts one or more elements into a tuple at index.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : int
            Start index of elements to be inserted.

    insert_tuple : MaybeSequence[Union[float, int, str]]
                   Element(s) to insert at index.

    Returns
    -------

    extended : Sequence[Union[float, int, str]]
               Tuple with inserted elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_concat, tuple_replace, tuple_gen_const
    """
    with HalconOperator(138) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, insert_tuple)
        proc.init_oct(0)
        proc.execute()
        extended = proc.get_output_tuple_m(0)
        return extended  # type: ignore


def tuple_int(t: MaybeSequence[Union[float, int]]) -> Sequence[int]:
    """
    Convert a tuple into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    int : Sequence[int]
          Result of the conversion into integer numbers.

    Alternatives
    ------------
    tuple_round
    """
    with HalconOperator(186) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        int = proc.get_output_tuple_m(0)
        return int  # type: ignore


def tuple_int_s(t: MaybeSequence[Union[float, int]]) -> int:
    """
    Convert a tuple into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    int : int
          Result of the conversion into integer numbers.

    Alternatives
    ------------
    tuple_round
    """
    with HalconOperator(186) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        int = proc.get_output_tuple_s(0)
        return int  # type: ignore


def tuple_intersection(
    set_1: HTupleType,
    set_2: HTupleType
) -> Sequence[HTupleElementType]:
    """
    Compute the intersection set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    intersection : Sequence[HTupleElementType]
                   The intersection set of two input tuples.

    See Also
    --------
    tuple_difference, tuple_symmdiff, tuple_union

    Alternatives
    ------------
    tuple_union
    """
    with HalconOperator(97) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        intersection = proc.get_output_tuple_m(0)
        return intersection  # type: ignore


def tuple_intersection_s(
    set_1: HTupleType,
    set_2: HTupleType
) -> HTupleElementType:
    """
    Compute the intersection set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    intersection : HTupleElementType
                   The intersection set of two input tuples.

    See Also
    --------
    tuple_difference, tuple_symmdiff, tuple_union

    Alternatives
    ------------
    tuple_union
    """
    with HalconOperator(97) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        intersection = proc.get_output_tuple_s(0)
        return intersection  # type: ignore


def tuple_inverse(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Invert a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    inverted : Sequence[Union[float, int, str]]
               Inverted input tuple.

    Alternatives
    ------------
    tuple_sort, tuple_sort_index
    """
    with HalconOperator(133) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        inverted = proc.get_output_tuple_m(0)
        return inverted  # type: ignore


def tuple_inverse_s(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Invert a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    inverted : Union[float, int, str]
               Inverted input tuple.

    Alternatives
    ------------
    tuple_sort, tuple_sort_index
    """
    with HalconOperator(133) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        inverted = proc.get_output_tuple_s(0)
        return inverted  # type: ignore


def tuple_is_handle(t: HTupleType) -> int:
    """
    Test if the internal representation of a tuple is of type handle.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_handle : int
                Boolean value indicating if the input tuple is of type
                handle.

    See Also
    --------
    tuple_is_int, tuple_is_real, tuple_is_string

    Alternatives
    ------------
    tuple_type, tuple_is_number, tuple_is_handle_elem, tuple_is_string,
    tuple_sem_type

    Notes
    -----
    Even if all tuple elements are of type handle, tuple_is_handle returns
    0 (false) if the internal representation of the tuple is of type
    H_TYPE_MIXED. To test if the elements of the tuple are of type handle,
    the operator tuple_is_handle_elem should be used.
    """
    with HalconOperator(2139) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_handle = proc.get_output_tuple_s(0)
        return is_handle  # type: ignore


def tuple_is_handle_elem(t: HTupleType) -> Sequence[int]:
    """
    Test whether the elements of a tuple are of type handle.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_handle : Sequence[int]
                Boolean values indicating if the elements of the input
                tuple are of type handle.

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_int_elem, tuple_is_real_elem,
    tuple_is_number, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_handle
    """
    with HalconOperator(2140) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_handle = proc.get_output_tuple_m(0)
        return is_handle  # type: ignore


def tuple_is_handle_elem_s(t: HTupleType) -> int:
    """
    Test whether the elements of a tuple are of type handle.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_handle : int
                Boolean values indicating if the elements of the input
                tuple are of type handle.

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_int_elem, tuple_is_real_elem,
    tuple_is_number, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_handle
    """
    with HalconOperator(2140) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_handle = proc.get_output_tuple_s(0)
        return is_handle  # type: ignore


def tuple_is_int(t: HTupleType) -> int:
    """
    Test if the internal representation of a tuple is of type integer.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_int : int
             Is the input tuple of type integer?

    See Also
    --------
    tuple_is_real, tuple_is_string, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_is_number, tuple_is_int_elem

    Notes
    -----
    Even if all tuple elements are of type integer, tuple_is_int returns 0
    (false) if the internal representation of the tuple is of type
    H_TYPE_MIXED. To test if the elements of the tuple are of type integer
    the operator tuple_is_int_elem should be used.
    """
    with HalconOperator(107) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_int = proc.get_output_tuple_s(0)
        return is_int  # type: ignore


def tuple_is_int_elem(t: HTupleType) -> Sequence[int]:
    """
    Test whether the types of the elements of a tuple are of type integer.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_int : Sequence[int]
             Are the elements of the input tuple of type integer?

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_real_elem, tuple_is_string_elem,
    tuple_is_number, tuple_is_handle_elem, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_int

    Notes
    -----
    tuple_is_int_elem returns true if the internal data type of the
    elements of the tuple is integer. In contrast to tuple_is_number it
    does not return whether the elements of a tuple could be represented
    as integer values.
    """
    with HalconOperator(102) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_int = proc.get_output_tuple_m(0)
        return is_int  # type: ignore


def tuple_is_int_elem_s(t: HTupleType) -> int:
    """
    Test whether the types of the elements of a tuple are of type integer.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_int : int
             Are the elements of the input tuple of type integer?

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_real_elem, tuple_is_string_elem,
    tuple_is_number, tuple_is_handle_elem, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_int

    Notes
    -----
    tuple_is_int_elem returns true if the internal data type of the
    elements of the tuple is integer. In contrast to tuple_is_number it
    does not return whether the elements of a tuple could be represented
    as integer values.
    """
    with HalconOperator(102) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_int = proc.get_output_tuple_s(0)
        return is_int  # type: ignore


def tuple_is_mixed(t: HTupleType) -> int:
    """
    Test whether a tuple is of type mixed.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_mixed : int
               Is the input tuple of type mixed?

    See Also
    --------
    tuple_is_int, tuple_is_real

    Alternatives
    ------------
    tuple_type, tuple_is_number
    """
    with HalconOperator(104) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_mixed = proc.get_output_tuple_s(0)
        return is_mixed  # type: ignore


def tuple_is_number(
    t: MaybeSequence[Union[float, int, str]]
) -> Sequence[int]:
    """
    Check a tuple (of strings) whether it represents numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int, str]]
        Input tuple.

    Returns
    -------

    is_number : Sequence[int]
                Tuple with Boolean numbers.

    See Also
    --------
    tuple_number

    Alternatives
    ------------
    tuple_is_int, tuple_is_real, tuple_type
    """
    with HalconOperator(183) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_number = proc.get_output_tuple_m(0)
        return is_number  # type: ignore


def tuple_is_number_s(t: MaybeSequence[Union[float, int, str]]) -> int:
    """
    Check a tuple (of strings) whether it represents numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int, str]]
        Input tuple.

    Returns
    -------

    is_number : int
                Tuple with Boolean numbers.

    See Also
    --------
    tuple_number

    Alternatives
    ------------
    tuple_is_int, tuple_is_real, tuple_type
    """
    with HalconOperator(183) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_number = proc.get_output_tuple_s(0)
        return is_number  # type: ignore


def tuple_is_real(t: HTupleType) -> int:
    """
    Test if the internal representation of a tuple is of type real.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_real : int
              Is the input tuple of type real?

    See Also
    --------
    tuple_is_int, tuple_is_string, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_is_number, tuple_is_real_elem

    Notes
    -----
    Even if all tuple elements are of type real, tuple_is_real returns 0
    (false) if the internal representation of the tuple is of type
    H_TYPE_MIXED. To test if the elements of the tuple are of type real
    the operator tuple_is_real_elem should be used.
    """
    with HalconOperator(106) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_real = proc.get_output_tuple_s(0)
        return is_real  # type: ignore


def tuple_is_real_elem(t: HTupleType) -> Sequence[int]:
    """
    Test whether the types of the elements of a tuple are of type real.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_real : Sequence[int]
              Are the elements of the input tuple of type real?

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_int_elem, tuple_is_string_elem,
    tuple_is_number, tuple_is_handle_elem, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_real

    Notes
    -----
    tuple_is_real_elem returns true if the internal data type of the
    elements of the tuple is real. In contrast to tuple_is_number it does
    not return whether the elements of a tuple could be represented as
    real values.
    """
    with HalconOperator(101) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_real = proc.get_output_tuple_m(0)
        return is_real  # type: ignore


def tuple_is_real_elem_s(t: HTupleType) -> int:
    """
    Test whether the types of the elements of a tuple are of type real.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_real : int
              Are the elements of the input tuple of type real?

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_int_elem, tuple_is_string_elem,
    tuple_is_number, tuple_is_handle_elem, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_real

    Notes
    -----
    tuple_is_real_elem returns true if the internal data type of the
    elements of the tuple is real. In contrast to tuple_is_number it does
    not return whether the elements of a tuple could be represented as
    real values.
    """
    with HalconOperator(101) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_real = proc.get_output_tuple_s(0)
        return is_real  # type: ignore


def tuple_is_serializable(tuple: HTupleType) -> int:
    """
    Test if a tuple is serializable.

    Parameters
    ----------

    tuple : HTupleType
            Tuple to check for serializability.

    Returns
    -------

    is_serializable : int
                      Boolean value indicating if the input can be
                      serialized.

    See Also
    --------
    tuple_is_serializable_elem, serialize_tuple, serialize_handle,
    deserialize_tuple, deserialize_handle, write_tuple

    Alternatives
    ------------
    tuple_is_serializable_elem

    Successors
    ----------
    serialize_tuple, write_tuple
    """
    with HalconOperator(2141) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        is_serializable = proc.get_output_tuple_s(0)
        return is_serializable  # type: ignore


def tuple_is_serializable_elem(tuple: HTupleType) -> Sequence[int]:
    """
    Test if the elements of a tuple are serializable.

    Parameters
    ----------

    tuple : HTupleType
            Tuple to check for serializability.

    Returns
    -------

    is_serializable_elem : Sequence[int]
                           Boolean value indicating if the input elements
                           can be serialized.

    See Also
    --------
    tuple_is_serializable, serialize_tuple, serialize_handle,
    deserialize_tuple, deserialize_handle, write_tuple

    Alternatives
    ------------
    tuple_is_serializable

    Successors
    ----------
    serialize_tuple, write_tuple
    """
    with HalconOperator(2142) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        is_serializable_elem = proc.get_output_tuple_m(0)
        return is_serializable_elem  # type: ignore


def tuple_is_serializable_elem_s(tuple: HTupleType) -> int:
    """
    Test if the elements of a tuple are serializable.

    Parameters
    ----------

    tuple : HTupleType
            Tuple to check for serializability.

    Returns
    -------

    is_serializable_elem : int
                           Boolean value indicating if the input elements
                           can be serialized.

    See Also
    --------
    tuple_is_serializable, serialize_tuple, serialize_handle,
    deserialize_tuple, deserialize_handle, write_tuple

    Alternatives
    ------------
    tuple_is_serializable

    Successors
    ----------
    serialize_tuple, write_tuple
    """
    with HalconOperator(2142) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        is_serializable_elem = proc.get_output_tuple_s(0)
        return is_serializable_elem  # type: ignore


def tuple_is_string(t: HTupleType) -> int:
    """
    Test if the internal representation of a tuple is of type string.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_string : int
                Is the input tuple of type string?

    See Also
    --------
    tuple_is_int, tuple_is_real, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_is_number, tuple_is_string_elem

    Notes
    -----
    Even if all tuple elements are of type string, tuple_is_string returns
    0 (false) if the internal representation of the tuple is of type
    H_TYPE_MIXED. To test if the elements of the tuple are of type string
    the operator tuple_is_string_elem should be used.
    """
    with HalconOperator(105) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_string = proc.get_output_tuple_s(0)
        return is_string  # type: ignore


def tuple_is_string_elem(t: HTupleType) -> Sequence[int]:
    """
    Test whether the types of the elements of a tuple are of type string.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_string : Sequence[int]
                Are the elements of the input tuple of type string?

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_int_elem, tuple_is_real_elem,
    tuple_is_number, tuple_is_handle_elem, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_string
    """
    with HalconOperator(100) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_string = proc.get_output_tuple_m(0)
        return is_string  # type: ignore


def tuple_is_string_elem_s(t: HTupleType) -> int:
    """
    Test whether the types of the elements of a tuple are of type string.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    is_string : int
                Are the elements of the input tuple of type string?

    See Also
    --------
    tuple_is_mixed, tuple_is_int, tuple_is_real, tuple_is_string,
    tuple_is_mixed, tuple_is_int_elem, tuple_is_real_elem,
    tuple_is_number, tuple_is_handle_elem, tuple_is_handle

    Alternatives
    ------------
    tuple_type, tuple_type_elem, tuple_is_string
    """
    with HalconOperator(100) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        is_string = proc.get_output_tuple_s(0)
        return is_string  # type: ignore


def tuple_is_valid_handle(handle: MaybeSequence[HHandle]) -> Sequence[int]:
    """
    Check if a handle is valid.

    Parameters
    ----------

    handle : MaybeSequence[HHandle]
             The handle to check for validity.

    Returns
    -------

    is_valid : Sequence[int]
               The validity of the handle, 1 or 0.
    """
    with HalconOperator(2143) as proc:
        proc.set_input_tuple(0, handle)
        proc.init_oct(0)
        proc.execute()
        is_valid = proc.get_output_tuple_m(0)
        return is_valid  # type: ignore


def tuple_is_valid_handle_s(handle: MaybeSequence[HHandle]) -> int:
    """
    Check if a handle is valid.

    Parameters
    ----------

    handle : MaybeSequence[HHandle]
             The handle to check for validity.

    Returns
    -------

    is_valid : int
               The validity of the handle, 1 or 0.
    """
    with HalconOperator(2143) as proc:
        proc.set_input_tuple(0, handle)
        proc.init_oct(0)
        proc.execute()
        is_valid = proc.get_output_tuple_s(0)
        return is_valid  # type: ignore


def tuple_last_n(
    tuple: MaybeSequence[Union[float, int, str]],
    index: int
) -> Sequence[Union[float, int, str]]:
    """
    Select all elements from index ``n'' to the end of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : int
            Index of the first element to select.

    Returns
    -------

    selected : Sequence[Union[float, int, str]]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_first_n, tuple_select, tuple_str_bit_select, tuple_concat,
    tuple_select_mask
    """
    with HalconOperator(136) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_m(0)
        return selected  # type: ignore


def tuple_last_n_s(
    tuple: MaybeSequence[Union[float, int, str]],
    index: int
) -> Union[float, int, str]:
    """
    Select all elements from index ``n'' to the end of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : int
            Index of the first element to select.

    Returns
    -------

    selected : Union[float, int, str]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_first_n, tuple_select, tuple_str_bit_select, tuple_concat,
    tuple_select_mask
    """
    with HalconOperator(136) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_ldexp(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the ldexp function of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    ldexp : Sequence[float]
            Ldexp function of the input tuples.

    See Also
    --------
    tuple_exp
    """
    with HalconOperator(188) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        ldexp = proc.get_output_tuple_m(0)
        return ldexp  # type: ignore


def tuple_ldexp_s(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the ldexp function of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    ldexp : float
            Ldexp function of the input tuples.

    See Also
    --------
    tuple_exp
    """
    with HalconOperator(188) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        ldexp = proc.get_output_tuple_s(0)
        return ldexp  # type: ignore


def tuple_length(tuple: MaybeSequence[Union[float, int, str]]) -> int:
    """
    Return the number of elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    length : int
             Number of elements of input tuple.

    See Also
    --------
    tuple_type

    Alternatives
    ------------
    tuple_min, tuple_max, tuple_mean, tuple_deviation, tuple_sum,
    tuple_median
    """
    with HalconOperator(115) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_s(0)
        return length  # type: ignore


def tuple_less(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test whether a tuple is less than another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    less : int
           Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_less_equal, tuple_greater, tuple_greater_equal, tuple_equal,
    tuple_not_equal, tuple_equal_elem, tuple_not_equal_elem,
    tuple_less_elem, tuple_greater_elem, tuple_less_equal_elem,
    tuple_greater_equal_elem
    """
    with HalconOperator(163) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        less = proc.get_output_tuple_s(0)
        return less  # type: ignore


def tuple_less_elem(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Test, whether a tuple is elementwise less than another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    less : Sequence[int]
           Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_greater_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(157) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        less = proc.get_output_tuple_m(0)
        return less  # type: ignore


def tuple_less_elem_s(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test, whether a tuple is elementwise less than another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    less : int
           Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_greater_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(157) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        less = proc.get_output_tuple_s(0)
        return less  # type: ignore


def tuple_less_equal(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test whether a tuple is less or equal to another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    lesseq : int
             Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_less, tuple_greater, tuple_greater_equal, tuple_equal,
    tuple_not_equal, tuple_equal_elem, tuple_not_equal_elem,
    tuple_less_elem, tuple_greater_elem, tuple_less_equal_elem,
    tuple_greater_equal_elem
    """
    with HalconOperator(162) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        lesseq = proc.get_output_tuple_s(0)
        return lesseq  # type: ignore


def tuple_less_equal_elem(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Test, whether a tuple is elementwise less or equal to another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    lesseq : Sequence[int]
             Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_greater_elem,
    tuple_less_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(156) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        lesseq = proc.get_output_tuple_m(0)
        return lesseq  # type: ignore


def tuple_less_equal_elem_s(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test, whether a tuple is elementwise less or equal to another tuple.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    lesseq : int
             Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_not_equal_elem, tuple_greater_elem,
    tuple_less_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(156) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        lesseq = proc.get_output_tuple_s(0)
        return lesseq  # type: ignore


def tuple_lgamma(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the logarithm of the absolute value of the gamma function of a
    tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    log_gamma : Sequence[float]
                Logarithm of the absolute value of the gamma function of
                the input tuple.

    Alternatives
    ------------
    tuple_tgamma
    """
    with HalconOperator(2201) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log_gamma = proc.get_output_tuple_m(0)
        return log_gamma  # type: ignore


def tuple_lgamma_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the logarithm of the absolute value of the gamma function of a
    tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    log_gamma : float
                Logarithm of the absolute value of the gamma function of
                the input tuple.

    Alternatives
    ------------
    tuple_tgamma
    """
    with HalconOperator(2201) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log_gamma = proc.get_output_tuple_s(0)
        return log_gamma  # type: ignore


def tuple_log(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the natural logarithm of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T > 0

    Returns
    -------

    log : Sequence[float]
          Natural logarithm of the input tuple.

    See Also
    --------
    tuple_exp, tuple_exp2, tuple_exp10, tuple_pow

    Alternatives
    ------------
    tuple_log2, tuple_log10
    """
    with HalconOperator(195) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log = proc.get_output_tuple_m(0)
        return log  # type: ignore


def tuple_log10(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the base 10 logarithm of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T > 0

    Returns
    -------

    log : Sequence[float]
          Base 10 logarithm of the input tuple.

    See Also
    --------
    tuple_exp, tuple_exp2, tuple_exp10, tuple_pow

    Alternatives
    ------------
    tuple_log, tuple_log2
    """
    with HalconOperator(194) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log = proc.get_output_tuple_m(0)
        return log  # type: ignore


def tuple_log10_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the base 10 logarithm of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T > 0

    Returns
    -------

    log : float
          Base 10 logarithm of the input tuple.

    See Also
    --------
    tuple_exp, tuple_exp2, tuple_exp10, tuple_pow

    Alternatives
    ------------
    tuple_log, tuple_log2
    """
    with HalconOperator(194) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log = proc.get_output_tuple_s(0)
        return log  # type: ignore


def tuple_log2(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the base 2 logarithm of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T > 0

    Returns
    -------

    log : Sequence[float]
          Base 2 logarithm of the input tuple.

    See Also
    --------
    tuple_exp, tuple_exp2, tuple_exp10, tuple_pow

    Alternatives
    ------------
    tuple_log, tuple_log10
    """
    with HalconOperator(2202) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log = proc.get_output_tuple_m(0)
        return log  # type: ignore


def tuple_log2_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the base 2 logarithm of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T > 0

    Returns
    -------

    log : float
          Base 2 logarithm of the input tuple.

    See Also
    --------
    tuple_exp, tuple_exp2, tuple_exp10, tuple_pow

    Alternatives
    ------------
    tuple_log, tuple_log10
    """
    with HalconOperator(2202) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log = proc.get_output_tuple_s(0)
        return log  # type: ignore


def tuple_log_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the natural logarithm of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T > 0

    Returns
    -------

    log : float
          Natural logarithm of the input tuple.

    See Also
    --------
    tuple_exp, tuple_exp2, tuple_exp10, tuple_pow

    Alternatives
    ------------
    tuple_log2, tuple_log10
    """
    with HalconOperator(195) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        log = proc.get_output_tuple_s(0)
        return log  # type: ignore


def tuple_lsh(
    t: MaybeSequence[int],
    shift: MaybeSequence[int]
) -> Sequence[int]:
    """
    Shift a tuple bitwise to the left.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    shift : MaybeSequence[int]
            Number of places to shift the input tuple.

    Returns
    -------

    lsh : Sequence[int]
          Shifted input tuple.

    See Also
    --------
    tuple_rsh

    Alternatives
    ------------
    tuple_mult
    """
    with HalconOperator(177) as proc:
        proc.set_input_tuple(0, t)
        proc.set_input_tuple(1, shift)
        proc.init_oct(0)
        proc.execute()
        lsh = proc.get_output_tuple_m(0)
        return lsh  # type: ignore


def tuple_lsh_s(t: MaybeSequence[int], shift: MaybeSequence[int]) -> int:
    """
    Shift a tuple bitwise to the left.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    shift : MaybeSequence[int]
            Number of places to shift the input tuple.

    Returns
    -------

    lsh : int
          Shifted input tuple.

    See Also
    --------
    tuple_rsh

    Alternatives
    ------------
    tuple_mult
    """
    with HalconOperator(177) as proc:
        proc.set_input_tuple(0, t)
        proc.set_input_tuple(1, shift)
        proc.init_oct(0)
        proc.execute()
        lsh = proc.get_output_tuple_s(0)
        return lsh  # type: ignore


def tuple_max(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Return the maximal element of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    max : Sequence[Union[float, int, str]]
          Maximal element of the input tuple elements.

    See Also
    --------
    tuple_max2, tuple_min2

    Alternatives
    ------------
    tuple_min, tuple_mean, tuple_deviation, tuple_sum, tuple_length,
    tuple_median
    """
    with HalconOperator(119) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        max = proc.get_output_tuple_m(0)
        return max  # type: ignore


def tuple_max2(
    t1: MaybeSequence[Union[float, int, str]],
    t2: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Calculate the elementwise maximum of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    max_2 : Sequence[Union[float, int, str]]
            Elementwise maximum of the input tuples.

    See Also
    --------
    tuple_min2, tuple_min, tuple_max, tuple_cumul
    """
    with HalconOperator(117) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        max_2 = proc.get_output_tuple_m(0)
        return max_2  # type: ignore


def tuple_max2_s(
    t1: MaybeSequence[Union[float, int, str]],
    t2: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Calculate the elementwise maximum of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    max_2 : Union[float, int, str]
            Elementwise maximum of the input tuples.

    See Also
    --------
    tuple_min2, tuple_min, tuple_max, tuple_cumul
    """
    with HalconOperator(117) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        max_2 = proc.get_output_tuple_s(0)
        return max_2  # type: ignore


def tuple_max_s(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Return the maximal element of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    max : Union[float, int, str]
          Maximal element of the input tuple elements.

    See Also
    --------
    tuple_max2, tuple_min2

    Alternatives
    ------------
    tuple_min, tuple_mean, tuple_deviation, tuple_sum, tuple_length,
    tuple_median
    """
    with HalconOperator(119) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        max = proc.get_output_tuple_s(0)
        return max  # type: ignore


def tuple_mean(tuple: MaybeSequence[Union[float, int]]) -> float:
    """
    Return the mean value of a tuple of numbers.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    Returns
    -------

    mean : float
           Mean value of tuple elements.

    Alternatives
    ------------
    tuple_deviation, tuple_sum, tuple_min, tuple_max, tuple_length,
    tuple_median
    """
    with HalconOperator(125) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        mean = proc.get_output_tuple_s(0)
        return mean  # type: ignore


def tuple_median(
    tuple: MaybeSequence[Union[float, int]]
) -> Union[int, float]:
    """
    Return the median of the elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    Returns
    -------

    median : Union[int, float]
             Median of the tuple elements.

    See Also
    --------
    tuple_mean, tuple_min, tuple_max

    Alternatives
    ------------
    tuple_select_rank
    """
    with HalconOperator(123) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        median = proc.get_output_tuple_s(0)
        return median  # type: ignore


def tuple_min(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Return the minimal element of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    min : Sequence[Union[float, int, str]]
          Minimal element of the input tuple elements.

    See Also
    --------
    tuple_max2, tuple_min2

    Alternatives
    ------------
    tuple_max, tuple_mean, tuple_deviation, tuple_sum, tuple_length,
    tuple_median
    """
    with HalconOperator(120) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        min = proc.get_output_tuple_m(0)
        return min  # type: ignore


def tuple_min2(
    t1: MaybeSequence[Union[float, int, str]],
    t2: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Calculate the elementwise minimum of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    min_2 : Sequence[Union[float, int, str]]
            Elementwise minimum of the input tuples.

    See Also
    --------
    tuple_max2, tuple_min, tuple_max
    """
    with HalconOperator(118) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        min_2 = proc.get_output_tuple_m(0)
        return min_2  # type: ignore


def tuple_min2_s(
    t1: MaybeSequence[Union[float, int, str]],
    t2: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Calculate the elementwise minimum of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int, str]]
         Input tuple 2.

    Returns
    -------

    min_2 : Union[float, int, str]
            Elementwise minimum of the input tuples.

    See Also
    --------
    tuple_max2, tuple_min, tuple_max
    """
    with HalconOperator(118) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        min_2 = proc.get_output_tuple_s(0)
        return min_2  # type: ignore


def tuple_min_s(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Return the minimal element of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    min : Union[float, int, str]
          Minimal element of the input tuple elements.

    See Also
    --------
    tuple_max2, tuple_min2

    Alternatives
    ------------
    tuple_max, tuple_mean, tuple_deviation, tuple_sum, tuple_length,
    tuple_median
    """
    with HalconOperator(120) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        min = proc.get_output_tuple_s(0)
        return min  # type: ignore


def tuple_mod(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Calculate the remainder of the integer division of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.
         Assertion: T2 != 0

    Returns
    -------

    mod : Sequence[int]
          Remainder of the division of the input tuples.

    See Also
    --------
    tuple_fmod, tuple_div
    """
    with HalconOperator(190) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        mod = proc.get_output_tuple_m(0)
        return mod  # type: ignore


def tuple_mod_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Calculate the remainder of the integer division of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.
         Assertion: T2 != 0

    Returns
    -------

    mod : int
          Remainder of the division of the input tuples.

    See Also
    --------
    tuple_fmod, tuple_div
    """
    with HalconOperator(190) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        mod = proc.get_output_tuple_s(0)
        return mod  # type: ignore


def tuple_mult(
    p1: MaybeSequence[Union[float, int]],
    p2: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Multiply two tuples.

    Parameters
    ----------

    p1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    p2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    prod : Sequence[Union[float, int]]
           Product of the input tuples.

    Alternatives
    ------------
    tuple_div
    """
    with HalconOperator(214) as proc:
        proc.set_input_tuple(0, p1)
        proc.set_input_tuple(1, p2)
        proc.init_oct(0)
        proc.execute()
        prod = proc.get_output_tuple_m(0)
        return prod  # type: ignore


def tuple_mult_s(
    p1: MaybeSequence[Union[float, int]],
    p2: MaybeSequence[Union[float, int]]
) -> Union[float, int]:
    """
    Multiply two tuples.

    Parameters
    ----------

    p1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    p2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    prod : Union[float, int]
           Product of the input tuples.

    Alternatives
    ------------
    tuple_div
    """
    with HalconOperator(214) as proc:
        proc.set_input_tuple(0, p1)
        proc.set_input_tuple(1, p2)
        proc.init_oct(0)
        proc.execute()
        prod = proc.get_output_tuple_s(0)
        return prod  # type: ignore


def tuple_neg(
    t: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Negate a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    neg : Sequence[Union[float, int]]
          Negation of the input tuple.
    """
    with HalconOperator(212) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        neg = proc.get_output_tuple_m(0)
        return neg  # type: ignore


def tuple_neg_s(t: MaybeSequence[Union[float, int]]) -> Union[float, int]:
    """
    Negate a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    neg : Union[float, int]
          Negation of the input tuple.
    """
    with HalconOperator(212) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        neg = proc.get_output_tuple_s(0)
        return neg  # type: ignore


def tuple_not(t: MaybeSequence[int]) -> Sequence[int]:
    """
    Compute the logical not of a tuple.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    Returns
    -------

    not_val : Sequence[int]
              Binary not of the input tuple.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_and, tuple_or, tuple_xor
    """
    with HalconOperator(168) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        not_val = proc.get_output_tuple_m(0)
        return not_val  # type: ignore


def tuple_not_equal(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test whether two tuples are not equal.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    nequal : int
             Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal, tuple_equal_elem, tuple_not_equal_elem,
    tuple_less_elem, tuple_greater_elem, tuple_less_equal_elem,
    tuple_greater_equal_elem
    """
    with HalconOperator(166) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        nequal = proc.get_output_tuple_s(0)
        return nequal  # type: ignore


def tuple_not_equal_elem(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Test, whether two tuples are elementwise not equal.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    nequal : Sequence[int]
             Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_less_elem, tuple_greater_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(160) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        nequal = proc.get_output_tuple_m(0)
        return nequal  # type: ignore


def tuple_not_equal_elem_s(
    t1: MaybeSequence[Union[int, float, str]],
    t2: MaybeSequence[Union[int, float, str]]
) -> int:
    """
    Test, whether two tuples are elementwise not equal.

    Parameters
    ----------

    t1 : MaybeSequence[Union[int, float, str]]
         Input tuple 1.

    t2 : MaybeSequence[Union[int, float, str]]
         Input tuple 2.

    Returns
    -------

    nequal : int
             Result of the comparison of the input tuples.

    Alternatives
    ------------
    tuple_equal_elem, tuple_less_elem, tuple_greater_elem,
    tuple_less_equal_elem, tuple_greater_equal_elem, tuple_equal,
    tuple_not_equal, tuple_less, tuple_greater, tuple_less_equal,
    tuple_greater_equal
    """
    with HalconOperator(160) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        nequal = proc.get_output_tuple_s(0)
        return nequal  # type: ignore


def tuple_not_s(t: MaybeSequence[int]) -> int:
    """
    Compute the logical not of a tuple.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    Returns
    -------

    not_val : int
              Binary not of the input tuple.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_and, tuple_or, tuple_xor
    """
    with HalconOperator(168) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        not_val = proc.get_output_tuple_s(0)
        return not_val  # type: ignore


def tuple_number(
    t: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Convert a tuple (of strings) into a tuple of numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int, str]]
        Input tuple.

    Returns
    -------

    number : Sequence[Union[float, int, str]]
             Input tuple as numbers.

    See Also
    --------
    tuple_is_number, tuple_string
    """
    with HalconOperator(184) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        number = proc.get_output_tuple_m(0)
        return number  # type: ignore


def tuple_number_s(
    t: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Convert a tuple (of strings) into a tuple of numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int, str]]
        Input tuple.

    Returns
    -------

    number : Union[float, int, str]
             Input tuple as numbers.

    See Also
    --------
    tuple_is_number, tuple_string
    """
    with HalconOperator(184) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        number = proc.get_output_tuple_s(0)
        return number  # type: ignore


def tuple_or(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Compute the logical or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    or_val : Sequence[int]
             Logical or of the input tuples.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_and, tuple_xor, tuple_not
    """
    with HalconOperator(170) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        or_val = proc.get_output_tuple_m(0)
        return or_val  # type: ignore


def tuple_or_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Compute the logical or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    or_val : int
             Logical or of the input tuples.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_and, tuple_xor, tuple_not
    """
    with HalconOperator(170) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        or_val = proc.get_output_tuple_s(0)
        return or_val  # type: ignore


def tuple_ord(t: MaybeSequence[str]) -> Sequence[int]:
    """
    Convert a tuple of strings of length 1 into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[str]
        Input tuple with strings of length 1.

    Returns
    -------

    ord : Sequence[int]
          Output tuple with Unicode character codes or ANSI codes of the
          characters passed in the input tuple.

    See Also
    --------
    tuple_chr, tuple_chrt

    Alternatives
    ------------
    tuple_ords
    """
    with HalconOperator(181) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        ord = proc.get_output_tuple_m(0)
        return ord  # type: ignore


def tuple_ord_s(t: MaybeSequence[str]) -> int:
    """
    Convert a tuple of strings of length 1 into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[str]
        Input tuple with strings of length 1.

    Returns
    -------

    ord : int
          Output tuple with Unicode character codes or ANSI codes of the
          characters passed in the input tuple.

    See Also
    --------
    tuple_chr, tuple_chrt

    Alternatives
    ------------
    tuple_ords
    """
    with HalconOperator(181) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        ord = proc.get_output_tuple_s(0)
        return ord  # type: ignore


def tuple_ords(t: MaybeSequence[Union[str, int]]) -> Sequence[int]:
    """
    Convert a tuple of strings into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[str, int]]
        Input tuple with strings.

    Returns
    -------

    ords : Sequence[int]
           Output tuple with the Unicode character codes or ANSI codes of
           the input string.

    See Also
    --------
    tuple_chr, tuple_chrt, write_serial

    Alternatives
    ------------
    tuple_ord
    """
    with HalconOperator(179) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        ords = proc.get_output_tuple_m(0)
        return ords  # type: ignore


def tuple_ords_s(t: MaybeSequence[Union[str, int]]) -> int:
    """
    Convert a tuple of strings into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[str, int]]
        Input tuple with strings.

    Returns
    -------

    ords : int
           Output tuple with the Unicode character codes or ANSI codes of
           the input string.

    See Also
    --------
    tuple_chr, tuple_chrt, write_serial

    Alternatives
    ------------
    tuple_ord
    """
    with HalconOperator(179) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        ords = proc.get_output_tuple_s(0)
        return ords  # type: ignore


def tuple_pow(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the power function of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    pow : Sequence[float]
          Power function of the input tuples.

    See Also
    --------
    tuple_log, tuple_log10

    Alternatives
    ------------
    tuple_exp
    """
    with HalconOperator(193) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        pow = proc.get_output_tuple_m(0)
        return pow  # type: ignore


def tuple_pow_s(
    t1: MaybeSequence[Union[float, int]],
    t2: MaybeSequence[Union[float, int]]
) -> float:
    """
    Calculate the power function of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    t2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    pow : float
          Power function of the input tuples.

    See Also
    --------
    tuple_log, tuple_log10

    Alternatives
    ------------
    tuple_exp
    """
    with HalconOperator(193) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        pow = proc.get_output_tuple_s(0)
        return pow  # type: ignore


def tuple_rad(deg: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Convert a tuple from degrees to radians.

    Parameters
    ----------

    deg : MaybeSequence[Union[float, int]]
          Input tuple.

    Returns
    -------

    rad : Sequence[float]
          Input tuple in radians.

    See Also
    --------
    tuple_deg
    """
    with HalconOperator(200) as proc:
        proc.set_input_tuple(0, deg)
        proc.init_oct(0)
        proc.execute()
        rad = proc.get_output_tuple_m(0)
        return rad  # type: ignore


def tuple_rad_s(deg: MaybeSequence[Union[float, int]]) -> float:
    """
    Convert a tuple from degrees to radians.

    Parameters
    ----------

    deg : MaybeSequence[Union[float, int]]
          Input tuple.

    Returns
    -------

    rad : float
          Input tuple in radians.

    See Also
    --------
    tuple_deg
    """
    with HalconOperator(200) as proc:
        proc.set_input_tuple(0, deg)
        proc.init_oct(0)
        proc.execute()
        rad = proc.get_output_tuple_s(0)
        return rad  # type: ignore


def tuple_rand(length: int) -> Sequence[float]:
    """
    Return a tuple of random numbers between 0 and 1.

    Parameters
    ----------

    length : int
             Length of tuple to generate.

    Returns
    -------

    rand : Sequence[float]
           Tuple of random numbers.

    See Also
    --------
    tuple_gen_const
    """
    with HalconOperator(114) as proc:
        proc.set_input_tuple(0, length)
        proc.init_oct(0)
        proc.execute()
        rand = proc.get_output_tuple_m(0)
        return rand  # type: ignore


def tuple_rand_s(length: int) -> float:
    """
    Return a tuple of random numbers between 0 and 1.

    Parameters
    ----------

    length : int
             Length of tuple to generate.

    Returns
    -------

    rand : float
           Tuple of random numbers.

    See Also
    --------
    tuple_gen_const
    """
    with HalconOperator(114) as proc:
        proc.set_input_tuple(0, length)
        proc.init_oct(0)
        proc.execute()
        rand = proc.get_output_tuple_s(0)
        return rand  # type: ignore


def tuple_real(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Convert a tuple into a tuple of floating point numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    real : Sequence[float]
           Input tuple as floating point numbers.
    """
    with HalconOperator(187) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        real = proc.get_output_tuple_m(0)
        return real  # type: ignore


def tuple_real_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Convert a tuple into a tuple of floating point numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    real : float
           Input tuple as floating point numbers.
    """
    with HalconOperator(187) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        real = proc.get_output_tuple_s(0)
        return real  # type: ignore


def tuple_regexp_match(
    data: MaybeSequence[str],
    expression: MaybeSequence[str]
) -> Sequence[str]:
    """
    Extract substrings using regular expressions.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to match.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    Returns
    -------

    matches : Sequence[str]
              Found matches.

    See Also
    --------
    tuple_regexp_replace, tuple_regexp_test, tuple_regexp_select

    Alternatives
    ------------
    tuple_strstr
    """
    with HalconOperator(113) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.init_oct(0)
        proc.execute()
        matches = proc.get_output_tuple_m(0)
        return matches  # type: ignore


def tuple_regexp_match_s(
    data: MaybeSequence[str],
    expression: MaybeSequence[str]
) -> str:
    """
    Extract substrings using regular expressions.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to match.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    Returns
    -------

    matches : str
              Found matches.

    See Also
    --------
    tuple_regexp_replace, tuple_regexp_test, tuple_regexp_select

    Alternatives
    ------------
    tuple_strstr
    """
    with HalconOperator(113) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.init_oct(0)
        proc.execute()
        matches = proc.get_output_tuple_s(0)
        return matches  # type: ignore


def tuple_regexp_replace(
    data: MaybeSequence[str],
    expression: MaybeSequence[str],
    replace: str
) -> Sequence[str]:
    """
    Replace a substring using regular expressions.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to process.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    replace : str
              Replacement expression.

    Returns
    -------

    result : Sequence[str]
             Processed strings.

    See Also
    --------
    tuple_regexp_match, tuple_regexp_test, tuple_regexp_select
    """
    with HalconOperator(112) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, replace)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_m(0)
        return result  # type: ignore


def tuple_regexp_replace_s(
    data: MaybeSequence[str],
    expression: MaybeSequence[str],
    replace: str
) -> str:
    """
    Replace a substring using regular expressions.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to process.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    replace : str
              Replacement expression.

    Returns
    -------

    result : str
             Processed strings.

    See Also
    --------
    tuple_regexp_match, tuple_regexp_test, tuple_regexp_select
    """
    with HalconOperator(112) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.set_input_tuple(2, replace)
        proc.init_oct(0)
        proc.execute()
        result = proc.get_output_tuple_s(0)
        return result  # type: ignore


def tuple_regexp_select(
    data: MaybeSequence[str],
    expression: MaybeSequence[str]
) -> Sequence[str]:
    """
    Select tuple elements matching a regular expression.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to match.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    Returns
    -------

    selection : Sequence[str]
                Matching strings

    See Also
    --------
    tuple_regexp_match, tuple_regexp_replace, tuple_regexp_test

    Alternatives
    ------------
    tuple_select
    """
    with HalconOperator(110) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.init_oct(0)
        proc.execute()
        selection = proc.get_output_tuple_m(0)
        return selection  # type: ignore


def tuple_regexp_select_s(
    data: MaybeSequence[str],
    expression: MaybeSequence[str]
) -> str:
    """
    Select tuple elements matching a regular expression.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to match.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    Returns
    -------

    selection : str
                Matching strings

    See Also
    --------
    tuple_regexp_match, tuple_regexp_replace, tuple_regexp_test

    Alternatives
    ------------
    tuple_select
    """
    with HalconOperator(110) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.init_oct(0)
        proc.execute()
        selection = proc.get_output_tuple_s(0)
        return selection  # type: ignore


def tuple_regexp_test(
    data: MaybeSequence[str],
    expression: MaybeSequence[str]
) -> int:
    """
    Test if a string matches a regular expression.

    Parameters
    ----------

    data : MaybeSequence[str]
           Input strings to match.

    expression : MaybeSequence[str]
                 Regular expression.
                 Value Suggestion: .*

    Returns
    -------

    num_matches : int
                  Number of matching strings

    See Also
    --------
    tuple_regexp_match, tuple_regexp_replace, tuple_regexp_select

    Alternatives
    ------------
    tuple_strstr
    """
    with HalconOperator(111) as proc:
        proc.set_input_tuple(0, data)
        proc.set_input_tuple(1, expression)
        proc.init_oct(0)
        proc.execute()
        num_matches = proc.get_output_tuple_s(0)
        return num_matches  # type: ignore


def tuple_remove(
    tuple: MaybeSequence[Union[float, int, str]],
    index: MaybeSequence[int]
) -> Sequence[Union[float, int, str]]:
    """
    Remove elements from a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : MaybeSequence[int]
            Indices of the elements to remove.

    Returns
    -------

    reduced : Sequence[Union[float, int, str]]
              Reduced tuple.

    See Also
    --------
    tuple_select, tuple_select_mask

    Alternatives
    ------------
    tuple_first_n, tuple_last_n, tuple_str_bit_select, tuple_concat,
    tuple_insert, tuple_replace
    """
    with HalconOperator(140) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        reduced = proc.get_output_tuple_m(0)
        return reduced  # type: ignore


def tuple_remove_s(
    tuple: MaybeSequence[Union[float, int, str]],
    index: MaybeSequence[int]
) -> Union[float, int, str]:
    """
    Remove elements from a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : MaybeSequence[int]
            Indices of the elements to remove.

    Returns
    -------

    reduced : Union[float, int, str]
              Reduced tuple.

    See Also
    --------
    tuple_select, tuple_select_mask

    Alternatives
    ------------
    tuple_first_n, tuple_last_n, tuple_str_bit_select, tuple_concat,
    tuple_insert, tuple_replace
    """
    with HalconOperator(140) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        reduced = proc.get_output_tuple_s(0)
        return reduced  # type: ignore


def tuple_replace(
    tuple: MaybeSequence[Union[float, int, str]],
    index: MaybeSequence[int],
    replace_tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Replaces one or more elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : MaybeSequence[int]
            Index/Indices of elements to be replaced.

    replace_tuple : MaybeSequence[Union[float, int, str]]
                    Element(s) to replace.

    Returns
    -------

    replaced : Sequence[Union[float, int, str]]
               Tuple with replaced elements.

    See Also
    --------
    tuple_remove, tuple_insert

    Alternatives
    ------------
    tuple_select, tuple_first_n, tuple_last_n, tuple_select_mask,
    tuple_str_bit_select, tuple_concat, tuple_select_rank
    """
    with HalconOperator(139) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.set_input_tuple(2, replace_tuple)
        proc.init_oct(0)
        proc.execute()
        replaced = proc.get_output_tuple_m(0)
        return replaced  # type: ignore


def tuple_round(t: MaybeSequence[Union[float, int]]) -> Sequence[int]:
    """
    Convert a tuple into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    round : Sequence[int]
            Result of the rounding.

    Alternatives
    ------------
    tuple_int
    """
    with HalconOperator(185) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        round = proc.get_output_tuple_m(0)
        return round  # type: ignore


def tuple_round_s(t: MaybeSequence[Union[float, int]]) -> int:
    """
    Convert a tuple into a tuple of integer numbers.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    round : int
            Result of the rounding.

    Alternatives
    ------------
    tuple_int
    """
    with HalconOperator(185) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        round = proc.get_output_tuple_s(0)
        return round  # type: ignore


def tuple_rsh(
    t: MaybeSequence[int],
    shift: MaybeSequence[int]
) -> Sequence[int]:
    """
    Shift a tuple bitwise to the right.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    shift : MaybeSequence[int]
            Number of places to shift the input tuple.

    Returns
    -------

    rsh : Sequence[int]
          Shifted input tuple.

    See Also
    --------
    tuple_lsh

    Alternatives
    ------------
    tuple_div
    """
    with HalconOperator(176) as proc:
        proc.set_input_tuple(0, t)
        proc.set_input_tuple(1, shift)
        proc.init_oct(0)
        proc.execute()
        rsh = proc.get_output_tuple_m(0)
        return rsh  # type: ignore


def tuple_rsh_s(t: MaybeSequence[int], shift: MaybeSequence[int]) -> int:
    """
    Shift a tuple bitwise to the right.

    Parameters
    ----------

    t : MaybeSequence[int]
        Input tuple.

    shift : MaybeSequence[int]
            Number of places to shift the input tuple.

    Returns
    -------

    rsh : int
          Shifted input tuple.

    See Also
    --------
    tuple_lsh

    Alternatives
    ------------
    tuple_div
    """
    with HalconOperator(176) as proc:
        proc.set_input_tuple(0, t)
        proc.set_input_tuple(1, shift)
        proc.init_oct(0)
        proc.execute()
        rsh = proc.get_output_tuple_s(0)
        return rsh  # type: ignore


def tuple_select(
    tuple: MaybeSequence[Union[float, int, str]],
    index: MaybeSequence[int]
) -> Sequence[Union[float, int, str]]:
    """
    Select single elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : MaybeSequence[int]
            Indices of the elements to select.

    Returns
    -------

    selected : Sequence[Union[float, int, str]]
               Selected tuple element.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_first_n, tuple_last_n, tuple_str_bit_select, tuple_concat,
    tuple_select_range, tuple_select_rank
    """
    with HalconOperator(142) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_m(0)
        return selected  # type: ignore


def tuple_select_mask(
    tuple: MaybeSequence[Union[float, int, str]],
    mask: MaybeSequence[int]
) -> Sequence[Union[float, int, str]]:
    """
    Select in mask specified elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    mask : MaybeSequence[int]
           > 0 specifies the elements to select.

    Returns
    -------

    selected : Sequence[Union[float, int, str]]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_first_n, tuple_last_n, tuple_str_bit_select, tuple_concat,
    tuple_select, tuple_select_range, tuple_select_rank
    """
    with HalconOperator(141) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, mask)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_m(0)
        return selected  # type: ignore


def tuple_select_mask_s(
    tuple: MaybeSequence[Union[float, int, str]],
    mask: MaybeSequence[int]
) -> Union[float, int, str]:
    """
    Select in mask specified elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    mask : MaybeSequence[int]
           > 0 specifies the elements to select.

    Returns
    -------

    selected : Union[float, int, str]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_first_n, tuple_last_n, tuple_str_bit_select, tuple_concat,
    tuple_select, tuple_select_range, tuple_select_rank
    """
    with HalconOperator(141) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, mask)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_select_range(
    tuple: MaybeSequence[Union[float, int, str]],
    leftindex: MaybeSequence[int],
    rightindex: MaybeSequence[int]
) -> Sequence[Union[float, int, str]]:
    """
    Select several elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    leftindex : MaybeSequence[int]
                Index of first element to select.

    rightindex : MaybeSequence[int]
                 Index of last element to select.

    Returns
    -------

    selected : Sequence[Union[float, int, str]]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_select, tuple_first_n, tuple_last_n, tuple_select_mask,
    tuple_str_bit_select, tuple_concat, tuple_select_rank
    """
    with HalconOperator(135) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, leftindex)
        proc.set_input_tuple(2, rightindex)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_m(0)
        return selected  # type: ignore


def tuple_select_range_s(
    tuple: MaybeSequence[Union[float, int, str]],
    leftindex: MaybeSequence[int],
    rightindex: MaybeSequence[int]
) -> Union[float, int, str]:
    """
    Select several elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    leftindex : MaybeSequence[int]
                Index of first element to select.

    rightindex : MaybeSequence[int]
                 Index of last element to select.

    Returns
    -------

    selected : Union[float, int, str]
               Selected tuple elements.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_select, tuple_first_n, tuple_last_n, tuple_select_mask,
    tuple_str_bit_select, tuple_concat, tuple_select_rank
    """
    with HalconOperator(135) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, leftindex)
        proc.set_input_tuple(2, rightindex)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_select_rank(
    tuple: MaybeSequence[Union[float, int]],
    rank_index: Union[float, int]
) -> Union[float, int]:
    """
    Select the element of rank n of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int]]
            Input tuple.

    rank_index : Union[float, int]
                 Rank of the element to select.

    Returns
    -------

    selected : Union[float, int]
               Selected tuple element.

    See Also
    --------
    tuple_median, tuple_select

    Alternatives
    ------------
    tuple_sort_index, tuple_sort
    """
    with HalconOperator(122) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, rank_index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_select_s(
    tuple: MaybeSequence[Union[float, int, str]],
    index: MaybeSequence[int]
) -> Union[float, int, str]:
    """
    Select single elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    index : MaybeSequence[int]
            Indices of the elements to select.

    Returns
    -------

    selected : Union[float, int, str]
               Selected tuple element.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_first_n, tuple_last_n, tuple_str_bit_select, tuple_concat,
    tuple_select_range, tuple_select_rank
    """
    with HalconOperator(142) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_sem_type(t: HTupleType) -> str:
    """
    Return the semantic type of a tuple.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    sem_type : str
               Semantic type of the input tuple as a string.

    See Also
    --------
    get_obj_class

    Alternatives
    ------------
    tuple_is_int, tuple_is_number, tuple_is_real, tuple_is_string,
    tuple_type
    """
    with HalconOperator(2144) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sem_type = proc.get_output_tuple_s(0)
        return sem_type  # type: ignore


def tuple_sem_type_elem(t: HTupleType) -> Sequence[str]:
    """
    Return the semantic type of the elements of a tuple.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    sem_types : Sequence[str]
                Semantic types of the elements of the input tuple as
                strings.

    See Also
    --------
    get_obj_class

    Alternatives
    ------------
    tuple_type, tuple_is_mixed, tuple_is_int, tuple_is_real,
    tuple_is_string, tuple_is_mixed, tuple_is_int_elem,
    tuple_is_real_elem, tuple_is_string_elem, tuple_type_elem,
    tuple_sem_type
    """
    with HalconOperator(2145) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sem_types = proc.get_output_tuple_m(0)
        return sem_types  # type: ignore


def tuple_sem_type_elem_s(t: HTupleType) -> str:
    """
    Return the semantic type of the elements of a tuple.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    sem_types : str
                Semantic types of the elements of the input tuple as
                strings.

    See Also
    --------
    get_obj_class

    Alternatives
    ------------
    tuple_type, tuple_is_mixed, tuple_is_int, tuple_is_real,
    tuple_is_string, tuple_is_mixed, tuple_is_int_elem,
    tuple_is_real_elem, tuple_is_string_elem, tuple_type_elem,
    tuple_sem_type
    """
    with HalconOperator(2145) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sem_types = proc.get_output_tuple_s(0)
        return sem_types  # type: ignore


def tuple_sgn(t: MaybeSequence[Union[float, int]]) -> Sequence[int]:
    """
    Calculate the sign of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    sgn : Sequence[int]
          Signs of the input tuple as integer numbers.
    """
    with HalconOperator(116) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sgn = proc.get_output_tuple_m(0)
        return sgn  # type: ignore


def tuple_sgn_s(t: MaybeSequence[Union[float, int]]) -> int:
    """
    Calculate the sign of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    sgn : int
          Signs of the input tuple as integer numbers.
    """
    with HalconOperator(116) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sgn = proc.get_output_tuple_s(0)
        return sgn  # type: ignore


def tuple_sin(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the sine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    sin : Sequence[float]
          Sine of the input tuple.

    See Also
    --------
    tuple_asin, tuple_sinh, tuple_asinh

    Alternatives
    ------------
    tuple_cos, tuple_tan
    """
    with HalconOperator(208) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sin = proc.get_output_tuple_m(0)
        return sin  # type: ignore


def tuple_sin_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the sine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    sin : float
          Sine of the input tuple.

    See Also
    --------
    tuple_asin, tuple_sinh, tuple_asinh

    Alternatives
    ------------
    tuple_cos, tuple_tan
    """
    with HalconOperator(208) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sin = proc.get_output_tuple_s(0)
        return sin  # type: ignore


def tuple_sinh(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the hyperbolic sine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    sinh : Sequence[float]
           Hyperbolic sine of the input tuple.

    See Also
    --------
    tuple_asinh, tuple_sin, tuple_asin

    Alternatives
    ------------
    tuple_cosh, tuple_tanh
    """
    with HalconOperator(199) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sinh = proc.get_output_tuple_m(0)
        return sinh  # type: ignore


def tuple_sinh_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the hyperbolic sine of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    sinh : float
           Hyperbolic sine of the input tuple.

    See Also
    --------
    tuple_asinh, tuple_sin, tuple_asin

    Alternatives
    ------------
    tuple_cosh, tuple_tanh
    """
    with HalconOperator(199) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sinh = proc.get_output_tuple_s(0)
        return sinh  # type: ignore


def tuple_sort(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Sort the elements of a tuple in ascending order.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    sorted : Sequence[Union[float, int, str]]
             Sorted tuple.

    Alternatives
    ------------
    tuple_sort_index, tuple_inverse
    """
    with HalconOperator(132) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        sorted = proc.get_output_tuple_m(0)
        return sorted  # type: ignore


def tuple_sort_index(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[int]:
    """
    Sort the elements of a tuple and return the indices of the sorted
    tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    indices : Sequence[int]
              Sorted tuple.

    Alternatives
    ------------
    tuple_sort, tuple_inverse
    """
    with HalconOperator(131) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_m(0)
        return indices  # type: ignore


def tuple_sort_index_s(tuple: MaybeSequence[Union[float, int, str]]) -> int:
    """
    Sort the elements of a tuple and return the indices of the sorted
    tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    indices : int
              Sorted tuple.

    Alternatives
    ------------
    tuple_sort, tuple_inverse
    """
    with HalconOperator(131) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        indices = proc.get_output_tuple_s(0)
        return indices  # type: ignore


def tuple_sort_s(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Sort the elements of a tuple in ascending order.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    sorted : Union[float, int, str]
             Sorted tuple.

    Alternatives
    ------------
    tuple_sort_index, tuple_inverse
    """
    with HalconOperator(132) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        sorted = proc.get_output_tuple_s(0)
        return sorted  # type: ignore


def tuple_split(
    string: MaybeSequence[str],
    separator: MaybeSequence[str]
) -> Sequence[str]:
    """
    Split strings into substrings using predefined separator symbol(s).

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to split.

    separator : MaybeSequence[str]
                Input tuple with separator symbol(s).

    Returns
    -------

    substrings : Sequence[str]
                 Substrings after splitting the input strings.

    Alternatives
    ------------
    tuple_strstr, tuple_strrstr, tuple_strchr, tuple_strrchr,
    tuple_strlen, tuple_str_first_n, tuple_str_last_n, tuple_environment
    """
    with HalconOperator(147) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, separator)
        proc.init_oct(0)
        proc.execute()
        substrings = proc.get_output_tuple_m(0)
        return substrings  # type: ignore


def tuple_split_s(
    string: MaybeSequence[str],
    separator: MaybeSequence[str]
) -> str:
    """
    Split strings into substrings using predefined separator symbol(s).

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to split.

    separator : MaybeSequence[str]
                Input tuple with separator symbol(s).

    Returns
    -------

    substrings : str
                 Substrings after splitting the input strings.

    Alternatives
    ------------
    tuple_strstr, tuple_strrstr, tuple_strchr, tuple_strrchr,
    tuple_strlen, tuple_str_first_n, tuple_str_last_n, tuple_environment
    """
    with HalconOperator(147) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, separator)
        proc.init_oct(0)
        proc.execute()
        substrings = proc.get_output_tuple_s(0)
        return substrings  # type: ignore


def tuple_sqrt(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the square root of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T >= 0

    Returns
    -------

    sqrt : Sequence[float]
           Square root of the input tuple.

    See Also
    --------
    tuple_cbrt, tuple_hypot

    Alternatives
    ------------
    tuple_pow
    """
    with HalconOperator(210) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sqrt = proc.get_output_tuple_m(0)
        return sqrt  # type: ignore


def tuple_sqrt_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the square root of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.
        Assertion: T >= 0

    Returns
    -------

    sqrt : float
           Square root of the input tuple.

    See Also
    --------
    tuple_cbrt, tuple_hypot

    Alternatives
    ------------
    tuple_pow
    """
    with HalconOperator(210) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        sqrt = proc.get_output_tuple_s(0)
        return sqrt  # type: ignore


def tuple_str_bit_select(
    tuple: MaybeSequence[Union[str, int]],
    index: int
) -> Sequence[Union[str, int]]:
    """
    Select single character or bit from a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[str, int]]
            Input tuple.

    index : int
            Position of character or bit to select.

    Returns
    -------

    selected : Sequence[Union[str, int]]
               Tuple containing the selected characters and bits.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_select, tuple_first_n, tuple_last_n, tuple_concat, tuple_strchr,
    tuple_strrchr, tuple_str_first_n, tuple_str_last_n, tuple_substr,
    tuple_and, tuple_or, tuple_xor, tuple_not
    """
    with HalconOperator(143) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_m(0)
        return selected  # type: ignore


def tuple_str_bit_select_s(
    tuple: MaybeSequence[Union[str, int]],
    index: int
) -> Union[str, int]:
    """
    Select single character or bit from a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[str, int]]
            Input tuple.

    index : int
            Position of character or bit to select.

    Returns
    -------

    selected : Union[str, int]
               Tuple containing the selected characters and bits.

    See Also
    --------
    tuple_remove

    Alternatives
    ------------
    tuple_select, tuple_first_n, tuple_last_n, tuple_concat, tuple_strchr,
    tuple_strrchr, tuple_str_first_n, tuple_str_last_n, tuple_substr,
    tuple_and, tuple_or, tuple_xor, tuple_not
    """
    with HalconOperator(143) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, index)
        proc.init_oct(0)
        proc.execute()
        selected = proc.get_output_tuple_s(0)
        return selected  # type: ignore


def tuple_str_first_n(
    string: MaybeSequence[str],
    position: MaybeSequence[Union[float, int]]
) -> Sequence[str]:
    """
    Cut the first characters up to position ``n'' out of a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    position : MaybeSequence[Union[float, int]]
               Input tuple with position(s) ``n''.

    Returns
    -------

    substring : Sequence[str]
                The first characters of the string(s) up to position ``n''.

    Alternatives
    ------------
    tuple_str_last_n, tuple_substr, tuple_strstr, tuple_strrstr,
    tuple_strlen, tuple_strchr, tuple_strrchr, tuple_split,
    tuple_environment
    """
    with HalconOperator(150) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, position)
        proc.init_oct(0)
        proc.execute()
        substring = proc.get_output_tuple_m(0)
        return substring  # type: ignore


def tuple_str_first_n_s(
    string: MaybeSequence[str],
    position: MaybeSequence[Union[float, int]]
) -> str:
    """
    Cut the first characters up to position ``n'' out of a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    position : MaybeSequence[Union[float, int]]
               Input tuple with position(s) ``n''.

    Returns
    -------

    substring : str
                The first characters of the string(s) up to position ``n''.

    Alternatives
    ------------
    tuple_str_last_n, tuple_substr, tuple_strstr, tuple_strrstr,
    tuple_strlen, tuple_strchr, tuple_strrchr, tuple_split,
    tuple_environment
    """
    with HalconOperator(150) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, position)
        proc.init_oct(0)
        proc.execute()
        substring = proc.get_output_tuple_s(0)
        return substring  # type: ignore


def tuple_str_last_n(
    string: MaybeSequence[str],
    position: MaybeSequence[Union[float, int]]
) -> Sequence[str]:
    """
    Cut all characters starting at position ``n'' out of a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    position : MaybeSequence[Union[float, int]]
               Input tuple with position(s) ``n''.

    Returns
    -------

    substring : Sequence[str]
                The last characters of the string(s) starting at position
                ``n''.

    Alternatives
    ------------
    tuple_str_first_n, tuple_substr, tuple_strstr, tuple_strrstr,
    tuple_strlen, tuple_strchr, tuple_strrchr, tuple_split,
    tuple_environment
    """
    with HalconOperator(149) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, position)
        proc.init_oct(0)
        proc.execute()
        substring = proc.get_output_tuple_m(0)
        return substring  # type: ignore


def tuple_str_last_n_s(
    string: MaybeSequence[str],
    position: MaybeSequence[Union[float, int]]
) -> str:
    """
    Cut all characters starting at position ``n'' out of a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    position : MaybeSequence[Union[float, int]]
               Input tuple with position(s) ``n''.

    Returns
    -------

    substring : str
                The last characters of the string(s) starting at position
                ``n''.

    Alternatives
    ------------
    tuple_str_first_n, tuple_substr, tuple_strstr, tuple_strrstr,
    tuple_strlen, tuple_strchr, tuple_strrchr, tuple_split,
    tuple_environment
    """
    with HalconOperator(149) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, position)
        proc.init_oct(0)
        proc.execute()
        substring = proc.get_output_tuple_s(0)
        return substring  # type: ignore


def tuple_strchr(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> Sequence[int]:
    """
    Forward search for characters within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with character(s) to search.

    Returns
    -------

    position : Sequence[int]
               Position of searched character(s) within the string(s).

    Alternatives
    ------------
    tuple_strrchr, tuple_strstr, tuple_strrstr, tuple_strlen,
    tuple_substr, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_environment
    """
    with HalconOperator(152) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_m(0)
        return position  # type: ignore


def tuple_strchr_s(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> int:
    """
    Forward search for characters within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with character(s) to search.

    Returns
    -------

    position : int
               Position of searched character(s) within the string(s).

    Alternatives
    ------------
    tuple_strrchr, tuple_strstr, tuple_strrstr, tuple_strlen,
    tuple_substr, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_environment
    """
    with HalconOperator(152) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_s(0)
        return position  # type: ignore


def tuple_string(
    t: MaybeSequence[Union[float, int, str]],
    format: str
) -> Sequence[str]:
    """
    Convert a tuple into a tuple of strings.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int, str]]
        Input tuple.

    format : str
             Format string.

    Returns
    -------

    string : Sequence[str]
             Input tuple converted to strings.

    Alternatives
    ------------
    tuple_sub
    """
    with HalconOperator(182) as proc:
        proc.set_input_tuple(0, t)
        proc.set_input_tuple(1, format)
        proc.init_oct(0)
        proc.execute()
        string = proc.get_output_tuple_m(0)
        return string  # type: ignore


def tuple_string_s(
    t: MaybeSequence[Union[float, int, str]],
    format: str
) -> str:
    """
    Convert a tuple into a tuple of strings.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int, str]]
        Input tuple.

    format : str
             Format string.

    Returns
    -------

    string : str
             Input tuple converted to strings.

    Alternatives
    ------------
    tuple_sub
    """
    with HalconOperator(182) as proc:
        proc.set_input_tuple(0, t)
        proc.set_input_tuple(1, format)
        proc.init_oct(0)
        proc.execute()
        string = proc.get_output_tuple_s(0)
        return string  # type: ignore


def tuple_strlen(t1: MaybeSequence[str]) -> Sequence[int]:
    """
    Determine the length of every string within a tuple of strings.

    Parameters
    ----------

    t1 : MaybeSequence[str]
         Input tuple.

    Returns
    -------

    length : Sequence[int]
             Lengths of the single strings of the input tuple.

    See Also
    --------
    tuple_is_string

    Alternatives
    ------------
    tuple_strstr, tuple_strrstr, tuple_strchr, tuple_strrchr,
    tuple_substr, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_environment
    """
    with HalconOperator(155) as proc:
        proc.set_input_tuple(0, t1)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_m(0)
        return length  # type: ignore


def tuple_strlen_s(t1: MaybeSequence[str]) -> int:
    """
    Determine the length of every string within a tuple of strings.

    Parameters
    ----------

    t1 : MaybeSequence[str]
         Input tuple.

    Returns
    -------

    length : int
             Lengths of the single strings of the input tuple.

    See Also
    --------
    tuple_is_string

    Alternatives
    ------------
    tuple_strstr, tuple_strrstr, tuple_strchr, tuple_strrchr,
    tuple_substr, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_environment
    """
    with HalconOperator(155) as proc:
        proc.set_input_tuple(0, t1)
        proc.init_oct(0)
        proc.execute()
        length = proc.get_output_tuple_s(0)
        return length  # type: ignore


def tuple_strrchr(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> Sequence[int]:
    """
    Backward search for characters within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with character(s) to search.

    Returns
    -------

    position : Sequence[int]
               Position of searched character(s) within the string(s).

    Alternatives
    ------------
    tuple_strchr, tuple_strstr, tuple_strrstr, tuple_strlen, tuple_substr,
    tuple_str_first_n, tuple_str_last_n, tuple_split, tuple_environment
    """
    with HalconOperator(151) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_m(0)
        return position  # type: ignore


def tuple_strrchr_s(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> int:
    """
    Backward search for characters within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with character(s) to search.

    Returns
    -------

    position : int
               Position of searched character(s) within the string(s).

    Alternatives
    ------------
    tuple_strchr, tuple_strstr, tuple_strrstr, tuple_strlen, tuple_substr,
    tuple_str_first_n, tuple_str_last_n, tuple_split, tuple_environment
    """
    with HalconOperator(151) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_s(0)
        return position  # type: ignore


def tuple_strrstr(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> Sequence[int]:
    """
    Backward search for strings within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with string(s) to search.

    Returns
    -------

    position : Sequence[int]
               Position of searched string(s) within the examined
               string(s).

    Alternatives
    ------------
    tuple_strstr, tuple_strlen, tuple_strchr, tuple_strrchr, tuple_substr,
    tuple_str_first_n, tuple_str_last_n, tuple_split, tuple_environment
    """
    with HalconOperator(153) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_m(0)
        return position  # type: ignore


def tuple_strrstr_s(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> int:
    """
    Backward search for strings within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with string(s) to search.

    Returns
    -------

    position : int
               Position of searched string(s) within the examined
               string(s).

    Alternatives
    ------------
    tuple_strstr, tuple_strlen, tuple_strchr, tuple_strrchr, tuple_substr,
    tuple_str_first_n, tuple_str_last_n, tuple_split, tuple_environment
    """
    with HalconOperator(153) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_s(0)
        return position  # type: ignore


def tuple_strstr(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> Sequence[int]:
    """
    Forward search for strings within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with string(s) to search.

    Returns
    -------

    position : Sequence[int]
               Position of searched string(s) within the examined
               string(s).

    Alternatives
    ------------
    tuple_strrstr, tuple_strlen, tuple_strchr, tuple_strrchr,
    tuple_substr, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_environment
    """
    with HalconOperator(154) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_m(0)
        return position  # type: ignore


def tuple_strstr_s(
    string: MaybeSequence[str],
    to_find: MaybeSequence[str]
) -> int:
    """
    Forward search for strings within a string tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    to_find : MaybeSequence[str]
              Input tuple with string(s) to search.

    Returns
    -------

    position : int
               Position of searched string(s) within the examined
               string(s).

    Alternatives
    ------------
    tuple_strrstr, tuple_strlen, tuple_strchr, tuple_strrchr,
    tuple_substr, tuple_str_first_n, tuple_str_last_n, tuple_split,
    tuple_environment
    """
    with HalconOperator(154) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, to_find)
        proc.init_oct(0)
        proc.execute()
        position = proc.get_output_tuple_s(0)
        return position  # type: ignore


def tuple_sub(
    d1: MaybeSequence[Union[float, int]],
    d2: MaybeSequence[Union[float, int]]
) -> Sequence[Union[float, int]]:
    """
    Subtract two tuples.

    Parameters
    ----------

    d1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    d2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    diff : Sequence[Union[float, int]]
           Difference of the input tuples.

    Alternatives
    ------------
    tuple_add
    """
    with HalconOperator(215) as proc:
        proc.set_input_tuple(0, d1)
        proc.set_input_tuple(1, d2)
        proc.init_oct(0)
        proc.execute()
        diff = proc.get_output_tuple_m(0)
        return diff  # type: ignore


def tuple_sub_s(
    d1: MaybeSequence[Union[float, int]],
    d2: MaybeSequence[Union[float, int]]
) -> Union[float, int]:
    """
    Subtract two tuples.

    Parameters
    ----------

    d1 : MaybeSequence[Union[float, int]]
         Input tuple 1.

    d2 : MaybeSequence[Union[float, int]]
         Input tuple 2.

    Returns
    -------

    diff : Union[float, int]
           Difference of the input tuples.

    Alternatives
    ------------
    tuple_add
    """
    with HalconOperator(215) as proc:
        proc.set_input_tuple(0, d1)
        proc.set_input_tuple(1, d2)
        proc.init_oct(0)
        proc.execute()
        diff = proc.get_output_tuple_s(0)
        return diff  # type: ignore


def tuple_substr(
    string: MaybeSequence[str],
    position_1: MaybeSequence[Union[float, int]],
    position_2: MaybeSequence[Union[float, int]]
) -> Sequence[str]:
    """
    Cut characters from position ``n1'' through ``n2'' out of a string
    tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    position_1 : MaybeSequence[Union[float, int]]
                 Input tuple with start position(s) ``n1''.

    position_2 : MaybeSequence[Union[float, int]]
                 Input tuple with end position(s) ``n2''.

    Returns
    -------

    substring : Sequence[str]
                Characters of the string(s) from position ``n1'' to ``n2''.

    Alternatives
    ------------
    tuple_str_first_n, tuple_str_last_n, tuple_strstr, tuple_strrstr,
    tuple_strlen, tuple_strchr, tuple_strrchr, tuple_split,
    tuple_environment
    """
    with HalconOperator(148) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, position_1)
        proc.set_input_tuple(2, position_2)
        proc.init_oct(0)
        proc.execute()
        substring = proc.get_output_tuple_m(0)
        return substring  # type: ignore


def tuple_substr_s(
    string: MaybeSequence[str],
    position_1: MaybeSequence[Union[float, int]],
    position_2: MaybeSequence[Union[float, int]]
) -> str:
    """
    Cut characters from position ``n1'' through ``n2'' out of a string
    tuple.

    Parameters
    ----------

    string : MaybeSequence[str]
             Input tuple with string(s) to examine.

    position_1 : MaybeSequence[Union[float, int]]
                 Input tuple with start position(s) ``n1''.

    position_2 : MaybeSequence[Union[float, int]]
                 Input tuple with end position(s) ``n2''.

    Returns
    -------

    substring : str
                Characters of the string(s) from position ``n1'' to ``n2''.

    Alternatives
    ------------
    tuple_str_first_n, tuple_str_last_n, tuple_strstr, tuple_strrstr,
    tuple_strlen, tuple_strchr, tuple_strrchr, tuple_split,
    tuple_environment
    """
    with HalconOperator(148) as proc:
        proc.set_input_tuple(0, string)
        proc.set_input_tuple(1, position_1)
        proc.set_input_tuple(2, position_2)
        proc.init_oct(0)
        proc.execute()
        substring = proc.get_output_tuple_s(0)
        return substring  # type: ignore


def tuple_sum(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Return the sum of all elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    sum : Sequence[Union[float, int, str]]
          Sum of tuple elements.

    See Also
    --------
    tuple_cumul

    Alternatives
    ------------
    tuple_mean, tuple_deviation, tuple_min, tuple_max, tuple_length,
    tuple_median
    """
    with HalconOperator(124) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        sum = proc.get_output_tuple_m(0)
        return sum  # type: ignore


def tuple_sum_s(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Return the sum of all elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    sum : Union[float, int, str]
          Sum of tuple elements.

    See Also
    --------
    tuple_cumul

    Alternatives
    ------------
    tuple_mean, tuple_deviation, tuple_min, tuple_max, tuple_length,
    tuple_median
    """
    with HalconOperator(124) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        sum = proc.get_output_tuple_s(0)
        return sum  # type: ignore


def tuple_symmdiff(
    set_1: HTupleType,
    set_2: HTupleType
) -> Sequence[HTupleElementType]:
    """
    Compute the symmetric difference set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    symm_diff : Sequence[HTupleElementType]
                The symmetric difference set of two input tuples.

    See Also
    --------
    tuple_difference, tuple_intersection, tuple_union

    Alternatives
    ------------
    tuple_difference
    """
    with HalconOperator(99) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        symm_diff = proc.get_output_tuple_m(0)
        return symm_diff  # type: ignore


def tuple_symmdiff_s(
    set_1: HTupleType,
    set_2: HTupleType
) -> HTupleElementType:
    """
    Compute the symmetric difference set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    symm_diff : HTupleElementType
                The symmetric difference set of two input tuples.

    See Also
    --------
    tuple_difference, tuple_intersection, tuple_union

    Alternatives
    ------------
    tuple_difference
    """
    with HalconOperator(99) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        symm_diff = proc.get_output_tuple_s(0)
        return symm_diff  # type: ignore


def tuple_tan(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the tangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    tan : Sequence[float]
          Tangent of the input tuple.

    See Also
    --------
    tuple_atan, tuple_atan2, tuple_tanh, tuple_atanh

    Alternatives
    ------------
    tuple_sin, tuple_cos
    """
    with HalconOperator(206) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        tan = proc.get_output_tuple_m(0)
        return tan  # type: ignore


def tuple_tan_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the tangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    tan : float
          Tangent of the input tuple.

    See Also
    --------
    tuple_atan, tuple_atan2, tuple_tanh, tuple_atanh

    Alternatives
    ------------
    tuple_sin, tuple_cos
    """
    with HalconOperator(206) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        tan = proc.get_output_tuple_s(0)
        return tan  # type: ignore


def tuple_tanh(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the hyperbolic tangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    tanh : Sequence[float]
           Hyperbolic tangent of the input tuple.

    See Also
    --------
    tuple_atanh, tuple_tan, tuple_atan, tuple_atan2

    Alternatives
    ------------
    tuple_sinh, tuple_cosh
    """
    with HalconOperator(197) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        tanh = proc.get_output_tuple_m(0)
        return tanh  # type: ignore


def tuple_tanh_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the hyperbolic tangent of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    tanh : float
           Hyperbolic tangent of the input tuple.

    See Also
    --------
    tuple_atanh, tuple_tan, tuple_atan, tuple_atan2

    Alternatives
    ------------
    tuple_sinh, tuple_cosh
    """
    with HalconOperator(197) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        tanh = proc.get_output_tuple_s(0)
        return tanh  # type: ignore


def tuple_tgamma(t: MaybeSequence[Union[float, int]]) -> Sequence[float]:
    """
    Compute the gamma function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    gamma : Sequence[float]
            Value of the gamma function of the input tuple.

    Alternatives
    ------------
    tuple_lgamma
    """
    with HalconOperator(2203) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        gamma = proc.get_output_tuple_m(0)
        return gamma  # type: ignore


def tuple_tgamma_s(t: MaybeSequence[Union[float, int]]) -> float:
    """
    Compute the gamma function of a tuple.

    Parameters
    ----------

    t : MaybeSequence[Union[float, int]]
        Input tuple.

    Returns
    -------

    gamma : float
            Value of the gamma function of the input tuple.

    Alternatives
    ------------
    tuple_lgamma
    """
    with HalconOperator(2203) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        gamma = proc.get_output_tuple_s(0)
        return gamma  # type: ignore


def tuple_type(t: HTupleType) -> int:
    """
    Return the type of a tuple.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    type : int
           Type of the input tuple as an integer number.

    See Also
    --------
    get_obj_class

    Alternatives
    ------------
    tuple_is_int, tuple_is_number, tuple_is_real, tuple_is_string,
    tuple_sem_type

    Notes
    -----
    tuple_type returns the internal data type of the tuple. In contrast to
    tuple_is_number it does not return whether a tuple could be
    represented as a tuple of a certain type.
    """
    with HalconOperator(108) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        type = proc.get_output_tuple_s(0)
        return type  # type: ignore


def tuple_type_elem(t: HTupleType) -> Sequence[int]:
    """
    Return the types of the elements of a tuple.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    types : Sequence[int]
            Types of the elements of the input tuple as integer values.

    See Also
    --------
    get_obj_class, tuple_is_number

    Alternatives
    ------------
    tuple_type, tuple_is_mixed, tuple_is_int, tuple_is_real,
    tuple_is_string, tuple_is_mixed, tuple_is_int_elem,
    tuple_is_real_elem, tuple_is_string_elem
    """
    with HalconOperator(103) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        types = proc.get_output_tuple_m(0)
        return types  # type: ignore


def tuple_type_elem_s(t: HTupleType) -> int:
    """
    Return the types of the elements of a tuple.

    Parameters
    ----------

    t : HTupleType
        Input tuple.

    Returns
    -------

    types : int
            Types of the elements of the input tuple as integer values.

    See Also
    --------
    get_obj_class, tuple_is_number

    Alternatives
    ------------
    tuple_type, tuple_is_mixed, tuple_is_int, tuple_is_real,
    tuple_is_string, tuple_is_mixed, tuple_is_int_elem,
    tuple_is_real_elem, tuple_is_string_elem
    """
    with HalconOperator(103) as proc:
        proc.set_input_tuple(0, t)
        proc.init_oct(0)
        proc.execute()
        types = proc.get_output_tuple_s(0)
        return types  # type: ignore


def tuple_union(
    set_1: HTupleType,
    set_2: HTupleType
) -> Sequence[HTupleElementType]:
    """
    Compute the union set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    union : Sequence[HTupleElementType]
            The union set of two input tuples.

    See Also
    --------
    tuple_difference, tuple_intersection, tuple_symmdiff

    Alternatives
    ------------
    tuple_intersection
    """
    with HalconOperator(96) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        union = proc.get_output_tuple_m(0)
        return union  # type: ignore


def tuple_union_s(
    set_1: HTupleType,
    set_2: HTupleType
) -> HTupleElementType:
    """
    Compute the union set of two input tuples.

    Parameters
    ----------

    set_1 : HTupleType
            Input tuple.

    set_2 : HTupleType
            Input tuple.

    Returns
    -------

    union : HTupleElementType
            The union set of two input tuples.

    See Also
    --------
    tuple_difference, tuple_intersection, tuple_symmdiff

    Alternatives
    ------------
    tuple_intersection
    """
    with HalconOperator(96) as proc:
        proc.set_input_tuple(0, set_1)
        proc.set_input_tuple(1, set_2)
        proc.init_oct(0)
        proc.execute()
        union = proc.get_output_tuple_s(0)
        return union  # type: ignore


def tuple_uniq(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Sequence[Union[float, int, str]]:
    """
    Discard all but one of successive identical elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    uniq : Sequence[Union[float, int, str]]
           Tuple without successive identical elements.

    Alternatives
    ------------
    tuple_intersection

    Predecessors
    ------------
    tuple_inverse, tuple_sort
    """
    with HalconOperator(127) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        uniq = proc.get_output_tuple_m(0)
        return uniq  # type: ignore


def tuple_uniq_s(
    tuple: MaybeSequence[Union[float, int, str]]
) -> Union[float, int, str]:
    """
    Discard all but one of successive identical elements of a tuple.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Input tuple.

    Returns
    -------

    uniq : Union[float, int, str]
           Tuple without successive identical elements.

    Alternatives
    ------------
    tuple_intersection

    Predecessors
    ------------
    tuple_inverse, tuple_sort
    """
    with HalconOperator(127) as proc:
        proc.set_input_tuple(0, tuple)
        proc.init_oct(0)
        proc.execute()
        uniq = proc.get_output_tuple_s(0)
        return uniq  # type: ignore


def tuple_xor(
    t1: MaybeSequence[int],
    t2: MaybeSequence[int]
) -> Sequence[int]:
    """
    Compute the logical exclusive or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    xor : Sequence[int]
          Binary exclusive or of the input tuples.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_and, tuple_or, tuple_not
    """
    with HalconOperator(169) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        xor = proc.get_output_tuple_m(0)
        return xor  # type: ignore


def tuple_xor_s(t1: MaybeSequence[int], t2: MaybeSequence[int]) -> int:
    """
    Compute the logical exclusive or of two tuples.

    Parameters
    ----------

    t1 : MaybeSequence[int]
         Input tuple 1.

    t2 : MaybeSequence[int]
         Input tuple 2.

    Returns
    -------

    xor : int
          Binary exclusive or of the input tuples.

    See Also
    --------
    tuple_band, tuple_bor, tuple_bxor, tuple_bnot

    Alternatives
    ------------
    tuple_and, tuple_or, tuple_not
    """
    with HalconOperator(169) as proc:
        proc.set_input_tuple(0, t1)
        proc.set_input_tuple(1, t2)
        proc.init_oct(0)
        proc.execute()
        xor = proc.get_output_tuple_s(0)
        return xor  # type: ignore


def uncalibrated_photometric_stereo(
    images: HObject,
    result_type: Sequence[str]
) -> Tuple[HObject, HObject, HObject]:
    """
    Reconstruct a surface from several, differently illuminated images.

    Parameters
    ----------

    images : HObject
             The input images with different illumination.

    result_type : Sequence[str]
                  The result type.
                  Value Suggestion: all

    Returns
    -------

    normal_field : HObject
                   The normal field of the surface.

    gradient : HObject
               The gradient field of the surface .

    albedo : HObject
             The albedo of the surface.

    See Also
    --------
    photometric_stereo

    Alternatives
    ------------
    photometric_stereo
    """
    with HalconOperator(2101) as proc:
        proc.set_input_object(1, images)
        proc.set_input_tuple(0, result_type)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # normal_field
            HObject(proc.get_output_object_key(2)),  # gradient
            HObject(proc.get_output_object_key(3))   # albedo
        )  # type: ignore


def union1(region: HObject) -> HObject:
    """
    Return the union of all input regions.

    Parameters
    ----------

    region : HObject
             Regions of which the union is to be computed.

    Returns
    -------

    region_union : HObject
                   Union of all input regions.

    See Also
    --------
    intersection, complement

    Alternatives
    ------------
    union2

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(483) as proc:
        proc.set_input_object(1, region)
        proc.execute()
        region_union = HObject(proc.get_output_object_key(1))
        return region_union  # type: ignore


def union2(region_1: HObject, region_2: HObject) -> HObject:
    """
    Return the union of two regions.

    Parameters
    ----------

    region_1 : HObject
               Region for which the union with all regions in Region2 is
               to be computed.

    region_2 : HObject
               Regions which should be added to Region1.

    Returns
    -------

    region_union : HObject
                   Resulting regions.

    See Also
    --------
    intersection, complement

    Alternatives
    ------------
    union1

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(482) as proc:
        proc.set_input_object(1, region_1)
        proc.set_input_object(2, region_2)
        proc.execute()
        region_union = HObject(proc.get_output_object_key(1))
        return region_union  # type: ignore


def union2_closed_contours_xld(
    contours_1: HObject,
    contours_2: HObject
) -> HObject:
    """
    Compute the union of closed contours.

    Parameters
    ----------

    contours_1 : HObject
                 Contours enclosing the first region.

    contours_2 : HObject
                 Contours enclosing the second region.

    Returns
    -------

    contours_union : HObject
                     Contours enclosing the union.

    See Also
    --------
    difference_closed_contours_xld, symm_difference_closed_contours_xld,
    intersection_closed_contours_xld, union2_closed_polygons_xld

    Alternatives
    ------------
    union2

    Predecessors
    ------------
    gen_contour_region_xld, zero_crossing_sub_pix, threshold_sub_pix
    """
    with HalconOperator(6) as proc:
        proc.set_input_object(1, contours_1)
        proc.set_input_object(2, contours_2)
        proc.execute()
        contours_union = HObject(proc.get_output_object_key(1))
        return contours_union  # type: ignore


def union2_closed_polygons_xld(
    polygons_1: HObject,
    polygons_2: HObject
) -> HObject:
    """
    Compute the union of closed polygons.

    Parameters
    ----------

    polygons_1 : HObject
                 Polygons enclosing the first region.

    polygons_2 : HObject
                 Polygons enclosing the second region.

    Returns
    -------

    polygons_union : HObject
                     Polygons enclosing the union.

    See Also
    --------
    difference_closed_polygons_xld, symm_difference_closed_polygons_xld,
    intersection_closed_polygons_xld, union2_closed_contours_xld

    Alternatives
    ------------
    union2

    Predecessors
    ------------
    gen_polygons_xld

    Notes
    -----
    The resulting polygons PolygonsUnion contain no references to the XLD
    contours that are possibly referenced by Polygons1 and Polygons2.
    Hence, operators that access the contours associated with a polygon,
    e.g., split_contours_xld will not work correctly.
    """
    with HalconOperator(5) as proc:
        proc.set_input_object(1, polygons_1)
        proc.set_input_object(2, polygons_2)
        proc.execute()
        polygons_union = HObject(proc.get_output_object_key(1))
        return polygons_union  # type: ignore


def union_adjacent_contours_xld(
    contours: HObject,
    max_dist_abs: float,
    max_dist_rel: float,
    mode: str
) -> HObject:
    """
    Compute the union of contours whose end points are close together.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    max_dist_abs : float
                   Maximum distance of the contours' end points.
                   Value Suggestion: 10.0

    max_dist_rel : float
                   Maximum distance of the contours' end points in
                   relation to the length of the longer contour.
                   Value Suggestion: 1.0

    mode : str
           Mode describing the treatment of the contours' attributes.
           Value Suggestion: attr_keep

    Returns
    -------

    union_contours : HObject
                     Output XLD contours.

    See Also
    --------
    edges_sub_pix, threshold_sub_pix, gen_polygons_xld,
    split_contours_xld, select_contours_xld, get_contour_xld,
    get_contour_attrib_xld

    Alternatives
    ------------
    union_collinear_contours_xld, union_collinear_contours_ext_xld,
    union_cocircular_contours_xld, union_straight_contours_xld,
    union_cotangential_contours_xld

    Predecessors
    ------------
    split_contours_xld, select_contours_xld
    """
    with HalconOperator(58) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, max_dist_abs)
        proc.set_input_tuple(1, max_dist_rel)
        proc.set_input_tuple(2, mode)
        proc.execute()
        union_contours = HObject(proc.get_output_object_key(1))
        return union_contours  # type: ignore


def union_cocircular_contours_xld(
    contours: HObject,
    max_arc_angle_diff: Union[int, float],
    max_arc_overlap: Union[int, float],
    max_tangent_angle: Union[int, float],
    max_dist: Union[int, float],
    max_radius_diff: Union[int, float],
    max_center_dist: Union[int, float],
    merge_small_contours: str,
    iterations: int
) -> HObject:
    """
    Compute the union of contours that belong to the same circle.

    Parameters
    ----------

    contours : HObject
               Contours to be merged.

    max_arc_angle_diff : Union[int, float]
                         Maximum angular distance of two circular arcs.
                         Value Suggestion: 0.5

    max_arc_overlap : Union[int, float]
                      Maximum overlap of two circular arcs.
                      Value Suggestion: 0.1

    max_tangent_angle : Union[int, float]
                        Maximum angle between the connecting line and the
                        tangents of circular arcs.
                        Value Suggestion: 0.2

    max_dist : Union[int, float]
               Maximum length of the gap between two circular arcs in
               pixels.
               Value Suggestion: 30

    max_radius_diff : Union[int, float]
                      Maximum radius difference of the circles fitted to
                      two arcs.
                      Value Suggestion: 10

    max_center_dist : Union[int, float]
                      Maximum center distance of the circles fitted to two
                      arcs.
                      Value Suggestion: 10

    merge_small_contours : str
                           Determine whether small contours without fitted
                           circles should also be merged.
                           Value Suggestion: true

    iterations : int
                 Number of iterations.
                 Value Suggestion: 1

    Returns
    -------

    union_contours : HObject
                     Merged contours.

    Alternatives
    ------------
    union_collinear_contours_xld, union_cotangential_contours_xld,
    union_straight_contours_xld, union_adjacent_contours_xld,
    union_collinear_contours_ext_xld

    Predecessors
    ------------
    split_contours_xld, select_contours_xld

    Notes
    -----
    Note that already closed contours are not considered for a union
    anymore. That is, even if a contour and the already closed contour
    share the same circle, they are returned as separate contours.
    """
    with HalconOperator(13) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, max_arc_angle_diff)
        proc.set_input_tuple(1, max_arc_overlap)
        proc.set_input_tuple(2, max_tangent_angle)
        proc.set_input_tuple(3, max_dist)
        proc.set_input_tuple(4, max_radius_diff)
        proc.set_input_tuple(5, max_center_dist)
        proc.set_input_tuple(6, merge_small_contours)
        proc.set_input_tuple(7, iterations)
        proc.execute()
        union_contours = HObject(proc.get_output_object_key(1))
        return union_contours  # type: ignore


def union_collinear_contours_ext_xld(
    contours: HObject,
    max_dist_abs: float,
    max_dist_rel: float,
    max_shift: float,
    max_angle: float,
    max_overlap: float,
    max_regr_error: float,
    max_costs: float,
    weight_dist: float,
    weight_shift: float,
    weight_angle: float,
    weight_link: float,
    weight_regr: float,
    mode: str
) -> HObject:
    """
    Compute the union of collinear contours  (operator with extended
    functionality).

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    max_dist_abs : float
                   Maximum distance of the contours' end points in the
                   direction of the reference regression line.
                   Value Suggestion: 10.0

    max_dist_rel : float
                   Maximum distance of the contours' end points in the
                   direction of the reference regression line in relation
                   to the length of the contour which is to be elongated.
                   Value Suggestion: 1.0

    max_shift : float
                Maximum distance of the contour from the reference
                regression line (i.e., perpendicular to the line).
                Value Suggestion: 2.0

    max_angle : float
                Maximum angle difference between the two contours.
                Value Suggestion: 0.1

    max_overlap : float
                  Maximum range of the overlap.
                  Value Suggestion: 0.0

    max_regr_error : float
                     Maximum regression error of the resulting contours
                     (NOT USED).
                     Value Suggestion: -1.0

    max_costs : float
                Threshold for reducing the total costs of unification.
                Value Suggestion: 1.0

    weight_dist : float
                  Influence of the distance in the line direction on the
                  total costs.
                  Value Suggestion: 1.0

    weight_shift : float
                   Influence of the distance from the regression line on
                   the total costs.
                   Value Suggestion: 1.0

    weight_angle : float
                   Influence of the angle difference on the total costs.
                   Value Suggestion: 1.0

    weight_link : float
                  Influence of the line disturbance by the linking segment
                  (overlap and angle difference) on the total costs.
                  Value Suggestion: 1.0

    weight_regr : float
                  Influence of the regression error on the total costs
                  (NOT USED).
                  Value Suggestion: 0.0

    mode : str
           Mode describing the treatment of the contours' attributes
           Value Suggestion: attr_keep

    Returns
    -------

    union_contours : HObject
                     Output XLD contours.

    See Also
    --------
    edges_sub_pix, threshold_sub_pix, gen_polygons_xld,
    split_contours_xld, select_contours_xld, get_contour_xld,
    get_contour_attrib_xld

    Alternatives
    ------------
    union_collinear_contours_xld, union_cocircular_contours_xld,
    union_cotangential_contours_xld, union_adjacent_contours_xld,
    union_straight_contours_xld

    Predecessors
    ------------
    split_contours_xld, select_contours_xld
    """
    with HalconOperator(56) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, max_dist_abs)
        proc.set_input_tuple(1, max_dist_rel)
        proc.set_input_tuple(2, max_shift)
        proc.set_input_tuple(3, max_angle)
        proc.set_input_tuple(4, max_overlap)
        proc.set_input_tuple(5, max_regr_error)
        proc.set_input_tuple(6, max_costs)
        proc.set_input_tuple(7, weight_dist)
        proc.set_input_tuple(8, weight_shift)
        proc.set_input_tuple(9, weight_angle)
        proc.set_input_tuple(10, weight_link)
        proc.set_input_tuple(11, weight_regr)
        proc.set_input_tuple(12, mode)
        proc.execute()
        union_contours = HObject(proc.get_output_object_key(1))
        return union_contours  # type: ignore


def union_collinear_contours_xld(
    contours: HObject,
    max_dist_abs: float,
    max_dist_rel: float,
    max_shift: float,
    max_angle: float,
    mode: str
) -> HObject:
    """
    Unite approximately collinear contours.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    max_dist_abs : float
                   Maximum length of the gap between two contours,
                   measured along the regression line of the reference
                   contour.
                   Value Suggestion: 10.0

    max_dist_rel : float
                   Maximum length of the gap between two contours,
                   relative to the length of the reference contour, both
                   measured along the regression line of the reference
                   contour.
                   Value Suggestion: 1.0

    max_shift : float
                Maximum distance of the second contour from the regression
                line of the reference contour.
                Value Suggestion: 2.0

    max_angle : float
                Maximum angle between the regression lines of two contours.
                Value Suggestion: 0.1

    mode : str
           Mode that defines the treatment of contour attributes, i.e., if
           the contour attributes are kept or discarded.
           Value Suggestion: attr_keep

    Returns
    -------

    union_contours : HObject
                     Output XLD contours.

    See Also
    --------
    get_contour_xld, get_contour_attrib_xld, query_contour_attribs_xld

    Alternatives
    ------------
    union_collinear_contours_ext_xld, union_straight_contours_xld,
    union_cocircular_contours_xld, union_cotangential_contours_xld,
    union_adjacent_contours_xld

    Predecessors
    ------------
    edges_sub_pix, lines_gauss, segment_contours_xld, select_contours_xld,
    select_shape_xld, split_contours_xld, threshold_sub_pix

    Successors
    ----------
    fit_line_contour_xld, select_contours_xld, select_shape_xld
    """
    with HalconOperator(57) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, max_dist_abs)
        proc.set_input_tuple(1, max_dist_rel)
        proc.set_input_tuple(2, max_shift)
        proc.set_input_tuple(3, max_angle)
        proc.set_input_tuple(4, mode)
        proc.execute()
        union_contours = HObject(proc.get_output_object_key(1))
        return union_contours  # type: ignore


def union_cotangential_contours_xld(
    contours: HObject,
    fit_clipping_length: float,
    fit_length: Union[float, str],
    max_tang_angle: float,
    max_dist: float,
    max_dist_perp: float,
    max_overlap: float,
    mode: str
) -> HObject:
    """
    Compute the union of cotangential contours.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    fit_clipping_length : float
                          Length of the part of a contour to skip for the
                          determination of tangents.
                          Value Suggestion: 0.0

    fit_length : Union[float, str]
                 Length of the part of a contour to use for the
                 determination of tangents.
                 Value Suggestion: 30.0

    max_tang_angle : float
                     Maximum angle difference between two contours'
                     tangents.
                     Value Suggestion: 0.78539816

    max_dist : float
               Maximum distance of the contours' end points.
               Value Suggestion: 25.0

    max_dist_perp : float
                    Maximum distance of the contours' end points
                    perpendicular to their tangents.
                    Value Suggestion: 10.0

    max_overlap : float
                  Maximum overlap of two contours.
                  Value Suggestion: 2.0

    mode : str
           Mode describing the treatment of the contours' attributes.
           Value Suggestion: attr_forget

    Returns
    -------

    union_contours : HObject
                     Output XLD contours.

    See Also
    --------
    edges_sub_pix, threshold_sub_pix, gen_polygons_xld, get_contour_xld,
    get_contour_attrib_xld

    Alternatives
    ------------
    union_collinear_contours_xld, union_collinear_contours_ext_xld,
    union_cocircular_contours_xld, union_straight_contours_xld,
    union_adjacent_contours_xld

    Predecessors
    ------------
    split_contours_xld, select_contours_xld
    """
    with HalconOperator(0) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, fit_clipping_length)
        proc.set_input_tuple(1, fit_length)
        proc.set_input_tuple(2, max_tang_angle)
        proc.set_input_tuple(3, max_dist)
        proc.set_input_tuple(4, max_dist_perp)
        proc.set_input_tuple(5, max_overlap)
        proc.set_input_tuple(6, mode)
        proc.execute()
        union_contours = HObject(proc.get_output_object_key(1))
        return union_contours  # type: ignore


def union_object_model_3d(
    object_models_3d: MaybeSequence[HHandle],
    method: str
) -> HHandle:
    """
    Combine several 3D object models to a new 3D object model.

    Parameters
    ----------

    object_models_3d : MaybeSequence[HHandle]
                       Handle of input 3D object models.

    method : str
             Method used for the union.
             Value Suggestion: 'points_surface'

    Returns
    -------

    union_object_model_3d : HHandle
                            Handle of the resulting 3D object model.

    See Also
    --------
    gen_box_object_model_3d, gen_sphere_object_model_3d,
    gen_cylinder_object_model_3d

    Predecessors
    ------------
    get_object_model_3d_params

    Successors
    ----------
    connection_object_model_3d, convex_hull_object_model_3d

    Notes
    -----
    union_object_model_3d ignores 3D object models of type 3D primitive
    and 3D shape model.
    """
    with HalconOperator(1062) as proc:
        proc.set_input_tuple(0, object_models_3d)
        proc.set_input_tuple(1, method)
        proc.init_oct(0)
        proc.execute()
        union_object_model_3d = proc.get_output_tuple_s(0)
        return union_object_model_3d  # type: ignore


def union_straight_contours_histo_xld(
    contours: HObject,
    ref_line_start_row: int,
    ref_line_start_column: int,
    ref_line_end_row: int,
    ref_line_end_column: int,
    width: int,
    max_width: int,
    filter_size: int
) -> Tuple[HObject, HObject, Sequence[int]]:
    """
    Compute the union of neighboring straight contours that have a similar
    distance from a given line.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    ref_line_start_row : int
                         y coordinate of the starting point of the
                         reference line.
                         Value Suggestion: 0

    ref_line_start_column : int
                            x coordinate of the starting point of the
                            reference line.
                            Value Suggestion: 0

    ref_line_end_row : int
                       y coordinate of the endpoint of the reference line.
                       Value Suggestion: 0

    ref_line_end_column : int
                          x coordinate of the endpoint of the reference
                          line.
                          Value Suggestion: 0

    width : int
            Maximum distance.
            Value Suggestion: 1

    max_width : int
                Maximum width between two minima.
                Value Suggestion: 1

    filter_size : int
                  Size of smoothing filter
                  Value Suggestion: 1

    Returns
    -------

    union_contours : HObject
                     Output XLD contours.

    selected_contours : HObject
                        Output XLD contours.

    histo_values : Sequence[int]
                   Output values of histogram.

    Warnings
    --------
    union_straight_contours_histo_xld is obsolete and is only provided
    for reasons of backward compatibility.  New applications should use
    the operators of the chapter 1D Measuring instead.

    Notes
    -----
    Before the contour parameters can be returned by
    union_straight_contours_histo_xld, the parameters of the regression
    line to the contour must be calculated by calling
    regress_contours_xld. Note further that already closed contours are
    not considered for a union anymore.
    """
    with HalconOperator(54) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, ref_line_start_row)
        proc.set_input_tuple(1, ref_line_start_column)
        proc.set_input_tuple(2, ref_line_end_row)
        proc.set_input_tuple(3, ref_line_end_column)
        proc.set_input_tuple(4, width)
        proc.set_input_tuple(5, max_width)
        proc.set_input_tuple(6, filter_size)
        proc.init_oct(0)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # union_contours
            HObject(proc.get_output_object_key(2)),  # selected_contours
            proc.get_output_tuple_m(0)   # histo_values
        )  # type: ignore


def union_straight_contours_xld(
    contours: HObject,
    max_dist: float,
    max_diff: float,
    percent: float,
    mode: str,
    iterations: Union[int, str]
) -> HObject:
    """
    Compute the union of neighboring straight contours that have a similar
    direction.

    Parameters
    ----------

    contours : HObject
               Input XLD contours.

    max_dist : float
               Maximum distance of the contours' endpoints.
               Value Suggestion: 5.0

    max_diff : float
               Maximum difference in direction.
               Value Suggestion: 0.5

    percent : float
              Weighting factor for the two selection criteria.
              Value Suggestion: 50.0

    mode : str
           Should parallel contours be taken into account?
           Value Suggestion: noparallel

    iterations : Union[int, str]
                 Number of iterations or 'maximum'.
                 Value Suggestion: maximum

    Returns
    -------

    union_contours : HObject
                     Output XLD contours.

    See Also
    --------
    fit_line_contour_xld, get_contour_xld, get_contour_attrib_xld,
    gen_contours_skeleton_xld, lines_gauss, lines_facet, edges_sub_pix,
    get_regress_params_xld, get_contour_global_attrib_xld,
    query_contour_global_attribs_xld

    Alternatives
    ------------
    union_collinear_contours_xld, union_collinear_contours_ext_xld,
    union_cocircular_contours_xld, union_cotangential_contours_xld,
    union_adjacent_contours_xld

    Predecessors
    ------------
    regress_contours_xld

    Notes
    -----
    Before the contour parameters can be returned by
    get_regress_params_xld, the parameters of the regression line to the
    contour must be calculated by calling regress_contours_xld.
    Furthermore, note that union_straight_contours_xld can not compute
    the union of contours with different contour point attributes.  This
    can be the case if different operators are used for the contour
    extraction (e.g., lines_gauss and lines_facet). For information on the
    contour attributes and when they are defined, see the  respective
    operator reference. You can query the point attributes of your
    contour using query_contour_attribs_xld.
    """
    with HalconOperator(55) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, max_dist)
        proc.set_input_tuple(1, max_diff)
        proc.set_input_tuple(2, percent)
        proc.set_input_tuple(3, mode)
        proc.set_input_tuple(4, iterations)
        proc.execute()
        union_contours = HObject(proc.get_output_object_key(1))
        return union_contours  # type: ignore


def unlock_mutex(mutex_handle: HHandle) -> None:
    """
    Unlock a mutex synchronization object.

    Parameters
    ----------

    mutex_handle : HHandle
                   Mutex synchronization object.

    Predecessors
    ------------
    lock_mutex, try_lock_mutex

    Successors
    ----------
    lock_mutex, try_lock_mutex, clear_mutex
    """
    with HalconOperator(561) as proc:
        proc.set_input_tuple(0, mutex_handle)
        proc.execute()


def unproject_coordinates(
    image: HObject,
    window_handle: HHandle,
    row: Union[float, int],
    column: Union[float, int]
) -> Tuple[int, int, Union[int, float]]:
    """
    Calculates image coordinates for a point in a 3D plot window.

    Parameters
    ----------

    image : HObject
            Displayed image.

    window_handle : HHandle
                    Window handle.

    row : Union[float, int]
          Row coordinate in the window.

    column : Union[float, int]
             Column coordinate in the window.

    Returns
    -------

    image_row : int
                Row coordinate in the image.

    image_column : int
                   Column coordinate in the image.

    height : Union[int, float]
             Height value.

    See Also
    --------
    disp_obj, update_window_pose, set_paint

    Predecessors
    ------------
    get_mbutton_sub_pix, get_mposition_sub_pix, disp_image
    """
    with HalconOperator(1168) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, row)
        proc.set_input_tuple(2, column)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # image_row
            proc.get_output_tuple_s(1),  # image_column
            proc.get_output_tuple_s(2)   # height
        )  # type: ignore


def unwarp_image_vector_field(
    image: HObject,
    vector_field: HObject
) -> HObject:
    """
    Unwarp an image using a vector field.

    Parameters
    ----------

    image : HObject
            Input image.

    vector_field : HObject
                   Input vector field.

    Returns
    -------

    image_unwarped : HObject
                     Unwarped image.

    Predecessors
    ------------
    optical_flow_mg
    """
    with HalconOperator(1483) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, vector_field)
        proc.execute()
        image_unwarped = HObject(proc.get_output_object_key(1))
        return image_unwarped  # type: ignore


def update_bg_esti(
    present_image: HObject,
    up_date_region: HObject,
    bg_esti_handle: HHandle
) -> None:
    """
    Change the estimated background image.

    Parameters
    ----------

    present_image : HObject
                    Current image.

    up_date_region : HObject
                     Region describing areas to change.

    bg_esti_handle : HHandle
                     ID of the BgEsti data set.

    See Also
    --------
    run_bg_esti, give_bg_esti

    Predecessors
    ------------
    run_bg_esti

    Successors
    ----------
    run_bg_esti

    Notes
    -----
    The passed image (PresentImage) must have the same type and size as
    the background image of the current data set (initialized with
    create_bg_esti).
    """
    with HalconOperator(2004) as proc:
        proc.set_input_object(1, present_image)
        proc.set_input_object(2, up_date_region)
        proc.set_input_tuple(0, bg_esti_handle)
        proc.execute()


def update_kalman(
    file_name: str,
    dimension_in: Sequence[int],
    model_in: Sequence[float],
    measurement_in: Sequence[float]
) -> Tuple[Sequence[int], Sequence[float], Sequence[float]]:
    """
    Read an update file of a Kalman filter.

    Parameters
    ----------

    file_name : str
                Update file for a Kalman filter.
                Value Suggestion: 'kalman.updt'

    dimension_in : Sequence[int]
                   The dimensions of the state vector, measurement vector
                   and controller vector.
                   Value Suggestion: [3,1,0]

    model_in : Sequence[float]
               The lined up matrices A,C,Q, possibly G and u, and if
               necessary L which all have been stored in row-major order.
               Value Suggestion: [1.0,1.0,0.5,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,54.3,37.9,48.0,37.9,34.3,42.5,48.0,42.5,43.7]

    measurement_in : Sequence[float]
                     The matrix R stored in row-major order.
                     Value Suggestion: [1,2]

    Returns
    -------

    dimension_out : Sequence[int]
                    The dimensions of the state vector, measurement vector
                    and controller vector.

    model_out : Sequence[float]
                The lined up matrices A,C,Q, possibly G and u, and if
                necessary L which all have been stored in row-major order.

    measurement_out : Sequence[float]
                      The matrix R stored in row-major order.

    See Also
    --------
    read_kalman, filter_kalman

    Successors
    ----------
    filter_kalman

    Warnings
    --------
    update_kalman is obsolete and is only provided for reasons of backward
    compatibility.
    """
    with HalconOperator(1106) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, dimension_in)
        proc.set_input_tuple(2, model_in)
        proc.set_input_tuple(3, measurement_in)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # dimension_out
            proc.get_output_tuple_m(1),  # model_out
            proc.get_output_tuple_m(2)   # measurement_out
        )  # type: ignore


def update_window_pose(
    window_handle: HHandle,
    last_row: Union[float, int],
    last_col: Union[float, int],
    current_row: Union[float, int],
    current_col: Union[float, int],
    mode: str
) -> None:
    """
    Modify the pose of a 3D plot.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    last_row : Union[float, int]
               Row coordinate of the first point.

    last_col : Union[float, int]
               Column coordinate of the first point.

    current_row : Union[float, int]
                  Row coordinate of the second point.

    current_col : Union[float, int]
                  Column coordinate of the second point.

    mode : str
           Navigation mode.
           Value Suggestion: rotate

    See Also
    --------
    unproject_coordinates

    Predecessors
    ------------
    set_paint, open_window, get_mposition_sub_pix, get_mbutton_sub_pix

    Successors
    ----------
    disp_image
    """
    with HalconOperator(1167) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, last_row)
        proc.set_input_tuple(2, last_col)
        proc.set_input_tuple(3, current_row)
        proc.set_input_tuple(4, current_col)
        proc.set_input_tuple(5, mode)
        proc.execute()


def var_threshold(
    image: HObject,
    mask_width: int,
    mask_height: int,
    std_dev_scale: Union[int, float],
    abs_threshold: Union[int, float],
    light_dark: str
) -> HObject:
    """
    Threshold an image by local mean and standard deviation analysis.

    Parameters
    ----------

    image : HObject
            Input image.

    mask_width : int
                 Mask width for mean and deviation calculation.
                 Value Suggestion: 15
                 Assertion: MaskWidth >= 1

    mask_height : int
                  Mask height for mean and deviation calculation.
                  Value Suggestion: 15
                  Assertion: MaskHeight >= 1

    std_dev_scale : Union[int, float]
                    Factor for the standard deviation of the gray values.
                    Value Suggestion: 0.2

    abs_threshold : Union[int, float]
                    Minimum gray value difference from the mean.
                    Value Suggestion: 2

    light_dark : str
                 Threshold type.
                 Value Suggestion: dark

    Returns
    -------

    region : HObject
             Segmented regions.

    Alternatives
    ------------
    dyn_threshold, threshold

    Notes
    -----
    This operator may return unexpected results if an image with a
    reduced domain is used as input. Please refer to the chapter  Filters.
    """
    with HalconOperator(451) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.set_input_tuple(2, std_dev_scale)
        proc.set_input_tuple(3, abs_threshold)
        proc.set_input_tuple(4, light_dark)
        proc.execute()
        region = HObject(proc.get_output_object_key(1))
        return region  # type: ignore


def vector_angle_to_rigid(
    row_1: Union[float, int],
    column_1: Union[float, int],
    angle_1: Union[float, int],
    row_2: Union[float, int],
    column_2: Union[float, int],
    angle_2: Union[float, int]
) -> Sequence[float]:
    """
    Compute a rigid affine transformation from points and angles.

    Parameters
    ----------

    row_1 : Union[float, int]
            Row coordinate of the original point.

    column_1 : Union[float, int]
               Column coordinate of the original point.

    angle_1 : Union[float, int]
              Angle of the original point.

    row_2 : Union[float, int]
            Row coordinate of the transformed point.

    column_2 : Union[float, int]
               Column coordinate of the transformed point.

    angle_2 : Union[float, int]
              Angle of the transformed point.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    See Also
    --------
    vector_field_to_hom_mat2d

    Alternatives
    ------------
    vector_to_rigid

    Predecessors
    ------------
    find_shape_model

    Successors
    ----------
    hom_mat2d_invert, affine_trans_image, affine_trans_region,
    affine_trans_contour_xld, affine_trans_polygon_xld,
    affine_trans_point_2d
    """
    with HalconOperator(264) as proc:
        proc.set_input_tuple(0, row_1)
        proc.set_input_tuple(1, column_1)
        proc.set_input_tuple(2, angle_1)
        proc.set_input_tuple(3, row_2)
        proc.set_input_tuple(4, column_2)
        proc.set_input_tuple(5, angle_2)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def vector_field_length(vector_field: HObject, mode: str) -> HObject:
    """
    Compute the length of the vectors of a vector field.

    Parameters
    ----------

    vector_field : HObject
                   Input vector field

    mode : str
           Mode for computing the length of the vectors.
           Value Suggestion: length

    Returns
    -------

    length : HObject
             Length of the vectors of the vector field.

    Predecessors
    ------------
    optical_flow_mg

    Successors
    ----------
    threshold
    """
    with HalconOperator(1485) as proc:
        proc.set_input_object(1, vector_field)
        proc.set_input_tuple(0, mode)
        proc.execute()
        length = HObject(proc.get_output_object_key(1))
        return length  # type: ignore


def vector_field_to_hom_mat2d(vector_field: HObject) -> Sequence[float]:
    """
    Approximate an affine map from a displacement vector field.

    Parameters
    ----------

    vector_field : HObject
                   Input image.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    Alternatives
    ------------
    vector_to_hom_mat2d

    Predecessors
    ------------
    optical_flow_mg

    Successors
    ----------
    affine_trans_image
    """
    with HalconOperator(1631) as proc:
        proc.set_input_object(1, vector_field)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def vector_field_to_real(
    vector_field: HObject
) -> Tuple[HObject, HObject]:
    """
    Convert a vector field image into two real-valued images.

    Parameters
    ----------

    vector_field : HObject
                   Vector field.

    Returns
    -------

    row : HObject
          Vector component in the row direction.

    col : HObject
          Vector component in the column direction.

    See Also
    --------
    optical_flow_mg

    Predecessors
    ------------
    optical_flow_mg
    """
    with HalconOperator(1473) as proc:
        proc.set_input_object(1, vector_field)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # row
            HObject(proc.get_output_object_key(2))   # col
        )  # type: ignore


def vector_to_aniso(
    px: Sequence[float],
    py: Sequence[float],
    qx: Sequence[float],
    qy: Sequence[float]
) -> Sequence[float]:
    """
    Approximate an anisotropic similarity transformation from point
    correspondences.

    Parameters
    ----------

    px : Sequence[float]
         X coordinates of the original points.

    py : Sequence[float]
         Y coordinates of the original points.

    qx : Sequence[float]
         X coordinates of the transformed points.

    qy : Sequence[float]
         Y coordinates of the transformed points.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    See Also
    --------
    vector_field_to_hom_mat2d, point_line_to_hom_mat2d

    Alternatives
    ------------
    vector_to_hom_mat2d, vector_to_similarity, vector_to_rigid

    Successors
    ----------
    hom_mat2d_invert, affine_trans_image, affine_trans_image_size,
    affine_trans_region, affine_trans_contour_xld,
    affine_trans_polygon_xld, affine_trans_point_2d

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(268) as proc:
        proc.set_input_tuple(0, px)
        proc.set_input_tuple(1, py)
        proc.set_input_tuple(2, qx)
        proc.set_input_tuple(3, qy)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def vector_to_essential_matrix(
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    cam_mat_1: Sequence[Union[float, int]],
    cam_mat_2: Sequence[Union[float, int]],
    method: str
) -> Tuple[Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the essential matrix given image point correspondences and
    known camera matrices and reconstruct 3D points.

    Parameters
    ----------

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 2

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) == length(Rows1)

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows1)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    cam_mat_1 : Sequence[Union[float, int]]
                Camera matrix of the 1st camera.

    cam_mat_2 : Sequence[Union[float, int]]
                Camera matrix of the 2nd camera.

    method : str
             Algorithm for the computation of the essential matrix and for
             special camera orientations.
             Value Suggestion: normalized_dlt

    Returns
    -------

    ematrix : Sequence[float]
              Computed essential matrix.

    cov_emat : Sequence[float]
               $9- covariance matrix of the essential matrix.

    error : Sequence[float]
            Root-Mean-Square of the epipolar distance error.

    x : Sequence[float]
        X coordinates of the reconstructed 3D points.

    y : Sequence[float]
        Y coordinates of the reconstructed 3D points.

    z : Sequence[float]
        Z coordinates of the reconstructed 3D points.

    cov_xyz : Sequence[float]
              Covariance matrices of the reconstructed 3D points.

    See Also
    --------
    stationary_camera_self_calibration

    Alternatives
    ------------
    vector_to_rel_pose, vector_to_fundamental_matrix

    Predecessors
    ------------
    match_essential_matrix_ransac

    Successors
    ----------
    essential_to_fundamental_matrix
    """
    with HalconOperator(356) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, cam_mat_1)
        proc.set_input_tuple(11, cam_mat_2)
        proc.set_input_tuple(12, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ematrix
            proc.get_output_tuple_m(1),  # cov_emat
            proc.get_output_tuple_m(2),  # error
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6)   # cov_xyz
        )  # type: ignore


def vector_to_essential_matrix_s(
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    cam_mat_1: Sequence[Union[float, int]],
    cam_mat_2: Sequence[Union[float, int]],
    method: str
) -> Tuple[Sequence[float], Sequence[float], float, Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the essential matrix given image point correspondences and
    known camera matrices and reconstruct 3D points.

    Parameters
    ----------

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 2

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) == length(Rows1)

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows1)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    cam_mat_1 : Sequence[Union[float, int]]
                Camera matrix of the 1st camera.

    cam_mat_2 : Sequence[Union[float, int]]
                Camera matrix of the 2nd camera.

    method : str
             Algorithm for the computation of the essential matrix and for
             special camera orientations.
             Value Suggestion: normalized_dlt

    Returns
    -------

    ematrix : Sequence[float]
              Computed essential matrix.

    cov_emat : Sequence[float]
               $9- covariance matrix of the essential matrix.

    error : float
            Root-Mean-Square of the epipolar distance error.

    x : Sequence[float]
        X coordinates of the reconstructed 3D points.

    y : Sequence[float]
        Y coordinates of the reconstructed 3D points.

    z : Sequence[float]
        Z coordinates of the reconstructed 3D points.

    cov_xyz : Sequence[float]
              Covariance matrices of the reconstructed 3D points.

    See Also
    --------
    stationary_camera_self_calibration

    Alternatives
    ------------
    vector_to_rel_pose, vector_to_fundamental_matrix

    Predecessors
    ------------
    match_essential_matrix_ransac

    Successors
    ----------
    essential_to_fundamental_matrix
    """
    with HalconOperator(356) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, cam_mat_1)
        proc.set_input_tuple(11, cam_mat_2)
        proc.set_input_tuple(12, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # ematrix
            proc.get_output_tuple_m(1),  # cov_emat
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6)   # cov_xyz
        )  # type: ignore


def vector_to_fundamental_matrix(
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    method: str
) -> Tuple[Sequence[float], Sequence[float], float, Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the fundamental matrix given a set of image point
    correspondences and reconstruct 3D points.

    Parameters
    ----------

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 8 || length(Rows1) >= 2

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) == length(Rows1)

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows1)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    method : str
             Estimation algorithm.
             Value Suggestion: normalized_dlt

    Returns
    -------

    fmatrix : Sequence[float]
              Computed fundamental matrix.

    cov_fmat : Sequence[float]
               $9- covariance matrix of the fundamental matrix.

    error : float
            Root-Mean-Square of the epipolar distance error.

    x : Sequence[float]
        X coordinates of the reconstructed points in projective 3D space.

    y : Sequence[float]
        Y coordinates of the reconstructed points in projective 3D space.

    z : Sequence[float]
        Z coordinates of the reconstructed points in projective 3D space.

    w : Sequence[float]
        W coordinates of the reconstructed points in projective 3D space.

    cov_xyzw : Sequence[float]
               Covariance matrices of the reconstructed 3D points.

    Alternatives
    ------------
    vector_to_essential_matrix, vector_to_rel_pose

    Predecessors
    ------------
    match_fundamental_matrix_ransac

    Successors
    ----------
    gen_binocular_proj_rectification
    """
    with HalconOperator(357) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.init_oct(7)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # fmatrix
            proc.get_output_tuple_m(1),  # cov_fmat
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6),  # w
            proc.get_output_tuple_m(7)   # cov_xyzw
        )  # type: ignore


def vector_to_fundamental_matrix_distortion(
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    image_width: int,
    image_height: int,
    method: str
) -> Tuple[Sequence[float], float, float, Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the fundamental matrix and the radial distortion coefficient
    given a set of image point correspondences and reconstruct 3D points.

    Parameters
    ----------

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 9 || length(Rows1) >= 4

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) == length(Rows1)

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows1)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    image_width : int
                  Width of the images from which the points were extracted.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images from which the points were
                   extracted.
                   Assertion: ImageHeight > 0

    method : str
             Estimation algorithm.
             Value Suggestion: gold_standard

    Returns
    -------

    fmatrix : Sequence[float]
              Computed fundamental matrix.

    kappa : float
            Computed radial distortion coefficient.

    error : float
            Root-Mean-Square epipolar distance error.

    x : Sequence[float]
        X coordinates of the reconstructed points in projective 3D space.

    y : Sequence[float]
        Y coordinates of the reconstructed points in projective 3D space.

    z : Sequence[float]
        Z coordinates of the reconstructed points in projective 3D space.

    w : Sequence[float]
        W coordinates of the reconstructed points in projective 3D space.

    See Also
    --------
    calibrate_cameras

    Alternatives
    ------------
    vector_to_fundamental_matrix, vector_to_essential_matrix,
    vector_to_rel_pose

    Predecessors
    ------------
    match_fundamental_matrix_distortion_ransac

    Successors
    ----------
    change_radial_distortion_cam_par, change_radial_distortion_image,
    change_radial_distortion_points, gen_binocular_proj_rectification
    """
    with HalconOperator(352) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, image_width)
        proc.set_input_tuple(11, image_height)
        proc.set_input_tuple(12, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # fmatrix
            proc.get_output_tuple_s(1),  # kappa
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6)   # w
        )  # type: ignore


def vector_to_hom_mat2d(
    px: Sequence[float],
    py: Sequence[float],
    qx: Sequence[float],
    qy: Sequence[float]
) -> Sequence[float]:
    """
    Approximate an affine transformation from point correspondences.

    Parameters
    ----------

    px : Sequence[float]
         X coordinates of the original points.

    py : Sequence[float]
         Y coordinates of the original points.

    qx : Sequence[float]
         X coordinates of the transformed points.

    qy : Sequence[float]
         Y coordinates of the transformed points.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    See Also
    --------
    vector_field_to_hom_mat2d, point_line_to_hom_mat2d

    Alternatives
    ------------
    vector_to_aniso, vector_to_similarity, vector_to_rigid

    Successors
    ----------
    affine_trans_image, affine_trans_image_size, affine_trans_region,
    affine_trans_contour_xld, affine_trans_polygon_xld,
    affine_trans_point_2d

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(269) as proc:
        proc.set_input_tuple(0, px)
        proc.set_input_tuple(1, py)
        proc.set_input_tuple(2, qx)
        proc.set_input_tuple(3, qy)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def vector_to_hom_mat3d(
    transformation_type: str,
    px: Sequence[float],
    py: Sequence[float],
    pz: Sequence[float],
    qx: Sequence[float],
    qy: Sequence[float],
    qz: Sequence[float]
) -> Sequence[float]:
    """
    Approximate a 3D transformation from point correspondences.

    Parameters
    ----------

    transformation_type : str
                          Type of the transformation to compute.
                          Value Suggestion: rigid

    px : Sequence[float]
         X coordinates of the original points.

    py : Sequence[float]
         Y coordinates of the original points.

    pz : Sequence[float]
         Z coordinates of the original points.

    qx : Sequence[float]
         X coordinates of the transformed points.

    qy : Sequence[float]
         Y coordinates of the transformed points.

    qz : Sequence[float]
         Z coordinates of the transformed points.

    Returns
    -------

    hom_mat_3d : Sequence[float]
                 Output transformation matrix.

    Successors
    ----------
    hom_mat3d_to_pose, affine_trans_point_3d
    """
    with HalconOperator(242) as proc:
        proc.set_input_tuple(0, transformation_type)
        proc.set_input_tuple(1, px)
        proc.set_input_tuple(2, py)
        proc.set_input_tuple(3, pz)
        proc.set_input_tuple(4, qx)
        proc.set_input_tuple(5, qy)
        proc.set_input_tuple(6, qz)
        proc.init_oct(0)
        proc.execute()
        hom_mat_3d = proc.get_output_tuple_m(0)
        return hom_mat_3d  # type: ignore


def vector_to_pose(
    world_x: Sequence[Union[float, int]],
    world_y: Sequence[Union[float, int]],
    world_z: Sequence[Union[float, int]],
    image_row: Sequence[Union[float, int]],
    image_column: Sequence[Union[float, int]],
    camera_param: Sequence[Union[float, int, str]],
    method: str,
    quality_type: MaybeSequence[str]
) -> Tuple[Sequence[Union[float, int]], Sequence[Union[float, int]]]:
    """
    Compute an absolute pose out of point correspondences between world
    and image coordinates.

    Parameters
    ----------

    world_x : Sequence[Union[float, int]]
              X-Component of world coordinates.

    world_y : Sequence[Union[float, int]]
              Y-Component of world coordinates.

    world_z : Sequence[Union[float, int]]
              Z-Component of world coordinates.

    image_row : Sequence[Union[float, int]]
                Row-Component of image coordinates.

    image_column : Sequence[Union[float, int]]
                   Column-Component of image coordinates.

    camera_param : Sequence[Union[float, int, str]]
                   The inner camera parameters from camera calibration.

    method : str
             Kind of algorithm
             Value Suggestion: iterative

    quality_type : MaybeSequence[str]
                   Type of pose quality to be returned in Quality.
                   Value Suggestion: error

    Returns
    -------

    pose : Sequence[Union[float, int]]
           Pose.

    quality : Sequence[Union[float, int]]
              Pose quality.

    See Also
    --------
    proj_hom_mat2d_to_pose, vector_to_rel_pose, camera_calibration

    Notes
    -----
    The method 'analytic' only allows a maximum number of 32767 point
    correspondences.
    """
    with HalconOperator(1902) as proc:
        proc.set_input_tuple(0, world_x)
        proc.set_input_tuple(1, world_y)
        proc.set_input_tuple(2, world_z)
        proc.set_input_tuple(3, image_row)
        proc.set_input_tuple(4, image_column)
        proc.set_input_tuple(5, camera_param)
        proc.set_input_tuple(6, method)
        proc.set_input_tuple(7, quality_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_m(1)   # quality
        )  # type: ignore


def vector_to_pose_s(
    world_x: Sequence[Union[float, int]],
    world_y: Sequence[Union[float, int]],
    world_z: Sequence[Union[float, int]],
    image_row: Sequence[Union[float, int]],
    image_column: Sequence[Union[float, int]],
    camera_param: Sequence[Union[float, int, str]],
    method: str,
    quality_type: MaybeSequence[str]
) -> Tuple[Sequence[Union[float, int]], Union[float, int]]:
    """
    Compute an absolute pose out of point correspondences between world
    and image coordinates.

    Parameters
    ----------

    world_x : Sequence[Union[float, int]]
              X-Component of world coordinates.

    world_y : Sequence[Union[float, int]]
              Y-Component of world coordinates.

    world_z : Sequence[Union[float, int]]
              Z-Component of world coordinates.

    image_row : Sequence[Union[float, int]]
                Row-Component of image coordinates.

    image_column : Sequence[Union[float, int]]
                   Column-Component of image coordinates.

    camera_param : Sequence[Union[float, int, str]]
                   The inner camera parameters from camera calibration.

    method : str
             Kind of algorithm
             Value Suggestion: iterative

    quality_type : MaybeSequence[str]
                   Type of pose quality to be returned in Quality.
                   Value Suggestion: error

    Returns
    -------

    pose : Sequence[Union[float, int]]
           Pose.

    quality : Union[float, int]
              Pose quality.

    See Also
    --------
    proj_hom_mat2d_to_pose, vector_to_rel_pose, camera_calibration

    Notes
    -----
    The method 'analytic' only allows a maximum number of 32767 point
    correspondences.
    """
    with HalconOperator(1902) as proc:
        proc.set_input_tuple(0, world_x)
        proc.set_input_tuple(1, world_y)
        proc.set_input_tuple(2, world_z)
        proc.set_input_tuple(3, image_row)
        proc.set_input_tuple(4, image_column)
        proc.set_input_tuple(5, camera_param)
        proc.set_input_tuple(6, method)
        proc.set_input_tuple(7, quality_type)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # pose
            proc.get_output_tuple_s(1)   # quality
        )  # type: ignore


def vector_to_proj_hom_mat2d(
    px: Sequence[Union[float, int]],
    py: Sequence[Union[float, int]],
    qx: Sequence[float],
    qy: Sequence[float],
    method: str,
    cov_xx1: Sequence[float],
    cov_yy1: Sequence[float],
    cov_xy1: Sequence[float],
    cov_xx2: Sequence[float],
    cov_yy2: Sequence[float],
    cov_xy2: Sequence[float]
) -> Tuple[Sequence[float], Sequence[float]]:
    """
    Compute a projective transformation matrix using given point
    correspondences.

    Parameters
    ----------

    px : Sequence[Union[float, int]]
         Input points in image 1 (row coordinate).

    py : Sequence[Union[float, int]]
         Input points in image 1 (column coordinate).

    qx : Sequence[float]
         Input points in image 2 (row coordinate).

    qy : Sequence[float]
         Input points in image 2 (column coordinate).

    method : str
             Estimation algorithm.
             Value Suggestion: normalized_dlt

    cov_xx1 : Sequence[float]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_yy1 : Sequence[float]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_xy1 : Sequence[float]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_xx2 : Sequence[float]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_yy2 : Sequence[float]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_xy2 : Sequence[float]
              Covariance of the points in image 2.
              Value Suggestion: []

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    covariance : Sequence[float]
                 $9- covariance matrix of the projective transformation
                 matrix.

    Alternatives
    ------------
    hom_vector_to_proj_hom_mat2d, proj_match_points_ransac,
    proj_match_points_ransac_guided

    Predecessors
    ------------
    proj_match_points_ransac, proj_match_points_ransac_guided,
    points_foerstner, points_harris

    Successors
    ----------
    projective_trans_image, projective_trans_image_size,
    projective_trans_region, projective_trans_contour_xld,
    projective_trans_point_2d, projective_trans_pixel

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(262) as proc:
        proc.set_input_tuple(0, px)
        proc.set_input_tuple(1, py)
        proc.set_input_tuple(2, qx)
        proc.set_input_tuple(3, qy)
        proc.set_input_tuple(4, method)
        proc.set_input_tuple(5, cov_xx1)
        proc.set_input_tuple(6, cov_yy1)
        proc.set_input_tuple(7, cov_xy1)
        proc.set_input_tuple(8, cov_xx2)
        proc.set_input_tuple(9, cov_yy2)
        proc.set_input_tuple(10, cov_xy2)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_m(1)   # covariance
        )  # type: ignore


def vector_to_proj_hom_mat2d_distortion(
    points_1row: Sequence[Union[float, int]],
    points_1col: Sequence[Union[float, int]],
    points_2row: Sequence[Union[float, int]],
    points_2col: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    image_width: int,
    image_height: int,
    method: str
) -> Tuple[Sequence[float], float, float]:
    """
    Compute a projective transformation matrix and the radial distortion
    coefficient using given image point correspondences.

    Parameters
    ----------

    points_1row : Sequence[Union[float, int]]
                  Input points in image 1 (row coordinate).
                  Assertion: length(Points1Row) >= 5

    points_1col : Sequence[Union[float, int]]
                  Input points in image 1 (column coordinate).
                  Assertion: length(Points1Col) == length(Points1Row)

    points_2row : Sequence[Union[float, int]]
                  Input points in image 2 (row coordinate).
                  Assertion: length(Points2Row) == length(Points1Row)

    points_2col : Sequence[Union[float, int]]
                  Input points in image 2 (column coordinate).
                  Assertion: length(Points2Col) == length(Points1Row)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    image_width : int
                  Width of the images from which the points were extracted.
                  Assertion: ImageWidth > 0

    image_height : int
                   Height of the images from which the points were
                   extracted.
                   Assertion: ImageHeight > 0

    method : str
             Estimation algorithm.
             Value Suggestion: gold_standard

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Homogeneous projective transformation matrix.

    kappa : float
            Computed radial distortion coefficient.

    error : float
            Root-Mean-Square transformation error.

    See Also
    --------
    calibrate_cameras

    Alternatives
    ------------
    vector_to_proj_hom_mat2d, hom_vector_to_proj_hom_mat2d

    Predecessors
    ------------
    proj_match_points_distortion_ransac,
    proj_match_points_distortion_ransac_guided, points_foerstner,
    points_harris

    Successors
    ----------
    change_radial_distortion_cam_par, change_radial_distortion_image,
    change_radial_distortion_points, projective_trans_image,
    projective_trans_image_size, projective_trans_region,
    projective_trans_contour_xld, projective_trans_point_2d,
    projective_trans_pixel

    Notes
    -----
    It should be noted that if a homogeneous transformation matrix is used
    to transform images, regions, XLD contours, or any other data that has
    been extracted from images, it is assumed that the origin of the
    coordinate system of the homogeneous transformation matrix lies in the
    upper left corner of a pixel.  The image processing operators that
    return point coordinates, however, assume a coordinate system in which
    the origin lies in the center of a pixel. Therefore, to obtain a
    consistent homogeneous transformation matrix, 0.5 must be added to the
    point coordinates before computing the transformation.
    """
    with HalconOperator(260) as proc:
        proc.set_input_tuple(0, points_1row)
        proc.set_input_tuple(1, points_1col)
        proc.set_input_tuple(2, points_2row)
        proc.set_input_tuple(3, points_2col)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, image_width)
        proc.set_input_tuple(11, image_height)
        proc.set_input_tuple(12, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # hom_mat_2d
            proc.get_output_tuple_s(1),  # kappa
            proc.get_output_tuple_s(2)   # error
        )  # type: ignore


def vector_to_rel_pose(
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    cam_par_1: Sequence[Union[float, int, str]],
    cam_par_2: Sequence[Union[float, int, str]],
    method: str
) -> Tuple[Sequence[Union[int, float]], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the relative orientation between two cameras given image point
    correspondences and known camera parameters and reconstruct 3D space
    points.

    Parameters
    ----------

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 2

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) == length(Rows1)

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows1)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    cam_par_1 : Sequence[Union[float, int, str]]
                Camera parameters of the 1st camera.

    cam_par_2 : Sequence[Union[float, int, str]]
                Camera parameters of the 2nd camera.

    method : str
             Algorithm for the computation of the relative pose and for
             special pose types.
             Value Suggestion: normalized_dlt

    Returns
    -------

    rel_pose : Sequence[Union[int, float]]
               Computed relative orientation of the cameras (3D pose).

    cov_rel_pose : Sequence[float]
                   $6- covariance matrix of the relative camera
                   orientation.

    error : Sequence[float]
            Root-Mean-Square of the epipolar distance error.

    x : Sequence[float]
        X coordinates of the reconstructed 3D points.

    y : Sequence[float]
        Y coordinates of the reconstructed 3D points.

    z : Sequence[float]
        Z coordinates of the reconstructed 3D points.

    cov_xyz : Sequence[float]
              Covariance matrices of the  reconstructed 3D points.

    See Also
    --------
    camera_calibration

    Alternatives
    ------------
    vector_to_essential_matrix, vector_to_fundamental_matrix,
    binocular_calibration

    Predecessors
    ------------
    match_rel_pose_ransac

    Successors
    ----------
    gen_binocular_rectification_map, rel_pose_to_fundamental_matrix
    """
    with HalconOperator(355) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, cam_par_1)
        proc.set_input_tuple(11, cam_par_2)
        proc.set_input_tuple(12, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rel_pose
            proc.get_output_tuple_m(1),  # cov_rel_pose
            proc.get_output_tuple_m(2),  # error
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6)   # cov_xyz
        )  # type: ignore


def vector_to_rel_pose_s(
    rows_1: Sequence[Union[float, int]],
    cols_1: Sequence[Union[float, int]],
    rows_2: Sequence[Union[float, int]],
    cols_2: Sequence[Union[float, int]],
    cov_rr1: Sequence[Union[float, int]],
    cov_rc1: Sequence[Union[float, int]],
    cov_cc1: Sequence[Union[float, int]],
    cov_rr2: Sequence[Union[float, int]],
    cov_rc2: Sequence[Union[float, int]],
    cov_cc2: Sequence[Union[float, int]],
    cam_par_1: Sequence[Union[float, int, str]],
    cam_par_2: Sequence[Union[float, int, str]],
    method: str
) -> Tuple[Sequence[Union[int, float]], Sequence[float], float, Sequence[float], Sequence[float], Sequence[float], Sequence[float]]:
    """
    Compute the relative orientation between two cameras given image point
    correspondences and known camera parameters and reconstruct 3D space
    points.

    Parameters
    ----------

    rows_1 : Sequence[Union[float, int]]
             Input points in image 1 (row coordinate).
             Assertion: length(Rows1) >= 6 || length(Rows1) >= 2

    cols_1 : Sequence[Union[float, int]]
             Input points in image 1 (column coordinate).
             Assertion: length(Cols1) == length(Rows1)

    rows_2 : Sequence[Union[float, int]]
             Input points in image 2 (row coordinate).
             Assertion: length(Rows2) == length(Rows1)

    cols_2 : Sequence[Union[float, int]]
             Input points in image 2 (column coordinate).
             Assertion: length(Cols2) == length(Rows1)

    cov_rr1 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rc1 : Sequence[Union[float, int]]
              Covariance of the points in image 1.
              Value Suggestion: []

    cov_cc1 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 1.
              Value Suggestion: []

    cov_rr2 : Sequence[Union[float, int]]
              Row coordinate variance of the points in image 2.
              Value Suggestion: []

    cov_rc2 : Sequence[Union[float, int]]
              Covariance of the points in image 2.
              Value Suggestion: []

    cov_cc2 : Sequence[Union[float, int]]
              Column coordinate variance of the points in image 2.
              Value Suggestion: []

    cam_par_1 : Sequence[Union[float, int, str]]
                Camera parameters of the 1st camera.

    cam_par_2 : Sequence[Union[float, int, str]]
                Camera parameters of the 2nd camera.

    method : str
             Algorithm for the computation of the relative pose and for
             special pose types.
             Value Suggestion: normalized_dlt

    Returns
    -------

    rel_pose : Sequence[Union[int, float]]
               Computed relative orientation of the cameras (3D pose).

    cov_rel_pose : Sequence[float]
                   $6- covariance matrix of the relative camera
                   orientation.

    error : float
            Root-Mean-Square of the epipolar distance error.

    x : Sequence[float]
        X coordinates of the reconstructed 3D points.

    y : Sequence[float]
        Y coordinates of the reconstructed 3D points.

    z : Sequence[float]
        Z coordinates of the reconstructed 3D points.

    cov_xyz : Sequence[float]
              Covariance matrices of the  reconstructed 3D points.

    See Also
    --------
    camera_calibration

    Alternatives
    ------------
    vector_to_essential_matrix, vector_to_fundamental_matrix,
    binocular_calibration

    Predecessors
    ------------
    match_rel_pose_ransac

    Successors
    ----------
    gen_binocular_rectification_map, rel_pose_to_fundamental_matrix
    """
    with HalconOperator(355) as proc:
        proc.set_input_tuple(0, rows_1)
        proc.set_input_tuple(1, cols_1)
        proc.set_input_tuple(2, rows_2)
        proc.set_input_tuple(3, cols_2)
        proc.set_input_tuple(4, cov_rr1)
        proc.set_input_tuple(5, cov_rc1)
        proc.set_input_tuple(6, cov_cc1)
        proc.set_input_tuple(7, cov_rr2)
        proc.set_input_tuple(8, cov_rc2)
        proc.set_input_tuple(9, cov_cc2)
        proc.set_input_tuple(10, cam_par_1)
        proc.set_input_tuple(11, cam_par_2)
        proc.set_input_tuple(12, method)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.init_oct(2)
        proc.init_oct(3)
        proc.init_oct(4)
        proc.init_oct(5)
        proc.init_oct(6)
        proc.execute()
        return (
            proc.get_output_tuple_m(0),  # rel_pose
            proc.get_output_tuple_m(1),  # cov_rel_pose
            proc.get_output_tuple_s(2),  # error
            proc.get_output_tuple_m(3),  # x
            proc.get_output_tuple_m(4),  # y
            proc.get_output_tuple_m(5),  # z
            proc.get_output_tuple_m(6)   # cov_xyz
        )  # type: ignore


def vector_to_rigid(
    px: Sequence[float],
    py: Sequence[float],
    qx: Sequence[float],
    qy: Sequence[float]
) -> Sequence[float]:
    """
    Approximate a rigid affine transformation from point correspondences.

    Parameters
    ----------

    px : Sequence[float]
         X coordinates of the original points.

    py : Sequence[float]
         Y coordinates of the original points.

    qx : Sequence[float]
         X coordinates of the transformed points.

    qy : Sequence[float]
         Y coordinates of the transformed points.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    See Also
    --------
    vector_field_to_hom_mat2d, point_line_to_hom_mat2d

    Alternatives
    ------------
    vector_to_hom_mat2d, vector_to_aniso, vector_to_similarity

    Successors
    ----------
    affine_trans_image, affine_trans_image_size, affine_trans_region,
    affine_trans_contour_xld, affine_trans_polygon_xld,
    affine_trans_point_2d

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(266) as proc:
        proc.set_input_tuple(0, px)
        proc.set_input_tuple(1, py)
        proc.set_input_tuple(2, qx)
        proc.set_input_tuple(3, qy)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def vector_to_similarity(
    px: Sequence[float],
    py: Sequence[float],
    qx: Sequence[float],
    qy: Sequence[float]
) -> Sequence[float]:
    """
    Approximate an similarity transformation from point correspondences.

    Parameters
    ----------

    px : Sequence[float]
         X coordinates of the original points.

    py : Sequence[float]
         Y coordinates of the original points.

    qx : Sequence[float]
         X coordinates of the transformed points.

    qy : Sequence[float]
         Y coordinates of the transformed points.

    Returns
    -------

    hom_mat_2d : Sequence[float]
                 Output transformation matrix.

    See Also
    --------
    vector_field_to_hom_mat2d, point_line_to_hom_mat2d

    Alternatives
    ------------
    vector_to_hom_mat2d, vector_to_aniso, vector_to_rigid

    Successors
    ----------
    affine_trans_image, affine_trans_image_size, affine_trans_region,
    affine_trans_contour_xld, affine_trans_polygon_xld,
    affine_trans_point_2d

    Notes
    -----
    It should be noted that homogeneous transformation matrices refer to a
    general right-handed mathematical coordinate system.  If a homogeneous
    transformation matrix is used to transform images, regions, XLD
    contours, or any other data that has been extracted from images, the
    row coordinates of the transformation must be passed in the x
    coordinates, while the column coordinates must be passed in the y
    coordinates.  Consequently, the order of passing row and column
    coordinates follows the usual order (Row,Column).  This convention is
    essential to obtain a right-handed coordinate system for the
    transformation of iconic data, and consequently to ensure in
    particular that rotations are performed in the correct mathematical
    direction.
    Furthermore, it should be noted that if a homogeneous transformation
    matrix is used to transform images, regions, XLD contours, or any
    other data that has been extracted from images, it is assumed that the
    origin of the coordinate system of the homogeneous transformation
    matrix lies in the upper left corner of a pixel.  The image processing
    operators that return point coordinates, however, assume a coordinate
    system in which the origin lies in the center of a pixel.  Therefore,
    to obtain a consistent homogeneous transformation matrix, 0.5 must be
    added to the point coordinates before computing the transformation.
    """
    with HalconOperator(267) as proc:
        proc.set_input_tuple(0, px)
        proc.set_input_tuple(1, py)
        proc.set_input_tuple(2, qx)
        proc.set_input_tuple(3, qy)
        proc.init_oct(0)
        proc.execute()
        hom_mat_2d = proc.get_output_tuple_m(0)
        return hom_mat_2d  # type: ignore


def volume_object_model_3d_relative_to_plane(
    object_model_3d: MaybeSequence[HHandle],
    plane: Sequence[Union[int, float]],
    mode: MaybeSequence[str],
    use_face_orientation: MaybeSequence[str]
) -> Sequence[float]:
    """
    Calculate the volume of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    plane : Sequence[Union[int, float]]
            Pose of the plane.
            Value Suggestion: [0,0,0,0,0,0,0]

    mode : MaybeSequence[str]
           Method to combine volumes laying above and below the reference
           plane.
           Value Suggestion: 'signed'

    use_face_orientation : MaybeSequence[str]
                           Decides whether the orientation of a face
                           should affect the resulting sign of the
                           underlying volume.
                           Value Suggestion: 'true'

    Returns
    -------

    volume : Sequence[float]
             Absolute value of the calculated volume.

    See Also
    --------
    area_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    select_points_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    The calculation of the volume might be numerically unstable in case of
    a large distance between the plane and the object (approx. distance >
    10000 times the object diameter).
    """
    with HalconOperator(1083) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, plane)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, use_face_orientation)
        proc.init_oct(0)
        proc.execute()
        volume = proc.get_output_tuple_m(0)
        return volume  # type: ignore


def volume_object_model_3d_relative_to_plane_s(
    object_model_3d: MaybeSequence[HHandle],
    plane: Sequence[Union[int, float]],
    mode: MaybeSequence[str],
    use_face_orientation: MaybeSequence[str]
) -> float:
    """
    Calculate the volume of a 3D object model.

    Parameters
    ----------

    object_model_3d : MaybeSequence[HHandle]
                      Handle of the 3D object model.

    plane : Sequence[Union[int, float]]
            Pose of the plane.
            Value Suggestion: [0,0,0,0,0,0,0]

    mode : MaybeSequence[str]
           Method to combine volumes laying above and below the reference
           plane.
           Value Suggestion: 'signed'

    use_face_orientation : MaybeSequence[str]
                           Decides whether the orientation of a face
                           should affect the resulting sign of the
                           underlying volume.
                           Value Suggestion: 'true'

    Returns
    -------

    volume : float
             Absolute value of the calculated volume.

    See Also
    --------
    area_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d,
    select_points_object_model_3d

    Successors
    ----------
    project_object_model_3d, object_model_3d_to_xyz

    Notes
    -----
    The calculation of the volume might be numerically unstable in case of
    a large distance between the plane and the object (approx. distance >
    10000 times the object diameter).
    """
    with HalconOperator(1083) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, plane)
        proc.set_input_tuple(2, mode)
        proc.set_input_tuple(3, use_face_orientation)
        proc.init_oct(0)
        proc.execute()
        volume = proc.get_output_tuple_s(0)
        return volume  # type: ignore


def wait_barrier(barrier_handle: HHandle) -> None:
    """
    Wait on the release of a barrier synchronization object.

    Parameters
    ----------

    barrier_handle : HHandle
                     Barrier synchronization object.

    Successors
    ----------
    clear_barrier
    """
    with HalconOperator(551) as proc:
        proc.set_input_tuple(0, barrier_handle)
        proc.execute()


def wait_condition(
    condition_handle: HHandle,
    mutex_handle: HHandle
) -> None:
    """
    wait on the signal of a condition synchronization object.

    Parameters
    ----------

    condition_handle : HHandle
                       Condition synchronization object.

    mutex_handle : HHandle
                   Mutex synchronization object.

    Successors
    ----------
    signal_condition, clear_condition
    """
    with HalconOperator(547) as proc:
        proc.set_input_tuple(0, condition_handle)
        proc.set_input_tuple(1, mutex_handle)
        proc.execute()


def wait_event(event_handle: HHandle) -> None:
    """
    Lock an event synchronization object.

    Parameters
    ----------

    event_handle : HHandle
                   Event synchronization object.

    Predecessors
    ------------
    create_event

    Successors
    ----------
    signal_event
    """
    with HalconOperator(557) as proc:
        proc.set_input_tuple(0, event_handle)
        proc.execute()


def wait_seconds(seconds: float) -> None:
    """
    Delaying the execution of the program.

    Parameters
    ----------

    seconds : float
              Number of seconds by which the execution of the program will
              be delayed.
              Value Suggestion: 10
              Assertion: Seconds >= 0

    See Also
    --------
    system_call, count_seconds

    Successors
    ----------
    system_call
    """
    with HalconOperator(315) as proc:
        proc.set_input_tuple(0, seconds)
        proc.execute()


def watersheds(image: HObject) -> Tuple[HObject, HObject]:
    """
    Extract watersheds and basins from an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    basins : HObject
             Segmented basins.

    watersheds : HObject
                 Watersheds between the basins.

    Alternatives
    ------------
    watersheds_threshold, pouring, watersheds_marker

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image, invert_image

    Successors
    ----------
    expand_region, select_shape, reduce_domain, opening

    Notes
    -----
    If the image contains many fine structures or is noisy, many output
    regions result, and thus the runtime increases considerably.
    """
    with HalconOperator(460) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        return (
            HObject(proc.get_output_object_key(1)),  # basins
            HObject(proc.get_output_object_key(2))   # watersheds
        )  # type: ignore


def watersheds_marker(image: HObject, markers: HObject) -> HObject:
    """
    Extract watersheds and combine basins based on markers.

    Parameters
    ----------

    image : HObject
            Input image.

    markers : HObject
              Initial markers from which to flood the image.

    Returns
    -------

    basins : HObject
             Basins for all markers.

    Alternatives
    ------------
    watersheds, pouring, watersheds_threshold

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image, invert_image, edges_image

    Successors
    ----------
    expand_region, select_shape, reduce_domain, opening

    Notes
    -----
    If the image contains many fine structures or is noisy, many watershed
    regions need to be processed internally, and thus the runtime
    increases  considerably.
    """
    with HalconOperator(2190) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, markers)
        proc.execute()
        basins = HObject(proc.get_output_object_key(1))
        return basins  # type: ignore


def watersheds_threshold(
    image: HObject,
    threshold: Union[float, int]
) -> HObject:
    """
    Extract watershed basins from an image using a threshold.

    Parameters
    ----------

    image : HObject
            Image to be segmented.

    threshold : Union[float, int]
                Threshold for the watersheds.
                Value Suggestion: 10
                Assertion: Threshold >= 0

    Returns
    -------

    basins : HObject
             Segments found (dark basins).

    Alternatives
    ------------
    watersheds, pouring, watersheds_marker

    Predecessors
    ------------
    binomial_filter, gauss_filter, smooth_image, invert_image

    Successors
    ----------
    expand_region, select_shape, reduce_domain, opening
    """
    with HalconOperator(459) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, threshold)
        proc.execute()
        basins = HObject(proc.get_output_object_key(1))
        return basins  # type: ignore


def wiener_filter(
    image: HObject,
    psf: HObject,
    filtered_image: HObject
) -> HObject:
    """
    Image restoration by Wiener filtering.

    Parameters
    ----------

    image : HObject
            Corrupted image.

    psf : HObject
          impulse response (PSF) of degradation (in spatial domain).

    filtered_image : HObject
                     Smoothed version of corrupted image.

    Returns
    -------

    restored_image : HObject
                     Restored image.

    See Also
    --------
    simulate_motion, gen_psf_motion, simulate_defocus, gen_psf_defocus

    Alternatives
    ------------
    wiener_filter_ni

    Predecessors
    ------------
    gen_psf_motion, simulate_motion, simulate_defocus, gen_psf_defocus,
    optimize_fft_speed

    Notes
    -----
    Psf must be of image type 'real' and conform to Image and
    FilteredImage in image width and height.
    """
    with HalconOperator(76) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, psf)
        proc.set_input_object(3, filtered_image)
        proc.execute()
        restored_image = HObject(proc.get_output_object_key(1))
        return restored_image  # type: ignore


def wiener_filter_ni(
    image: HObject,
    psf: HObject,
    noise_region: HObject,
    mask_width: int,
    mask_height: int
) -> HObject:
    """
    Image restoration by Wiener filtering.

    Parameters
    ----------

    image : HObject
            Corrupted image.

    psf : HObject
          impulse response (PSF) of degradation (in spatial domain).

    noise_region : HObject
                   Region for noise estimation.

    mask_width : int
                 Width of filter mask.
                 Value Suggestion: 3

    mask_height : int
                  Height of filter mask.
                  Value Suggestion: 3

    Returns
    -------

    restored_image : HObject
                     Restored image.

    See Also
    --------
    simulate_motion, gen_psf_motion, simulate_defocus, gen_psf_defocus

    Alternatives
    ------------
    wiener_filter

    Predecessors
    ------------
    gen_psf_motion, simulate_motion, simulate_defocus, gen_psf_defocus,
    optimize_fft_speed

    Notes
    -----
    Psf must be of image type 'real' and conform to Image in width and
    height. The Region used for noise estimation must lie completely
    within the image. If MaskWidth or MaskHeight is an even number, it is
    replaced by the next higher odd number (this allows the unique
    extraction of the center of the filter mask). Width/height of the mask
    may not exceed the image width/height or be less than null.
    """
    with HalconOperator(75) as proc:
        proc.set_input_object(1, image)
        proc.set_input_object(2, psf)
        proc.set_input_object(3, noise_region)
        proc.set_input_tuple(0, mask_width)
        proc.set_input_tuple(1, mask_height)
        proc.execute()
        restored_image = HObject(proc.get_output_object_key(1))
        return restored_image  # type: ignore


def write_aop_knowledge(
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, int, float]]
) -> None:
    """
    Write knowledge about hardware dependent behavior of automatic
    operator parallelization to file.

    Parameters
    ----------

    file_name : str
                Name of knowledge file
                Value Suggestion: ''

    gen_param_name : MaybeSequence[str]
                     Parameter name
                     Value Suggestion: none

    gen_param_value : MaybeSequence[Union[str, int, float]]
                      Parameter value
                      Value Suggestion: none
    """
    with HalconOperator(570) as proc:
        proc.set_input_tuple(0, file_name)
        proc.set_input_tuple(1, gen_param_name)
        proc.set_input_tuple(2, gen_param_value)
        proc.execute()


def write_bar_code_model(bar_code_handle: HHandle, file_name: str) -> None:
    """
    Write a bar code model to a file.

    Parameters
    ----------

    bar_code_handle : HHandle
                      Handle of the bar code model.

    file_name : str
                Name of the bar code model file.
                Value Suggestion: bar_code_model.bcm

    See Also
    --------
    create_bar_code_model, set_bar_code_param, find_bar_code

    Predecessors
    ------------
    create_bar_code_model, set_bar_code_param
    """
    with HalconOperator(1989) as proc:
        proc.set_input_tuple(0, bar_code_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_calib_data(calib_data_id: HHandle, file_name: str) -> None:
    """
    Store a calibration data model into a file.

    Parameters
    ----------

    calib_data_id : HHandle
                    Handle of a calibration data model.

    file_name : str
                The file name of the model to be saved.
    """
    with HalconOperator(1964) as proc:
        proc.set_input_tuple(0, calib_data_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_cam_par(
    camera_param: Sequence[Union[int, float, str]],
    cam_par_file: str
) -> None:
    """
    Write internal camera parameters into a file.

    Parameters
    ----------

    camera_param : Sequence[Union[int, float, str]]
                   Internal camera parameters.

    cam_par_file : str
                   File name of internal camera parameters.
                   Value Suggestion: campar.dat

    See Also
    --------
    find_caltab, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab, read_cam_par, write_pose, read_pose, project_3d_point,
    get_line_of_sight

    Predecessors
    ------------
    camera_calibration
    """
    with HalconOperator(1943) as proc:
        proc.set_input_tuple(0, camera_param)
        proc.set_input_tuple(1, cam_par_file)
        proc.execute()


def write_camera_setup_model(
    camera_setup_model_id: HHandle,
    file_name: str
) -> None:
    """
    Store a camera setup model into a file.

    Parameters
    ----------

    camera_setup_model_id : HHandle
                            Handle to the camera setup model.

    file_name : str
                The file name of the model to be saved.
    """
    with HalconOperator(1953) as proc:
        proc.set_input_tuple(0, camera_setup_model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_class_box(classif_handle: HHandle, file_name: str) -> None:
    """
    Save a classifier in a file.

    Parameters
    ----------

    classif_handle : HHandle
                     Handle of the classifier.

    file_name : str
                Name of the file which contains the written data.

    See Also
    --------
    create_class_box, read_class_box

    Predecessors
    ------------
    create_class_box, enquire_class_box, learn_class_box, test_sampset_box

    Successors
    ----------
    close_class_box, clear_sampset

    Warnings
    --------
    write_class_box is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  MLP, SVM, KNN
    or GMM operators instead.

    Notes
    -----
    If a file with this name exists, it is overwritten without a warning.
    The file can not be edited.
    """
    with HalconOperator(1886) as proc:
        proc.set_input_tuple(0, classif_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_class_gmm(gmmhandle: HHandle, file_name: str) -> None:
    """
    Write a Gaussian Mixture Model to a file.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    file_name : str
                File name.

    See Also
    --------
    create_class_gmm, read_class_gmm, write_samples_class_gmm

    Predecessors
    ------------
    train_class_gmm

    Successors
    ----------
    clear_class_gmm
    """
    with HalconOperator(1829) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_class_knn(knnhandle: HHandle, file_name: str) -> None:
    """
    Save the k-NN classifier in a file.

    Parameters
    ----------

    knnhandle : HHandle
                Handle of the k-NN classifier.

    file_name : str
                Name of the file in which the classifier will be written.

    See Also
    --------
    create_class_knn, read_class_knn

    Predecessors
    ------------
    train_class_knn, read_class_knn
    """
    with HalconOperator(1810) as proc:
        proc.set_input_tuple(0, knnhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_class_mlp(mlphandle: HHandle, file_name: str) -> None:
    """
    Write a multilayer perceptron to a file.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    file_name : str
                File name.

    See Also
    --------
    create_class_mlp, read_class_mlp, write_samples_class_mlp

    Predecessors
    ------------
    train_class_mlp

    Successors
    ----------
    clear_class_mlp
    """
    with HalconOperator(1868) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_class_svm(svmhandle: HHandle, file_name: str) -> None:
    """
    Write a support vector machine to a file.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    file_name : str
                File name.

    See Also
    --------
    create_class_svm, read_class_svm, write_samples_class_svm

    Predecessors
    ------------
    train_class_svm

    Successors
    ----------
    clear_class_svm
    """
    with HalconOperator(1847) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_class_train_data(
    class_train_data_handle: HHandle,
    file_name: str
) -> None:
    """
    Save the training data for classifiers in a file.

    Parameters
    ----------

    class_train_data_handle : HHandle
                              Handle of the training data.

    file_name : str
                Name of the file in which the training data will be
                written.

    See Also
    --------
    create_class_train_data, read_class_train_data
    """
    with HalconOperator(1782) as proc:
        proc.set_input_tuple(0, class_train_data_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_component_model(
    component_model_id: HHandle,
    file_name: str
) -> None:
    """
    Write a component model to a file.

    Parameters
    ----------

    component_model_id : HHandle
                         Handle of the component model.

    file_name : str
                File name.

    Predecessors
    ------------
    create_component_model, create_trained_component_model
    """
    with HalconOperator(1003) as proc:
        proc.set_input_tuple(0, component_model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_contour_xld_arc_info(contours: HObject, file_name: str) -> None:
    """
    Write XLD contours to a file in ARC/INFO generate format.

    Parameters
    ----------

    contours : HObject
               XLD contours to be written.

    file_name : str
                Name of the ARC/INFO file.

    See Also
    --------
    read_world_file, read_contour_xld_arc_info, write_polygon_xld_arc_info

    Predecessors
    ------------
    affine_trans_contour_xld
    """
    with HalconOperator(21) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_contour_xld_dxf(contours: HObject, file_name: str) -> None:
    """
    Write XLD contours to a file in DXF format.

    Parameters
    ----------

    contours : HObject
               XLD contours to be written.

    file_name : str
                Name of the DXF file.

    See Also
    --------
    read_contour_xld_dxf, write_polygon_xld_dxf,
    query_contour_attribs_xld, query_contour_global_attribs_xld,
    get_contour_attrib_xld, get_contour_global_attrib_xld

    Predecessors
    ------------
    edges_sub_pix
    """
    with HalconOperator(1637) as proc:
        proc.set_input_object(1, contours)
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_data_code_2d_model(
    data_code_handle: HHandle,
    file_name: str
) -> None:
    """
    Writes a 2D data code model into a file.

    Parameters
    ----------

    data_code_handle : HHandle
                       Handle of the 2D data code model.

    file_name : str
                Name of the 2D data code model file.
                Value Suggestion: data_code_model.dcm

    See Also
    --------
    create_data_code_2d_model, set_data_code_2d_param, find_data_code_2d

    Alternatives
    ------------
    get_data_code_2d_param

    Predecessors
    ------------
    set_data_code_2d_param, find_data_code_2d
    """
    with HalconOperator(1775) as proc:
        proc.set_input_tuple(0, data_code_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_deep_ocr(deep_ocr_handle: HHandle, file_name: str) -> None:
    """
    Write a Deep OCR model in a file.

    Parameters
    ----------

    deep_ocr_handle : HHandle
                      Handle of the Deep OCR model.

    file_name : str
                Filename

    Predecessors
    ------------
    create_deep_ocr, set_deep_ocr_param
    """
    with HalconOperator(2218) as proc:
        proc.set_input_tuple(0, deep_ocr_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_deformable_model(model_id: HHandle, file_name: str) -> None:
    """
    Write a deformable model to a file.

    Parameters
    ----------

    model_id : HHandle
               Handle of a model to be saved.

    file_name : str
                The path and filename of the model to be saved.

    Predecessors
    ------------
    create_planar_uncalib_deformable_model,
    create_planar_calib_deformable_model, create_local_deformable_model
    """
    with HalconOperator(966) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_deformable_surface_model(
    deformable_surface_model: HHandle,
    file_name: str
) -> None:
    """
    Write a deformable surface model to a file.

    Parameters
    ----------

    deformable_surface_model : HHandle
                               Handle of the deformable surface model to
                               write.

    file_name : str
                File name to write to.

    See Also
    --------
    create_deformable_surface_model, read_deformable_surface_model

    Predecessors
    ------------
    read_deformable_surface_model, create_deformable_surface_model,
    get_deformable_surface_model_param

    Successors
    ----------
    clear_deformable_surface_model
    """
    with HalconOperator(1025) as proc:
        proc.set_input_tuple(0, deformable_surface_model)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_descriptor_model(model_id: HHandle, file_name: str) -> None:
    """
    Write a descriptor model to a file.

    Parameters
    ----------

    model_id : HHandle
               Handle of a model to be saved.

    file_name : str
                The path and filename of the model to be saved.

    See Also
    --------
    create_uncalib_descriptor_model, create_calib_descriptor_model

    Predecessors
    ------------
    points_lepetit, create_uncalib_descriptor_model,
    create_calib_descriptor_model
    """
    with HalconOperator(947) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_dict(
    dict_handle: HHandle,
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Write a dictionary to a file.

    Parameters
    ----------

    dict_handle : HHandle
                  Dictionary handle.

    file_name : str
                File name.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    See Also
    --------
    read_dict, serialize_handle, deserialize_handle

    Predecessors
    ------------
    read_dict, deserialize_handle, create_dict

    Successors
    ----------
    read_dict
    """
    with HalconOperator(2173) as proc:
        proc.set_input_tuple(0, dict_handle)
        proc.set_input_tuple(1, file_name)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def write_distance_transform_xld(
    distance_transform_id: HHandle,
    file_name: str
) -> None:
    """
    Write an XLD distance transform into a file.

    Parameters
    ----------

    distance_transform_id : HHandle
                            Handle of the XLD distance transform.

    file_name : str
                Name of the file.

    See Also
    --------
    read_distance_transform_xld, deserialize_distance_transform_xld,
    get_distance_transform_xld_contour, apply_distance_transform_xld,
    get_distance_transform_xld_param, set_distance_transform_xld_param

    Alternatives
    ------------
    serialize_distance_transform_xld

    Predecessors
    ------------
    create_distance_transform_xld

    Successors
    ----------
    clear_distance_transform_xld
    """
    with HalconOperator(1356) as proc:
        proc.set_input_tuple(0, distance_transform_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_dl_classifier(
    dlclassifier_handle: HHandle,
    file_name: str
) -> None:
    """
    Write a deep-learning-based classifier in a file.

    Parameters
    ----------

    dlclassifier_handle : HHandle
                          Handle of the deep-learning-based classifier.

    file_name : str
                File name.

    Alternatives
    ------------
    write_dl_model

    Predecessors
    ------------
    read_dl_classifier, train_dl_classifier_batch, set_dl_classifier_param

    Warnings
    --------
    write_dl_classifier is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the common
    CNN-based operator write_dl_model instead.
    """
    with HalconOperator(2132) as proc:
        proc.set_input_tuple(0, dlclassifier_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_dl_model(dlmodel_handle: HHandle, file_name: str) -> None:
    """
    Write a deep learning model in a file.

    Parameters
    ----------

    dlmodel_handle : HHandle
                     Handle of the deep learning model.

    file_name : str
                Filename

    Predecessors
    ------------
    read_dl_model, train_dl_model_batch, train_dl_model_anomaly_dataset,
    set_dl_model_param
    """
    with HalconOperator(2174) as proc:
        proc.set_input_tuple(0, dlmodel_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_fft_optimization_data(file_name: str) -> None:
    """
    Store FFT speed optimization data in a file.

    Parameters
    ----------

    file_name : str
                File name of the optimization data.
                Value Suggestion: 'fft_opt.dat'

    See Also
    --------
    fft_generic, fft_image, fft_image_inv, wiener_filter,
    wiener_filter_ni, photometric_stereo, sfs_pentland, sfs_mod_lr,
    sfs_orig_lr, read_fft_optimization_data

    Predecessors
    ------------
    optimize_fft_speed, optimize_rft_speed
    """
    with HalconOperator(1538) as proc:
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_funct_1d(
    function: Sequence[Union[float, int]],
    file_name: str
) -> None:
    """
    Write a function to a file.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Function to be written.

    file_name : str
                Name of the file to be written.

    See Also
    --------
    read_funct_1d, write_image, write_region, open_file

    Alternatives
    ------------
    write_tuple, fwrite_string

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1398) as proc:
        proc.set_input_tuple(0, function)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_image(
    image: HObject,
    format: str,
    fill_color: Union[int, float],
    file_name: MaybeSequence[str]
) -> None:
    """
    Write images in graphic formats.

    Parameters
    ----------

    image : HObject
            Input images.

    format : str
             Graphic format.
             Value Suggestion: tiff

    fill_color : Union[int, float]
                 Fill gray value for pixels not belonging to the image
                 domain (region).
                 Value Suggestion: 0

    file_name : MaybeSequence[str]
                Name of image file.

    Predecessors
    ------------
    open_window, read_image
    """
    with HalconOperator(1655) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, format)
        proc.set_input_tuple(1, fill_color)
        proc.set_input_tuple(2, file_name)
        proc.execute()


def write_image_metadata(
    format: str,
    tag_name: str,
    tag_value: Union[int, float, str],
    file_name: str
) -> None:
    """
    Write metadata of image files.

    Parameters
    ----------

    format : str
             Graphic format.
             Value Suggestion: 'tiff'

    tag_name : str
               Name of the tag to be written in the image file.
               Value Suggestion: 'tiff_image_description'

    tag_value : Union[int, float, str]
                Value of the tag to be written in the image file.

    file_name : str
                Name of image file.

    Predecessors
    ------------
    write_image

    Successors
    ----------
    read_image_metadata
    """
    with HalconOperator(2191) as proc:
        proc.set_input_tuple(0, format)
        proc.set_input_tuple(1, tag_name)
        proc.set_input_tuple(2, tag_value)
        proc.set_input_tuple(3, file_name)
        proc.execute()


def write_io_channel(
    iochannel_handle: MaybeSequence[HHandle],
    value: Sequence[Union[int, float, str]]
) -> Sequence[int]:
    """
    Write a value to the specified I/O channels.

    Parameters
    ----------

    iochannel_handle : MaybeSequence[HHandle]
                       Handles of the opened I/O channels.

    value : Sequence[Union[int, float, str]]
            Write values.

    Returns
    -------

    status : Sequence[int]
             Status of written values.

    See Also
    --------
    read_io_channel, open_io_channel, query_io_device, set_io_channel_param

    Predecessors
    ------------
    open_io_channel, set_io_channel_param

    Successors
    ----------
    close_io_channel
    """
    with HalconOperator(2011) as proc:
        proc.set_input_tuple(0, iochannel_handle)
        proc.set_input_tuple(1, value)
        proc.init_oct(0)
        proc.execute()
        status = proc.get_output_tuple_m(0)
        return status  # type: ignore


def write_lut(window_handle: HHandle, file_name: str) -> None:
    """
    Write look-up-table (lut) as file.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    file_name : str
                File name (of file containing the look-up-table).
                Value Suggestion: /tmp/lut

    See Also
    --------
    set_lut, set_pixel, get_pixel

    Predecessors
    ------------
    set_lut

    Warnings
    --------
    write_lut is obsolete and is only provided for reasons of backward
    compatibility.

    Notes
    -----
    write_lut is only suitable for systems using 256 colors.
    """
    with HalconOperator(1284) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_matrix(
    matrix_id: HHandle,
    file_format: str,
    file_name: str
) -> None:
    """
    Write a matrix to a file.

    Parameters
    ----------

    matrix_id : HHandle
                Matrix handle of the input matrix.

    file_format : str
                  Format of the file.
                  Value Suggestion: binary

    file_name : str
                File name.

    Predecessors
    ------------
    create_matrix
    """
    with HalconOperator(843) as proc:
        proc.set_input_tuple(0, matrix_id)
        proc.set_input_tuple(1, file_format)
        proc.set_input_tuple(2, file_name)
        proc.execute()


def write_measure(measure_handle: HHandle, file_name: str) -> None:
    """
    Write a measure object to a file.

    Parameters
    ----------

    measure_handle : HHandle
                     Measure object handle.

    file_name : str
                File name.

    See Also
    --------
    read_measure

    Predecessors
    ------------
    gen_measure_rectangle2, gen_measure_arc
    """
    with HalconOperator(823) as proc:
        proc.set_input_tuple(0, measure_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_message(
    message_handle: HHandle,
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Write a message to a file.

    Parameters
    ----------

    message_handle : HHandle
                     Message handle.
                     Assertion: MessageHandle != 0

    file_name : str
                File name.

    gen_param_name : MaybeSequence[str]
                     Name of the generic parameter.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[int, float, str]]
                      Value of the generic parameter.
                      Value Suggestion: []

    See Also
    --------
    read_message, serialize_handle, deserialize_handle

    Predecessors
    ------------
    read_message, deserialize_handle, create_message

    Successors
    ----------
    read_message
    """
    with HalconOperator(2175) as proc:
        proc.set_input_tuple(0, message_handle)
        proc.set_input_tuple(1, file_name)
        proc.set_input_tuple(2, gen_param_name)
        proc.set_input_tuple(3, gen_param_value)
        proc.execute()


def write_metrology_model(
    metrology_handle: HHandle,
    file_name: str
) -> None:
    """
    Write a metrology model to a file.

    Parameters
    ----------

    metrology_handle : HHandle
                       Handle of the metrology model.

    file_name : str
                File name.

    See Also
    --------
    read_metrology_model

    Predecessors
    ------------
    apply_metrology_model

    Successors
    ----------
    clear_metrology_model

    Notes
    -----
    Note that only the input values are saved, i.e., no measure regions
    and no results obtained by the operator apply_metrology_model are
    saved.
    """
    with HalconOperator(797) as proc:
        proc.set_input_tuple(0, metrology_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_ncc_model(model_id: HHandle, file_name: str) -> None:
    """
    Write an NCC model to a file.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    file_name : str
                File name.

    Predecessors
    ------------
    create_ncc_model
    """
    with HalconOperator(986) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_object(object: HObject, file_name: str) -> None:
    """
    Write an iconic object.

    Parameters
    ----------

    object : HObject
             Iconic object.

    file_name : str
                Name of file.

    See Also
    --------
    read_object, write_image, read_image, write_region, read_region

    Successors
    ----------
    read_object, read_image
    """
    with HalconOperator(1647) as proc:
        proc.set_input_object(1, object)
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_object_model_3d(
    object_model_3d: HHandle,
    file_type: str,
    file_name: str,
    gen_param_name: MaybeSequence[str],
    gen_param_value: MaybeSequence[Union[str, float, int]]
) -> None:
    """
    Writes a 3D object model to a file.

    Parameters
    ----------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    file_type : str
                Type of the file that is written.
                Value Suggestion: om3

    file_name : str
                Name of the file that is written.

    gen_param_name : MaybeSequence[str]
                     Names of the generic parameters.
                     Value Suggestion: []

    gen_param_value : MaybeSequence[Union[str, float, int]]
                      Values of the generic parameters.
                      Value Suggestion: []

    See Also
    --------
    read_object_model_3d

    Predecessors
    ------------
    read_object_model_3d, xyz_to_object_model_3d

    Successors
    ----------
    read_object_model_3d
    """
    with HalconOperator(1103) as proc:
        proc.set_input_tuple(0, object_model_3d)
        proc.set_input_tuple(1, file_type)
        proc.set_input_tuple(2, file_name)
        proc.set_input_tuple(3, gen_param_name)
        proc.set_input_tuple(4, gen_param_value)
        proc.execute()


def write_ocr(ocr_handle: HHandle, file_name: str) -> None:
    """
    Writing an OCR classifier into a file.

    Parameters
    ----------

    ocr_handle : HHandle
                 ID of the OCR classifier.

    file_name : str
                Name of the file for the OCR classifier (without
                extension).
                Value Suggestion: my_ocr

    See Also
    --------
    read_ocr, do_ocr_multi, traind_ocr_class_box, trainf_ocr_class_box

    Predecessors
    ------------
    traind_ocr_class_box, trainf_ocr_class_box

    Successors
    ----------
    do_ocr_multi, do_ocr_single

    Warnings
    --------
    write_ocr is obsolete and is only provided for reasons of backward
    compatibility.  New applications should use the MLP, SVM or CNN based
    operators instead.

    Notes
    -----
    The output file FileName must be given without extension.
    """
    with HalconOperator(711) as proc:
        proc.set_input_tuple(0, ocr_handle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_ocr_class_knn(ocrhandle: HHandle, file_name: str) -> None:
    """
    Write a k-NN classifier for an OCR task to a file.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the k-NN classifier for an OCR task.

    file_name : str
                File name.

    See Also
    --------
    create_class_knn, read_ocr_class_knn

    Predecessors
    ------------
    trainf_ocr_class_knn, read_ocr_class_knn
    """
    with HalconOperator(651) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_ocr_class_mlp(ocrhandle: HHandle, file_name: str) -> None:
    """
    Write an OCR classifier to a file.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    file_name : str
                File name.

    See Also
    --------
    create_ocr_class_mlp, read_ocr_class_mlp, write_class_mlp,
    read_class_mlp

    Predecessors
    ------------
    trainf_ocr_class_mlp

    Successors
    ----------
    clear_ocr_class_mlp
    """
    with HalconOperator(695) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_ocr_class_svm(ocrhandle: HHandle, file_name: str) -> None:
    """
    Write an OCR classifier to a file.

    Parameters
    ----------

    ocrhandle : HHandle
                Handle of the OCR classifier.

    file_name : str
                File name.

    See Also
    --------
    create_ocr_class_svm, read_ocr_class_svm, write_class_svm,
    read_class_svm

    Predecessors
    ------------
    trainf_ocr_class_svm

    Successors
    ----------
    clear_ocr_class_svm
    """
    with HalconOperator(677) as proc:
        proc.set_input_tuple(0, ocrhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_ocr_trainf(
    character: HObject,
    image: HObject,
    class_val: MaybeSequence[str],
    training_file: str
) -> None:
    """
    Storing of training characters into a file.

    Parameters
    ----------

    character : HObject
                Characters to be trained.

    image : HObject
            Gray values of the characters.

    class_val : MaybeSequence[str]
                Class (name) of the characters.

    training_file : str
                    Name of the training file.
                    Value Suggestion: 'train_ocr'

    Predecessors
    ------------
    threshold, connection, read_ocr_trainf

    Successors
    ----------
    trainf_ocr_class_mlp, trainf_ocr_class_svm
    """
    with HalconOperator(720) as proc:
        proc.set_input_object(1, character)
        proc.set_input_object(2, image)
        proc.set_input_tuple(0, class_val)
        proc.set_input_tuple(1, training_file)
        proc.execute()


def write_ocr_trainf_image(
    character: HObject,
    class_val: MaybeSequence[str],
    training_file: str
) -> None:
    """
    Write characters into a training file.

    Parameters
    ----------

    character : HObject
                Characters to be trained.

    class_val : MaybeSequence[str]
                Class (name) of the characters.

    training_file : str
                    Name of the training file.
                    Value Suggestion: 'train_ocr'

    Alternatives
    ------------
    write_ocr_trainf, append_ocr_trainf

    Predecessors
    ------------
    threshold, connection, read_ocr_trainf

    Successors
    ----------
    trainf_ocr_class_mlp, trainf_ocr_class_svm
    """
    with HalconOperator(729) as proc:
        proc.set_input_object(1, character)
        proc.set_input_tuple(0, class_val)
        proc.set_input_tuple(1, training_file)
        proc.execute()


def write_ocv(ocvhandle: HHandle, file_name: str) -> None:
    """
    Saving an OCV tool to file.

    Parameters
    ----------

    ocvhandle : HHandle
                Handle of the OCV tool to be written.

    file_name : str
                Name of the file where the tool has to be saved.
                Value Suggestion: test_ocv

    See Also
    --------
    write_ocr

    Predecessors
    ------------
    traind_ocv_proj

    Successors
    ----------
    close_ocv
    """
    with HalconOperator(643) as proc:
        proc.set_input_tuple(0, ocvhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_polygon_xld_arc_info(polygons: HObject, file_name: str) -> None:
    """
    Write XLD polygons to a file in ARC/INFO generate format.

    Parameters
    ----------

    polygons : HObject
               XLD polygons to be written.

    file_name : str
                Name of the ARC/INFO file.

    See Also
    --------
    read_world_file, read_polygon_xld_arc_info, write_contour_xld_arc_info

    Predecessors
    ------------
    affine_trans_polygon_xld

    Notes
    -----
    The XLD contours that are possibly referenced by Polygons are not
    stored in the ARC/INFO file, since this is not possible with the
    ARC/INFO generate file format.  Therefore, when the polygons are read
    again using read_polygon_xld_arc_info, this information is lost, and
    no references to contours are generated for the polygons.  Hence,
    operators that access the contours associated with a polygon, e.g.,
    split_contours_xld will not work correctly.
    """
    with HalconOperator(19) as proc:
        proc.set_input_object(1, polygons)
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_polygon_xld_dxf(polygons: HObject, file_name: str) -> None:
    """
    Write XLD polygons to a file in DXF format.

    Parameters
    ----------

    polygons : HObject
               XLD polygons to be written.

    file_name : str
                Name of the DXF file.

    See Also
    --------
    read_polygon_xld_dxf, write_contour_xld_dxf

    Predecessors
    ------------
    gen_polygons_xld

    Notes
    -----
    The XLD contours that are possibly referenced by Polygons are not
    stored in the DXF file.  Therefore, when the polygons are read again
    using read_polygon_xld_dxf, this information is lost, and no
    references to contours are generated for the polygons.  Hence,
    operators that access the contours associated with a polygon, e.g.,
    split_contours_xld will not work correctly.
    """
    with HalconOperator(1635) as proc:
        proc.set_input_object(1, polygons)
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_pose(pose: Sequence[Union[int, float]], pose_file: str) -> None:
    """
    Write a 3D pose to a text file.

    Parameters
    ----------

    pose : Sequence[Union[int, float]]
           3D pose.

    pose_file : str
                File name of the external camera parameters.
                Value Suggestion: campose.dat

    See Also
    --------
    create_pose, find_marks_and_pose, camera_calibration, disp_caltab,
    sim_caltab, read_pose, pose_to_hom_mat3d, hom_mat3d_to_pose

    Predecessors
    ------------
    camera_calibration, get_calib_data, hom_mat3d_to_pose
    """
    with HalconOperator(1941) as proc:
        proc.set_input_tuple(0, pose)
        proc.set_input_tuple(1, pose_file)
        proc.execute()


def write_region(region: HObject, file_name: str) -> None:
    """
    Write regions to a file.

    Parameters
    ----------

    region : HObject
             Region of the images which are returned.

    file_name : str
                Name of region file.
                Value Suggestion: region.hobj

    See Also
    --------
    read_region

    Predecessors
    ------------
    open_window, read_image, read_region, read_object, threshold,
    regiongrowing
    """
    with HalconOperator(1654) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, file_name)
        proc.execute()


def write_sample_identifier(
    sample_identifier: HHandle,
    file_name: str
) -> None:
    """
    Write a sample identifier to a file.

    Parameters
    ----------

    sample_identifier : HHandle
                        Handle of the sample identifier.

    file_name : str
                File name.

    See Also
    --------
    create_sample_identifier, prepare_sample_identifier,
    train_sample_identifier, apply_sample_identifier,
    get_sample_identifier_param, get_sample_identifier_object_info,
    remove_sample_identifier_preparation_data,
    remove_sample_identifier_training_data, read_sample_identifier,
    deserialize_sample_identifier, set_sample_identifier_object_info

    Alternatives
    ------------
    serialize_sample_identifier

    Predecessors
    ------------
    prepare_sample_identifier, train_sample_identifier,
    add_sample_identifier_preparation_data,
    add_sample_identifier_training_data, set_sample_identifier_param

    Successors
    ----------
    clear_sample_identifier
    """
    with HalconOperator(903) as proc:
        proc.set_input_tuple(0, sample_identifier)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_samples_class_gmm(gmmhandle: HHandle, file_name: str) -> None:
    """
    Write the training data of a Gaussian Mixture Model to a file.

    Parameters
    ----------

    gmmhandle : HHandle
                GMM handle.

    file_name : str
                File name.

    See Also
    --------
    create_class_gmm, read_samples_class_gmm, read_samples_class_mlp,
    write_samples_class_mlp

    Predecessors
    ------------
    add_sample_class_gmm

    Successors
    ----------
    clear_samples_class_gmm
    """
    with HalconOperator(1831) as proc:
        proc.set_input_tuple(0, gmmhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_samples_class_mlp(mlphandle: HHandle, file_name: str) -> None:
    """
    Write the training data of a multilayer perceptron to a file.

    Parameters
    ----------

    mlphandle : HHandle
                MLP handle.

    file_name : str
                File name.

    See Also
    --------
    create_class_mlp, get_prep_info_class_mlp, read_samples_class_mlp

    Predecessors
    ------------
    add_sample_class_mlp

    Successors
    ----------
    clear_samples_class_mlp
    """
    with HalconOperator(1870) as proc:
        proc.set_input_tuple(0, mlphandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_samples_class_svm(svmhandle: HHandle, file_name: str) -> None:
    """
    Write the training data of a support vector machine to a file.

    Parameters
    ----------

    svmhandle : HHandle
                SVM handle.

    file_name : str
                File name.

    See Also
    --------
    create_class_svm, get_prep_info_class_svm, read_samples_class_svm

    Predecessors
    ------------
    add_sample_class_svm

    Successors
    ----------
    clear_samples_class_svm
    """
    with HalconOperator(1849) as proc:
        proc.set_input_tuple(0, svmhandle)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_serial(serial_handle: HHandle, data: MaybeSequence[int]) -> None:
    """
    Write to a serial connection.

    Parameters
    ----------

    serial_handle : HHandle
                    Serial interface handle.

    data : MaybeSequence[int]
           Characters to write (as tuple of integers).

    See Also
    --------
    read_serial

    Predecessors
    ------------
    open_serial
    """
    with HalconOperator(308) as proc:
        proc.set_input_tuple(0, serial_handle)
        proc.set_input_tuple(1, data)
        proc.execute()


def write_shape_model(model_id: HHandle, file_name: str) -> None:
    """
    Write a shape model to a file.

    Parameters
    ----------

    model_id : HHandle
               Handle of the model.

    file_name : str
                File name.

    Predecessors
    ------------
    create_shape_model, create_scaled_shape_model, create_aniso_shape_model
    """
    with HalconOperator(919) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_shape_model_3d(shape_model_3did: HHandle, file_name: str) -> None:
    """
    Write a 3D shape model to a file.

    Parameters
    ----------

    shape_model_3did : HHandle
                       Handle of the 3D shape model.

    file_name : str
                File name.

    Predecessors
    ------------
    create_shape_model_3d
    """
    with HalconOperator(1053) as proc:
        proc.set_input_tuple(0, shape_model_3did)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_sheet_of_light_model(
    sheet_of_light_model_id: HHandle,
    file_name: str
) -> None:
    """
    Write a sheet-of-light model to a file.

    Parameters
    ----------

    sheet_of_light_model_id : HHandle
                              Handle of the sheet-of-light model.

    file_name : str
                Name of the sheet-of-light model file.
                Value Suggestion: sheet_of_light_model.solm

    See Also
    --------
    read_sheet_of_light_model

    Predecessors
    ------------
    create_sheet_of_light_model, set_sheet_of_light_param
    """
    with HalconOperator(375) as proc:
        proc.set_input_tuple(0, sheet_of_light_model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_string(
    window_handle: HHandle,
    string: MaybeSequence[Union[int, float, str]]
) -> None:
    """
    Print text in a window.

    Parameters
    ----------

    window_handle : HHandle
                    Window handle.

    string : MaybeSequence[Union[int, float, str]]
             Tuple of output values (all types).
             Value Suggestion: hello

    See Also
    --------
    set_tposition, get_string_extents, set_font, set_system, set_check

    Alternatives
    ------------
    fwrite_string

    Predecessors
    ------------
    open_window, set_font, get_string_extents

    Notes
    -----
    If clipping at the window boundary is desired, exceptions can be
    switched off by set_check('~text')set_check('text')}.
    """
    with HalconOperator(1190) as proc:
        proc.set_input_tuple(0, window_handle)
        proc.set_input_tuple(1, string)
        proc.execute()


def write_structured_light_model(
    structured_light_model: HHandle,
    file_name: str
) -> None:
    """
    Write a structured light model to a file.

    Parameters
    ----------

    structured_light_model : HHandle
                             Handle of the structured light model.

    file_name : str
                File name.

    See Also
    --------
    create_structured_light_model, clear_structured_light_model

    Successors
    ----------
    clear_structured_light_model
    """
    with HalconOperator(2133) as proc:
        proc.set_input_tuple(0, structured_light_model)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_surface_model(surface_model_id: HHandle, file_name: str) -> None:
    """
    Write a surface model to a file.

    Parameters
    ----------

    surface_model_id : HHandle
                       Handle of the surface model.

    file_name : str
                File name.

    See Also
    --------
    create_surface_model, read_surface_model

    Predecessors
    ------------
    read_surface_model, create_surface_model, get_surface_model_param

    Successors
    ----------
    clear_surface_model
    """
    with HalconOperator(1040) as proc:
        proc.set_input_tuple(0, surface_model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_template(template_id: HHandle, file_name: str) -> None:
    """
    Writing a template to file.

    Parameters
    ----------

    template_id : HHandle
                  Template number.

    file_name : str
                file name.

    Predecessors
    ------------
    create_template, create_template_rot

    Warnings
    --------
    write_template is obsolete and is only provided for reasons of
    backward compatibility. New applications should use the  shape-based
    or NCC-based operators instead.
    """
    with HalconOperator(1492) as proc:
        proc.set_input_tuple(0, template_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_texture_inspection_model(
    texture_inspection_model: HHandle,
    file_name: str
) -> None:
    """
    Write a texture inspection model to a file.

    Parameters
    ----------

    texture_inspection_model : HHandle
                               Handle of the texture inspection model.

    file_name : str
                File name.

    See Also
    --------
    create_texture_inspection_model, clear_texture_inspection_model,
    set_texture_inspection_model_param,
    get_texture_inspection_model_param, add_texture_inspection_model_image

    Predecessors
    ------------
    train_texture_inspection_model

    Successors
    ----------
    clear_texture_inspection_model
    """
    with HalconOperator(2100) as proc:
        proc.set_input_tuple(0, texture_inspection_model)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_training_components(
    component_training_id: HHandle,
    file_name: str
) -> None:
    """
    Write a component training result to a file.

    Parameters
    ----------

    component_training_id : HHandle
                            Handle of the training result.

    file_name : str
                File name.

    Predecessors
    ------------
    train_model_components
    """
    with HalconOperator(1014) as proc:
        proc.set_input_tuple(0, component_training_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_tuple(
    tuple: MaybeSequence[Union[float, int, str]],
    file_name: str
) -> None:
    """
    Write a tuple to a file.

    Parameters
    ----------

    tuple : MaybeSequence[Union[float, int, str]]
            Tuple with any kind of data.

    file_name : str
                Name of the file to be written.

    See Also
    --------
    read_tuple, write_image, write_region, open_file

    Alternatives
    ------------
    fwrite_string
    """
    with HalconOperator(219) as proc:
        proc.set_input_tuple(0, tuple)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def write_variation_model(model_id: HHandle, file_name: str) -> None:
    """
    Write a variation model to a file.

    Parameters
    ----------

    model_id : HHandle
               ID of the variation model.

    file_name : str
                File name.

    See Also
    --------
    read_variation_model

    Predecessors
    ------------
    train_variation_model
    """
    with HalconOperator(84) as proc:
        proc.set_input_tuple(0, model_id)
        proc.set_input_tuple(1, file_name)
        proc.execute()


def x_range_funct_1d(
    function: Sequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Smallest and largest x value of the function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    xmin : float
           Smallest x value.

    xmax : float
           Largest x value.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1389) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # xmin
            proc.get_output_tuple_s(1)   # xmax
        )  # type: ignore


def xyz_to_object_model_3d(
    x: HObject,
    y: HObject,
    z: HObject
) -> HHandle:
    """
    Transform 3D points from images to a 3D object model.

    Parameters
    ----------

    x : HObject
        Image with the X-Coordinates and the ROI of the 3D points.

    y : HObject
        Image with the Y-Coordinates of the 3D points.

    z : HObject
        Image with the Z-Coordinates of the 3D points.

    Returns
    -------

    object_model_3d : HHandle
                      Handle of the 3D object model.

    See Also
    --------
    read_object_model_3d

    Alternatives
    ------------
    gen_object_model_3d_from_points,
    get_sheet_of_light_result_object_model_3d

    Predecessors
    ------------
    disparity_image_to_xyz, get_sheet_of_light_result
    """
    with HalconOperator(1093) as proc:
        proc.set_input_object(1, x)
        proc.set_input_object(2, y)
        proc.set_input_object(3, z)
        proc.init_oct(0)
        proc.execute()
        object_model_3d = proc.get_output_tuple_s(0)
        return object_model_3d  # type: ignore


def y_range_funct_1d(
    function: Sequence[Union[float, int]]
) -> Tuple[float, float]:
    """
    Smallest and largest y value of the function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function.

    Returns
    -------

    ymin : float
           Smallest y value.

    ymax : float
           Largest y value.

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array
    """
    with HalconOperator(1388) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.init_oct(1)
        proc.execute()
        return (
            proc.get_output_tuple_s(0),  # ymin
            proc.get_output_tuple_s(1)   # ymax
        )  # type: ignore


def zero_crossing(image: HObject) -> HObject:
    """
    Extract zero crossings from an image.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    region_crossing : HObject
                      Zero crossings.

    Alternatives
    ------------
    threshold, dual_threshold, zero_crossing_sub_pix

    Predecessors
    ------------
    laplace, laplace_of_gauss, derivate_gauss

    Successors
    ----------
    connection, skeleton, boundary, select_shape, fill_up
    """
    with HalconOperator(461) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        region_crossing = HObject(proc.get_output_object_key(1))
        return region_crossing  # type: ignore


def zero_crossing_sub_pix(image: HObject) -> HObject:
    """
    Extract zero crossings from an image with subpixel accuracy.

    Parameters
    ----------

    image : HObject
            Input image.

    Returns
    -------

    zero_crossings : HObject
                     Extracted zero crossings.

    See Also
    --------
    threshold_sub_pix

    Alternatives
    ------------
    zero_crossing

    Predecessors
    ------------
    laplace, laplace_of_gauss, diff_of_gauss, derivate_gauss
    """
    with HalconOperator(462) as proc:
        proc.set_input_object(1, image)
        proc.execute()
        zero_crossings = HObject(proc.get_output_object_key(1))
        return zero_crossings  # type: ignore


def zero_crossings_funct_1d(
    function: Sequence[Union[float, int]]
) -> Sequence[float]:
    """
    Calculate the zero crossings of a function.

    Parameters
    ----------

    function : Sequence[Union[float, int]]
               Input function

    Returns
    -------

    zero_crossings : Sequence[float]
                     Zero crossings of the input function

    Predecessors
    ------------
    create_funct_1d_pairs, create_funct_1d_array, smooth_funct_1d_gauss,
    smooth_funct_1d_mean
    """
    with HalconOperator(1381) as proc:
        proc.set_input_tuple(0, function)
        proc.init_oct(0)
        proc.execute()
        zero_crossings = proc.get_output_tuple_m(0)
        return zero_crossings  # type: ignore


def zoom_image_factor(
    image: HObject,
    scale_width: float,
    scale_height: float,
    interpolation: str
) -> HObject:
    """
    Zoom an image by a given factor.

    Parameters
    ----------

    image : HObject
            Input image.

    scale_width : float
                  Scale factor for the width of the image.
                  Value Suggestion: 0.5

    scale_height : float
                   Scale factor for the height of the image.
                   Value Suggestion: 0.5

    interpolation : str
                    Type of interpolation.
                    Value Suggestion: constant

    Returns
    -------

    image_zoomed : HObject
                   Scaled image.

    See Also
    --------
    hom_mat2d_scale, affine_trans_image

    Alternatives
    ------------
    zoom_image_size, affine_trans_image, hom_mat2d_scale

    Notes
    -----
    If the system parameter 'int_zooming' is set to 'true', the internally
    used integer arithmetic may lead to errors in the following two cases:
    First, if zoom_image_factor is used on an uint2 or int2 image with
    high dynamics (i.e. images containing values close to the respective
    limits) in combination with scale factors smaller than $0.5$, then the
    gray values of the output image may be erroneous.  Second, if
    Interpolation is set to a value other than 'nearest_neighbor', a large
    scale factor is applied, and a large output image is obtained, then
    undefined gray values at the lower and at the right image border may
    result. The maximum width B_max$B_{max}$ of this border of undefined
    gray values can be estimated as B_max = 0.5 * S * I / 2^15$B_{max}=0.5
    - S - I / 2^{15}$, where $S$ is the scale factor in one dimension and
    $I$ is the size of the output image in the corresponding dimension. In
    both cases, it is recommended to set 'int_zooming' to 'false' via the
    operator set_system.
    If 'nearest_neighbor' is set as interpolation method  the results can
    differ slightly for different image types. This is due to the usage of
    image type specific optimizations of the applied interpolation
    algorithm.
    zoom_image_factor is not parallelized internally if ScaleWidth = $0.5$
    and ScaleHeight = $0.5$. Further zoom_image_factor is not parallelized
    internally with Interpolation='nearest_neighbor'.
    zoom_image_factor can be executed on OpenCL devices if the input image
    does not exceed the maximum size of image objects of the selected
    device. Due to numerical reasons, there can be slight differences in
    the output compared to the execution on the CPU.
    """
    with HalconOperator(1624) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, scale_width)
        proc.set_input_tuple(1, scale_height)
        proc.set_input_tuple(2, interpolation)
        proc.execute()
        image_zoomed = HObject(proc.get_output_object_key(1))
        return image_zoomed  # type: ignore


def zoom_image_size(
    image: HObject,
    width: int,
    height: int,
    interpolation: str
) -> HObject:
    """
    Zoom an image to a given size.

    Parameters
    ----------

    image : HObject
            Input image.

    width : int
            Width of the resulting image.
            Value Suggestion: 512

    height : int
             Height of the resulting image.
             Value Suggestion: 512

    interpolation : str
                    Type of interpolation.
                    Value Suggestion: constant

    Returns
    -------

    image_zoom : HObject
                 Scaled image.

    See Also
    --------
    hom_mat2d_scale, affine_trans_image

    Alternatives
    ------------
    zoom_image_factor, affine_trans_image, hom_mat2d_scale

    Notes
    -----
    If the system parameter 'int_zooming' is set to 'true', the internally
    used integer arithmetic may lead to errors in the following two cases:
    First, if zoom_image_size is used on an uint2 or int2 image with high
    dynamics (i.e. images containing values close to the respective
    limits) in combination with scale factors (ratio of output to input
    image size) smaller than $0.5$, then the gray values of the output
    image may be erroneous.  Second, if Interpolation is set to a value
    other than 'nearest_neighbor', a large scale factor is applied, and a
    large output image is obtained, then undefined gray values at the
    lower and at the right image border may result. The maximum width
    B_max$B_{max}$ of this border of undefined gray values can be
    estimated as B_max = 0.5 * S * I / 2^15$B_{max}=0.5 - - I / 2^{15}$,
    where $S$ is the scale factor in one dimension and $I$ is the size of
    the output image in the corresponding dimension. In both cases, it is
    recommended to set 'int_zooming' to 'false' via the operator
    set_system.
    If 'nearest_neighbor' is set as interpolation method  the results can
    differ slightly for different image types. This is due to the usage of
    image type specific optimizations of the applied interpolation
    algorithm.
    zoom_image_size is not parallelized internally if Width and Height
    correspond to half the dimensions of Image.  Further zoom_image_size
    is not parallelized internally with Interpolation='nearest_neighbor'.
    zoom_image_size can be executed on OpenCL devices if the input image
    does not exceed the maximum size of image objects of the selected
    device. Due to numerical reasons, there can be slight differences in
    the output compared to the execution on the CPU.
    """
    with HalconOperator(1625) as proc:
        proc.set_input_object(1, image)
        proc.set_input_tuple(0, width)
        proc.set_input_tuple(1, height)
        proc.set_input_tuple(2, interpolation)
        proc.execute()
        image_zoom = HObject(proc.get_output_object_key(1))
        return image_zoom  # type: ignore


def zoom_region(
    region: HObject,
    scale_width: float,
    scale_height: float
) -> HObject:
    """
    Zoom a region.

    Parameters
    ----------

    region : HObject
             Region(s) to be zoomed.

    scale_width : float
                  Scale factor in x-direction.
                  Value Suggestion: 2.0

    scale_height : float
                   Scale factor in y-direction.
                   Value Suggestion: 2.0

    Returns
    -------

    region_zoom : HObject
                  Zoomed region(s).

    See Also
    --------
    zoom_image_size, zoom_image_factor

    Predecessors
    ------------
    threshold, connection, regiongrowing, pouring

    Successors
    ----------
    select_shape, disp_region
    """
    with HalconOperator(490) as proc:
        proc.set_input_object(1, region)
        proc.set_input_tuple(0, scale_width)
        proc.set_input_tuple(1, scale_height)
        proc.execute()
        region_zoom = HObject(proc.get_output_object_key(1))
        return region_zoom  # type: ignore
